
* "Grain" is a holistic thing, a _gestalt_.  This makes it difficult to write about extension methods or immutable value types.  Instead our parts should be about meatier topics -- e.g. like the error handling part -- that can show how the different features of Kotlin come together to create a grain, and how that influences design.

* Domain modelling idea: separate things that can be modelled algebraically from "human-centric" things that are messy.  Compose or calculate the latter from the former.
+
E.g. Money and FX conversions can be modelled algebraically.  The _application_ domain model of CostSummary is human-centric: what it contains depends on what the user(s) of this application need it to do.

* Factoring pure functions out of the middle of pipelines that have I/O at each end, rather than telling other objects to do something (which will eventuall involve doing some I/O).
** The Anura refactoring experience

* Mutability is nasty because it makes it hard to rearrange code (not just because of parallelism).
** TODO: find a data pipeline example where a refactoring breaks the logic

* Funny story: error results in zeros being stored as lat/lon, which results in map showing short journey in London being routed via Africa.





