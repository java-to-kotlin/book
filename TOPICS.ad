= Topics to cover

Small details...

* Option<T> -> nullable T?
* Properties vs fields/get/set
* value classes vs data class
* Collections and compiler magic
* Statics vs companion objects, and annotating Kotlin code to play well with existing Java (@JvmStatic)
* Error handling - checked exceptions to result monad
* Extension methods
** how they play nicely with null
** define them for different domains in the app



Java coding styles
"Modern Java" (streams, lambdas, immutable data, composition, lightweight frameworks) vs "beans" (mutable state, null references as sentinel values, getters & setters, reflection, annotations)
Common properties of Java:
Good things: JVM, tooling, libraries
Annoyances: verbosity, special cases (e.g. primitive vs reference types, void), language features that do not compose well (e.g. checked exceptions & streams), null references (Tony Hoare's "billion dollar mistake").
Kotlin supports "beans" style Java well, but you don't get a lot of the benefits at larger scales.  Modern Java lends itself well to conversion to idiomatic Kotlin that takes advantage of Kotlin's default immutability, better type system and the safety that provides.
The "grain" of Kotlin:
Immutable data
Functions rather than classes
Deliberate polymorphism
Explicit control flow
Data Classes - we take some Java classes representing data and convert them to Kotlin
Adding a Kotlin build to a Java project
Converting your first file
Java v Kotlin Classes
Data Classes
Constructors, Properties, Methods
Java style (classes with methods) vs Kotlin style (classes, freestanding functions or extension methods, class methods for polymorphism)
Calling Java from Kotlin and vice versa
Variables and values
Read-only collections
Extension functions
Nulls - build on the previous example showing how to Java and Kotlin handle null differently
The problem with null in Java
Nullable annotations and their limitations
Optional
Null is part of Kotlin's type system: type safety is null safety
Domain Code - convert Java code for manipulating the data from Chapter 1 into Kotlin
Top level and static scope
Extension functions on core library types
Extension functions on nullable types
Converting Java streams
Lambdas, destructuring
Computed extension properties
API design by adding extension methods to existing types rather than defining new ones
Typealiases
Modules and Functions - convert Java JSON serialisation utilities to Kotlin
Reinforcing many of the earlier lessons
Refactoring into a DSL rather than designing one from scratch
Exceptions
Convenience functions (let, apply etc)

Later chapters will build on this core - they will be about more high-level refactorings.

Error Handling:
The background of error handling facilities inherited from Java: exceptions.
Options/nulls
monadic error handling
Data Pipelines
Composing algorithms from sequence of primitive transformations
Comparison to Java streams, and limitations of Streams API -- it doesn't let you abstract transformations of entire streams in the same way as transformations of values within a stream. E.g. you cannot add new, higher-level methods to Streams
Using Kotlin extension methods to refactor pipeline stages: transformations of streams and of values can be treated in the same way, leading to much more readable pipelines.
Input and Output
The problem with IO
Moving IO to the edge of our software
Functional Design (refactoring from the procedural style common in enterprise Java systems to a functional style)
Functional core, imperative shell
Referential transparency
Compositionality
Data driven design
