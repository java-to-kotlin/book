== An opinionated history of Java programming style
Kotlin has features that support different _styles_ of Java programming.  Over the decades, Java programming style has developed through several distinct eras, that I think of as: The Applets Age, The Beans Age, The Enterprise Age, and The Modern Age.  We'll refer to these "ages" as a shorthand when explaining why certain Kotlin features exist, and how to use them.

=== The Applets Age

Java was originally developed for use in domestic appliances and interactive TV, but it only took off when Sun released their HotJava web browser. HotJava never achieved mass market success, but it did convince Netscape to support Java applets in their hugely popular Navigator browser.  Suddenly everyone with a web browser had a Java runtime environment.  Sun released the Java development kit 1.0, Microsoft included Java in Internet Explorer, and interest in Java as a programming language exploded.

A lot of the fundamentals of Java existed by then: the Java virtual machine and its bytecode and classfile format; primitive and reference types; garbage collection; classes and interfaces; methods and control flow statements; checked exceptions for error handling; the abstract windowing toolkit;  classes for networking with Internet and web protocols; and loading and linking of code at runtime, sandboxed by a security manager; However, Java wasn’t yet ready for general purpose programming: the JVM was slow and the standard library sparse.

Java looked like a cross between C++ and Smalltalk, and Java programming style at the time was influenced by those two languages. It had not yet developed the "get/set/get/set" and "BeanFactoryFactoryProxyImplBeanFactoryBean" conventions that programmers of other languages poke fun at.

One of Java's unsung innovations was an official coding convention that specified how programmers should name packages, classes, methods, and variables.  C and C++ programmers followed a seemingly infinite variety of coding conventions, and code that combined multiple libraries ended up looking <s>like a right dog's dinner</s> somewhat inconsistent.  Java's one true coding convention meant that Java programmers could seamlessly integrate strangers' libraries into their programs, which encouraged widespread use of open source in the Java community.

== The Beans Age

Java started to become a practical tool with version 1.1. This brought a beefier JVM, language changes (most notably inner classes), a standard collections framework, a better GUI framework, a database API (JDBC, "inspired by" Microsoft’s ODBC), a Servlets and Java Beans. (from Microsoft's Active-X)

Sun was eyeing Microsoft's domination of enterprise software development, and saw in Java a potential competitor to Visual Basic.  They added a slew of APIs that were, to be charitable, heavily inspired by Microsoft APIs.  JDBC for data base access (Microsoft had ODBC), servlets for HTTP server programming (Microsoft had IIS), Swing for desktop GUI programming (Microsoft had MFC), and the API that had the biggest influence on Java programming style: Java Beans.

Java Beans was Sun's attempt to compete with Microsoft's ActiveX component model for low-code, graphical, drag-and-drop programming.  Programmers could use ActiveX components in their Visual Basic programs, or embed them in office documents, or in web pages on their corporate intranet.  ActiveX components were notoriously difficult to write, and Java Beans were much easier.  You merely had to follow some additional coding conventions for your class to be considered a "bean" that could be instantiated and configured in a graphical UI designer.

In the end, graphical composition of Java beans never really took off.  But the coding conventions stuck.  Java programmers followed the Java Bean conventions even when they had no intention of their class being used as a Java Bean, and so Beans and had an enormous, lasting influence on Java programming style.

Bean style:

* No arg constructor.
* GetXxx/setXXX method pairs for public properties.
* Event listeners interfaces and event objects, and addXxxListener/removeXxxListener method pairs for notifications.
* Lots of mutable state.
* Nulls leaking all over the place.

=== The Enterprise Age

Java generics.  HotSpot.

J2EE.  Abstraction Inversion.  The rise of Dependency Injection and the fall of object abstraction.

Coding style: like beans... but more so.

Best in class development tools.


=== The Modern Age

Lambdas and streams.  Immutability, and a more functional programming style.

Modules.


=== The future

Records.  User defined value types.  Unifying primitive and reference types.
