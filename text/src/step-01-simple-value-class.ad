= We convert a value class to Kotlin

Kotlin data classes are probably the quickest win for most Java projects. Let's warm up on a very simple example.

Here is a typical Java class, representing a Presenter at a conference.

// begin-insert: tags/r1.0:src/main/java/colloquiumatic/Presenter.java
[source,java]
[%autofit]
----
public class Presenter {
    private final String id;   // <1>
    private final String name; // <1>

    public Presenter(String id, String name) {
        this.id = id;
        this.name = name;
    }

    // <2>
    public String getId() {
        return id;
    }

    // <2>
    public String getName() {
        return name;
    }

    // <3>
    @Override
    public String toString() {
        return "colloquiumatic.Presenter{" +
            "id='" + id + '\'' +
            ", name='" + name + '\'' +
            '}';
    }

    // <3>
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Presenter presenter = (Presenter) o;
        return id.equals(presenter.id) && // <3>
            name.equals(presenter.name);
    }

    // <3>
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }

}
----
// end-insert

Looking at the code you can see:

1. Presenter is immutable.

2. Although the class is not a Java Bean, the accessor methods of the `id` and `name` properties follow the Java Bean naming conventions.

3. We want to make sure that two presenters with the same fields compare equal, and have the same hashcode - Presenter is a Value Object. There is quite a lot of code to make that happen, but luckily our IDE has generated it for us.

4. We come from the school of Java that assumes that everything we pass, store or return is not null unless explicitly indicated otherwise.footnote:[Well, you can't _see_ that, but it's why there are no `@Nullable` annotations or null checks of parameters.]

IntelliJ has a command to convert a Java source file to Kotlin. It is called (at the time of writing) 'Convert Java File to Kotlin File', and is bound to Ctrl+Shift+Alt+K on Windows and Linux, Cmd-Shift-Option-K on Mac. When we run that command on Presenter.java, IntelliJ thinks for a while and then pops up a dialog that informs us "Some of the code in the rest of your project may require corrections after performing this conversion." and asks "Do you want to find such code and correct it too?".  We'll look into the effects of this choice later. For now, we'll click the "Yes" button and let IntelliJ to do the needful.  When it finishes, our code looks like:

// begin-insert: tags/r1.1:src/main/java/colloquiumatic/Presenter.kt
[source,kotlin]
[%autofit]
----
class Presenter(val id: String, val name: String) {

    override fun toString(): String {
        return "colloquiumatic.Presenter{" +
            "id='" + id + '\''.toString() +
            ", name='" + name + '\''.toString() +
            '}'.toString()
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val presenter = o as Presenter?
        return id == presenter!!.id && name == presenter.name
    }

    override fun hashCode(): Int {
        return Objects.hash(id, name)
    }
}
----
// end-insert

Take some time to compare the two files.

To our eyes the first noticeable difference is that in the Kotlin file, fields have been moved into brackets after the class name. This is a _primary constructor_ (we'll come to secondary constructors later). Any parameters to the primary constructor may be labelled as `val` and will automatically become available as properties. In other words that first line stands in for all this Java

// begin-insert: tags/r1.0:src/main/java/colloquiumatic/Presenter.java#replaced_by_primary_constructor
[source,java]
[%autofit]
----
public class Presenter {
    private final String id;   // <1>
    private final String name; // <1>

    public Presenter(String id, String name) {
        this.id = id;
        this.name = name;
    }

    // <2>
    public String getId() {
        return id;
    }

    // <2>
    public String getName() {
        return name;
    }

    ...
----
// end-insert

The primary constructor syntax is convenient, but it does interfere with the "scannability" of the class.  Java classes that follow the standard coding conventions always define their elements in the same order: class name, superclass, interfaces, then within the class body, fields, constructors, and methods.  This makes it easy to skim-read the class and quickly locate the features you're interested in.  It's not quite so easy in Kotlin: a class definition is organised thus: class name, primary constructor (which can contain parameters and/or property definitions), superclass (which may also be the call to the superclass' constructor), interfaces, then within the class body, more properties, more constructors, methods, and companion objects (we'll come to those later).  Coming from Java, I definitely found it harder to read classes at first, and although I got used to it eventually, I still find it hard at times to neatly format classes that have a primary constructor, a superclass, several interfaces, and properties that are defined outside the primary constructor. I'll happily diverge from the standard Kotlin coding conventions to add more blank lines between the primary constructor and the rest of the class definition if it makes it easier to distinguish different elements of the class.


`Val` is short for 'value' and marks a property that you cannot change once set - the equivalent of Java's `final`. We could (but almost always wouldn't) have used `var` for `variable`, in which case the property could be modified and a Java setter would be generated.

TODO: something on name.equals v name ==

So far converting our Presenter to Kotlin has saved us 13 lines of code, but we aren't done yet. Value types like this are so useful but so tedious to get right and keep right that Kotlin supports them at a language level. Mark the class with the `data` modifier and the compiler will generate the `equals`, `hashCode` and `toString` methods automatically, allowing us to delete them from our code, leaving us with just:

// begin-insert: tags/r1.2:src/main/java/colloquiumatic/Presenter.kt
[source,kotlin]
[%autofit]
----
data class Presenter(val id: String, val name: String)
----
// end-insert

Ah that's better, and when we add properties to a Presenter we won't have to remember to update the generated methods or find ourselves with hard-to-diagnose bugs.

Now there is so little code, it's easy to pick out a few more differences between Java and Kotlin.

Firstly, the default visibility in Kotlin is public, so `public class Presenter` can just be `class Presenter`.

====
If you are the same sort of Java programmer as we were you may question this language design decision. Our experience working with the language is that it fits well with a more data-oriented design philosophy, where less state has to be hidden. See Chapter TODO.
====

Secondly, type specifiers in Kotlin come after the identifier, not before it. So instead of `String id` we have `id: String`. This turns out to play nicer with complex nested types and we found that we very quickly didn't notice it at all.

Finally, we have been able to remove the body of the class altogether, so there isn't an empty `{}` pair.

You haven't seen them yet, but we had some tests for our Presenter.

// begin-insert: tags/r1.2:src/test/java/colloquiumatic/PresenterTests.java
[source,java]
[%autofit]
----
class PresenterTests {

    private Presenter nat = new Presenter("1", "Nat");
    private Presenter duncan = new Presenter("2", "Duncan");

    @Test
    void properties() {
        assertEquals("1", nat.getId());
        assertEquals("Duncan", duncan.getName());
    }

    @Test
    void equality() {
        assertEquals(nat, new Presenter("1", "Nat"));
        assertNotEquals(nat, duncan);
    }

    @Test
    void testHashCode() {
        assertEquals(nat.hashCode(), new Presenter("1", "Nat").hashCode());
        assertNotEquals(nat.hashCode(), duncan.hashCode());
    }
}
----
// end-insert

Due to the excellent interoperation between Kotlin and Java, these continue to pass with the converted class. Take a moment to think what that implies about the generated class.

Our Java Presenter had explicit `getId` and `getName` methods. These are not in the converted Kotlin, but still our Java can call them. The Kotlin compiler is not only generating the `equals`, `hashCode` and `toString` methods we knew about, but also `getId` and `getName`. `id` and `name` are not fields in Kotlin, they are properties.

====
We'll have a lot to say about properties later, but for now if you think of them as a private field with a public getter you won't often be wrong.
====

Let's convert the tests themselves to Kotlin

// begin-insert: tags/r1.3:src/test/java/colloquiumatic/PresenterTests.kt
[source,kotlin]
[%autofit]
----
internal class PresenterTests {
    private val nat = Presenter("1", "Nat")
    private val duncan = Presenter("2", "Duncan")

    @Test
    fun properties() {
        Assertions.assertEquals("1", nat.id)
        Assertions.assertEquals("Duncan", duncan.name)
    }

    @Test
    fun equality() {
        Assertions.assertEquals(nat, Presenter("1", "Nat"))
        Assertions.assertNotEquals(nat, duncan)
    }

    @Test
    fun testHashCode() {
        Assertions.assertEquals(nat.hashCode(), Presenter("1", "Nat").hashCode())
        Assertions.assertNotEquals(nat.hashCode(), duncan.hashCode())
    }
}
----
// end-insert

As usual, take a few moments to compare before and after.

TODO - internal

The first thing that we spot is that the Java fields, `nat` and `duncan` are declared as `val` properties but we haven't had to repeat their type - `Presenter nat = new Presenter(...);`. Kotlin would allow us to say `val nat: Presenter = Presenter(...)` but does not require it here.

====
Properties can be declared with `val` if they don't change, and `var` if they do. Even though we had not declared the fields as `final` in Java, the translator has been clever enough to see that they are not changed and to convert them to `val`.
====

Looking at the properties, we see that there is no `new` keyword to construct instances of classes - 'invoking' the class name as a function calls the relevant constructor.

At the end of the line, if you're already used to reading languages other than Java you may not notice the lack of semicolons to terminate statements. They are optional in Kotlin - you can use them to separate statements on a single line, but if the compiler can make sense of code by pretending that there is one on the end of a line it will.

Moving on, we might infer that the Java `void` keyword is replaced in Kotlin by `fun`. Actually though, methods in Kotlin are marked by `fun` and, where they return nothing, do not have to declare a return type.

Looking in the body of the methods, where Java called `nat.getId()`, Kotlin accesses the property `nat.id`. In actual fact Kotlin will call the `getId` that it has generated (or one supplied by a Java class) rather than accessing a field directly - so nothing has really changed except that we can drop the `get` and `()`.

====
There is quite a bit of subtlety to properties. We will keep on returning to this subject.
====

One irritation is that for us the static import of `org.junit.jupiter.api.Assertions.*` has been lost in the conversion. The converter is a work in progress and that may have changed by the time that you read this. A couple of quick Alt-Enters will fix it up in any case.

Stepping away from the Java, and comparing with our previous Kotlin class, Presenter, we see that in test class does not declare its properties in the primary constructor.  JUnit requires a default (no argument) constructor, and where a class does not initialise properties through a constructor (as with `nat` and `duncan` here) they are not declared in the primary constructor but rather inside the class body.

Stepping even further back, we can look at these tests and say that, as we have no logic in our Presenter, we have no need for the tests. If we delete them we have reduced 64 lines of Java code and tests to 1 line of Kotlin.

== Conclusions

* Convert to Kotlin is handy
* But does not do all the work for you
* Minimum ceremony
* Convenience
* Favour immutability
* Data classes FTW
