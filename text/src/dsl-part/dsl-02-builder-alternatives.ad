[[builders]]
= We look at alternatives to the [class="pattern"]_Builder_ pattern

Java programmers use the [class="pattern"]_Builder_ pattern for several purposes:
to make it easier to instantiate classes that have many constructor parameters;
to construct immutable objects in imperative code;
to allow tests to specify only the properties relevant to a test scenario and use safe defaults for all others;
to act as the grammar of an embedded domain-specific language expressed with chained method calls, known as a [class="pattern"]_Fluent API_.
Despite all the repetitive boiler plate code they involve, Java programmers do find builders are worth the effort and address real challenges that they face using the language.

In this chapter, we'll look at Kotlin features that make many of these uses of builders unnecessary, and how to introduce them in a mixed Java/Kotlin codebase.  In later chapters we'll look at how to safely transform ex-Java code that uses builders to idiomatic Kotlin, and how to use Kotlin language features to turn builders into embedded domain-specific languages.


== Builders for constructors with many parameters

The following code shows class representing session proposals.  Our system has a web application for people to propose conference sessions during the CFP period.

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/Proposal.java#built_object
[source,java]
[%autofit]
----
public class Proposal {
    private final SessionType type;
    private final String title;
    private final List<PresenterDetails> presenters;
    private final int durationInSlots;
    private final String blurb;
    private final String detailsForReviewers;
    private final String extraRequirements;

    public Proposal( // <1>
        SessionType type,
        String title,
        List<PresenterDetails> presenters,
        int durationInSlots,
        String blurb,
        String detailsForReviewers,
        String extraRequirements
    ) {
        this.type = type;
        this.title = title;
        this.presenters = List.copyOf(presenters);
        this.durationInSlots = durationInSlots;
        this.blurb = blurb;
        this.detailsForReviewers = detailsForReviewers;
        this.extraRequirements = extraRequirements;
    }

    public static ProposalBuilder builder() { // <2>
        return new ProposalBuilder();
    }

    public SessionType getType() {
        return type;
    }

    public String getTitle() {
        return title;
    }

    // ... the rest of the accessors, equals, hashCode, and toString
}
----
// end-insert

The Proposal constructor has a lot of parameters, because Proposals have a lot of fields and sub-objects.  This makes calling the constructor directly error-prone. It's easy to pass the parameters in the wrong order, and end up with an presenter's email address where their name should be, or details for reviewers where the blurb for the audience should be, and it's difficult to spot those errors when reading the code.

To address these problems, we use the [class="pattern"]_Builder_ pattern.  Here's the method that parses a Proposal from a form posted by a web browser:

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/ProposalFormParser.java#use_builder
[source,java]
[%autofit]
----
public Proposal parseProposalForm(Form form) throws FormParseException {
    ProposalBuilder pb = Proposal.builder()
        .withType(form.field("type", SessionType.class))
        .withTitle(form.field("title"))
        .withBlurb(form.field("blurb"))
        .withDetailsForReviewers(form.field("details"))
        .withExtraRequirements(form.field("extra_requirements"))
        .withDurationInSlots(form.field("slots", Integer.class, Integer::parseInt));

    int i = 1;
    while (form.hasField("presenter_" + i + "_name")) {
        pb.plusPresenter(
            PresenterDetails.builder()
                .withName(form.field("presenter_" + i + "_name"))
                .withCountryISO2(form.field("presenter_" + i + "_country_iso2"))
                .withEmailAddress(form.field("presenter_" + i + "_email"))
                .build());
        i = i + 1;
    }

    return pb.build();
}
----
// end-insert

The builder makes clear which properties are being set, which helps us avoid setting the wrong properties when we are writing the code, and makes it much easier to understand the code when we read it later.

However, writing a builder involves a lot of boilerplate:

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/ProposalBuilder.java#builder
[source,java]
[%autofit]
----
public class ProposalBuilder {
    private SessionType type; // <1>
    private String title;
    private List<PresenterDetails> presenters = new ArrayList<>();
    private int durationInSlots;
    private String blurb;
    private String detailsForReviewers;
    private String extraRequirements;

    public ProposalBuilder withType(SessionType type) { // <2>
        this.type = type;
        return this;
    }

    public ProposalBuilder withTitle(String title) {
        this.title = title;
        return this;
    }

    public ProposalBuilder withPresenters(List<PresenterDetails> presenters) {
        this.presenters = new ArrayList<>(presenters); // <3>
        return this;
    }

    public ProposalBuilder plusPresenters(List<PresenterDetails> morePresenters) { // <4>
        this.presenters.addAll(morePresenters);
        return this;
    }

    public ProposalBuilder plusPresenter(PresenterDetails p) { // <4>
        this.presenters.add(p);
        return this;
    }

    // ... setters for the rest of the properties
    public Proposal build() { // <5>
        assert type != null;
        assert title != null && !title.isEmpty();
        assert presenters != null && !presenters.isEmpty();
        assert durationInSlots > 0;
        assert blurb != null && !blurb.isEmpty();
        assert detailsForReviewers != null && !detailsForReviewers.isEmpty();
        assert extraRequirements != null;

        return new Proposal(
            type,
            title,
            presenters,
            durationInSlots,
            blurb,
            detailsForReviewers,
            extraRequirements);
    }
}
----
// end-insert

...

This use of builders is not necessary in Kotlin.  The language supports named function (and constructor) parameters, allowing us to write the code above like this instead:

// begin-insert: tags/builders.6:src/main/java/colloquiumatic/proposal/ProposalFormParsing.kt
[source,kotlin]
[%autofit]
----
fun parseProposal(form: Form) =
    Proposal(
        type = form.field("type", SessionType::class.java),
        title = form.field("title"),
        blurb = form.field("blurb"),
        detailsForReviewers = form.field("details"),
        extraRequirements = form.field("extra_requirements"),
        durationInSlots = form.field("slots", Int::class.java) { s: String -> s.toInt() },
        presenters = parsePresenters(form)
    )

private fun parsePresenters(form: Form) =
    generateSequence(1, { it + 1 })
        .takeWhile { form.hasField("presenter_" + it + "_name") }
        .map { parsePresenter(form, it) }
        .toList()

private fun parsePresenter(form: Form, n: Int) =
    PresenterDetails(
        name = form.field("presenter_" + n + "_name"),
        countryISO2 = form.field("presenter_" + n + "_country_iso2"),
        emailAddress = form.field("presenter_" + n + "_email")
    )
----
// end-insert

As we introduce Kotlin into the codebase, we'll have to keep the builders around for the remaining Java code, but can call constructors directly when writing new Kotlin code.

It is worth translating the builder classes to Kotlin in the meantime.  As we change the Kotlin domain classes we can lean on Kotlin's more rigorous typechecking to make sure we keep the builder and built classes in sync.  Specifically, the builders use `null` as a sentinel value for properties that have not been initialised, and assertions to ensure that objects are not built with uninitialised properties.  That looks worrisome.  It's easy to forget to add an assertion when adding a new property to a class.  In Kotlin, having null safety in the type system means that the type checker will do the job of the assertions' run-time checks, with no effort needed on our part.

Although they are closely related, I prefer to break down the conversion of classes and their builders into small steps, and do them independently rather than all in one go.
However, that static `builder` method creates a circular dependency between the Proposal and ProposalBuilder classes.
It is a common convention in Java code: a bit of syntactic sugar that lets us avoid using the "new" keyword. It also makes it easier for programmers to discover that a builder exists in the codebase when they are looking at a class, which helps makes our codebase more consistent.  The circular dependency isn't a big deal: the class and its builder form a highly cohesive unit.

But when we convert the built class to Kotlin and leave the builder in Java, we put the interop layer between those two classes.  We'll end up with some boilerplate code in our Kotlin class -- a companion object to hold the static builder method -- that exists only to support the Java side.

However, it's hard to argue that the syntactic sugar of the `builder` method really adds enough value in the production code to justify its existence.

We care more about syntactic sugar in our tests, where we want our code to be read more like a declarative specification.
But the tests do not call the `builder` method directly.
The test module contains a bit _more_ syntactic sugar that creates a [class="pattern"]_Test Data Builder_ set up with default property values, so that a test need specify only the property values that are relevant to the test scenario.  For example:

// begin-insert: tags/builders.0:src/test/java/colloquiumatic/proposal/ProposalNotificationsTest.java#use_of_builder
[source,java]
[%autofit]
----
@Test
public void test_sends_initial_confirmation_email_to_all_presenters() {
    Proposal proposalWithTwoPresenters = aProposal()
        .withPresenters(List.of(
            aPresenter().withEmailAddress("alice@example.com").build(),
            aPresenter().withEmailAddress("bob@example.com").build()))
        .build();

    // ... test that a confirmation email is dispatched to both presenters
    // ... via the GDPR-compliant messaging logic
}
----
// end-insert

On balance, therefore, let's break the circular dependency between classes and their builders by removing the `builder` methods and calling `new` directly.
We'll see what we do about the [class="pattern"]_Test Data Builders_ in <<test-data-builders>>.

We can break the dependency by inlining the builder function, leaving code that uses a builder looking like:

// TODO: example here ...

We can then convert the Proposal class to a Kotlin data class and tidy up the code as we did in <<value-types>>:

// TODO: CODE HERE ...

The Proposal class uses the PresenterDetails class, and that also has a builder.  We'll also have to inline _it's_ builder function, and then we can convert it to a Kotlin data class.

...


[[test-data-builders]]
== Test Data Builders



In Kotlin, we can use constants instead of builders, as long as the objects we want to create are data objects.
