= Values, Calculations, and Actions

In his excellent book _Grokking Simplicity_,
Eric Normand develops the idea
that we can categorise our code into values, calculations, and actions.
Actually he says _data_ rather that _values_,
but in the context of Kotlin,
which allows mutable data types,
values avoids confusion.

== Values

Values are immutable data.
You know code that represents data when you it when you see it.
While that sounds like a cop-out,
it's the key attribute -
you can interpret data
without executing code.

[source,kotlin]
----
val data = mapOf(
    "firstName" to "Fred",
    "lastName" to "Flintstone"
)
----

or

[source,kotlin]
----
val customer = Customer(
    firstName = "Fred",
    lastName = "Flintstone"
)
----

or

[source,json]
----
{
    "firstName" : "Fred",
    "lastName" : "Flintstone"
}
----

are all meaningful without being run by some computer.
The JSON form even manages to be meaningful
between different systems,
written in different languages,
even when the system that wrote it was decommissioned
before the system that read it was conceived,
and even when one of those systems is a human.

It is this simplicity of interpretation that makes data so useful.
To make it even more useful,
we further constrain data to be immutable.
Otherwise we don't just have data,
we have data as it is at a particular time,
and that isn't simple at all.
So maybe _values_ would be a better characterisation than data,
but let's stick with Eric's terminology.

== Calculations

Calculations are mappings from input values to output values -
they are functions.
We specify their working in code
(or maths, or some notation) -
as a result they are less easy to interpret than values.
We call them calculations,
rather than functions,
because they are pure -
they must always give the same output given the same input.
Not all software functions are calculations.

[source,kotlin]
----
fun fullName(customer: Customer) = "${customer.firstName} ${customer.lastName}"
----

is a calculation,
as it will always return the same value
when supplied the same `Customer` value.
This is true only if `Customer` is immutable,
(or at least `firstName` and `secondName` are) -
let's stick with values for our inputs and that will always be true.

By extension 
(pun only retrospectively intended)

[source,kotlin]
----
fun Customer.fullName() = "$firstName $lastName"
----

is also a calculation,
making it clear that the receiver of extension function
counts as an input in our definition.

Computed properties can also be calculations

[source,kotlin]
----
val Customer.fullName get() = "$firstName $lastName"
----

indeed things get confusing quickly 
if they don't always give the same result.
That's a good guideline for when to use to choose a property
over a function or method -
when the result doesn't change over time.

Methods,
or the hidden methods that are computed member-properties,
can also be calculations.

[source,kotlin]
----
data class Customer(
    val firstName: String,
    val lastName: String
) {
    fun getFullName() = "$firstName $lastName"
    val fullName get() = "$firstName $lastName"
}
----

Here `this` is considered a input to the functions,
as the receiver was for the extension examples.

== Actions

Code that does not define values,
or specify a pure calculation,
is an action.
Actions depend on when and/or how many times they are run.
This will happen if they change something in their environment,
or their environment affects their result - 
side-effects in other words.

[source,kotlin]
----
class Customers {
    fun save(data: CustomerData) {
        ...
    }
    fun find(id: String): Customer? {
        ...
    }
}
----

Both `save` and `find` are actions,
as find's result depends on whether it is run before or after
a customer with that id has been saved.

[source,kotlin]
----
fun email(itinerary: Itinerary) {
    ...
}
----

is an action,
because if you run it twice the customer will get two emails,
which is different from if you run it once,
which is different from if you run it nonce.

Functions returning `void` or `Unit` are a dead giveaway for actions,
as are functions that take no parameters
(although there are exceptions here).














