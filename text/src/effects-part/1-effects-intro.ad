= Values, Calculations, and Actions

In his excellent book
https://www.manning.com/books/grokking-simplicity[Grokking Simplicity],
Eric Normand develops the idea
that we can categorise our code into values, calculations, and actions.
Actually he says _data_ rather that _values_,
but in the context of Kotlin,
which allows mutable data types,
values avoids confusion.

== Values

Values are immutable data.
You know code that represents data when you it when you see it.
While that sounds like a cop-out,
it's the key attribute -
you can interpret data
without executing code.

[source,kotlin]
----
val data = mapOf(
    "firstName" to "Fred",
    "lastName" to "Flintstone"
)
----

or

[source,kotlin]
----
val customer = Customer(
    firstName = "Fred",
    lastName = "Flintstone"
)
----

or

[source,json]
----
{
    "firstName" : "Fred",
    "lastName" : "Flintstone"
}
----

are all meaningful without being run by some computer.
The JSON form even manages to be meaningful
between different systems,
written in different languages,
even when the system that wrote it was decommissioned
before the system that read it was conceived,
and even when one of those systems is a human.

It is this simplicity of interpretation that makes data so useful.
To make it even more useful,
we further constrain data to be immutable.
Otherwise we don't just have data,
we have data as it is at a particular time,
and that isn't simple at all.
So maybe _values_ would be a better characterisation than data,
but let's stick with Eric's terminology.

== Calculations

Calculations are mappings from input values to output values -
they are functions.
We specify their working in code
(or maths, or some notation) -
as a result they are less easy to interpret than values.
We call them calculations,
rather than functions,
because they are pure -
they must always give the same output given the same input.
Not all software functions are calculations.

[source,kotlin]
----
fun fullName(customer: Customer) = "${customer.firstName} ${customer.lastName}"
----

is a calculation,
as it will always return the same value
when supplied the same `Customer` value.
This is true only if `Customer` is immutable,
(or at least `firstName` and `secondName` are) -
let's stick with values for our inputs and that will always be true.

By extension 
(pun only retrospectively intended)

[source,kotlin]
----
fun Customer.fullName() = "$firstName $lastName"
----

is also a calculation,
making it clear that the receiver of extension function
counts as an input in our definition.

Computed properties can also be calculations

[source,kotlin]
----
val Customer.fullName get() = "$firstName $lastName"
----

indeed things get confusing quickly 
if they don't always give the same result.
That's a good guideline for when to choose a property
over a function or method -
when the result doesn't change over time.

Methods,
or the hidden methods that are computed member-properties,
can also be calculations.

[source,kotlin]
----
data class Customer(
    val firstName: String,
    val lastName: String
) {
    fun getFullName() = "$firstName $lastName"
    val fullName get() = "$firstName $lastName"
}
----

Here `this` is considered a input to the functions,
as the receiver was for the extension examples.

== Actions

Code that does not define values,
or specify a pure calculation,
is an action.
Actions depend on when and/or how many times they are run.
This will happen if they change something in their environment,
or their environment affects their result - 
side-effects in other words.

[source,kotlin]
----
class Customers {
    fun save(data: CustomerData) {
        ...
    }
    fun find(id: String): Customer? {
        ...
    }
}
----

Both `save` and `find` are actions,
as find's result depends on whether it is run before or after
a customer with that id has been saved.

[source,kotlin]
----
fun email(itinerary: Itinerary) {
    ...
}
----

is an action,
because if you run it twice the customer will get two emails,
which is different from if you run it once,
which is different from if you run it nonce.
Functions returning `void` or `Unit` are a dead giveaway for actions,
because if they do anything they have to do it by side effect.

Functions that have no parameters
(so this doesn't include methods or extension functions)
must also either be returning a constant;
or be reading from some other source
and so be categorised as actions.
So we can deduce that the top-level function

[source,kotlin]
----
fun requestRate(): Double {
    ...
}
----

is probably an action,
reading from some global mutable state,
whereas

[source,kotlin]
----
class Metrics(
   ...
) {

    fun requestRate(): Double {
        ...
    }
}
----

is probably a calculation,
provided `Metrics` is immutable.
We say probably,
because in languages that allow IO or mutating data from any code
(like Java or Kotlin),
there is no way to be sure if a function represents a value, calculation or action
short of examining it.
We'll return to that problem soon.

== Why Should We Care?

We should obviously pay special attention to some actions in our software.
Sending the same email to every user twice is a bug,
as is not sending it at all.
We care exactly how many times it is sent,
and probably when it is sent too,
maybe down to the minute,
so that our offer for a free first-class upgrade is at the top of our customer's inbox
when they read their email over breakfast.

Other seemingly innocuous actions may be more nocuous than we think.
Changing the order of read and write actions causes concurrency bugs.
Error handling is much more complicated if the second of two related actions fails.
Fundamentally,
actions prevent us having free-reign to refactor in ways
which change when or whether they are invoked.

Calculations on the other hand can be invoked at any time,
with no consequences except a waste of time and energy.
If you are refactoring code
and find that you don't need the result of a calculation,
you can safely not invoke it.
If it is an expensive calculation,
you can safely cache its result;
if it is not expensive,
you can safely recalculate it on demand if that simplifies things.
It is this feeling of safety that puts the smug smile on the faces of functional programmers.

Values, well they just are.
Simply accessing immutable data takes even less reasoning than calculations.
You don't have to drill down through source code,
or write tests,
to determine behaviour.
Calculations can fail for various reasons,
the main error that we have to consider with data is what to do in its absence,
and, at least in the case of Kotlin,
we have language support for that.
The more code we can move into the values category
the simpler our life will be.

.Procedural Code
****
Nat and Duncan are both old enough to have learned to programme in Sinclair BASIC. This dialect had no local variables, no immutable data, and no concept of defining a function with parameters that could return values.
It requires real discipline to programme in such a system, because practically every line of code is an action, and hence potentially affects the functioning of every other statement.

This is in fact very close to the way that our computers actually work, with mutable values held in registers and global memory, manipulated by machine-code actions.
The evolution of programming languages has been a process of restricting the ultimate flexibility of this model, in order that humans can better reason with the code that they create.
****

== Combining Categories

The categories - values, calculations and actions, do not overlap.
If code depends on when or whether you run it, it is an action and not a calculation.
If it doesn't, but isn't just accessing immutable data, it is a calculation.
Otherwise, the code is expressing a value.

If you have code which is simply accessing a value, and you change it to invoke a calculation, it becomes a calculation itself, as we now have to interpret code to work out what it is doing.
Similarly, any calculation which invokes an action becomes an action itself, as it is now subject to time.
We see a similar situation with errors - code is raised to the most tainted level of all of its dependencies.

As with the susceptibility to errors, if we value the lack of taint, we must strive to pull the boundary between impure and pure code to the outer layers of our system.
If we succeed, then a significant proportion of our code can be values and calculations, and hence easily tested, reasoned-with, and refactored.

If we don't succeed in keeping actions at the top of our call-stack, we can fix things with refactoring.





















