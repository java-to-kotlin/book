= Refactoring to Kotlin
Duncan McGregor; Nat Pryce
:doctype: book
:pdf-page-size: 7inx9.1875in
:icons: font
:sectnums:
:toc:
// Needed for syntax for UI interactions
:experimental:
:plantuml-config: style.plantuml

= Introduction

:leveloffset: +1

include::intro-why-kotlin.ad[]

include::intro-why-refactoring-to-kotlin.ad[]

include::intro-an-opinionated-history-of-java-style.ad[]

include::worked-example-overview.ad[]

include::step-00-making-the-project-multilingual.ad[]

include::intro-where-to-start.ad[]

:leveloffset: -1

[[value-types]]
= Values and Functions

:leveloffset: +1

include::step-01-simple-value-class.ad[]

include::step-02-collections.ad[]

include::step-03-optionality.ad[]

:leveloffset: -1


= Data Pipelines

== TODO


= Extension Functions

== TODO


= Syntactic Sugar and Embedded Domain-Specific Languages

* syntactic sugar / embedded domain specific embedded languages
* applicative vs builder style
* options in Java vs Kotlin
* maintaining a DSL for a mixed Java/Kotlin codebase
  - distinct syntactic sugar for each language.
  - Separate syntax from implementation.
  - using annotations to reduce impact of Kotlin style on existing Java code

:leveloffset: +1

include::step-dsl-01-applicative.ad[]
include::step-dsl-02-builders.ad[]

:leveloffset: -1


= Error Handling

:leveloffset: +1

include::step-x-errors.ad[]

:leveloffset: -1


= Input/Output

== TODO


= Assembling the Application

== TODO


= Theoretical Stuff Not Yet Woven Through the Examples

:leveloffset: +1

include::error-handling.ad[]

include::digression-type-hierarchy.ad[]

include::digression-generic-types.ad[]

:leveloffset: -1