= We can make a Java API for building JSON trees less "noisy" with Kotlin

Our application contains a little bit of code that we use in tests to build examples of JSON data. This allows us to write self contained tests that are not split between Java code and JSON resource files, and is more convenient than building JSON examples by string concatenation.

Here's what code that builds a JSON tree looks like:

// begin-insert: tags/jsondsl.0:src/test/java/colloquiumatic/rating/RateSessionCommandParserTest.java#json_dsl_usage
[source,java]
[%autofit]
----
import static colloquiumatic.json.Json.obj;
import static colloquiumatic.json.Json.prop;
...
        JsonNode commandAsJson = obj(
            prop("userId", exampleUserId),
            prop("scheduledSessionId", exampleSessionId),
            prop("wouldRecommend", 1),
            prop("appreciation", "Helpful tips and strategies for refactoring Java to Kotlin."),
            prop("suggestions", "Would like information about what to do with code that uses Lombok.")
        );
----
// end-insert

The `Json` class contains static functions that return objects from Jackson library:

// begin-insert: tags/jsondsl.0:src/test/java/colloquiumatic/json/Json.java#json_dsl
[source,java]
[%autofit]
----
public class Json {
    private static final JsonNodeFactory nodes = JsonNodeFactory.instance;

    @SafeVarargs
    public static ObjectNode obj(Map.Entry<String, JsonNode>... props) {
        return obj(asList(props));
    }

    public static ObjectNode obj(Iterable<Map.Entry<String, JsonNode>> props) {
        ObjectNode node = nodes.objectNode();
        props.forEach(p -> node.set(p.getKey(), p.getValue()));
        return node;
    }

    public static Map.Entry<String, JsonNode> prop(String name, JsonNode value) {
        return new AbstractMap.SimpleImmutableEntry<>(name, value);
    }

    public static Map.Entry<String, JsonNode> prop(String name, String textValue) {
        return prop(name, new TextNode(textValue));
    }

    public static Map.Entry<String, JsonNode> prop(String name, int intValue) {
        return prop(name, new IntNode(intValue));
    }

    // and similar syntactic sugar for other primitive JSON types, and JSON arrays
}
----
// end-insert

The Jackson library does most of the heavy lifting required, and our `Json` class just tries to make Java source code that builds JSON data as close to JSON syntax as possible.  That's not very close, to be fair, but closer than you can get by using the Jackson library directly.

To convert this into Kotlin, it doesn't make sense to start with the `Json` class: it's job is to provide syntactic sugar for our Java code.  At best, converting it to Kotlin will leave the Java code unchanged, and so not be worth the effort.  At worst, the conversion will make it _worse_ as a convenient notation, and we'll have to annotate the Kotlin API to get it back to where we started.

Instead, let's convert the code that depends on the `Json` class to Kotlin first.  When that's done, we can convert the `Json` class to Kotlin, and then apply Kotlin language features to make a better notation than is possible in Java.

Unfortunately, IntelliJ does not know that the purpose of the Json class is to define syntactic sugar and it doesn't carry the static imports across into Kotlin. It translates `obj` and `prop` to `Json.obj` and `Json.prop`, and messes up our carefully crafted notation.  We can fix this by hitting Alt-Enter on the first call to each method in the file we translated and choose to import the method directly.

When all the dependent code is converted to Kotlin, we can convert the Json class itself.  The Java class of static methods is translated into a top level Kotlin object, also called `Json`.

At the time of writing, the translator doesn't get the conversion quite right.  It marks more types as nullable than we would want, and doesn't infer the nullability correctly, so the resulting code doesn't compile.

// begin-insert: tags/jsondsl.3:src/test/java/colloquiumatic/json/Json.kt#incorrect_translation
[source,kotlin]
[%autofit]
----
    @SafeVarargs
    fun obj(vararg props: Map.Entry<String?, JsonNode?>?): ObjectNode {
        return obj(Arrays.asList(*props)) /// note: Type mismatch.
    }

    fun obj(props: Iterable<Map.Entry<String?, JsonNode?>>): ObjectNode {
        val node = nodes.objectNode()
        props.forEach(Consumer { p: Map.Entry<String?, JsonNode?> ->
            node.set<JsonNode>(p.key, p.value)
        })
        return node
    }
----
// end-insert

We can fix it by removing the nullability modifiers.

// begin-insert: tags/jsondsl.4:src/test/java/colloquiumatic/json/Json.kt#correction
[source,kotlin]
[%autofit]
----
    @SafeVarargs
    fun obj(vararg props: Map.Entry<String, JsonNode>): ObjectNode {
        return obj(Arrays.asList(*props)) /// note: Type mismatch.
    }

    fun obj(props: Iterable<Map.Entry<String, JsonNode>>): ObjectNode {
        val node = nodes.objectNode()
        props.forEach(Consumer { p: Map.Entry<String, JsonNode> ->
            node.set<ObjectNode>(p.key, p.value)
        })
        return node
    }
----
// end-insert

Now everything is working again, we can start applying Kotlin features to simplify the implementation of our syntactic sugar, and make it less "noisy".

DRAFT BELOW...

Tidy up the construction of JSON objects using Kotlin stdlib instead of JDK APIs and SAMs, and single-expression functions instead of block functions.

// begin-insert: tags/jsondsl.5:src/test/java/colloquiumatic/json/Json.kt#tidy_implementation
[source,kotlin]
[%autofit]
----
object Json {
    private val nodes = JsonNodeFactory.instance

    fun obj(vararg props: Map.Entry<String, JsonNode>) = obj(props.asList())

    fun obj(props: Iterable<Map.Entry<String, JsonNode>>): ObjectNode =
        nodes.objectNode().apply {
            props.forEach { p -> set<ObjectNode>(p.key, p.value) }
        }

    fun prop(name: String, value: JsonNode) = SimpleImmutableEntry(name, value)
    fun prop(name: String, textValue: String) = prop(name, TextNode(textValue))
    fun prop(name: String, intValue: Int) = prop(name, IntNode(intValue))

    // and the rest of the syntactic sugar...
}
----
// end-insert

... replace use of Map.Entry with pair...

There's no automatic way of doing this refactoring in one go.  However, thanks to Kotlin type inference and our use of single-expression functions, Map.Entry is only referred to in three places: as parameters of the `obj` functions and in the implementation of `prop(String,JsonNode)`.  Code that _uses_ our syntactic sugar does not refer to the Map.Entry type at all.   So, it's easy enough to change these by hand.

However, with a bit of refactoring-fu we can perform the transformation as a series of safe additions of temporary code and automated transformation steps without ever introducing a compilation error:

1. Alt-Enter on the "Entry" in Map.Entry, and select "add import for 'kotlin.collections.Map.Entry'".  Now all references in the file to the `Map.Entry` type are via the unqualified name "Entry".
2. Add a typealias below the imports, aliasing Entry and SimpleImmutableEntry to Pair:

   ----
   typealias Entry<K,V> = Pair<K,V>
   typealias SimpleImmutableEntry<K,V> = Pair<K,V>
   ----

3. Delete the imports of kotlin.collections.Map.Entry and java.util.AbstractMap.SimpleImmutableEntry.  All uses of Entry in the file are now referring to `kotlin.Pair`.
4. Define two temporary extension properties on Pair to match those on Map.Entry:

   ----
   val <K,V> Pair<K,V>.key get() = first
   val <K,V> Pair<K,V>.value get() = second
   ----

5. Inline the typealiases.
6. Inline the temporary extension properties we created in step 4.
7. Tidy up by removing unnecessary explicit type parameters that IntelliJ left in the `prop` function that creates Pairs.

That leaves the code looking like:

// begin-insert tags/jsondsl.7:src/test/java/colloquiumatic/json/Json.kt#tidy_implementation
// end-insert
****
Was that worth it for this small class?  Maybe not.  But when transformations have to touch lots of places across the code, it's easier and less risky to perform the refactoring as a sequence of small steps in which the IDE automatically changes dependent code.  So I like to practice working in that way whenever I get the opportunity.
****


... make `prop` an infix function.

It's not idiomatic Kotlin to create pairs by calling the constructor.
Alt-Enter on the call to the Pair constructor in the `prop` function, and choose the option "convert to 'to'".

The `to` operator for constructing Pairs is not a language feature.  It's an _infix_ function defined in the standard library.  An infix function is a method or extension function that takes one parameter and is marked with the `infix` modifier.  It can be called with operator-like syntax: you don't need to use a dot to reference the method or enclose the parameter in parentheses.

That gives us a clue as to how to improve the notation now we are working in Kotlin.  Wouldn't it be nice if object properties did not have to be wrapped in a call to `prop`, but used an infix notation instead. We can't call our JSON infix operator "to"; that's been taken for Pairs.  But we can use a similarly short word.  How about "of"?  That would make code that builds JSON look like:

TODO: refer to the final state here

How do we turn a function into an infix function?  We need to first introduce an extension method, and then mark it as infix.  IntelliJ can automatically do the first step: Alt-Enter on the first parameter of each `prop` function and select "Convert parameter to receiver".  We must mark it as infix manually.  Now our JSON-building code looks like this:

TODO: refer to wrong direction state here

But how do we make the call sites use infix syntax?  At the time of writing, IntelliJ automates that for an individual call site via the Alt-Enter menu, but doesn't have a way to do it in bulk for _all_ uses of an infix function in the codebase.  Too tedious!

Let's roll back and take another run at it: we'll try using the _Add-code-and-inline_ trick we used to swap out the Map.Entry type for Pair.


... make top level ...

