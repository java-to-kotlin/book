= We can make a Java API for building JSON trees less "noisy" with Kotlin

Our application contains a little bit of code that we use in tests to build examples of JSON data. This allows us to write self contained tests that are not split between Java code and JSON resource files, and is more convenient than building JSON examples by string concatenation.

Here's what code that builds a JSON tree looks like:

// begin-insert: tags/jsondsl.0:src/test/java/colloquiumatic/rating/RateSessionCommandParserTest.java#json_dsl_usage
[source,java]
[%autofit]
----
import static colloquiumatic.json.Json.obj;
import static colloquiumatic.json.Json.prop;
...
        JsonNode commandAsJson = obj(
            prop("userId", exampleUserId),
            prop("scheduledSessionId", exampleSessionId),
            prop("wouldRecommend", 1),
            prop("appreciation", "Helpful tips and strategies for refactoring Java to Kotlin."),
            prop("suggestions", "Would like information about what to do with code that uses Lombok.")
        );
----
// end-insert

The `Json` class contains static functions that return objects from Jackson library:

// begin-insert: tags/jsondsl.0:src/test/java/colloquiumatic/json/Json.java#json_dsl
[source,java]
[%autofit]
----
public class Json {
    private static final JsonNodeFactory nodes = JsonNodeFactory.instance;

    @SafeVarargs
    public static ObjectNode obj(Map.Entry<String, JsonNode>... props) {
        return obj(asList(props));
    }

    public static ObjectNode obj(Iterable<Map.Entry<String, JsonNode>> props) {
        ObjectNode node = nodes.objectNode();
        props.forEach(p -> node.set(p.getKey(), p.getValue()));
        return node;
    }

    public static Map.Entry<String, JsonNode> prop(String name, JsonNode value) {
        return new AbstractMap.SimpleImmutableEntry<>(name, value);
    }

    public static Map.Entry<String, JsonNode> prop(String name, String textValue) {
        return prop(name, new TextNode(textValue));
    }

    public static Map.Entry<String, JsonNode> prop(String name, int intValue) {
        return prop(name, new IntNode(intValue));
    }

    // and similar syntactic sugar for other primitive JSON types, and JSON arrays
}
----
// end-insert

The Jackson library does most of the heavy lifting required, and our `Json` class just tries to make Java source code that builds JSON data as close to JSON syntax as possible.  That's not very close, to be fair, but closer than you can get by using the Jackson library directly.

To convert this into Kotlin, it doesn't make sense to start with the `Json` class: it's job is to provide syntactic sugar for our Java code.  At best, converting it to Kotlin will leave the Java code unchanged, and so not be worth the effort.  At worst, the conversion will make it _worse_ as a convenient notation, and we'll have to annotate the Kotlin API to get it back to where we started.

Instead, let's convert the code that depends on the `Json` class to Kotlin first.  When that's done, we can convert the `Json` class to Kotlin, and then apply Kotlin language features to make a better notation than is possible in Java.

Unfortunately, IntelliJ does not know that the purpose of the Json class is to define syntactic sugar and it doesn't carry the static imports across into Kotlin. It translates `obj` and `prop` to `Json.obj` and `Json.prop`, and messes up our carefully crafted notation.  We can fix this by hitting Alt-Enter on the first call to each method in the file we translated and choose to import the method directly.

When all the dependent code is converted to Kotlin, we can convert the Json class itself.  The Java class of static methods is translated into a top level Kotlin object, also called `Json`.

At the time of writing, the translator doesn't get the conversion quite right.  It marks more types as nullable than we would want, and doesn't infer the nullability correctly, so the resulting code doesn't compile.

// begin-insert: tags/jsondsl.3:src/test/java/colloquiumatic/json/Json.kt#incorrect_translation
[source,kotlin]
[%autofit]
----
    @SafeVarargs
    fun obj(vararg props: Map.Entry<String?, JsonNode?>?): ObjectNode {
        return obj(Arrays.asList(*props)) /// note: Type mismatch.
    }

    fun obj(props: Iterable<Map.Entry<String?, JsonNode?>>): ObjectNode {
        val node = nodes.objectNode()
        props.forEach(Consumer { p: Map.Entry<String?, JsonNode?> ->
            node.set<JsonNode>(p.key, p.value)
        })
        return node
    }
----
// end-insert

We can fix it by removing the nullability modifiers.

// begin-insert: tags/jsondsl.4:src/test/java/colloquiumatic/json/Json.kt#correction
[source,kotlin]
[%autofit]
----
    @SafeVarargs
    fun obj(vararg props: Map.Entry<String, JsonNode>): ObjectNode {
        return obj(Arrays.asList(*props)) /// note: Type mismatch.
    }

    fun obj(props: Iterable<Map.Entry<String, JsonNode>>): ObjectNode {
        val node = nodes.objectNode()
        props.forEach(Consumer { p: Map.Entry<String, JsonNode> ->
            node.set<ObjectNode>(p.key, p.value)
        })
        return node
    }
----
// end-insert

Now everything is working again, we can start applying Kotlin features to simplify the implementation of our syntactic sugar, and make it less "noisy".

DRAFT BELOW...

Tidy up the construction of JSON objects using Kotlin stdlib instead of JDK APIs and SAMs, and single-expression functions instead of block functions.

// begin-insert: tags/jsondsl.5:src/test/java/colloquiumatic/json/Json.kt#tidy_implementation
[source,kotlin]
[%autofit]
----
object Json {
    private val nodes = JsonNodeFactory.instance

    fun obj(vararg props: Map.Entry<String, JsonNode>) = obj(props.asList())

    fun obj(props: Iterable<Map.Entry<String, JsonNode>>): ObjectNode =
        nodes.objectNode().apply {
            props.forEach { p -> set<ObjectNode>(p.key, p.value) }
        }

    fun prop(name: String, value: JsonNode) = SimpleImmutableEntry(name, value)
    fun prop(name: String, textValue: String) = prop(name, TextNode(textValue))
    fun prop(name: String, intValue: Int) = prop(name, IntNode(intValue))

    // and the rest of the syntactic sugar...
}
----
// end-insert
