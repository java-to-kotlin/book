= We refactor a "domain-specific embedded language" for building JSON data

Our application contains a utility class of static methods that we use in tests to build examples of JSON data.
This allows us to write self-contained tests that are not split between Java code and JSON resource files without having to build JSON examples by string concatenation.

Here's what some test code that builds a JSON tree looks like:

// begin-insert: tags/jsondsl.0:src/test/java/colloquiumatic/rating/RateSessionCommandParserTest.java#json_dsl_usage
[source,java]
[%autofit]
----
import static colloquiumatic.json.Json.obj;
import static colloquiumatic.json.Json.prop;
...
        JsonNode commandAsJson = obj(
            prop("userId", exampleUserId),
            prop("scheduledSessionId", exampleSessionId),
            prop("wouldRecommend", 1),
            prop("appreciation", "Helpful tips and strategies for refactoring Java to Kotlin."),
            prop("suggestions", "Would like information about what to do with code that uses Lombok.")
        );
----
// end-insert

Our Json class acts as an _embedded domain specific language_.
It wraps the Jackson library, which does all the work of representing JSON data and serialising/deserialising JSON to and from strings and stream, and tries to make Java code that builds JSON data look as close to JSON syntax as possible.
That's not _very_ close, to be fair, but its closer than is possible by using the Jackson library directly.

// begin-insert: tags/jsondsl.0:src/test/java/colloquiumatic/json/Json.java#json_dsl
[source,java]
[%autofit]
----
public class Json {
    private static final JsonNodeFactory nodes = JsonNodeFactory.instance;

    @SafeVarargs
    public static ObjectNode obj(Map.Entry<String, JsonNode>... props) {
        return obj(asList(props));
    }

    public static ObjectNode obj(Iterable<Map.Entry<String, JsonNode>> props) {
        ObjectNode node = nodes.objectNode();
        props.forEach(p -> node.set(p.getKey(), p.getValue()));
        return node;
    }

    public static Map.Entry<String, JsonNode> prop(String name, JsonNode value) {
        return new AbstractMap.SimpleImmutableEntry<>(name, value);
    }

    public static Map.Entry<String, JsonNode> prop(String name, String textValue) {
        return prop(name, new TextNode(textValue));
    }

    public static Map.Entry<String, JsonNode> prop(String name, int intValue) {
        return prop(name, new IntNode(intValue));
    }

    // and similar syntactic sugar for other primitive JSON types, and JSON arrays
}
----
// end-insert

Now we need to decide what we convert first: the Json class or the code that depends on it.
Up to now, we've preferred starting with classes that are leaves in the dependency tree, and pushing the Kotlin boundary outwards, creating an expanding region of code in which we take full advantage Kotlin's type safety and standard library.
But this case is different: the Json class provides syntactic sugar to our Java code and has almost no logic itself.
At best, converting it to Kotlin will leave the Java code unchanged, and so not be worth the effort.
The conversion could make it _worse_ as a convenient notation in Java, and we'll have to annotate the Kotlin API to get it back to where we started.
And even then we won't be able to apply Kotlin-specific features, such as infix or inline functions, to improve the DSL because what works well as a notation in Kotlin will not carry over to the Java code and definitely make it worse.

If we start by converting the code using the Json class, we'll end up with a notation in the Kotlin code that is no worse than our existing Java, and that we can improve when we convert the Json class to Kotlin.

Let's convert that test to Kotlin:

// begin-insert: tags/jsondsl.1:src/test/java/colloquiumatic/rating/RateSessionCommandParserTest.kt#json_dsl_usage
[source,kotlin]
[%autofit]
----
...
        val commandAsJson: JsonNode = Json.obj(
            Json.prop("userId", exampleUserId),
            Json.prop("scheduledSessionId", exampleSessionId),
            Json.prop("wouldRecommend", 1),
            Json.prop("appreciation", "Helpful tips and strategies for refactoring Java to Kotlin."),
            Json.prop("suggestions", "Would like information about what to do with code that uses Lombok.")
        )
----
// end-insert

Unfortunately, IntelliJ didn't carry the static imports across into Kotlin.
It translated `obj` and `prop` to `Json.obj` and `Json.prop`, and messed up our carefully crafted notation.
It did not know that the Json class exists to define syntactic sugar, and that the way that the Java imported its functions was significant.

We can fix this by hitting Alt-Enter on the first call to each method in the file we translated and choose to import the method directly.

Once we have converted all the dependent code to Kotlin, we can convert the Json class itself.
The Java class of static methods becomes a top-level Kotlin object, also called `Json`.

At the time of writing, the translator doesn't get the conversion quite right.
It marks more types as nullable than we would want, and doesn't infer the nullability correctly, so the resulting code doesn't compile.

// begin-insert: tags/jsondsl.3:src/test/java/colloquiumatic/json/Json.kt#incorrect_translation
[source,kotlin]
[%autofit]
----
@SafeVarargs
fun obj(vararg props: Map.Entry<String?, JsonNode?>?): ObjectNode {
    return obj(Arrays.asList(*props)) /// note: Type mismatch.
}

fun obj(props: Iterable<Map.Entry<String?, JsonNode?>>): ObjectNode {
    val node = nodes.objectNode()
    props.forEach(Consumer { p: Map.Entry<String?, JsonNode?> ->
        node.set<JsonNode>(p.key, p.value)
    })
    return node
}
----
// end-insert

We can fix it by removing the nullability modifiers.

// begin-insert: tags/jsondsl.4:src/test/java/colloquiumatic/json/Json.kt#correction
[source,kotlin]
[%autofit]
----
@SafeVarargs
fun obj(vararg props: Map.Entry<String, JsonNode>): ObjectNode {
    return obj(Arrays.asList(*props)) /// note: Type mismatch.
}

fun obj(props: Iterable<Map.Entry<String, JsonNode>>): ObjectNode {
    val node = nodes.objectNode()
    props.forEach(Consumer { p: Map.Entry<String, JsonNode> ->
        node.set<ObjectNode>(p.key, p.value)
    })
    return node
}
----
// end-insert

Now everything is working again, we can start applying Kotlin features to simplify the implementation of our syntactic sugar and improve the notation in code that uses it.

// TODO - write this paragraph!
Tidy up the construction of JSON objects using Kotlin stdlib instead of JDK APIs and SAMs, and single-expression functions instead of block functions.

// begin-insert: tags/jsondsl.5:src/test/java/colloquiumatic/json/Json.kt#tidy_implementation
[source,kotlin]
[%autofit]
----
object Json {
    private val nodes = JsonNodeFactory.instance

    fun obj(vararg props: Map.Entry<String, JsonNode>) = obj(props.asList())

    fun obj(props: Iterable<Map.Entry<String, JsonNode>>): ObjectNode =
        nodes.objectNode().apply {
            props.forEach { p -> set<ObjectNode>(p.key, p.value) }
        }

    fun prop(name: String, value: JsonNode) = SimpleImmutableEntry(name, value)
    fun prop(name: String, textValue: String) = prop(name, TextNode(textValue))
    fun prop(name: String, intValue: Int) = prop(name, IntNode(intValue))

    // and the rest of the syntactic sugar...
}
----
// end-insert

The use of Map.Entry and AbstractMap.SimpleImmutableEntry now stand out.
We used them to hold key/value pairs, because Java doesn't have a value type for pairs.
Kotlin does: kotlin.Pair.
Let's use it.

There's no automatic refactoring that can replace Map.Entry and AbstractMap.SimpleImmutableEntry with Pair in one go.
However, thanks to Kotlin type inference and our use of single-expression functions, Map.Entry is only referred to in three places: as parameters of the `obj` functions and in the implementation of `prop(String,JsonNode)`.
The code that _uses_ our syntactic sugar does not refer to the Map.Entry type at all.
So, it's easy enough to change these by hand.
However, with a bit of refactoring-fu we can perform the transformation as a series of safe additions of temporary code and automated transformation steps without ever introducing a compilation error:

First, we Alt-Enter on the "Entry" in Map.Entry, and select "add import for 'kotlin.collections.Map.Entry'". Now all references in the file to the `Map.Entry` type are via the unqualified name "Entry".

Secondly, we add a typealias below the imports, aliasing Entry and SimpleImmutableEntry to Pair:

// begin-insert: tags/jsondsl.6:src/test/java/colloquiumatic/json/Json.kt#type_aliases
[source,kotlin]
[%autofit]
----
typealias Entry<K,V> = Pair<K,V>
typealias SimpleImmutableEntry<K,V> = Pair<K,V>
----
// end-insert

IntelliJ will highlight them as unused, because the imports of Entry and SimpleImmutableEntry take precedence over the typealiases in the file.  But hold on, those imports are going to disappear shortly.

Now we define two extension properties on Pair to match the properties of Map.Entry:

// begin-insert: tags/jsondsl.6:src/test/java/colloquiumatic/json/Json.kt#temporary_extension_properties
[source,kotlin]
[%autofit]
----
val <K,V> Pair<K,V>.key get() = first
val <K,V> Pair<K,V>.value get() = second
----
// end-insert

Again, IntelliJ will highlight them as unused, but they will become used as soon as the imports disappear.

Now we delete the imports of kotlin.collections.Map.Entry and java.util.AbstractMap.SimpleImmutableEntry.
All uses of Entry in the file are now referring to kotlin.Pair.  IntelliJ no longer highlights the typealiases and extension properties as unused.

Finally we clean up by inlining the typealiases and the temporary extension properties, so that the Pair type is used directly, and removing unnecessary type parameters that the inline refactoring left in call to the Pair constructor.

That leaves the code looking like:

// begin-insert: tags/jsondsl.7:src/test/java/colloquiumatic/json/Json.kt#json_dsl
[source,kotlin]
[%autofit]
----
object Json {
    private val nodes = JsonNodeFactory.instance

    fun obj(vararg props: Pair<String, JsonNode>) = obj(props.asList())

    fun obj(props: Iterable<Pair<String, JsonNode>>): ObjectNode =
        nodes.objectNode().apply {
            props.forEach { p -> set<ObjectNode>(p.first, p.second) }
        }

    fun prop(name: String, value: JsonNode) = Pair(name, value)
    fun prop(name: String, textValue: String) = prop(name, TextNode(textValue))
    fun prop(name: String, intValue: Int) = prop(name, IntNode(intValue))

    // and the rest of the syntactic sugar...
}
----
// end-insert

****
Was that worth it for this small class?
Maybe not.
But when transformations have to touch lots of places across the code, it's easier and less risky to perform the refactoring as a sequence of small steps in which the IDE automatically applies changes to dependent code.
Think of this as a demonstration of the technique in the small, so we can use it for larger changes later.
****

The definition of the first prop function now looks a bit iffy.
In Kotlin we don't usually create pairs by calling the Pair constructor.
Alt-Enter on the call to `Pair` in the prop function, and choose the option "convert to 'to'".
It now looks like:

// begin-insert: tags/jsondsl.8:src/test/java/colloquiumatic/json/Json.kt#use_to
[source,kotlin]
[%autofit]
----
fun prop(name: String, value: JsonNode) = name to value
----
// end-insert

The `to` operator for constructing Pairs is not a language feature.
It's an _infix_ function defined in the standard library.
An infix function is a method or extension function that takes one parameter and is marked with the `infix` modifier.
It can be called with operator-like syntax: you don't need to use a dot to reference the method or enclose the parameter in parentheses.

That gives us a clue as to how to improve the notation now we are working in Kotlin.
Wouldn't it be nice if object properties did not have to be wrapped in a call to `prop`, but used infix notation instead.
We can't call our JSON infix operator "to"; that's been taken for Pairs.
But we can use a similarly short word.
How about "of"?
That would make code that builds JSON look like:

// begin-insert: tags/jsondsl.11:src/test/java/colloquiumatic/rating/RateSessionCommandParserTest.kt#json_dsl_usage
[source,kotlin]
[%autofit]
----
import colloquiumatic.json.Json.obj
import colloquiumatic.json.Json.of
...
        val commandAsJson: JsonNode = obj(
            "userId" of exampleUserId,
            "scheduledSessionId" of exampleSessionId,
            "wouldRecommend" of 1,
            "appreciation" of "Helpful tips and strategies for refactoring Java to Kotlin.",
            "suggestions" of "Would like information about what to do with code that uses Lombok."
        )
----
// end-insert

How do we turn a function into an infix function?
We need to first make it an extension method, and then mark it as infix.
IntelliJ can automatically do the first step: Alt-Enter on the first parameter of each `prop` function and select "Convert parameter to receiver".
Now our JSON-building code looks like this:

// begin-insert: tags/jsondsl.9:src/test/java/colloquiumatic/rating/RateSessionCommandParserTest.kt#json_dsl_usage
[source,kotlin]
[%autofit]
----
val commandAsJson: JsonNode = obj(
    "userId".prop(exampleUserId),
    "scheduledSessionId".prop(exampleSessionId),
    "wouldRecommend".prop(1),
    "appreciation".prop("Helpful tips and strategies for refactoring Java to Kotlin."),
    "suggestions".prop("Would like information about what to do with code that uses Lombok.")
)
----
// end-insert

We must apply the infix modifier by hand, so how do we make the call sites use infix syntax?
At the time of writing, IntelliJ automates that for an individual call site via the Alt-Enter menu, but doesn't have a way to do it in bulk for _all_ uses of an infix function in the codebase.
Too tedious!

Let's roll back and take another run at it: we'll try using the _add-code-and-inline_ trick we used to swap out the Map.Entry type for Pair.
This time, we'll add new, infix functions called "of" and make the "prop" functions delegate to them.

// begin-insert: tags/jsondsl.10:src/test/java/colloquiumatic/json/Json.kt#temporary_delegation_to_infix_of_function
[source,kotlin]
[%autofit]
----
fun prop(name: String, value: JsonNode) = name of value
fun prop(name: String, textValue: String) = name of textValue
fun prop(name: String, intValue: Int) = name of intValue

infix fun String.of(value: JsonNode) = this to value
infix fun String.of(textValue: String) = this of TextNode(textValue)
infix fun String.of(intValue: Int) = this of IntNode(intValue)
----
// end-insert

Now we can inline the prop functions, and we're done.

// begin-insert: tags/jsondsl.11:src/test/java/colloquiumatic/json/Json.kt
[source,kotlin]
[%autofit]
----
object Json {
    private val nodes = JsonNodeFactory.instance

    fun obj(vararg props: Pair<String, JsonNode>) = obj(props.asList())

    fun obj(props: Iterable<Pair<String, JsonNode>>): ObjectNode =
        nodes.objectNode().apply {
            props.forEach { p -> set<ObjectNode>(p.first, p.second) }
        }

    infix fun String.of(value: JsonNode) = this to value
    infix fun String.of(textValue: String) = this of TextNode(textValue)
    infix fun String.of(intValue: Int) = this of IntNode(intValue)
}


----
// end-insert


... still not entirely idiomatic Kotlin.  We're not using the Json object as an object.  It's merely a namespace to hold the functions and a reference to the object mapper.  We might as well define them at the top level of the file.  However, IntelliJ cannot (at the time of writing) automatically move declarations from an object to the top level.  We'd have to do it by hand, either by deleting the first line and final brace and then "leaning on the compiler" to fix up dependent code, or by using the _add-code-and-inline_ move again.  Is it worth it?  I'll leave that up to you, the reader, if you're following along at home.
== Discussion: syntactic sugar, domain specific embedded languages, Java vs Kotlin

... TBD...

