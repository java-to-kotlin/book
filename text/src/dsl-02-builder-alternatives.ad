[[builders]]
= We look at alternatives to the [.pattern]_Builder_ pattern

Java programmers use the [.pattern]_Builder_ pattern for several purposes:
to make it easier to instantiate classes that have many constructor parameters;
to construct immutable objects in imperative code;
to allow tests to specify only the properties relevant to a test scenario and use safe defaults for all others;
to act as the grammar of an embedded domain-specific language expressed with chained method calls, known as a [.pattern]_Fluent API_.
Despite all the repetitive boiler plate code they involve, Java programmers do find builders are worth the effort and address real challenges that they face using the language.

In this chapter, we'll look at Kotlin features that make many of these uses of builders unnecessary, and how to introduce them in a mixed Java/Kotlin codebase.  In later chapters we'll look at how to safely transform ex-Java code that uses builders to idiomatic Kotlin, and how to use Kotlin language features to turn builders into embedded domain-specific languages.


== Builders for constructors with many parameters

The following code shows class representing session proposals.  Our system has a web application for people to propose conference sessions during the CFP period.

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/Proposal.java#built_object
[source,java]
[%autofit]
----
public class Proposal {
    private final SessionType type;
    private final String title;
    private final List<PresenterDetails> presenters;
    private final int durationInSlots;
    private final String blurb;
    private final String detailsForReviewers;
    private final String extraRequirements;

    public Proposal( // <1>
        SessionType type,
        String title,
        List<PresenterDetails> presenters,
        int durationInSlots,
        String blurb,
        String detailsForReviewers,
        String extraRequirements
    ) {
        this.type = type;
        this.title = title;
        this.presenters = List.copyOf(presenters);
        this.durationInSlots = durationInSlots;
        this.blurb = blurb;
        this.detailsForReviewers = detailsForReviewers;
        this.extraRequirements = extraRequirements;
    }

    public static ProposalBuilder builder() { // <2>
        return new ProposalBuilder();
    }

    public SessionType getType() {
        return type;
    }

    public String getTitle() {
        return title;
    }

    // ... the rest of the accessors, equals, hashCode, and toString
}
----
// end-insert

The Proposal constructor has a lot of parameters, because Proposals have a lot of fields and sub-objects.  This makes calling the constructor directly error-prone. It's easy to pass the parameters in the wrong order, and end up with an presenter's email address where their name should be, or details for reviewers where the blurb for the audience should be, and it's difficult to spot those errors when reading the code.

To address these problems, we use the [.pattern]_Builder_ pattern.  Here's the method that parses a Proposal from a form posted by a web browser:

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/ProposalFormParser.java#use_builder
[source,java]
[%autofit]
----
public Proposal parseProposalForm(Form form) throws FormParseException {
    ProposalBuilder pb = Proposal.builder()
        .withType(form.field("type", SessionType.class))
        .withTitle(form.field("title"))
        .withBlurb(form.field("blurb"))
        .withDetailsForReviewers(form.field("details"))
        .withExtraRequirements(form.field("extra_requirements"))
        .withDurationInSlots(form.field("slots", Integer.class, Integer::parseInt));

    int i = 1;
    while (form.hasField("presenter_" + i + "_name")) {
        pb.plusPresenter(
            PresenterDetails.builder()
                .withName(form.field("presenter_" + i + "_name"))
                .withCountryISO2(form.field("presenter_" + i + "_country_iso2"))
                .withEmailAddress(form.field("presenter_" + i + "_email"))
                .build());
        i = i + 1;
    }

    return pb.build();
}
----
// end-insert

The builder makes clear which properties are being set, which helps us avoid setting the wrong properties when we are writing the code, and makes it much easier to understand the code when we read it later.

However, writing a builder involves a lot of boilerplate:

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/ProposalBuilder.java#builder
[source,java]
[%autofit]
----
public class ProposalBuilder {
    private SessionType type; // <1>
    private String title;
    private List<PresenterDetails> presenters = new ArrayList<>();
    private int durationInSlots;
    private String blurb;
    private String detailsForReviewers;
    private String extraRequirements;

    public ProposalBuilder withType(SessionType type) { // <2>
        this.type = type;
        return this;
    }

    public ProposalBuilder withTitle(String title) {
        this.title = title;
        return this;
    }

    public ProposalBuilder withPresenters(List<PresenterDetails> presenters) {
        this.presenters = new ArrayList<>(presenters); // <3>
        return this;
    }

    public ProposalBuilder plusPresenters(List<PresenterDetails> morePresenters) { // <4>
        this.presenters.addAll(morePresenters);
        return this;
    }

    public ProposalBuilder plusPresenter(PresenterDetails p) { // <4>
        this.presenters.add(p);
        return this;
    }

    // ... setters for the rest of the properties
    public Proposal build() { // <5>
        assert type != null;
        assert title != null && !title.isEmpty();
        assert presenters != null && !presenters.isEmpty();
        assert durationInSlots > 0;
        assert blurb != null && !blurb.isEmpty();
        assert detailsForReviewers != null && !detailsForReviewers.isEmpty();
        assert extraRequirements != null;

        return new Proposal(
            type,
            title,
            presenters,
            durationInSlots,
            blurb,
            detailsForReviewers,
            extraRequirements);
    }
}
----
// end-insert

...

This use of builders is not necessary in Kotlin.  The language supports named function (and constructor) parameters, allowing us to write the code above like this instead:

// begin-insert: tags/builders.6:src/main/java/colloquiumatic/proposal/ProposalFormParsing.kt
[source,kotlin]
[%autofit]
----
fun parseProposal(form: Form) =
    Proposal(
        type = form.field("type", SessionType::class.java),
        title = form.field("title"),
        blurb = form.field("blurb"),
        detailsForReviewers = form.field("details"),
        extraRequirements = form.field("extra_requirements"),
        durationInSlots = form.field("slots", Int::class.java) { s: String -> s.toInt() },
        presenters = parsePresenters(form)
    )

private fun parsePresenters(form: Form) =
    generateSequence(1, { it + 1 })
        .takeWhile { form.hasField("presenter_" + it + "_name") }
        .map { parsePresenter(form, it) }
        .toList()

private fun parsePresenter(form: Form, n: Int) =
    PresenterDetails(
        name = form.field("presenter_" + n + "_name"),
        countryISO2 = form.field("presenter_" + n + "_country_iso2"),
        emailAddress = form.field("presenter_" + n + "_email")
    )
----
// end-insert

As we introduce Kotlin into the codebase, we'll have to keep the builders around for the remaining Java code, but can call constructors directly when writing new Kotlin code.

Currently the static `builder` method creates a circular dependency between the Proposal and ProposalBuilder classes.
The static `builder` method is a common convention in Java code.  It's a bit of syntactic sugar that lets us avoid using the "new" keyword. It also makes it easier for programmers to realise they can use a builder to create intances, which makes our codebase more consistent.  The circular dependency isn't a big deal: the class and its builder form a highly cohesive unit.

But when we convert the built class to Kotlin and leave the builder in Java, we put the interop layer between those two classes. This will make evolving that class and its builder a bit more work, and we'll end up with some code in our Kotlin class -- a companion object to hold the static builder method -- that exists only to support the Java side.

We've got a couple of options: convert the class and its builder to Kotlin in one go; or to break the circular dependency so that all references to the builder can remain on the Java side.

It's a bit weird to have Kotlin code that is _only_ to be used from Java, and never in Kotlin.
Looking at the Java logic, the syntactic sugar of the `builder` method does not add much value to production code where we use the builder.

We care more about syntactic sugar in our tests, where we want our code to be read more like a declarative specification.
However, our tests do not call the `builder` method directly.
We have a bit more syntactic sugar that creates a builder set up with default property values, so that a test need specify only the property values that are relevant to the test scenario.  For example:

// begin-insert: tags/builders.0:src/test/java/colloquiumatic/proposal/ProposalNotificationsTest.java#use_of_builder
[source,java]
[%autofit]
----
@Test
public void test_sends_initial_confirmation_email_to_all_presenters() {
    Proposal proposalWithTwoPresenters = aProposal()
        .withPresenters(List.of(
            aPresenter().withEmailAddress("alice@example.com").build(),
            aPresenter().withEmailAddress("bob@example.com").build()))
        .build();

    // ... test that a confirmation email is dispatched to both presenters
    // ... via the GDPR-compliant messaging logic
}
----
// end-insert

On balance, therefore, the second option looks like our best bet: to break the circular dependency to keep all references to the builder in Java, and then convert the built class to Kotlin.

We'll see what we do about the _Test Data Builders_ in <<test-data-builders>>.

We can break the dependency by inlining the builder function, leaving code that uses a builder looking like:

// TODO: example here ...

We can then convert the Proposal class to a Kotlin data class and tidy up the code as we did in <<value-types>>:

// TODO: CODE HERE ...

The Proposal class uses the PresenterDetails class, and that also has a builder.  We'll also have to inline _it's_ builder function, and then we can convert it to a Kotlin data class.

...


[[test-data-builders]]
== Test Data Builders

In Kotlin, we can use constants instead of builders, as long as the objects we want to create are data objects.

