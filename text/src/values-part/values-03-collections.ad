[[collections-and-transformation-pipelines]]

== Collections and Transformation Pipelines

The grain of Java and Kotlin are very different when it comes to collections.
Java's collection interfaces are fundamentally mutable and so force you to encapsulate collections within classes to avoid accidental aliasing.
Kotlin's collections default to being immutable, which reduces the need such encapsulation.
Kotlin's standard library contains many more useful higher-order functions than Java's collection and stream APIs.
This reduces the need for imperative programming when processing collections.
These two forces encourage designs in which many free-standing functions transform a few generic collection types.


=== A Class That Encapsulates a Collection

One of the core services of our Travelator application is route planning.

A Route is a sequence of Journeys that can take the traveller from one location to another.
Each Journey in a route is a service provided by an Operator, via some mode of transport -- ship, train, bus, camel, etc. -- departing from one location at a specific time and arriving at another location some time later.
The routing service suggests several possible routes, and our travellers can compare them by cost, duration, and so on, to choose the route they prefer.

The journeys along a route do not always have a convenient interchange between them.
Some services run only once a day, or once a week, so our travellers want to know when they will have to book somewhere to stay between the end of one journey and the start of the next.
This will let us improve the cost estimate for a route, because we can suggest places to stay and include the cost in the overall cost of the route.
We can make the feature earn its keep by booking their preferred choices and earning a commission.

The first step is to find every interchange in a Route where the traveller will need to stay one or more nights.
This gives us a good reason to convert our Route class to Kotlin.
Writing this logic in Java requires verbose, imperative code.
With Kotlin's standard library, we can write this as a concise, declarative pipeline of transformations.

Let's take a look at our Java Route class.

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route implements Iterable<Journey> {
    private final List<Journey> journeys;

    public Route(List<Journey> journeys) {
        this.journeys = List.copyOf(journeys); // <1>
    }

    @Override
    public Iterator<Journey> iterator() { // <2>
        return journeys.iterator();
    }

    public Location getStart() {
        return journeys.get(0).getDepartsFrom();
    }

    public Location getDestination() {
        return journeys.get(journeys.size() - 1).getArrivesAt();
    }

    public Duration getDuration() {
        return Duration.between(
            journeys.get(0).getDepartureTime(),
            journeys.get(journeys.size() - 1).getArrivalTime());
    }

    public CostSummary cost(Currency userCurrency, ExchangeRates fx) {
        return CostSummary.calculate(journeys, userCurrency, fx); // <2>
    }

    ...
}
----
// end-insert

<1> A Route encapsulates a List of Journeys.
Because Lists are mutable -- or, at least, the type system offers no guarantee that the List is _not_ mutable -- the constructor takes a defensive copy of the list to avoid https://martinfowler.com/bliki/AliasingBug.html[_aliasing errors_].
<2> Because `List.copyOf` method returns an immutable List, there is no need to make a defensive copy or wrap the list with a `Collections.unmodifiableList` when returning an Iterator over the list, or when passing the list as a parameter to another class.
Unfortunately the type system does not prevent us calling mutator methods on Iterator or List, but doing so will throw `UnsupportedOperationException`, so coding errors will be caught pretty quickly by our tests.

If we were to add a method to this class that returned the required stays, it would look like this:

[[required-stays-imperative]]
// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#imperative_algorithm
[source,java]
----
public List<Interchange> requiredStays() {
    var results = new ArrayList<Interchange>();

    for (int i = 1; i < journeys.size(); i++) {
        var interchange =
            Interchange.between(journeys.get(i - 1), journeys.get(i));

        if (interchange.isStayRequired()) {
            results.add(interchange);
        }
    }

    return results;
}
----
// end-insert

Let's translate the class to Kotlin, tidy it up, and then see how we can write the `requiredStays` logic in Kotlin.

Here's the class after IntelliJ has worked its translation magic:

// begin-insert: tags/collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> {
    private val journeys: MutableList<Journey>
    init {
        this.journeys = java.util.List.copyOf(journeys)
    }

    override fun iterator(): MutableIterator<Journey> =
        journeys.iterator()

    val start: Location get() =
        journeys[0].departsFrom

    val destination: Location get() =
        journeys[journeys.size - 1].arrivesAt

    val duration: Duration get() =
        Duration.between(
            journeys[0].departureTime,
            journeys[journeys.size - 1].arrivalTime)

    fun cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
        CostSummary.calculate(journeys, userCurrency, fx)

    ...
}
----
// end-insert

The construction of the Route class is pretty convoluted, and has broken the type safety of our Java class.

The constructor's List parameter is a _Kotlin_ List, which is unmodifiable.
Our Route class makes an defensive, immutable copy by calling `java.util.List.copyOf`, which returns a `java.util.List`.
Unlike a Kotlin List, a `java.util.List` does have methods for mutating the list, so the translated code store sthe result as a `MutableList` and exposes the iterator of that list as a `MutableIterator`.
Although this doesn't break encapsulation -- nothing can actually change the list of journeys -- it does break type safety -- calling a mutator method would throw `UnsupportedOperationException` at runtime.

TODO: explain the Kotlin/Java interop magic for collections implemented in the compiler?

Simplifying the code will also restore its type safety.

The class could make an  defensive, unmodifiable copy of the List in a Kotlin-esque way by calling `journeys.toList()`.
However, in our Travelator system, that list only comes from two places: from a JSON deserialiser that does not hold a reference to the list after creating the Route, and from test code that creates immutable lists.
This means that making a defensive copy is unnecessary work.
The can just store the immutable list.
We can do that succinctly by declaring the constructor parameter as a `val` and deleting the rest of the initialisation code.

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#constructor
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> {
    override fun iterator(): Iterator<Journey> =
        journeys.iterator()

    ...
}
----
// end-insert

The Route class implements the `Iterable` interface by delegating to the `journeys` List.
We can get the compiler to generate that delegation for us.

// begin-insert: tags/collections.4:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> by journeys {
    ...
}
----
// end-insert

The `destination` and `duration` accessors get the last journey in the list by calculating its integer index.
The Kotlin standard library defines a `List.last()` extension that we can use instead.
To make the code symmetrical, we'll also use the `List.first()` extension to get the first journey.

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#use_first_and_last
[source,kotlin]
----
val start: Location get() =
    journeys.first().departsFrom

val destination: Location get() =
    journeys.last().arrivesAt

val duration: Duration get() =
    Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime)
----
// end-insert

That leaves the Route class as:

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> by journeys {
    val start: Location get() =
        journeys.first().departsFrom

    val destination: Location get() =
        journeys.last().arrivesAt

    val duration: Duration get() =
        Duration.between(
            journeys.first().departureTime,
            journeys.last().arrivalTime)

    fun cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
        CostSummary.calculate(journeys, userCurrency, fx)

    ...
}
----
// end-insert

Now, let's add the `requiredStays` method to our Kotlin class.


=== Plugging Together a Transformation Pipeline

Recall the logic we want to add: find every interchange in a Route where the traveller will need to stay one or more nights.
An interchange is between two journeys is denoted by: `Interchange.between(journey1, journey2)`.
We can calculate all the interchanges in a route by sliding a two-element window along the list of journeys and calling `Interchange.between` for each pair it encounters.
Then we must filter the Interchanges to select only those that require one or more overnight stays.

In Java we would have had to implement this logic imperatively, <<required-stays-imperative,as shown above>>, with a for loop and mutable list, because the Java collection and streams APIs do not implement a sliding window across the elements of a list.
The imperative implementation inextricably intertwines the different aspects of the calculation.

In Kotlin, the standard library provides operations on List that do exactly what we want, allowing us to clearly express each step of the calculation:

// begin-insert: tags/collections.6:src/main/java/travelator/itinerary/Route.kt#declarative_algorithm
[source,kotlin]
----
fun requiredStays() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isStayRequired }
----
// end-insert


=== Do We Even Need the Route Class?

[quote,Alan Perlis,Epigrams in Programming]
It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.

In Java, the Route class encapsulated a mutable list to ensure that it couldn't be mutated.
In Kotlin, the List type cannot be mutated, so there is nothing to encapsulate.
There is no compelling reason for the `journeys` field to be private.

The Route class also provides accessors -- properties and query methods -- that return useful information about the route.
Those accessors support different parts of the application, but were defined in the Route class because they used the private list of Journeys.
With the list of journeys public, we can defined those as extension methods, and move them into the part of the application that uses them.
Except, while we still have Java that uses Routes, those accessors have another responsibility: to provide a convenient API for use by our Java code.

As we translate the Java code using the Route class into Kotlin, we will get to the point where methods and properties are only called from Kotlin.
At that point we can convert the class features to extensions and, where it makes sense, move them into the module that uses them.
IntelliJ can do this automatically.

When no more Java code depends on Route, it looks like:

// begin-insert: tags/collections.7:src/main/java/travelator/itinerary/Route.kt
[source,kotlin]
----
class Route(val journeys: List<Journey>) : Iterable<Journey> by journeys

val Route.start: Location get() =
    journeys.first().departsFrom

val Route.destination: Location get() =
    journeys.last().arrivesAt

val Route.duration: Duration get() =
    Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime)

fun Route.cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
    CostSummary.calculate(journeys, userCurrency, fx)
----
// end-insert

// begin-insert: tags/collections.7:src/main/java/travelator/rooms/Route_RequiredStays.kt
[source,kotlin]
----
fun Route.requiredStays() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isStayRequired }
----
// end-insert

It is now glaringly obvious that a Route is nothing more than a list of Journeys.
In Kotlin, we can express that directly, with a `typealias`:

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
----
// end-insert

However, replacing the class definition with a typealias will break code that constructs Route objects or refers to the `journeys` property.
We need to refactor our definition of `Route` from a class to a typealias without breaking the code that depends on it.
The way we'll do this is to replace the class with a typealias _and_ temporary definitions that emulate the API of the class.

// begin-insert: tags/collections.12:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
fun Route(journeys: List<Journey>) = journeys
val Route.journeys get() = this
----
// end-insert

The `Route` function ensures the calls to the constructor still compile.
The `Route.journeys` extension property ensures that references to the `journeys` property of the Route class still compile when a Route is a List of Journeys.

Then we can inline those temporary definitions, leaving the code that used them working with Lists of Journeys.

However, the replacement of the class definition with a typealias and temporary functions requires a manual edit.
Replacing the `journeys` property defined on the `Route` class with a `Route.journeys` extension property will break all the code that uses the `journeys` property, because a property on a class does not need to be imported, but an extension does.
We must refactor the class, and the code that depends on it, into a form in which the manual edit does not break any code.
In this case, this means converting the `journeys` property defined on the class into an extension property that is imported by the files that depend on it, before we replace it with the definition above.
We can do so with a sequence of automated refactoring steps.

We'll apply the "Move to class body" refactoring to the declaration of the `journeys` property in the primary constructor definition.

// begin-insert: tags/collections.8:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> by journeys {
    val journeys = journeys
}
----
// end-insert

We'll then apply the "Introduce backing property" refactoring to the `journeys` property in the class body.

// begin-insert: tags/collections.9:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> by journeys {
    private val _journeys = journeys
    val journeys: List<Journey>
        get() = _journeys
}
----
// end-insert

This refactoring has made the `journeys` property virtual, allowing us to turn it into an extension property on Route that is correctly imported into every file that refers to it.
We'll make the `_journeys` property internal.

// begin-insert: tags/collections.10:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> by journeys {
    internal val _journeys = journeys
    val journeys: List<Journey>
        get() = _journeys
}
----
// end-insert

Then we'll apply the `Convert to extension` refactoring to the `journeys` property.

// begin-insert: tags/collections.11:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> by journeys {
    internal val _journeys = journeys
}

val Route.journeys: List<Journey>
    get() = _journeys
----
// end-insert

Now we can manually replace the Route class with the typealias, `Route` function and `Route.journeys` extension property:

// begin-insert: tags/collections.12:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
fun Route(journeys: List<Journey>) = journeys
val Route.journeys get() = this
----
// end-insert

Finally, we inline the `Route` function and `journeys` extension property.

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
----
// end-insert

Now a Route _is_ a List of Journeys, across our entire codebase.

// begin-insert: tags/collections.13:src/main/java/travelator/rooms/Route_RequiredStays.kt
[source,kotlin]
----
fun Route.requiredStays() =
    this
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isStayRequired }
----
// end-insert


=== Abstracting Part of the Transformation Pipeline

TODO: extract `interchanges()` as an extension function on List<Journey>.

This is a generally useful function, that we would want people to find serendipitously if they are working with routes and interchanges, so that they don't rewrite it.
Therefore, let's make it public.  IntelliJ will then offer it as an autocomplete suggesstion on expressions of type List<Journey>.

This abstracts the _middle_ of a transformation pipeline, and makes it seamlessly meld in with the existing transformations API. This is something that cannot be done in Java with the Streams API does not, but Kotlin makes trivialm, thanks to extension functions.

TODO: Something about a general principle: factor out the middle of pipelines into useful transformations, rather than the downstream ends as you would do with tell-don't-ask OO design.


=== Conclusions

In Java, the justifiable fear of aliasing errors leads one to encapsulate collections of data in classes.
This tends to "attract" behaviour to the classes that encapsulate the data the behaviour requires.
However, by doing this we _reduce_ the operations available for us to work with the data to only those defined by the encapsulating class.

Immutable data does not require encapsulation.
We don't need to ensure that state changes always go through the class' interface because there are no state changes.
When our domain model _is_ the appropriate data structure, rather than encapsulating and hiding the data structure behind a class boundary, we _increase_ the operations available for us to work with the data.
We have all the operations defined for the collection, and can extend it with our own application-specific operations.

Immutable collections and extensions allow us to organise our code in different ways.
We can group all the logic required by a particular feature of the application, or group logic that bridges between different domains.
We continue this train of thought in <<organising-code-by-domain>>.
