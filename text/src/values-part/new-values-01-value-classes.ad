== Value Types

Compared to Java, Kotlin makes it easier to define and transform immutable values.
As a result, your authors find they define new value classes more frequently in Kotlin than in Java.
Kotlin makes it practical to define the core application domain model entirely as immutable values and functions that act upon them, and cheap to define "throwaway" value classes to hold the intermediate results of calculation pipelines, or to pivot data into shapes that make it easier to write application logic.

=== A Value Class Grouping Related Data

Our users want to know what their trip will cost.  We show costs in the local currencies of the countries they are travelling through, and convert those costs to the user's currency to give them an idea of the total cost of the entire trip.

Here is the Java value type in our application that represents the result of a currency conversion.

// begin-insert: tags/value_types.0:src/main/java/travelator/money/CurrencyConversion.java
[source,java]
----
public class CurrencyConversion {
    private final Money fromMoney; // <1>
    private final Money toMoney;

    // <2>
    public CurrencyConversion(Money fromMoney, Money toMoney) {
        this.fromMoney = fromMoney;
        this.toMoney = toMoney;
    }

    public Money getFromMoney() { // <3>
        return fromMoney;
    }

    public Money getToMoney() { // <3>
        return toMoney;
    }

    @Override
    public boolean equals(Object o) { // <4>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CurrencyConversion that = (CurrencyConversion) o;
        return fromMoney.equals(that.fromMoney) &&
            toMoney.equals(that.toMoney);
    }

    @Override
    public int hashCode() { // <4>
        return Objects.hash(fromMoney, toMoney);
    }

    @Override
    public String toString() { // <5>
        return "CurrencyConversion{" +
            "fromMoney=" + fromMoney +
            ", toMoney=" + toMoney +
            '}';
    }
}
----
// end-insert

This class is very simple -- it does nothing more than group related data and provides no operations of its own.
Even so, the class involves a lot of boilerplate code:

<1> Values are immutable, so the class declares its fields as final.
<2> It must define a constructor to initialise those fields
<3> Although the class is not a Java Bean, because it is not serializable and doesn't have a zero-argument constructor, the accessor methods of its properties follow the Java Bean naming conventions.
<4> The class implements the equals and hashCode methods to ensure that two CurrencyConversion values with equal fields compare as equal.
There is quite a lot of code to make that happen, but happily our IDE generated it for us.
However, we have to remember to delete and regenerate those methods when we change the fields of the class to avoid confusing bugs.
<5> It returns a textual representation of itself from the toString method.

We come from the school of Java that assumes that everything we pass, store or return is not null unless explicitly indicated otherwise.
You can't _see_ that, but it's why there are no `@Nullable` annotations or null checks of parameters.

Let's see what this looks like when we translate it to Kotlin.

IntelliJ has a command to convert a Java source file to Kotlin.
It is called (at the time of writing) 'Convert Java File to Kotlin File', and is bound to Ctrl+Shift+Alt+K on Windows and Linux, Cmd-Shift-Option-K on the Mac.
When we run that command on CurrencyConversion.java, IntelliJ thinks for a while and then pops up a dialog that informs us "Some of the code in the rest of your project may require corrections after performing this conversion." and asks "Do you want to find such code and correct it too?".
We'll look into the effects of this choice later.
For now, we'll click the "Yes" button and let IntelliJ to do the needful.
When it finishes, our code looks like:

// begin-insert: tags/value_types.2:src/main/java/travelator/money/CurrencyConversion.kt
[source,kotlin]
----
class CurrencyConversion(val fromMoney: Money, val toMoney: Money) {

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as CurrencyConversion
        return fromMoney == that.fromMoney && toMoney == that.toMoney
    }

    override fun hashCode(): Int {
        return Objects.hash(fromMoney, toMoney)
    }

    override fun toString(): String {
        return "CurrencyConversion{" +
            "fromMoney=" + fromMoney +
            ", toMoney=" + toMoney +
            '}'
    }
}
----
// end-insert

The Kotlin class is noticeably more succinct because it declares its properties in the primary constructor.
Those declarations stand in for all this Java:

// begin-insert: tags/value_types.1:src/main/java/travelator/money/CurrencyConversion.java#replaced_by_primary_constructor
[source,java]
----
private final Money fromMoney;
private final Money toMoney;

public CurrencyConversion(Money fromMoney, Money toMoney) {
    this.fromMoney = fromMoney;
    this.toMoney = toMoney;
}

public Money getFromMoney() {
    return fromMoney;
}

public Money getToMoney() {
    return toMoney;
}
----
// end-insert

The primary constructor syntax is convenient, but it does interfere with the "scannability" of the class.
Java classes that follow the standard coding conventions always define their elements in the same order: class name, superclass, interfaces, then within the class body, fields, constructors, and methods.
This makes it easy to skim-read the class and quickly locate the features you're interested in.
It's not quite so easy in Kotlin: a class definition is organised thus: class name, primary constructor (which can contain parameters and/or property definitions), superclass (which may also be the call to the superclass' constructor), interfaces, then within the class body, more properties, more constructors, methods, and companion objects (we'll come to those later).
Coming from Java, I definitely found it harder to read classes at first, and although I got used to it eventually, I still find it hard at times to neatly format classes that have a primary constructor, a superclass, several interfaces, and properties that are defined outside the primary constructor.
I'll happily diverge from the standard Kotlin coding conventions to add more blank lines between the primary constructor and the rest of the class definition if it makes it easier to distinguish different elements of the class.

The `val` keyword is short for 'value' and marks a property that you cannot change once set - the equivalent of Java's `final`.
We could (but almost always wouldn't) have used `var` for `variable`, in which case the property could be modified and the class would no longer have true value semantics.

So far converting our value type to Kotlin has saved us 12 lines of code, but we aren't done yet.
Value types like this are so useful but so tedious to get right and keep right that Kotlin supports them at a language level.
Mark the class with the `data` modifier and the compiler will generate `equals`, `hashCode` and `toString` methods automatically, if they are not defined by the class.
That reduces the CurrencyConversion class to:

// begin-insert: tags/value_types.3:src/main/java/travelator/money/CurrencyConversion.kt
[source,kotlin]
----
data class CurrencyConversion(
    val fromMoney: Money,
    val toMoney: Money)
----
// end-insert

That's much more succinct than the Java.
More importantly, our CurrencyConversion class is now defined entirely by its properties.
When we add properties in the future we won't have to remember to update the generated methods or find ourselves with hard-to-diagnose bugs.

We have JUnit tests for the value semantics of our CurrencyConversion class.
We could convert these tests to Kotlin, but as we now have no logic of our own in the CurrencyConversion class, we have no need for the tests and instead can delete the entire test class.
We have reduced the entire Money class and its tests to a single, declarative line of Kotlin.

Now that we have so little code, smaller syntactic differences between Java and Kotlin stand out.
For example, there are no visibility modifiers.
The default visibility in Kotlin is public, so `public class CurrencyConversion` in Java has been translated to just `class CurrencyConversion` in Kotlin.
Being used to Java programming style, as we were, you may question this language design decision.
Our experience working with Kotlin is that public by default works well with a design philosophy oriented around the transformation of data, where there is less need to hide and encapsulate mutable state.
It's another example of Kotlin's grain nudging the design in a different direction from Java:
modelling with objects that encapsulate mutable state needs more work than modelling with immutable values.

We also use the CurrencyConversion class elsewhere in our production code.  For example, the ExchangeRates type creates CurrencyConversion values to represent the result of a currency conversion calculation:

// begin-insert: tags/value_types.3:src/main/java/travelator/money/ExchangeRates.java
[source,java]
----
public interface ExchangeRates {
    BigDecimal rate(Currency fromCurrency, Currency toCurrency);

    default CurrencyConversion convert(Money fromMoney, Currency toCurrency) {
        BigDecimal rate = rate(fromMoney.getCurrency(), toCurrency);
        BigDecimal toAmount = fromMoney.getAmount().multiply(rate);
        Money toMoney = Money.of(toAmount, toCurrency);
        
        return new CurrencyConversion(fromMoney, toMoney);
    }
}
----
// end-insert: tags/value_types.3:src/main/java/travelator/money/ExchangeRates.java

And the CostSummary class stores a list of CurrencyConversions representing costs in the local and user's currencies, and calculates the total amount in the user's currency:

// begin-insert: tags/value_types.3:src/main/java/travelator/itinerary/CostSummary.java#use_of_currency_conversion
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public Money getTotal() {
        return total;
    }

    ...
}
----
// end-insert

Due to the excellent interoperation between Kotlin and Java, these continue to work with the converted class.
Our Java CurrencyConversion class had explicit "getter" methods.
These do not appear in the converted Kotlin source, but our Java can still call them.
The Kotlin compiler is not only generating the `equals` and `hashCode` methods we knew about, but also  `getFromMoney` and `getToMoney` -- `fromMoney` and `toMoney` are not fields in Kotlin, they are properties.
Where Java code calls the `line.getToMoney()` method, Kotlin code accesses the property `line.toMoney`.
In actual fact Kotlin will call the `getToMoney()` method that it has generated (or one supplied by a Java class) rather than accessing a field directly - so nothing has really changed except that we can drop the `get` and `()`.
We'll have more to say about properties later, but for now if you think of them as a private field with a public getter and, if a `var` property, a public setter, you won't often be wrong.


=== A Value Class Implementing Domain Logic

A CurrencyConversion is a very simple value.
It holds two related data items that we want keep together and show to the user, but it has no operations of its own.
Where our application uses CurrencyConversions, it performs calculations with its properties individually rather than treating the CurrencyConversion value as an atomic whole.
This is not the normal case.  We usually define value types in order to abstract the representation of a concept in our application domain and define the operations on that abstraction.
An example of a value type with operations of its own is our `Money` class:

// begin-insert: tags/value_types.4:src/main/java/travelator/money/Money.java#money
[source,java]
----
public class Money {
    private final BigDecimal amount;
    private final Currency currency;

    private Money(BigDecimal amount, Currency currency) { // <1>
        this.amount = amount;
        this.currency = currency;
    }

    public static Money of(BigDecimal amount, Currency currency) { // <1>
        return new Money(
            amount.setScale(
                currency.getDefaultFractionDigits(),
                RoundingMode.UNNECESSARY),
            currency);
    }

    // ... and convenience overloads

    public BigDecimal getAmount() { // <2>
        return amount;
    }

    public Currency getCurrency() { // <3>
        return currency;
    }

    @Override
    public boolean equals(Object o) { // <3>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amount.equals(money.amount) &&
            currency.equals(money.currency);
    }

    @Override
    public int hashCode() { // <3>
        return Objects.hash(amount, currency);
    }

    @Override
    public String toString() { // <4>
        return amount.toString() + " " + currency.getCurrencyCode();
    }

    public Money add(Money that) { // <5>
        if (!this.currency.equals(that.currency)) {
            throw new IllegalArgumentException(
                "cannot add Money values of different currencies");
        }

        return new Money(this.amount.add(that.amount), this.currency);
    }
}
----
// end-insert

<1> The constructor is private.
Other classes obtain Money values by calling the static `Money.of` method, which guarantees that the scale of the amount is consistent with the number of minor units of the currency.
Most currencies have 100 minor units (two digits), but some have fewer and some more: the Japanese Yen has no minor units, and the Jordanian Dinar has one thousand, for example.
+
The "of" method follows a coding convention of <<modern-java-style,Modern Java>> that draws a distinction in the source between objects with identity, which are constructed by the new operator, and values, which are obtained from static methods.  This convention is followed by the Java time API (for example `LocalDate.of(2020,8,17)`) and recent additions to the collections API (for example, `List.of(1,2,3)` creates an immutable list)
+
The Money class provides some convenient overloads of the `of` method for String or int amounts.
<2> It exposes the amount and currency properties using Java Bean conventions, even though, like CurrencyConversion, it is not actually a Java Bean.
<3> The equals and hashCode methods implement value semantics.
<4> The toString method returns a representation of its properties.  Unlike the CurrencyConversion class, Money returns a representation that is shown to the user, not just for debugging.
<5> Money provides operations for calculating with money values.  For example, you can add monetary values together.  The add method constructs new Money values by calling the constructor directly, because the result of BigDecimal.add has the correct scale already and so we can avoid the overhead of setting the scale.

[NOTE]
====
.BigDecimal.setScale does not set the scale!

The method `BigDecimal.setScale` is confusing.
Although named like a Java Bean setter, it does not actually mutate the BigDecimal object.  Like our Money class, BigDecimal is an immutable value type, so `setScale` returns a BigDecimal value with the specified scale.

Sun added the BigDecimal class to the standard library in Java 1.1.  This release also included the first version of the Java Beans API. The hype around the Beans API popularised the Java Beans coding conventions, and they were widely adopted, even for classes that, like BigDecimal, were not Java Beans (see <<bean-java-style>>). There were no Java conventions for value types.

Today, we avoid the "set" prefix for methods that do not mutate their receiver and instead use names that emphasise when the method returns a transformation of the receiver.  One convention is to use the prefix "with" for transformations that affect a single property, which would make the code in our Money class read as:

[source,kotlin]
----
 amount.withScale(currency.getDefaultFractionDigits())
----

In Kotlin we can write extension methods to fix such historical accidents.  If we were writing a lot of code that calculated with BigDecimals, it might be worth doing so to improve the clarity of the code:

[source,kotlin]
----
inline fun BigDecimal.withScale(int scale, RoundingMode mode) =
    setScale(scale, mode)
----
====

Converting Money to Kotlin produces the following code:

// begin-insert: tags/value_types.5:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money
private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val money = o as Money
        return amount == money.amount && currency == money.currency
    }

    override fun hashCode(): Int {
        return Objects.hash(amount, currency)
    }

    override fun toString(): String {
        return amount.toString() + " " + currency.currencyCode
    }

    fun add(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    companion object {
        @JvmStatic
        fun of(amount: BigDecimal, currency: Currency): Money {
            return Money(
                amount.setScale(
                    currency.defaultFractionDigits,
                    RoundingMode.UNNECESSARY
                ),
                currency
            )
        }

        // ... and convenience overloads
    }
}
----
// end-insert

The Kotlin class still has a primary constructor, but that constructor is now marked private.
The syntax for this is a little clunky.

The static "of" functions are now methods on a companion object. IntelliJ noticed that they are called from our Java code, and annotated them as `@JvmStatic` to ensure they are compiled to static methods and the call sites in the Java code are unaffected.

****
TODO: sidebar to explain @Jvm... annotations. Coordinate with what Duncan is writing.
****

Can we also reduce the size of the class even further by making it a data class?

When we change `class` to `data class`, IntelliJ highlights the `private` keyword of the primary constructor with a warning: "Private data class constructor is exposed via the generated 'copy' method."

What's that all about?

Kotlin generates a public `copy` method for data classes that creates a copy of an instance, replacing some of the field values.

The constructor of the Money class is private because the class maintains an invariant between its properties, ensuring that the scale of the amount field is equal to the default number of minor currency digits of the currency field.  The `Money.of(BigDecimal,Currency)` method ensures the invariant for new Money values. The `add` method maintains the invariant because adding two BigDecimal values with the same scale produces a BigDecimal that also has the same scale. The add method therefore can call the constructor directly because doesn't need to recalculate the scale.  The constructor need only assign fields, safe in the knowledge that it is only called with parameters that meet the class invariant. and it is private to prevent code outside the Money class from creating values that violate the invariant.

However, the public `copy` method of a data class _would_ allow client code to create Money values that violate the invariant.  Our Money class cannot be a data class.

[TIP]
====
Don't define a value type as a data class if it must maintain invariants between its properties.
====

We can still make the code more concise by applying other Kotlin features. We can define all the methods in single-expression form, and lean on Kotlin's flow-sensitive type inference to greatly simplify the `equals` method:

// begin-insert: tags/value_types.7:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    override fun equals(other: Any?) =
        this === other ||
            other is Money &&
            amount == other.amount &&
            currency == other.currency

    override fun hashCode() =
        Objects.hash(amount, currency)

    override fun toString() =
        amount.toString() + " " + currency.currencyCode

    fun add(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    companion object {
        @JvmStatic
        fun of(amount: BigDecimal, currency: Currency) = Money(
            amount.setScale(
                currency.defaultFractionDigits,
                RoundingMode.UNNECESSARY
            ),
            currency
        )

        // ... and convenience overloads
    }
}
----
// end-insert

ifdef::todos[]
TODO: Convert tests to Kotlin (??? is it worth showing? They don't look that different.)
endif::[]

=== Conclusions

Because they require no boilerplate, it is much easier to define new value types in Kotlin than in Java.
Your authors find they introduce new value classes far more frequently in Kotlin than in Java --
to declare application-specific "micro-types" that wrap primitive values,
to hold intermediate results of a calculation pipeline,
or to pivot data into temporary structures that make it easier to write application logic.

Data classes greatly reduce the amount of boilerplate we need to implement value semantics.
However, the limitations of data classes mean they are only applicable to values that do not maintain invariants between their properties.

Kotlin's nudges towards immutability go much further than the ease with which we can define value types.  The standard library also makes it easy to program by transforming values in bulk.  We'll look at that in <<collections-and-transformation-pipelines>>, but first, let's see what we can do to make our Money class feel more natural in Kotlin code.
