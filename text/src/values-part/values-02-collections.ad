= We encounter Kotlin collections

Casting around the code for some more easy wins we find another value class -  Session.

// begin-insert: tags/r2.0:src/main/java/colloquiumatic/Session.java
[source,java]
[%autofit]
----
public class Session {

    private final String id;
    private final String title;
    private final List<Presenter> presenters; // <1>

    public Session(String id, String title, List<Presenter> presenters) {
        this.id = id;
        this.title = title;
        this.presenters = List.copyOf(presenters); // <2>
    }

    public String getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public List<Presenter> getPresenters() {
        return presenters;
    }

    // <3>
    public Session withPresenters(List<Presenter> newLineUp) {
        return new Session(id, title, newLineUp);
    }

    public Session withTitle(String newTitle) {
        return new Session(id, newTitle, presenters);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Session session = (Session) o;
        return id.equals(session.id) &&
            title.equals(session.title) &&
            presenters.equals(session.presenters);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, title, presenters);
    }

    @Override
    public String toString() {
        return "Session{" +
            "id='" + id + '\'' +
            ", title='" + title + '\'' +
            ", presenters=" + presenters +
            '}';
    }
}
----
// end-insert

Like Presenter, Session is immutable and has tedious code to manage value identity. But it has some other features, namely

<1> One of the fields is a collection: a session has a list of presenters.

<2> Because Java collections are mutable, the constructor makes a defensive copy of the list to avoid https://martinfowler.com/bliki/AliasingBug.html[_aliasing errors_].
// TODO: Q: should the  getPresenters method also wrap the list in Collections.unmodifiableList? A: yes, it's currently on the small-fixed branch

<3> There are some convenience methods that return a copy of the session with modified properties to make it easier to write purely functional business logic.

If we use IntelliJ to convert this to Kotlin, we get the following

// begin-insert: tags/r2.1:src/main/java/colloquiumatic/Session.kt
[source,kotlin]
[%autofit]
----
class Session(val id: String, val title: String, presenters: List<Presenter>?) { // <1>
    val presenters: List<Presenter> // <2>

    fun withPresenters(newLineUp: List<Presenter>?): Session { // <4>
        return Session(id, title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(id, newTitle, presenters)
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val session = o as Session
        return id == session.id && title == session.title && presenters == session.presenters
    }

    override fun hashCode(): Int {
        return Objects.hash(id, title, presenters)
    }

    override fun toString(): String {
        return "Session{" +
            "id='" + id + '\'' +
            ", title='" + title + '\'' +
            ", presenters=" + presenters +
            '}'
    }

    init {
        this.presenters = java.util.List.copyOf(presenters) // <3>
    }
}
----
// end-insert

The conversion has left us with some dubious Kotlin

<1> The `presenters` constructor parameter is marked with a `?` - Kotlin's way of indicating that it may be null. Why this is we don't know. (Don't worry, we'll talk a lot more about nullability throughout this book.)
<2> We have a `presenters` property outside the constructor.
<3> Which is initialised in this dangling `init` block.
<4> The `newPresenters` parameter has also been made nullable.

Alt-Enter at <3> will join the initialisation and we can just delete the question marks to show that `presenters` is not nullable.

// begin-insert: tags/r2.2:src/main/java/colloquiumatic/Session.kt
[source,kotlin]
[%autofit]
----
class Session(
    val id: String,
    val title: String,
    presenters: List<Presenter> /// |
) {
    val presenters: List<Presenter> = java.util.List.copyOf(presenters) /// |

    fun withPresenters(newLineUp: List<Presenter>): Session { /// |
        return Session(id, title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(id, newTitle, presenters)
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val session = o as Session
        return id == session.id && title == session.title && presenters == session.presenters
    }

    override fun hashCode(): Int {
        return Objects.hash(id, title, presenters)
    }

    override fun toString(): String {
        return "Session{" +
            "id='" + id + '\'' +
            ", title='" + title + '\'' +
            ", presenters=" + presenters +
            '}'
    }
}
----
// end-insert

`java.util.List` may have caught your attention. The other Lists here are Kotlin's own types, which are read-only views of the Java type. You'll find they are often interchangeable, and we'll cover them in detail in later chapters. Here you can see that we can assign a `java.util.List` to a Kotlin list.

We would like to be able to remove all that value object boilerplate by making Session a data class, but in order to do that we have to have all the properties initialised in the constructor, and those defensive calls to `List.copyOf` and `Collections.unmodifiableList` are preventing that at the moment. Checking all the callers of the constructor we find that none of them mutate the presenters having passed them in, so we can move the property into the constructor and we have another data class.

// begin-insert: tags/r2.3:src/main/java/colloquiumatic/Session.kt
[source,kotlin]
[%autofit]
----
data class Session( /// |
    val id: String,
    val title: String,
    val presenters: List<Presenter> /// |
) {

    fun withPresenters(newLineUp: List<Presenter>): Session {
        return Session(id, title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(id, newTitle, presenters)
    }
}
----
// end-insert

None of the Java users of Session have had to change so far - let's look at the tests for example.

// begin-insert: tags/r2.3:src/test/java/colloquiumatic/SessionTests.java
[source,java]
[%autofit]
----
public class SessionTests {

    private static Presenter alice = new Presenter("id1", "Alice");
    private static Presenter bob = new Presenter("id2", "Bob");
    private static final List<Presenter> noPresenters = Collections.emptyList();

    private Session aSession = new Session("s1", "The Title", List.of(bob, alice)); // <1>

    @Test
    public void can_change_title() {
        assertEquals(
            new Session("s1", "Another Title", List.of(bob, alice)),
            aSession.withTitle("Another Title")
        );
    }

    @Test
    public void can_change_presenters() {
        assertEquals(
            new Session("s1", "The Title", noPresenters),
            aSession.withPresenters(noPresenters)
        );
    }
}
----
// end-insert

<1> We can see that the `java.util.List<String>` argument is compatible with the `kotlin.collections.List<String>` parameter.

Converting the tests to Kotlin with IntelliJ we get

// begin-insert: tags/r2.4:src/test/java/colloquiumatic/SessionTests.kt
[source,kotlin]
[%autofit]
----
class SessionTests {
    private val aSession = Session(
        "s1",
        "The Title",
        java.util.List.of(bob, alice)
    )

    @Test
    fun can_change_title() {
        Assertions.assertEquals(
            Session(
                "s1",
                "Another Title",
                java.util.List.of(bob, alice)
            ),
            aSession.withTitle("Another Title")
        )
    }

    @Test
    fun can_change_presenters() {
        Assertions.assertEquals(
            Session("s1", "The Title", noPresenters),
            aSession.withPresenters(noPresenters)
        )
    }

    companion object {
        private val alice = Presenter("id1", "Alice")
        private val bob = Presenter("id2", "Bob")
        private val noPresenters: List<Presenter> = emptyList()
    }
}
----
// end-insert

Look at the differences between the Java and Kotlin versions. They are very similar except that the static members have been moved onto a companion object. This provides a namespace for class-scoped code with advantages over Java that we will examine in later chapters.

The `java.util.List.of` also stands out, and in fact IntelliJ offers to convert it to the Kotlin equivalent - `kotlin.collections.listOf`. Another Alt-Enter Easter egg can be found on the function names - IntelliJ will offer to convert them to eg `can change title` using the backtick feature to allow spaces and other characters in identifiers.

Once we're done the tests now look like this

// begin-insert: tags/r2.5:src/test/java/colloquiumatic/SessionTests.kt
[source,kotlin]
[%autofit]
----
class SessionTests {
    private val aSession = Session(
        "s1",
        "The Title",
        listOf(bob, alice) /// |
    )

    @Test
    fun `can change title`() { /// |
        Assertions.assertEquals(
            Session(
                "s1",
                "Another Title",
                listOf(bob, alice)
            ),
            aSession.withTitle("Another Title")
        )
    }

    @Test
    fun `can change presenters`() { /// |
        Assertions.assertEquals(
            Session("s1", "The Title", noPresenters),
            aSession.withPresenters(noPresenters)
        )
    }

    companion object {
        private val alice = Presenter("id1", "Alice")
        private val bob = Presenter("id2", "Bob")
        private val noPresenters: List<Presenter> = emptyList()
    }
}
----
// end-insert

We have one more data class trick up our sleeve. Returning to Session

// begin-insert: tags/r2.5:src/main/java/colloquiumatic/Session.kt
[source,kotlin]
[%autofit]
----
data class Session( /// |
    val id: String,
    val title: String,
    val presenters: List<Presenter> /// |
) {

    fun withPresenters(newLineUp: List<Presenter>): Session {
        return Session(id, title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(id, newTitle, presenters)
    }
}
----
// end-insert

we can make use of Kotlin's named parameters (Alt-Enter inside the brackets)

// begin-insert: tags/r2.6:src/main/java/colloquiumatic/Session.kt#foo
[source,kotlin]
[%autofit]
----
fun withPresenters(newLineUp: List<Presenter>): Session {
    return Session(id = id, title = title, presenters = newLineUp) /// |
}

fun withTitle(newTitle: String): Session {
    return Session(id = id, title = newTitle, presenters = presenters) /// |
}
----
// end-insert

and then replace the constructor invocations with the special copy method

// begin-insert: tags/r2.7:src/main/java/colloquiumatic/Session.kt#foo
[source,kotlin]
[%autofit]
----
fun withPresenters(newLineUp: List<Presenter>): Session {
    return copy(id = id, title = title, presenters = newLineUp) /// |
}

fun withTitle(newTitle: String): Session {
    return copy(id = id, title = newTitle, presenters = presenters) /// |
}
----
// end-insert

Now remove the redundant arguments

// begin-insert: tags/r2.8:src/main/java/colloquiumatic/Session.kt#foo
[source,kotlin]
[%autofit]
----
fun withPresenters(newLineUp: List<Presenter>): Session {
    return copy(presenters = newLineUp) /// |
}

fun withTitle(newTitle: String): Session {
    return copy(title = newTitle) /// |
}
----
// end-insert

Where a Kotlin function body consists of a single expression you can Alt-Enter on the brace to convert it to a shorter form.

// begin-insert: tags/r2.9:src/main/java/colloquiumatic/Session.kt#foo
[source,kotlin]
[%autofit]
----
fun withPresenters(newLineUp: List<Presenter>) = copy(presenters = newLineUp) /// |

fun withTitle(newTitle: String) = copy(title = newTitle) /// |
----
// end-insert

While there are still Java uses of `withPresenters` and `withTitle` that is as far as we can go, but once the all callers have been converted to Kotlin, we can inline the methods

// begin-insert: tags/r2.10:src/test/java/colloquiumatic/SessionTests.kt#foo
[source,kotlin]
[%autofit]
----
@Test
fun `can change title`() {
    Assertions.assertEquals(
        Session(
            "s1",
            "Another Title",
            listOf(bob, alice)
        ),
        aSession.withTitle("Another Title") /// |
    )
}

@Test
fun `can change presenters`() {
    Assertions.assertEquals(
        Session("s1", "The Title", noPresenters),
        aSession.withPresenters(noPresenters) /// |
    )
}
----
// end-insert

// begin-insert: tags/r2.11:src/test/java/colloquiumatic/SessionTests.kt#foo
[source,kotlin]
[%autofit]
----
@Test
fun `can change title`() {
    Assertions.assertEquals(
        Session(
            "s1",
            "Another Title",
            listOf(bob, alice)
        ),
        aSession.copy(title = "Another Title") /// |
    )
}

@Test
fun `can change presenters`() {
    Assertions.assertEquals(
        Session("s1", "The Title", noPresenters),
        aSession.copy(presenters = noPresenters) /// |
    )
}
----
// end-insert

at which point the test is now just checking the compiler, so we can delete it, leaving just the Session class.

// begin-insert: tags/r2.11:src/main/java/colloquiumatic/Session.kt
[source,kotlin]
[%autofit]
----
data class Session(
    val id: String,
    val title: String,
    val presenters: List<Presenter>
)
----
// end-insert

== Conclusions

* We can convert code to Kotlin without changing its clients at all - we can convert only what and when suits us.
* The resulting Kotlin is often much smaller.
* Once all client code is converted to Kotlin we can take advantage of other Kotlin features to remove even more code.