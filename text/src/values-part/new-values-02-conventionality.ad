[[conventionality]]
== Supporting Java and Kotlin Conventions

In <<value-types>> we translated our Money class from Kotlin to Java.
However, it still looks sort of "Java-ish".
It follows conventions for value types that are common in <<modern-java-style,Modern Java>>, but are not the way things are usually done in Kotlin:
it uses methods of a companion object to create values,
and it uses methods, rather than operators, for arithmetic.

In a monolingual codebase, it'd be pretty straightforward to address those issues.
But when adopting Kotlin in a project that has a significant amount of Java, it's unlikely that we will translate all the Java in one big bang -- it involves too much up-front cost and risk.
So, we'll continue to make changes to the Java and to the Kotlin, until Kotlin has edged Java out altogether.
In the meantime, when both Kotlin _and_ Java use a Kotlin class, we'll ensure that the call sites in either language are conventional enough to not surprise the horses.


=== User-Defined Operators

Our Kotlin code that adds Money values is still rather clumsy:

[source,kotlin]
----
total = price.add(tax)
----

This is the best we can do in Java, but in Kotlin we can define arithmetic operators for our own classes, allowing us to write code like:

[source,kotlin]
----
total = price + tax
----

We give classes the `+` operator by writing an operator method or extension function called `plus`.
For our Money class we can rename the existing `add` method to `plus` and add the `operator` modifier:

// begin-insert: tags/value_types.9:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    ...

    operator fun plus(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    ...
}
----
// end-insert

With this change, our Kotlin code can add Money values with the + operator, while the Java code calls `plus` as a method.

The name "plus" isn't conventional Java.
Java classes in the standard library that have arithmetic operations, such as BigDecimal and BigInteger, use the name "add", not "plus".

We can make the method appear to have different names in Java and Kotlin by annotating it's definition with the `@JvmName` annotation.
Let's revert the change we just made and take another run at it, starting by annotating the method with `@JvmName("add")`.

// begin-insert: tags/value_types.10:src/main/java/travelator/money/Money.kt#add_method
[source,kotlin]
----
@JvmName("add")
fun add(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Now when we rename the method to "plus", our Java code is unchanged.

Marking the method as an operator allows both Java and Kotlin code to call the method according to their respective language conventions.

// begin-insert: tags/value_types.11:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
@JvmName("add")
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Whether this is desirable is a matter of opinion.
It can be quite confusing to have the same method appear under different names in different parts of the same codebase,
but on the other hand, because it's an operator method, our Kotlin code should only use the name "plus" in the definition of the method, and all uses of the method be via the `+` operator.
On balance, your authors think it's worth using the @JvmName annotation in this case,
but it's something you will need to agree within your team.

=== Calling Operators from Existing Kotlin Code

This still leaves us with a problem.
At the time of writing, IntelliJ does not have an automated refactoring to replace all direct calls to an operator method with use of the respective operator.
Any of our Kotlin code that had been calling the `Money.add` method before we turned it into an operator will now be calling `Money.plus` as a method instead of using the `+` operator.
Even if we only called `Money.add` from Java code, we've still got a problem:
IntelliJ will convert that code to Kotlin that calls 'Money.plus' as a method instead of using `+` operator.
IntelliJ can automatically refactor each of those call sites from a method call to an operator, but we would have to go through them one by one, refactoring each one individually.

To address these problems, we'll need to use a _refactoring combo_ to switch all our Kotlin code over to use the `+` operator, and leave a hook in our code to let us easily do that in bulk as we convert more Java classes to Kotlin.

Let's revert our change again, and take yet another run at the conversion.

This time, we'll extract the entire body of the `add` method as a method called `plus` and make it a public, operator method:

// begin-insert: tags/value_types.13:src/main/java/travelator/money/Money.kt#extract_plus
[source,kotlin]
----
fun add(that: Money): Money {
    return plus(that)
}

operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Using IntelliJ's automatic refactoring, we make `this` explicit in the call to `plus`:

// begin-insert: tags/value_types.14:src/main/java/travelator/money/Money.kt#add
[source,kotlin]
----
fun add(that: Money): Money {
    return this.plus(that)
}
----
// end-insert

From this form, IntelliJ's lets us automatically refactor from method call to operator:

// begin-insert: tags/value_types.15:src/main/java/travelator/money/Money.kt#add
[source,kotlin]
----
fun add(that: Money): Money {
    return this + that
}
----
// end-insert

And finally we can transform the `add` method to single-expression form.

// begin-insert: tags/value_types.16:src/main/java/travelator/money/Money.kt#extract_plus
[source,kotlin]
----
fun add(that: Money) = this + that

operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

We now have two methods for addition.
The `plus` operator method implements addition logic and is what we'd like all our Kotlin code to use in the future, but nothing calls it directly yet.
The `add` method will remain for use by our Java code, while it exists, and its body contains the ideal syntax we would like to use in our Kotlin code.

We can make all our Kotlin code that adds Money values use that ideal syntax by inlining the `Money.add` method.
When we do so, IntelliJ reports that it was unable to inline all the uses of `add`.
That's just what we want!
We can't inline Kotlin code into Java, so IntelliJ has inlined the body of `add` method only into the Kotlin call sites, and has not deleted `add` method because it is still called by Java.
All our Kotlin code is now using the `+` operator, and our Java code is unchanged.

In the future, when we translate more Java classes that add Money values to Kotlin, we can inline the `add` method again to make the converted Kotlin class use the `+` operator instead of method call syntax.
As long as there is Java code in our codebase that calls it, IntelliJ will preserve the `add` method.
After we've converted the last Java class that adds Money, IntelliJ will remove the now unused `add` method as part of the inline refactoring.
Our codebase will then only use the `+` operator.

// this refactoring combo is also used to introduce infix methods in the JSON DSL chapter -- ensure they are consistent and don't repeat themselves

=== Operators for existing Java classes

While we're working on the `plus` method, we can also take the opportunity to use the `+` operator inside the method to add the amount values.
The Money class represents its amount as a `BigDecimal`, a class from the Java standard library.
We can replace the call to the BigDecimal's `add` method with the + operator:

// begin-insert: tags/value_types.19:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
@JvmName("add")
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(this.amount + that.amount, currency)
}
----
// end-insert

Our code continues to compile.
How is that possible?

The Kotlin standard library includes extension functions that define operators for classes in the Java standard library: mathematical classes, such as `BigInteger` and `BigDecimal` and collections, such as `List<T>` or `Set<T>`.
Because these extension functions are defined in the `kotlin` package, they are available to any package automatically; we do not need to explicitly import them.

=== Construction of Values

* Money.of(...) is not idiomatic Kotlin.
** Money(...) or moneyOf(...) would be more conventional, or even extension methods on Currency.  E.g. GBP.of(10) or EUR.zero

To define a top-level `moneyOf` function we would have to declare the constructor as `internal`, rather than `private`, so that our function could call it.  This makes the constructor visible to any Kotlin code in the same compilation unit (equivalent to a Gradle subproject or IntelliJ module), but prevents it being called by Kotlin code in other compilation units.  The compilation unit, rather than the class, would then have to guarantee the invariants of the Money class by never calling its constructor inappropriately.   That would be safe enough, if it wasn't for parts of our system that continue to be written in Java, and that we will continue to maintain while translating our system to Kotlin.  Java and the JVM does not even have the concept of `internal` visiblity.  The Kotlin compiler must compile an internal feature to a public feature in the JVM classfile, and records that it has internal visibility in an additional metadata section.  The Kotlin compiler reads this metadata and enforces the internal visibility, but to the Java compiler and JVM it has public visibility.  As a result, it would be possible to accidentally create invalid Money values when we're working in the Java side of our project.  Let's take that option off the table.

TODO: call forward to <<organising-code-by-domain>>?

* Instead rename 'of' to 'invoke' and make it an operator function.  Now code creating objects as if with the constructor outside the class will call the Companion.invoke method, but inside the class will call the primary constructor.
* The factory functions ensure invariants, but client code can treat the class as if itâ€™s constructed normally
* But: in Java, code would now look like `Money.invoke("200.00", EUR)`.  The `of` function has two roles: to enforce the invariant _and_ to be syntactic sugar that makes the code read well at the call site.
* Use the same refactoring combo's we used to introduce the plus operator, this time to make the method be "operator invoke" in Kotlin and "of" in Java.
** Annotate `of` method with `@JvmName("of")` before renaming it to invoke
** Use the "delegate-and-inline" combo to replace of with function call in Kotlin code.

[WARNING]
====
.Avoid operator punning.

E.g. using "/" to append URIs because the division operator looks like a path separator.

Remember Kotlin's grain: prefer explicitness.
====