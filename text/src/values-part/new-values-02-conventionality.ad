[[conventionality]]
== Supporting Java and Kotlin Conventions

In <<value-types>> we translated our Money class from Kotlin to Java.
However, it still looks sort of "Java-ish".
It follows conventions for value types that are common in <<modern-java-style,Modern Java>>, but are not the way things are usually done in Kotlin:
it uses methods of a companion object to create values,
and it uses methods, rather than operators, for arithmetic.

In a monolingual codebase, it'd be pretty straightforward to address those issues.
But when adopting Kotlin in a project that has a significant amount of Java, it's unlikely that we will translate all the Java in one big bang -- it involves too much up-front cost and risk.
So, we'll continue to make changes to the Java and to the Kotlin, until Kotlin has edged Java out altogether.
In the meantime, when both Kotlin _and_ Java use a Kotlin class, we'll ensure that the call sites in either language are conventional enough to not surprise the horses.


=== Operator Overloading

Code that adds Money values is still rather clumsy:

[source,kotlin]
----
total = price.add(tax)
----

This is the best we can do in Java, but in Kotlin we have operator overloading, allowing us to write code like:

[source,kotlin]
----
total = price + tax
----


The Kotlin `+` operator is implemented as a method, or extension function, called `plus`, marked with the `operator` keyword.  We can rename the existing `add` method to `plus` and add the `operator` modifier:

// begin-insert: tags/value_types.9:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    ...

    operator fun plus(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    ...
}
----
// end-insert

Our Kotlin code can now add Money values with the + operator, and Java code does so by calling `plus` as a method.

However, if any of our Kotlin code added Money values by calling the `add` method, it won't have been converted to use the `+` operator.  At the time of writing, IntelliJ does not have an automated refactoring to replace all calls to an operator method with the appropriate arithmetic operator.  We'll have to use a _refactoring combo_ to achieve that.

** introduce the "delegate and inline" refactoring combination
** this is also used to introduce infix methods in the JSON DSL chapter -- ensure they are consistent and don't repeat themselves

* NOTE: limitations of operators: cannot change flow control. Remember, the "grain" of Kotlin is to prefer explicitness

[WARNING]
====
TODO

Avoid operator "punning". E.g. URL construction example using `/`
====

Also use operator overloading _inside_ the plus method of the Money class.
Operator overloading implemented as extension methods in stdlib for Java classes.



=== Supporting Both Java and Kotlin Style Conventions

* Money.of(...) is not idiomatic Kotlin.
** Money(...) or moneyOf(...) would be more conventional, or even extension methods on Currency.  E.g. GBP.of(10) or EUR.zero

To define a top-level `moneyOf` function we would have to declare the constructor as `internal`, rather than `private`, so that our function could call it.  This makes the constructor visible to any Kotlin code in the same compilation unit (equivalent to a Gradle subproject or IntelliJ module), but prevents it being called by Kotlin code in other compilation units.  The compilation unit, rather than the class, would then have to guarantee the invariants of the Money class by never calling its constructor inappropriately.   That would be safe enough, if it wasn't for parts of our system that continue to be written in Java, and that we will continue to maintain while translating our system to Kotlin.  Java and the JVM does not even have the concept of `internal` visiblity.  The Kotlin compiler must compile an internal feature to a public feature in the JVM classfile, and records that it has internal visibility in an additional metadata section.  The Kotlin compiler reads this metadata and enforces the internal visibility, but to the Java compiler and JVM it has public visibility.  As a result, it would be possible to accidentally create invalid Money values when we're working in the Java side of our project.  Let's take that option off the table.

TODO: call forward to <<organising-code-by-domain>>?

* Instead rename 'of' to 'invoke' and make it an operator function.  Now code creating objects as if with the constructor outside the class will call the Companion.invoke method, but inside the class will call the primary constructor.
* The factory functions ensure invariants, but client code can treat the class as if itâ€™s constructed normally
* But: in Java, code would now look like `Money.invoke("200.00", EUR)`.  The `of` function has two roles: to enforce the invariant _and_ to be syntactic sugar that makes the code read well at the call site.
* Introduce refactoring trick to use 'of' in Java and 'invoke' in Kotlin:
** annotate 'of' method with @JvmName("of")  before renaming it to invoke, the Kotlin code sees the renamed method, while Java code remains unchanged.  So you can rename a static factory function with a name that makes sense in Java to, say, operator invoke: and Java call sites continue to have Java-specific syntactic sugar, and Kotlin call sites have Kotlin-specific syntactic sugar.
