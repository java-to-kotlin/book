[[conventionality]]
== Supporting Java and Kotlin Conventions

In <<value-types>> we translated our Money class from Kotlin to Java.
However, it still looks sort of "Java-ish".
It follows conventions for value types that are common in <<modern-java-style,Modern Java>>, but are not the way things are usually done in Kotlin:
it uses methods of a companion object to create values,
and it uses methods, rather than operators, for arithmetic.

In a monolingual codebase, it'd be pretty straightforward to address those issues.
But when adopting Kotlin in a project that has a significant amount of Java, it's unlikely that we will translate all the Java in one big bang -- it involves too much up-front cost and risk.
So, we'll continue to make changes to the Java and to the Kotlin, until Kotlin has edged Java out altogether.
In the meantime, when both Kotlin _and_ Java use a Kotlin class, we'll ensure that the call sites in either language are conventional enough to not surprise the horses.


=== Adding A User-Defined Operator

Kotlin code that adds Money values is still rather clumsy:

[source,kotlin]
----
val total = price.add(tax)
----

This is the best we can do in Java, but in Kotlin we can define arithmetic operators for our own classes, allowing us to write that code as:

[source,kotlin]
----
val total = price + tax
----

We give classes the `+` operator by writing an operator method or extension function called `plus`.
For our Money class we can rename the existing `add` method to `plus` and add the `operator` modifier:

// begin-insert: tags/value_types.9:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    ...

    operator fun plus(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    ...
}
----
// end-insert

With this change, our Kotlin code can add Money values with the + operator, while the Java code calls `plus` as a method.

The name "plus" isn't conventional Java.
Java classes in the standard library that have arithmetic operations, such as BigDecimal and BigInteger, use the name "add", not "plus".

We can make the method appear to have different names in Java and Kotlin by annotating it's definition with the `@JvmName` annotation.
Let's revert the change we just made and take another run at it, starting by annotating the method with `@JvmName("add")`.

// begin-insert: tags/value_types.10:src/main/java/travelator/money/Money.kt#add_method
[source,kotlin]
----
@JvmName("add")
fun add(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Now when we rename the method to "plus", our Java code is unchanged.

Marking the method as an operator allows both Java and Kotlin code to call the method according to their respective language conventions.

// begin-insert: tags/value_types.11:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
@JvmName("add")
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Whether this is desirable is a matter of opinion.
It can be quite confusing to have the same method appear under different names in different parts of the same codebase,
but on the other hand, because it's an operator method, our Kotlin code should only use the name "plus" in the definition of the method, and all uses of the method be via the `+` operator.
On balance, your authors think it's worth using the @JvmName annotation in this case,
but it's something you will need to agree within your team.


=== Calling Our Operator from Existing Kotlin Code

This still leaves us with a problem.
At the time of writing, IntelliJ does not have an automated refactoring to replace all direct calls to an operator method with use of the respective operator.
Any of our Kotlin code that had been calling the `Money.add` method before we turned it into an operator will now be calling `Money.plus` as a method instead of using the `+` operator.
Even if we only called `Money.add` from Java code, we've still got a problem:
IntelliJ will convert that code to Kotlin that calls 'Money.plus' as a method instead of using `+` operator.
IntelliJ can automatically refactor each of those call sites from a method call to an operator, but we would have to go through them one by one, refactoring each one individually.

To address these problems, we'll need to use a _refactoring combo_ to switch all our Kotlin code over to use the `+` operator, and leave a hook in our code to let us easily do that in bulk as we convert more Java classes to Kotlin.

Let's revert our change again, and take yet another run at the conversion.

This time, we'll extract the entire body of the `add` method as a method called `plus` and make it a public, operator method:

// begin-insert: tags/value_types.13:src/main/java/travelator/money/Money.kt#extract_plus
[source,kotlin]
----
fun add(that: Money): Money {
    return plus(that)
}

operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Using IntelliJ's automatic refactoring, we make `this` explicit in the call to `plus`:

// begin-insert: tags/value_types.14:src/main/java/travelator/money/Money.kt#add
[source,kotlin]
----
fun add(that: Money): Money {
    return this.plus(that)
}
----
// end-insert

From this form, IntelliJ's lets us automatically refactor from method call to operator:

// begin-insert: tags/value_types.15:src/main/java/travelator/money/Money.kt#add
[source,kotlin]
----
fun add(that: Money): Money {
    return this + that
}
----
// end-insert

Finally we can transform the `add` method to single-expression form.

// begin-insert: tags/value_types.16:src/main/java/travelator/money/Money.kt#extract_plus
[source,kotlin]
----
fun add(that: Money) = this + that

operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

We now have two methods for addition.
The `plus` operator method implements the addition logic and is what we'd like all our Kotlin code to use in the future, but nothing calls it directly yet.
The `add` method will remain for use by our Java code, while it exists, and its body contains the ideal syntax we would like to use in our Kotlin code.

We can make all our Kotlin code that adds Money values use that ideal syntax by inlining the `Money.add` method.
When we do so, IntelliJ reports that it was unable to inline all the uses of `add`.
That's just what we want!
We can't inline Kotlin code into Java, so IntelliJ has inlined the body of `add` method only into the Kotlin call sites, and has not deleted `add` method because it is still called by Java.
All our Kotlin code is now using the `+` operator, and our Java code is unchanged.

In the future, when we translate more Java classes that add Money values to Kotlin, we can inline the `add` method again to make the converted Kotlin class use the `+` operator instead of method call syntax.
As long as there is Java code in our codebase that calls it, IntelliJ will preserve the `add` method.
After we've converted the last Java class that adds Money, IntelliJ will remove the now unused `add` method as part of the inline refactoring.
Our codebase will then only use the `+` operator.

// this refactoring combo is also used to introduce infix methods in the JSON DSL chapter -- ensure they are consistent and don't repeat themselves


=== Operators for existing Java classes

While we're working on the `plus` method, we can also take the opportunity to use the `+` operator inside the method to add the amount values.
The Money class represents its amount as a `BigDecimal`, a class from the Java standard library.
We can replace the call to the BigDecimal's `add` method with the + operator:

// begin-insert: tags/value_types.18:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(this.amount + that.amount, currency)
}
----
// end-insert

Our code continues to compile.
How is that possible?

The Kotlin standard library includes extension functions that define operators for classes in the Java standard library: mathematical classes, such as `BigInteger` and `BigDecimal` and collections, such as `List<T>` or `Set<T>`.
Because these extension functions are defined in the `kotlin` package, they are available to any package automatically; we do not need to explicitly import them.


=== Conventions for Denoting Values

Another aspect of our Money class that breaks Kotlin conventions are the `of` functions on the companion object, used to denote Money values.

Java syntax distinguishes between instantiating a class with the `new` operator and obtaining an object as the result of a method call.
A <<modern-java-style,Modern Java>> convention is that stateful objects, for which identity is significant, are constructed with the new operator, and values are denoted by calls to static factory functions.
For example, the expression `new ArrayList<>()` constructs a new mutable list distinct from any other mutable list, while the expression `List.of("a","b","c")` denotes an immutable list value.

Kotlin does not draw a distinction between constructing objects and calling functions: the syntax for instantiating a class is the same as that for calling a function.
Nor are there coding conventions to distinguish between constructing new a stateful object that has a distinct identity, and denoting values that do not.

Where a class does need multiple factory functions, as our Money class does, they are usually defined as top level functions, not on the companion object of the class.
IntelliJ does its bit to nudge one towards this style:
it is much better at autosuggesting top-level functions than methods on a companion object.

So, it would be more conventional if our Money class was created by expressions like `Money(...)` or, alternatively, like `moneyOf(...)`.

We've declared the Money constructor as private, so it looks like defining top-level `moneyOf` functions in the same source file as the Money class looks like the easiest option.
However, those `moneyOf` functions would have to call the Money class' constructor, and so we would have to declare it as `internal`, rather than `private`.  Internal visibility would make the constructor visible to any Kotlin code in the same compilation unit (equivalent to a Gradle subproject or IntelliJ module), but prevent it being called by Kotlin code in other compilation units.  The compilation unit, rather than the class, would be responsible for guaranteeing the invariants of the Money class by never calling its constructor inappropriately.  That would be safe enough, if it wasn't for those parts of our system that we will continue to maintain in Java during our system's transition to Kotlin.  Java and the JVM does not have the concept of internal visibility.  The Kotlin compiler translates internal features of a class to a public features in the JVM classfiles it generates, and records the internal visibility as additional metadata that is processed by the Kotlin compiler but ignored by the Java compiler.  As a result, Kotlin features declared as internal appear to be public to the Java compiler and JVM, allowing us to accidentally create invalid Money values when we're working in the Java code of our project.

Instead, we can lean on Kotlin's operator overloading again, defining the function call operator on the companion object to allow client code to create money values using the same syntax as if they were directly calling the constructor.

* Rename 'of' to 'invoke' and make it an operator function.  Now code creating objects as if with the constructor outside the class will call the Companion.invoke method, but inside the class will call the primary constructor.
* The factory functions ensure invariants, but client code can treat the class as if it’s constructed normally
* But: in Java, code would now look like `Money.invoke("200.00", EUR)`.  The `of` function has two roles: to enforce the invariant _and_ to be syntactic sugar that makes the code read well at the call site.
* Use the same refactoring combo's we used to introduce the plus operator, this time to make the method be "operator invoke" in Kotlin and "of" in Java.
** Annotate `of` method with `@JvmName("of")` before renaming it to invoke
** Use the "delegate-and-inline" combo to replace of with function call in Kotlin code.

[WARNING]
====
.Avoid operator punning.

E.g. using "/" to append URIs because the division operator looks like a path separator.

Remember Kotlin's grain: prefer explicitness.
====