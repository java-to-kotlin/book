[[conventionality]]
== Supporting Java and Kotlin Conventions

In <<value-types>> we translated our Money class from Kotlin to Java.
However, it still looks sort of "Java-ish".
It follows conventions for value types that are common in <<modern-java-style,Modern Java>>, but are not the way things are usually done in Kotlin:
it uses methods of a companion object to create values,
and it uses methods, rather than operators, for arithmetic.

In a monolingual codebase, it'd be pretty straightforward to address those issues.
But when adopting Kotlin in a project that has a significant amount of Java, it's unlikely that we will translate all the Java in one big bang -- it involves too much up-front cost and risk.
So, we'll continue to make changes to the Java and to the Kotlin, until Kotlin has edged Java out altogether.
In the meantime, when both Kotlin _and_ Java use a Kotlin class, we'll ensure that the call sites in either language are conventional enough to not surprise the horses.


=== Operator Overloading

Our Kotlin code that adds Money values is still rather clumsy:

[source,kotlin]
----
total = price.add(tax)
----

This is the best we can do in Java, but in Kotlin we can define arithmetic operators for our own classes, allowing us to write code like:

[source,kotlin]
----
total = price + tax
----

In Kotlin we give classes the `+` operator by writing an operator method or extension function called `plus`.
For our Money class we can rename the existing `add` method to `plus` and add the `operator` modifier:

// begin-insert: tags/value_types.9:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    ...

    operator fun plus(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    ...
}
----
// end-insert

With this change, our Kotlin code can add Money values with the + operator, while the Java code calls `plus` as a method.

The name "plus" isn't conventional Java.
Java classes in the standard library that have arithmetic operations, such as BigDecimal and BigInteger, use the name "add", not "plus".
Let's revert that change and take another run at it.

We can make the method appear to have different names in Java and Kotlin by annotating it's definition with the `@JvmName` annotation.
If we annotate the method with `@JvmName("add")` before renaming it to "plus", the rename will not affect our Java code.

// begin-insert: tags/value_types.10:src/main/java/travelator/money/Money.kt#add_method
[source,kotlin]
----
@JvmName("add")
fun add(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

We can now mark the method as an operator, allowing both Java and Kotlin code to call the method according to their respective language conventions.

// begin-insert: tags/value_types.11:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
@JvmName("add")
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Whether this is desirable is a matter of opinion.
It can be quite confusing to have the same method appear under different names in different parts of the same codebase,
but on the other hand, because it's an operator method, our Kotlin code should only use the name "plus" in the definition of the method, and all uses of the method be via the `+` operator.
On balance, your authors think it's worth using the @JvmName annotation in this case,
but it's something you will need to agree within your team.

=== Calling Operators from Existing Kotlin Code

At the time of writing, IntelliJ does not have an automated refactoring to replace all calls to an operator method with the appropriate arithmetic operator.
If, before the rename, any of our Kotlin code had been calling the `Money.add` method, it will now be calling `Money.plus` instead of the `+` operator operator.
If we have a mixture of Kotlin and Java code calling `add`, we'll need to use a _refactoring combo_ to switch all our Kotlin code over to use the `+` operator.

** introduce the "delegate and inline" refactoring combination
** this is also used to introduce infix methods in the JSON DSL chapter -- ensure they are consistent and don't repeat themselves

* NOTE: limitations of operators: cannot change flow control. Remember, the "grain" of Kotlin is to prefer explicitness

[WARNING]
====
TODO

Avoid operator "punning". E.g. URL construction example using `/`
====

Also use operator overloading _inside_ the plus method of the Money class.
Operator overloading implemented as extension methods in stdlib for Java classes.


=== Construction of Values

* Money.of(...) is not idiomatic Kotlin.
** Money(...) or moneyOf(...) would be more conventional, or even extension methods on Currency.  E.g. GBP.of(10) or EUR.zero

To define a top-level `moneyOf` function we would have to declare the constructor as `internal`, rather than `private`, so that our function could call it.  This makes the constructor visible to any Kotlin code in the same compilation unit (equivalent to a Gradle subproject or IntelliJ module), but prevents it being called by Kotlin code in other compilation units.  The compilation unit, rather than the class, would then have to guarantee the invariants of the Money class by never calling its constructor inappropriately.   That would be safe enough, if it wasn't for parts of our system that continue to be written in Java, and that we will continue to maintain while translating our system to Kotlin.  Java and the JVM does not even have the concept of `internal` visiblity.  The Kotlin compiler must compile an internal feature to a public feature in the JVM classfile, and records that it has internal visibility in an additional metadata section.  The Kotlin compiler reads this metadata and enforces the internal visibility, but to the Java compiler and JVM it has public visibility.  As a result, it would be possible to accidentally create invalid Money values when we're working in the Java side of our project.  Let's take that option off the table.

TODO: call forward to <<organising-code-by-domain>>?

* Instead rename 'of' to 'invoke' and make it an operator function.  Now code creating objects as if with the constructor outside the class will call the Companion.invoke method, but inside the class will call the primary constructor.
* The factory functions ensure invariants, but client code can treat the class as if itâ€™s constructed normally
* But: in Java, code would now look like `Money.invoke("200.00", EUR)`.  The `of` function has two roles: to enforce the invariant _and_ to be syntactic sugar that makes the code read well at the call site.
* Introduce refactoring trick to use 'of' in Java and 'invoke' in Kotlin:
** annotate 'of' method with @JvmName("of")  before renaming it to invoke, the Kotlin code sees the renamed method, while Java code remains unchanged.  So you can rename a static factory function with a name that makes sense in Java to, say, operator invoke: and Java call sites continue to have Java-specific syntactic sugar, and Kotlin call sites have Kotlin-specific syntactic sugar.
