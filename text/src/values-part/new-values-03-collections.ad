[[collections-and-transformation-pipelines]]

== Collections and Transformation Pipelines

One of the core services of our Travelator application is route planning.
A Route is a sequence of Journeys that can take the traveller from one location to another via a sequence Journeys. Each Journey in a route is a service provided by an Operator, via some mode of transport -- sea, train, bus, car, camel, etc. -- departing from one location at a specific time and arriving at another location some time later.
The routing service suggests several possible routes, and our travellers can compare them by cost, duration, and so on, to choose the route they prefer.

The journeys along a route do not always have a convenient interchange between them.
Some services run only once a day, or once a week, so our travellers want to know when they will have to book somewhere to stay between the end of one journey and the start of the next.
This will let us improve the cost estimate for a route, because we can suggest places to stay and include the cost in the overall cost of the route.
We can make the feature earn its keep by booking their preferred choices and earning a commission.

The first step is to find every interchange in a Route where the traveller will need to stay one or more nights.
This gives us a good reason to convert our Route class to Kotlin.
Writing this logic in Java requires verbose, imperative code.
With Kotlin's standard library, we can write this as a concise, declarative pipeline of transformations.

Let's take a look at our Java Route class.

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route implements Iterable<Journey> {
    private final List<Journey> journeys;

    public Route(List<Journey> journeys) {
        this.journeys = List.copyOf(journeys); // <1>
    }

    @Override
    public Iterator<Journey> iterator() { // <2>
        return journeys.iterator();
    }

    public Location getStart() {
        return journeys.get(0).getDepartsFrom();
    }

    public Location getDestination() {
        return journeys.get(journeys.size() - 1).getArrivesAt();
    }

    public Duration getDuration() {
        return Duration.between(
            journeys.get(0).getDepartureTime(),
            journeys.get(journeys.size() - 1).getArrivalTime());
    }

    public CostSummary cost(Currency userCurrency, ExchangeRates fx) {
        return CostSummary.calculate(journeys, userCurrency, fx); // <2>
    }

    ...
}
----
// end-insert

<1> A Route encapsulates a List of Journeys.
Because Lists are mutable -- or, at least, the type system offers no guarantee that the List is _not_ mutable -- the constructor takes a defensive copy of the list to avoid https://martinfowler.com/bliki/AliasingBug.html[_aliasing errors_].
<2> Because `List.copyOf` method returns an immutable List, there is no need to make a defensive copy or wrap the list with a `Collections.unmodifiableList` when returning an Iterator over the list, or when passing the list as a parameter to another class.
Unfortunately the type system does not prevent us calling mutator methods on Iterator or List, but doing so will throw `UnsupportedOperationException`, so coding errors will be caught pretty quickly by our tests.
Hopefully.

If we were to add a method to return the required stays, it would look like this:

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#imperative_algorithm
[source,java]
----
public List<Interchange> requiredStays() {
    var results = new ArrayList<Interchange>();

    for (int i = 1; i < journeys.size(); i++) {
        var interchange =
            Interchange.between(journeys.get(i - 1), journeys.get(i));

        if (interchange.isStayRequired()) {
            results.add(interchange);
        }
    }

    return results;
}
----
// end-insert

Let's translate the class to Kotlin, tidy it up, and then see how we can write the `requiredStays` logic in Kotlin.

Here's the class after IntelliJ has worked its translation magic:

// begin-insert: tags/collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> {
    private val journeys: MutableList<Journey> // <1>
    init {
        this.journeys = java.util.List.copyOf(journeys) // <2>
    }

    override fun iterator(): MutableIterator<Journey> = // <3>
        journeys.iterator()

    val start: Location get() =
        journeys[0].departsFrom

    val destination: Location get() =
        journeys[journeys.size - 1].arrivesAt

    val duration: Duration get() =
        Duration.between(
            journeys[0].departureTime,
            journeys[journeys.size - 1].arrivalTime)

    fun cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
        CostSummary.calculate(journeys, userCurrency, fx)

    ...
}
----
// end-insert

The construction of the Route class is pretty convoluted, and has broken the type safety of our Java class.

The constructor's List parameter is a _Kotlin_ List, which is unmodifiable.
Our Route class makes an defensive, immutable copy by calling `java.util.List.copyOf`, which returns a `java.util.List`.
Unlike a Kotlin List, a `java.util.List` does have methods for mutating the list, so the translated code store sthe result as a `MutableList` and exposes the iterator of that list as a `MutableIterator`.
Although this doesn't break encapsulation -- nothing can actually change the list of journeys -- it does break type safety -- calling a mutator method would throw `UnsupportedOperationException` at runtime.

TODO: explain the Kotlin/Java interop magic for collections implemented in the compiler?

Simplifying the code will also restore its type safety.

The class could make an  defensive, unmodifiable copy of the List in a Kotlin-esque way by calling `journeys.toList()`.
However, in our Travelator system, that list only comes from two places: from a JSON deserialiser that does not hold a reference to the list after creating the Route, and from test code that creates immutable lists.
This means that making a defensive copy is unnecessary work.
The can just store the immutable list.
We can do that succinctly by declaring the constructor parameter as a `val` and deleting the rest of the initialisation code.

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#constructor
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> {
    ...
}
----
// end-insert

The Route class implements the `Iterable` interface by delegating to the `journeys` List.
We can get the compiler to generate that delegation for us.

// begin-insert: tags/collections.4:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> by journeys {
    ...
}
----
// end-insert

The `destination` and `duration` accessors get the last journey in the list by calculating its integer index.
The Kotlin standard library defines a `List.last()` extension that we can use instead.
To make the code symmetrical, we'll also use the `List.first()` extension to get the first journey.

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#use_first_and_last
[source,kotlin]
----
val start: Location get() =
    journeys.first().departsFrom

val destination: Location get() =
    journeys.last().arrivesAt

val duration: Duration get() =
    Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime)
----
// end-insert

That leaves the Route class as:

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> by journeys {
    val start: Location get() =
        journeys.first().departsFrom

    val destination: Location get() =
        journeys.last().arrivesAt

    val duration: Duration get() =
        Duration.between(
            journeys.first().departureTime,
            journeys.last().arrivalTime)

    fun cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
        CostSummary.calculate(journeys, userCurrency, fx)

    ...
}
----
// end-insert

After all that, what is the Route class actually doing?

In Java, the Route class encapsulated a mutable list to ensure that it couldn't be mutated.
In Kotlin, the standard List type cannot be mutated, so there is nothing to encapsulate.
In fact, there is no compelling reason to make the `journeys` field private.

The Route class also provides accessors -- properties and query methods -- that return useful information about the route.
Those accessors are used by different features of the application, but were originally defined on the Route class because they needed access to the private list of Journeys.
If the list of journeys is not private, they could be defined as extension methods


TODO below here...

* Mutability requires encapsulation, which attracts methods to objects that encapsulate the required data.
* Immutability requires less encapsulation, and therefore frees us up to organise our logic in different ways. Logic no longer needs to be defined on the class that holds the private data that the logic needs.  We can separate


* Abstracting common transformations into extension methods
** E.g. List<Journey>.interchanges()
** Factor out the middle of pipelines (useful transformations), rather than the downstream ends (tell-don't-ask).
** call forward to extension methods part

* Refactoring Java streams to Kotlin stdlib?
