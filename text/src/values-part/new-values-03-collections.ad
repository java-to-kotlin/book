[[collections-and-transformation-pipelines]]

== Collections and Transformation Pipelines

TODO: something about grain of Java and Kotlin being very different when it comes to collections...

One of the core services of our Travelator application is route planning.
A Route is a sequence of Journeys that can take the traveller from one location to another via a sequence Journeys. Each Journey in a route is a service provided by an Operator, via some mode of transport -- sea, train, bus, car, camel, etc. -- departing from one location at a specific time and arriving at another location some time later.
The routing service suggests several possible routes, and our travellers can compare them by cost, duration, and so on, to choose the route they prefer.

The journeys along a route do not always have a convenient interchange between them.
Some services run only once a day, or once a week, so our travellers want to know when they will have to book somewhere to stay between the end of one journey and the start of the next.
This will let us improve the cost estimate for a route, because we can suggest places to stay and include the cost in the overall cost of the route.
We can make the feature earn its keep by booking their preferred choices and earning a commission.

The first step is to find every interchange in a Route where the traveller will need to stay one or more nights.
This gives us a good reason to convert our Route class to Kotlin.
Writing this logic in Java requires verbose, imperative code.
With Kotlin's standard library, we can write this as a concise, declarative pipeline of transformations.

=== A Class That Contains a Collection

Let's take a look at our Java Route class.

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route implements Iterable<Journey> {
    private final List<Journey> journeys;

    public Route(List<Journey> journeys) {
        this.journeys = List.copyOf(journeys); // <1>
    }

    @Override
    public Iterator<Journey> iterator() { // <2>
        return journeys.iterator();
    }

    public Location getStart() {
        return journeys.get(0).getDepartsFrom();
    }

    public Location getDestination() {
        return journeys.get(journeys.size() - 1).getArrivesAt();
    }

    public Duration getDuration() {
        return Duration.between(
            journeys.get(0).getDepartureTime(),
            journeys.get(journeys.size() - 1).getArrivalTime());
    }

    public CostSummary cost(Currency userCurrency, ExchangeRates fx) {
        return CostSummary.calculate(journeys, userCurrency, fx); // <2>
    }

    ...
}
----
// end-insert

<1> A Route encapsulates a List of Journeys.
Because Lists are mutable -- or, at least, the type system offers no guarantee that the List is _not_ mutable -- the constructor takes a defensive copy of the list to avoid https://martinfowler.com/bliki/AliasingBug.html[_aliasing errors_].
<2> Because `List.copyOf` method returns an immutable List, there is no need to make a defensive copy or wrap the list with a `Collections.unmodifiableList` when returning an Iterator over the list, or when passing the list as a parameter to another class.
Unfortunately the type system does not prevent us calling mutator methods on Iterator or List, but doing so will throw `UnsupportedOperationException`, so coding errors will be caught pretty quickly by our tests.

If we were to add a method to this class that returned the required stays, it would look like this:

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#imperative_algorithm
[source,java]
----
public List<Interchange> requiredStays() {
    var results = new ArrayList<Interchange>();

    for (int i = 1; i < journeys.size(); i++) {
        var interchange =
            Interchange.between(journeys.get(i - 1), journeys.get(i));

        if (interchange.isStayRequired()) {
            results.add(interchange);
        }
    }

    return results;
}
----
// end-insert

Let's translate the class to Kotlin, tidy it up, and then see how we can write the `requiredStays` logic in Kotlin.

Here's the class after IntelliJ has worked its translation magic:

// begin-insert: tags/collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(journeys: List<Journey>) : Iterable<Journey> {
    private val journeys: MutableList<Journey> // <1>
    init {
        this.journeys = java.util.List.copyOf(journeys) // <2>
    }

    override fun iterator(): MutableIterator<Journey> = // <3>
        journeys.iterator()

    val start: Location get() =
        journeys[0].departsFrom

    val destination: Location get() =
        journeys[journeys.size - 1].arrivesAt

    val duration: Duration get() =
        Duration.between(
            journeys[0].departureTime,
            journeys[journeys.size - 1].arrivalTime)

    fun cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
        CostSummary.calculate(journeys, userCurrency, fx)

    ...
}
----
// end-insert

The construction of the Route class is pretty convoluted, and has broken the type safety of our Java class.

The constructor's List parameter is a _Kotlin_ List, which is unmodifiable.
Our Route class makes an defensive, immutable copy by calling `java.util.List.copyOf`, which returns a `java.util.List`.
Unlike a Kotlin List, a `java.util.List` does have methods for mutating the list, so the translated code store sthe result as a `MutableList` and exposes the iterator of that list as a `MutableIterator`.
Although this doesn't break encapsulation -- nothing can actually change the list of journeys -- it does break type safety -- calling a mutator method would throw `UnsupportedOperationException` at runtime.

TODO: explain the Kotlin/Java interop magic for collections implemented in the compiler?

Simplifying the code will also restore its type safety.

The class could make an  defensive, unmodifiable copy of the List in a Kotlin-esque way by calling `journeys.toList()`.
However, in our Travelator system, that list only comes from two places: from a JSON deserialiser that does not hold a reference to the list after creating the Route, and from test code that creates immutable lists.
This means that making a defensive copy is unnecessary work.
The can just store the immutable list.
We can do that succinctly by declaring the constructor parameter as a `val` and deleting the rest of the initialisation code.

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#constructor
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> {
    ...
}
----
// end-insert

The Route class implements the `Iterable` interface by delegating to the `journeys` List.
We can get the compiler to generate that delegation for us.

// begin-insert: tags/collections.4:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> by journeys {
    ...
}
----
// end-insert

The `destination` and `duration` accessors get the last journey in the list by calculating its integer index.
The Kotlin standard library defines a `List.last()` extension that we can use instead.
To make the code symmetrical, we'll also use the `List.first()` extension to get the first journey.

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#use_first_and_last
[source,kotlin]
----
val start: Location get() =
    journeys.first().departsFrom

val destination: Location get() =
    journeys.last().arrivesAt

val duration: Duration get() =
    Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime)
----
// end-insert

That leaves the Route class as:

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) : Iterable<Journey> by journeys {
    val start: Location get() =
        journeys.first().departsFrom

    val destination: Location get() =
        journeys.last().arrivesAt

    val duration: Duration get() =
        Duration.between(
            journeys.first().departureTime,
            journeys.last().arrivalTime)

    fun cost(userCurrency: Currency, fx: ExchangeRates): CostSummary =
        CostSummary.calculate(journeys, userCurrency, fx)

    ...
}
----
// end-insert

After all that, what is the Route class actually doing?

In Java, the Route class encapsulated a mutable list to ensure that it couldn't be mutated.
In Kotlin, the List type cannot be mutated, so there is nothing to encapsulate.
There is no compelling reason to make the `journeys` field private.

The Route class also provides accessors -- properties and query methods -- that return useful information about the route.
Those accessors are used by different features of the application, but were originally defined on the Route class because they needed access to the private list of Journeys.
Were the list of journeys public, the accessors could be defined as extension methods -- except they are still called from Java.
The accessors have another responsibility: to provide a convenient API for use by our Java code.
When that Java code has been translated to Kotlin, we can revisit this class and see what we can do with extension methods.

But now, let's add the `requiredStays` method to our Kotlin class.


=== Adding a Transformation Pipeline

Recall the logic we want to add: find every interchange in a Route where the traveller will need to stay one or more nights.  An interchange is created between two journeys, like this: `Interchange.between(journey1, journey2)`.  We can calculate all the interchanges in a route by sliding a two-element window along the list of journeys and call `Interchange.between` for each pair it encounters.  Then we filter the Interchanges to select those that require one or more overnight stays.

In Java we would have had to implement this logic imperatively, with for loop and mutable list, because the collections and streams APIs do not have a method that implements a sliding window across the elements of a list.
The imperative implementation inextricably intertwines the different aspects of the calculation: sliding a two-element window along the list, using the sliding window to create Interchanges from the list of Journeys, and selecting the Interchanges that require a stay.

In Kotlin, the standard library contains higher order functions that do exactly what we want:

// begin-insert: tags/collections.6:src/main/java/travelator/itinerary/Route.kt#declarative_algorithm
[source,kotlin]
----
fun requiredStays() =
    journeys.windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isStayRequired }
----
// end-insert

We can make that logic more self-explanatory by extracting the code that calculates the interchanges into an extension function on List<Journey>:

// begin-insert: tags/collections.7:src/main/java/travelator/itinerary/Route.kt#declarative_algorithm
[source,kotlin]
----
fun requiredStays() =
    interchanges().filter { it.isStayRequired }

private fun interchanges() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
----
// end-insert


=== Do We Even Need the Route Class?

TODO: with no uses from Java, we can replace Route class with a typealias and extension functions.

=== Abstracting Part of the Transformation Pipeline

TODO: `interchanges()` has to be an extension function on List<Journey>.
This is a generally useful function, that we would want people to find serendipitously if they are working with routes and interchanges, so that they don't rewrite it.
Therefore, let's make it public.  IntelliJ will then offer it as an autocomplete suggesstion on expressions of type List<Journey>.

This abstracts the _middle_ of a transformation pipeline, and makes it seamlessly meld in with the existing transformations API. This is something that cannot be done in Java with the Streams API does not, but Kotlin makes trivialm, thanks to extension functions.

TODO: Something about a general principle: factor out the middle of pipelines into useful transformations, rather than the downstream ends as you would do with tell-don't-ask OO design.


=== Conclusions

Mutability requires encapsulation, which "attracts" behaviour onto classes that encapsulate the data it requires.
Immutable data requires less encapsulation, and therefore allows us to organise our logic in different ways.
We can group all the logic required by a particular feature of the application, or group logic that bridges between different domains.
We continue this train of thought in <<organising-code-by-domain>>.

TODO: more...