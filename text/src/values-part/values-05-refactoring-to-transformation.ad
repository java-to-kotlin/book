[[mutation-to-transformation]]
== From Mutation to Transformation

Recall the cost function we ended up with, after the refactoring in <<collections-and-transformation-pipelines>>:

// begin-insert: tags/mutations.0:src/main/java/travelator/money/Cost.kt
[source,kotlin]
----
fun ExchangeRates.cost(userCurrency: Currency, items: Iterable<Priced>): CostSummary {
    val calculator = CostSummaryCalculator(userCurrency, this)
    items.forEach { p ->
        calculator.addItem(p)
    }
    return calculator.summarise()
}
----
// end-insert

// suppress inspection "GrazieInspection"
The function uses a mutable object, the CostSummaryCalculator, to compute the cost summary for the journeys in a route, given the traveller's preferred currency and a source of exchange rates.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addItem(Priced item) {
        Money price = item.getPrice();
        currencyTotals.merge(price.getCurrency(), price, Money::add);
    }

    public CostSummary summarise() {
        var totals = new ArrayList<>(currencyTotals.values());
        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));

        CostSummary summary = new CostSummary(userCurrency);
        for (var total : totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }
        return summary;
    }
}
----
// end-insert

The CostSummaryCalculator keeps a running total of prices by currency as the Route.cost function adds journeys.  When asked for a summary, it converts those totals to the traveller's preferred currency and adds the conversion results to the `CostSummary`.   The CostSummary maintains a running total of the cost in the traveller's preferred currency as the CostSummaryCalculator adds the conversion results.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

Thus, the full calculation of the summary is split between the two classes.
The CostCurrencyCalculator has three responsibilities:
it holds the user's currency and source of ExchangeRates for the currency conversions,
calculates the total amount per currency before doing the currency conversions, to minimise rounding errors,
and orders the summary lines by the original currency.
The CostSummary has two responsibilities: it calculates the total amount,
and it reports the lines and total so that they can be displayed to the user.


TODO:

* refactoring loops and mutation to value types and transformations using the stdlib
** CostSummary.calculate example
** Aggregate data into intermediate form, calculate result from intermediate form.

Example of the following design process:

* Transform inputs into outputs.
* If you can't do that easily in one step, transform inputs into an intermediate representation from which it is easy to transform into outputs.
* Can't do _that_ easily in one step? Repeat until you can.


Where does mutation go?

* push mutation outwards towards the entry points
* or inwards and never let mutability escape local variables of a single function (this is an optimisation or when stdlib doesn't have the right HOF)
** a function can be referentially transparent to callers even if its implementation is not.
** In fact, that's how most of the HOFs in the standard library are implemented

