[[mutation-to-transformation]]
== From Mutation to Transformation

One of the most important things our travellers want to know is how much will their travels cost.
International travel makes this rather complicated.
A trip will involve costs in multiple currencies, as it wends its way across borders, but the traveller wants to be able to compare overall costs to make decisions about routes and where to stay.
Therefore, Travelator summarises costs by local currency _and_ the traveller's preferred currency, and shows the the overall total in the traveller's preferred currency.
It does this using the `CostSummary` and `CostSummaryCalculator` classes.
Let's take a look at how they are used, and then we'll look at their implementation.


=== Advantages and Disadvantages of Mutable State

We didn't show it during the refactoring in <<collections-and-transformation-pipelines>>,
but our `Route` class has an operation for summarising its costs with a `CostSummaryCalculator`.

Our Java code used it like this:

[[cost-summary-calculator-usage]]
// begin-insert: tags/value_types.0:src/test/java/travelator/itinerary/RouteCostTest.java#calculation
[source,java]
----
ExchangeRates fx = ...
Currency userCurrency = ...

CostSummaryCalculator calculator =
    new CostSummaryCalculator(userCurrency, fx); // <1>

public CostSummary costSummary(Route r) {
    r.addCostsTo(calculator); // <2>
    return calculator.summarise(); // <3>
}
----
// end-insert

<1> create a `CostSummaryCalculator` with the traveller's preferred currency and a source of currency exchange rates.
<2> tell the Route to add its costs to the calculator.  The Route adds the cost of each journey.
<3> when all the costs have been collected, call the calculator's `summarise` method to obtain the `CostSummary`.

The `Route.addCostsTo` method was implemented in Java as follows:

// begin-insert: tags/value_types.0:src/main/java/travelator/itinerary/Route.java#costs
[source,java]
----
public class Route implements Iterable<Journey> {
    private final List<Journey> journeys;

    ...

    public void addCostsTo(CostSummaryCalculator calculator) {
        for (var j : journeys) {
            calculator.addCost(j.getPrice());
        }
    }

    ...
}
----
// end-insert

By the end of <<collections-and-transformation-pipelines>>, we had refactored Route to be a typealias of `List<Journey>`. The `addCostsTo` operation is now an extension method:

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.addCostsTo(calculator: CostSummaryCalculator) {
    forEach { journey -> calculator.addCost(journey.price) }
}
----
// end-insert

The logic is essentially the same as in Java because it relies upon side effects to accumulate costs in the mutable state of the `CostSummaryCalculator`.

The benefit of this approach is that we can use the calculator to summarise the costs of any object in our domain model without knowing the structure of that object.
The object is responsible for adding costs to the calculator or passing the calculator to its sub-objects.
This decouples the code that asks for the costs from the code that provides the costs, allowing us to evolve them independently.

For example, a Route contains Journeys that each have a cost, and an Itinerary contains a Route and a collection of hotel stays that each have a cost.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/Itinerary.kt
[source,kotlin]
----
data class Itinerary(
    val route: Route,
    val stays: List<Stay>
)

fun Itinerary.addCostsTo(calculator: CostSummaryCalculator) {
    route.addCostsTo(calculator)
    stays.forEach { stay -> calculator.addCost(stay.price) }
}
----
// end-insert

However, our use of mutable state has two significant disadvantages.

Firstly, it introduces the possibility of aliasing errors.
If we reuse a calculator to summarise the costs of multiple entities, we have to reset its state between each calculation to stop costs collected during one calculation being included in the next.
The type system cannot help us avoid this mistake.
The example code on <<cost-summary-calculator-usage,page>> may make this error.
The calculator is not local to the `costSummary` method, but `costSummary` does not reset the calculator before each calculation.
We can't tell if this is a problem or not merely by looking at the `costSummary` method.
We have to understand how that method is used in its wider context, and
as we make changes in that wider context, we have to make sure those changes do not break our assumptions about how the `costSummary` method is used.
Mutable state makes it easy to inadvertently create "spooky action at a distance" that is not immediately obvious from the source code.

Secondly, the stateful computation duplicates _logic_ that is already implemented by the standard library, but makes that duplication hard to spot because the _code_ looks so different.

To see how, let's take a look at the `CostSummaryCalculator` class:

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addCost(Money cost) {
        currencyTotals.merge(cost.getCurrency(), cost, Money::add);
    }

    public CostSummary summarise() {
        var totals = new ArrayList<>(currencyTotals.values());
        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));

        CostSummary summary = new CostSummary(userCurrency);
        for (var total : totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }

        return summary;
    }

    public void reset() {
        currencyTotals.clear();
    }
}
----
// end-insert

The full calculation of the summary is split between two classes.
The CostSummaryCalculator keeps a running total of costs in each currency as the Route.cost function adds journeys.
When asked for a summary, it converts those totals to the traveller's preferred currency and adds the conversion results to the `CostSummary`.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

The `CostSummary` maintains a running total of the cost in the traveller's preferred currency as the CostSummaryCalculator adds the conversion results.

The two classes intertwine the following responsibilities:

* Hold information from the context of the calculation that is needed to compute the summary
* Calculate per-currency totals, so the calculation doesn't accumulate rounding errors
* Convert costs to the traveller's preferred currency
* Calculate the grand total in the traveller's preferred currency
* Sort the currency conversions in alphabetical order of the original currency code.
* Store the currency conversions and grand total so they can be displayed to the traveller.

Such comingling of responsibilities across classes is a common when one computes by mutating shared state.
We'd like to disentangle the responsibilities and replace our own code by calls to existing functions in the standard library.
What is the final structure we should refactor towards?

One clue is in the name of the "CostCurrencyCalculator" class, or rather its "...or" suffix.
Linguistically, the class name is an _agent noun_ -- a noun derived from a verb that means no more than a thing that performs the action identified by the verb.
CostCurrencyCalculator is a "doer class".

Another clue is in the data that the class holds.
The traveller's preferred currency and source of exchange rates are the context for the calculation.
They are managed elsewhere in the application and held by `CostCurrencyCalculator` so that they are close at hand for its calculations.
The map of totals by currency contains transient, intermediate results of the calculation that are irrelevant after the calculation is complete, and in fact should be discarded to avoid aliasing errors.
The class doesn't _own_ any data, only hold it temporarily for operational reasons.

The `CostCurrencyCalculator` class doesn't represent a concept in our application domain model, but a _function_ that we perform upon elements of our domain model.
In Kotlin, we usually implement functions not with objects but with, well, functions.

Let's refactor the calculation from mutable classes to functions that work with immutable data.


=== Refactoring to Functions over Immutable Data

Converting the two classes to idiomatic Kotlin leaves us with "Java in Kotlin syntax", a starting point from which we can start refactoring away the mutability.

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val totals = ArrayList(currencyTotals.values)
        totals.sortWith(comparing { m: Money -> m.currency.currencyCode })

        val summary = CostSummary(userCurrency)
        for (total in totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency))
        }
        return summary
    }

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency)
        private set

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

We'll work from the inside, by making CostSummary an immutable value type,
and gradually push immutability outwards through the CostSummaryCalculator.

If CostSummary was immutable, client code would have to pass the list of lines to its constructor instead of calling its `addLine` method.
We can baby-step our way there by adding a secondary constructor to the CostSummary class that takes a list of lines and calls `addLine` for each one:

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency)
        private set

    constructor(
        userCurrency: Currency,
        lines: List<CurrencyConversion>
    ): this(userCurrency) {
        lines.forEach(::addLine)
    }

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

Now we can change the `CostSummaryCalculator.summarise` method to call the new constructor, treating the `CostSummary` class as if it was an immutable value type.
While we are about it, we'll sort the totals by currency code with Kotlin's `List.sortedBy` function, instead of a mutable ArrayList and Java's in-place sort.

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt#summarise
[source,kotlin]
----
fun summarise() = CostSummary(
    userCurrency,
    currencyTotals.values
        .sortedBy { it.currency.currencyCode }
        .map { exchangeRates.convert(it, userCurrency) })
----
// end-insert

This allows us to remove mutation from the CostSummary class:

// begin-insert: tags/mutations.3:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency, val lines: List<CurrencyConversion>) {
    val total = lines
        .map { it.toMoney }
        .fold(Money.zero(userCurrency), Money::add)
}
----
// end-insert

If we push the total calculation out as a constructor parameter, we could make the CostSummary a data class.

Then we'll select the expression to the right of the equals sign, and push it out as a constructor parameter:

// begin-insert: tags/new_mutations.4:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(val lines: List<CurrencyConversion>, total: Money) {
    val total = total
}
----
// end-insert

Then auto-correct on the total property to move its definition into the constructor:

// begin-insert: tags/new_mutations.5:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(val lines: List<CurrencyConversion>, val total: Money)
----
// end-insert

Now we can make `CostSummary` a data class.
Its sole responsibility is to hold the results of the calculation for display to the user.

// begin-insert: tags/new_mutations.6:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
data class CostSummary(val lines: List<CurrencyConversion>, val total: Money)
----
// end-insert

That leaves our `CostSummaryCalculator` looking like this:

// begin-insert: tags/new_mutations.6:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        val total = lines
            .map { it.toMoney }
            .fold(Money.zero(userCurrency), Money::add)

        return CostSummary(lines, total)
    }

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

We can apply a similar process to eliminate its shared mutable state.
In this case we won't add a secondary constructor.
Instead, we will add an overload of the `summarise` method that takes the costs, calls `addCost` for each one, and then returns the result of the original `summarise` method.
This will draw a distinction between the context of cost summary calculations, which will be passed to the constructor, and the arguments to a specific calculation, which will be passed to the `summarise` method.

We'll pass the costs as a lazily evaluated `Sequence<Money>` to avoid copying between collections when reporting costs from composite entities.

// begin-insert: tags/new_mutations.7:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun summarise(costs: Sequence<Money>): CostSummary {
        reset()
        costs.forEach(::addCost)
        return summarise()
    }

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        val total = lines
            .map { it.toMoney }
            .fold(Money.zero(userCurrency), Money::add)

        return CostSummary(lines, total)
    }

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

To switch over to using the new `summarise` method, we'll have to query the costs of the entities we want to summarise, rather than add their costs to a mutable calculator.
We'll end up using the calculator like this:

// begin-insert: tags/new_mutations.8:src/test/java/travelator/itinerary/Route_CostTest.kt#calculation
[source,kotlin]
----
val fx: ExchangeRates = ...
val userCurrency = ...

val calculator = CostSummaryCalculator(userCurrency, fx)

fun costSummary(r: Route) =
    calculator.summarise(r.costs())
----
// end-insert

And we'll report the costs from our domain models like this:

// begin-insert: tags/new_mutations.8:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.costs(): Sequence<Money> =
    this.asSequence().map { it.price }
----
// end-insert

// begin-insert: tags/new_mutations.8:src/main/java/travelator/itinerary/Itinerary.kt#costs
[source,kotlin]
----
fun Itinerary.costs(): Sequence<Money> =
    route.costs() + stays.asSequence().map { it.price }
----
// end-insert

When our application only uses the new `summarise` method, we can move the calculation of the `currencyTotals` and `CostSummary` into that method, and delete the `addCost` and no-argument `summarise` methods:

// begin-insert: tags/new_mutations.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    fun summarise(costs: Sequence<Money>): CostSummary {
        val currencyTotals = costs
            .groupingBy { it.currency }
            .reduce { _, a, b -> a + b }

        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        val total = lines
            .map { it.toMoney }
            .fold(Money(0, userCurrency), Money::add)

        return CostSummary(lines, total)
    }
}
----
// end-insert

=== Separating Context from Specifics

This clearly shows us that we have a pure function that is applied to a collection of costs, and is evaluated in a context comprised of the exchange rates and the traveller's preferred currency.
There are other calculations in our application that also use exchange rates and the traveller's preferred currency.
By separating the calculation of the cost summary from the context of that calculation, we have discovered a useful abstraction that we can use more widely to simplify code elsewhere in the application.

For example, we show the cost of individual items in both the local and preferred currency.
The CostSummaryCalculator also converts the cost of individual items in order to summarise them.
We can expose that functionality as a method, and remove duplicate logic elsewhere in the application.

The class is not a summary calculator any more -- it holds the context for pricing calculations we do for a specific traveller.
Let's rename the class to make that explicit.
I can't think of a better name than PricingContext at the moment.
It's a bit too generic for my tastes, but will do until we think of something better.
At least it's not misleading.
Because renames are cheap, even in a mixed Java/Kotlin codebase, a small incremental improvement is better than no improvement.


TODO...

What does the code look like if we turn summarise into an extension function?
IntelliJ can automatically convert the method into an extension function and back again.
However, at the moment, the properties of CostSummaryCalculator are private, and so would be inaccessible to an extension function.
We could make them public -- they are immutable, so that wouldn't be a terrible change.
However, the class only uses them in one place: the conversion of a cost to the traveller's preferred currency.
If we extract that as a public method, `summarise` can be made an extension method:




=== Conclusion

We can see the shape of the calculation more clearly now.
It first aggregates data into intermediate form, and then calculates the final result from that intermediate form.

This is an example of the following design process:

* Transform inputs into outputs.
* If you can't do that easily in one step, transform inputs into an intermediate representation from which it is easy to transform into outputs.
* If you can't do _that_ easily in one step? Repeat until you can.


Where does mutation go?

* push mutation outwards towards the entry points
* or inwards and never let mutability escape local variables of a single function (this is an optimisation or when stdlib doesn't have the right HOF)
** a function can be referentially transparent to callers even if its implementation is not.
** In fact, that's how most of the HOFs in the standard library are implemented

