[[mutation-to-transformation]]
== From Mutation to Transformation

One of the most important things our travellers want to know is how much will their travels cost.
International travel makes this rather complicated.
A trip will involve costs in multiple currencies, as it wends its way across borders, but the user wants to be able to compare overall costs to make decisions about routes and where to stay.
Therefore, Travelator summarises costs by local currency _and_ the user's preferred currency, and shows the the overall total in the user's preferred currency.
It does this using the `CostSummary` and `CostSummaryCalculator` classes.
Let's take a look at how they are used, and then we'll look at their implementation.

One of the things for which our application calculates a cost summary is a Route.
We didn't show it during the refactoring in <<collections-and-transformation-pipelines>>,
but our `Route` class has an operation for summarising its costs with a CostSummaryCalculator.

// begin-insert: tags/value_types.0:src/main/java/travelator/itinerary/Route.java#costs
[source,java]
----
public class Route implements Iterable<Journey> {
    private final List<Journey> journeys;

    ...

    public void addCostsTo(CostSummaryCalculator calculator) {
        for (var p : journeys) {
            calculator.addCost(p.getPrice());
        }
    }

    ...
}
----
// end-insert

By the end of the refactoring, this had been converted to an extension method on `List<Journey>`, but the logic was essentially the same:

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.addCostsTo(calculator: CostSummaryCalculator) {
    forEach { journey -> calculator.addCost(journey.price) }
}
----
// end-insert

The process of summarising costs relies upon side effects.
Costs are added toa  CostSummaryCalculator, and then the summary is generated by the `summarise` method:


// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addCost(Money cost) {
        currencyTotals.merge(cost.getCurrency(), cost, Money::add);
    }

    public CostSummary summarise() {
        var totals = new ArrayList<>(currencyTotals.values());
        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));

        CostSummary summary = new CostSummary(userCurrency);
        for (var total : totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }
        return summary;
    }
}
----
// end-insert

The full calculation of the summary is split between two classes.
The CostSummaryCalculator keeps a running total of costs in each currency as the Route.cost function adds journeys.
When asked for a summary, it converts those totals to the traveller's preferred currency and adds the conversion results to the `CostSummary`.
The `CostSummary` maintains a running total of the cost in the traveller's preferred currency as the CostSummaryCalculator adds the conversion results.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

The two classes intertwine the following responsibilities:

* Hold information about the context of the calculation needed to compute its result
* Calculate per-currency totals, so we don't accumulate rounding errors
* Convert costs to the user's preferred currency
* Calculate the total in the user's preferred currency
* Create a summary of the currency conversions and total, so that the application can report the summary to the user.
* Sort the lines of the summary in alphabetical order of the original currency code.

This intertwingling of responsibilities is a common outcome of using mutation of shared state.
We want to disentangle the responsibilities, but what's our end goal?

A clue is in the name of the "CostCurrencyCalculator" class, or rather the "or" suffix.
It's a "doer" class.
Linguistically, the class name is an _agent noun_, derived from a verb and meaning no more than an entity that performs the action identified by the verb.

Another clue is in the data that the class holds.
The user's currency and ExchangeRates are the _context_ for the calculation.
They are created elsewhere in the application and passed to the CostCurrencyCalculator's constructor so that it can use them in its calculations.
The other field is the mutable map of `currencyTotals`, which are transient, intermediate results of the calculation.
The class doesn't own any long-lived data.

It doesn't represent a concept in our application domain model, but a _function_ that we perform upon entities of our the domain model.
In Kotlin, we usually implement functions not with classes but with, well,  _functions_.

Let's refactor the calculation from mutable classes to functions that work with immutable data.


=== Converting to Kotlin

Let's convert the two classes to idiomatic Kotlin:

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val totals = ArrayList(currencyTotals.values)
        totals.sortWith(comparing { m: Money -> m.currency.currencyCode })

        val summary = CostSummary(userCurrency)
        for (total in totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency))
        }
        return summary
    }
}
----
// end-insert

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency?) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency!!)
        private set

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

We'll start by making CostSummary an immutable value type, and then see what we can do about the CostSummaryCalculator.

If CostSummary was immutable, client code would have to pass the list of lines to its constructor instead of calling `addLine`.
We can baby-step our way there by adding a secondary constructor to the CostSummary class that takes a list of lines and calls addLine for each one:

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency?) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency!!)
        private set

    constructor(
        userCurrency: Currency,
        lines: List<CurrencyConversion>
    ): this(userCurrency) {
        lines.forEach(::addLine)
    }

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

Now we can change the `CostSummaryCalculator.summarise` method to call the new constructor, treating the `CostSummary` class as if it was an immutable value type.
While we are about it, we'll use Kotlin's `List.sortedBy` function, instead of a mutable ArrayList and Java's in-place sort, to sort the totals by currency code.

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt#summarise
[source,kotlin]
----
fun summarise() = CostSummary(
    userCurrency,
    currencyTotals.values
        .sortedBy { it.currency.currencyCode }
        .map { exchangeRates.convert(it, userCurrency) })
----
// end-insert

This allows us to remove mutation from the CostSummary class:

// begin-insert: tags/mutations.3:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency, val lines: List<CurrencyConversion>) {
    val total = lines
        .map { it.toMoney }
        .fold(Money.zero(userCurrency), Money::add)
}
----
// end-insert

We can apply a similar process to the CostSummaryCalculator.
In this case we won't add a secondary constructor.
Instead, we will add an overload of the `summarise` method that takes the items, calls `addItem` for each one, and then returns the result of the original `summarise` method.
This draws a distinction between the context of cost summary calculations, which is passed to the constructor, and the arguments to a specific calculation, which are passed to the `summarise` method.

// begin-insert: tags/mutations.4:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(costs: Iterable<Money>): CostSummary {
        costs.forEach(::addCost)
        return summarise()
    }

    fun summarise() = CostSummary(
        userCurrency,
        currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) })
}
----
// end-insert

The CostSummaryCalculator is now used like this:

// begin-insert: tags/mutations.4:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.costs() = map { it.price }
----
// end-insert

We must change all uses of the CostSummaryCalculator pass the items to our new override of the `summarise` method.

// begin-insert: tags/mutations.5:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.costs() = map { it.price }
----
// end-insert

The function is starting to look too trivial to be useful, but let's finish our refactoring of the CostSummaryCalculator, and then have a think about what to do with this function.


TODO: mutable accumulator to fold over chained sequences.  E.g. Itinerary has both Route and Stays

Now the only method called on the CostSummaryCalculator is the overload of summarise that takes the Items as an argument.
We can move logic from `addItems` and `summarise()` into that method:

// begin-insert: tags/mutations.5:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    fun summarise(items: Iterable<Money>): CostSummary {
        val currencyTotals = items
            .groupingBy { it.currency }
            .reduce { _, a, b -> a + b }

        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        return CostSummary(userCurrency, lines)
    }
}
----
// end-insert


Now we can see quite clearly that we have a pure function over a collection of priced items, that executes in a context made up of the exchange rates and user's preferred currency.
The class is not a calculator any more -- it's the context for pricing calculations we do for a specific traveller.

Let's refactor to show that:

To be continued...

TODO:

* refactoring loops and mutation to value types and transformations using the stdlib
** Aggregate data into intermediate form, calculate result from intermediate form.

Example of the following design process:

* Transform inputs into outputs.
* If you can't do that easily in one step, transform inputs into an intermediate representation from which it is easy to transform into outputs.
* Can't do _that_ easily in one step? Repeat until you can.


Where does mutation go?

* push mutation outwards towards the entry points
* or inwards and never let mutability escape local variables of a single function (this is an optimisation or when stdlib doesn't have the right HOF)
** a function can be referentially transparent to callers even if its implementation is not.
** In fact, that's how most of the HOFs in the standard library are implemented

