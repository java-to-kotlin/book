[[mutation-to-transformation]]
== From Mutation to Transformation

One of the most important things our travellers want to know is how much will their travels cost.
International travel makes this rather complicated.
A trip will involve costs in multiple currencies, as it wends its way across borders, but the traveller wants to be able to compare overall costs to make decisions about routes and where to stay.
Therefore, Travelator summarises costs by local currency _and_ the traveller's preferred currency, and shows the the overall total in the traveller's preferred currency.
It does this using the `CostSummary` and `CostSummaryCalculator` classes.
Let's take a look at how they are used, and then we'll look at their implementation.

One of the things for which our application calculates a cost summary is a Route.
We didn't show it during the refactoring in <<collections-and-transformation-pipelines>>,
but our `Route` class has an operation for summarising its costs with a CostSummaryCalculator.
It is used like this:

// begin-insert: tags/value_types.0:src/test/java/travelator/itinerary/RouteCostTest.java#calculation
[source,java]
----
ExchangeRates fx = ...

Currency userCurrency = ...

CostSummaryCalculator calculator =
    new CostSummaryCalculator(userCurrency, fx);

public CostSummary costSummary(Route r) {
    r.addCostsTo(calculator);
    return calculator.summarise();
}
----
// end-insert

And implemented like this:

// begin-insert: tags/value_types.0:src/main/java/travelator/itinerary/Route.java#costs
[source,java]
----
public class Route implements Iterable<Journey> {
    private final List<Journey> journeys;

    ...

    public void addCostsTo(CostSummaryCalculator calculator) {
        for (var p : journeys) {
            calculator.addCost(p.getPrice());
        }
    }

    ...
}
----
// end-insert

By the end of the refactoring, this had been converted to an extension method on `List<Journey>`:

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.addCostsTo(calculator: CostSummaryCalculator) {
    forEach { journey -> calculator.addCost(journey.price) }
}
----
// end-insert

The logic is essentially the same because it relies upon side effects that accumulate costs in mutable state of the `CostSummaryCalculator`.
To obtain a `CostSummary` for a `Route`, Travelator creates a `CostSummaryCalculator` with the traveller's preferred currency and a source of currency exchange rates.
It passes the calculator to the Route's `addCostsTo` method and, when that method returns, calls the calculator's `summarise` method to calculate the `CostSummary`.

The benefit of this model is that we can use the calculator to summarise any composite object that contains elements that incur costs.
For example, a Route is made up of Journeys that each have a cost, and an Itinerary is made up of a Route and a collection of hotel stays that each have a cost.
The method or function that adds costs to the CostSummaryCalculator decouples the code that uses the summary  from the internal structure of the composite object.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/Itinerary.kt
[source,kotlin]
----
data class Itinerary(
    val route: Route,
    val stays: List<Stay>
)

fun Itinerary.addCostsTo(calculator: CostSummaryCalculator) {
    route.addCostsTo(calculator)
    stays.forEach { stay -> calculator.addCost(stay.price) }
}
----
// end-insert

However, this use of mutable state has two significant disadvantages.

Firstly, it introduces the possibility of aliasing errors.
... explain ...

Secondly, it duplicates logic that is already implemented by the standard library, and does so in a way that makes that duplication hard to notice.

To see how, let's take a look at the `CostSummaryCalculator` class:

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addCost(Money cost) {
        currencyTotals.merge(cost.getCurrency(), cost, Money::add);
    }

    public CostSummary summarise() {
        var totals = new ArrayList<>(currencyTotals.values());
        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));

        CostSummary summary = new CostSummary(userCurrency);
        for (var total : totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }

        return summary;
    }

    public void reset() {
        currencyTotals.clear();
    }
}
----
// end-insert

The full calculation of the summary is split between two classes.
The CostSummaryCalculator keeps a running total of costs in each currency as the Route.cost function adds journeys.
When asked for a summary, it converts those totals to the traveller's preferred currency and adds the conversion results to the `CostSummary`.
The `CostSummary` maintains a running total of the cost in the traveller's preferred currency as the CostSummaryCalculator adds the conversion results.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

The two classes intertwine the following responsibilities:

* Hold information from the context of the calculation that is needed to compute the summary
* Calculate per-currency totals, so the calculation doesn't accumulate rounding errors
* Convert costs to the travellers's preferred currency
* Calculate the grand total in the travellers's preferred currency
* Represent the summary of the currency conversions and total that the application reports to the traveller.
* Sort the lines of the summary in alphabetical order of the original currency code.

This intertwingling of responsibilities is a common outcome of using mutation of shared state.
We'd like to disentangle the responsibilities and implement them with existing functions in the standard library.
What is final shape of the code we should aim for with this refactoring?

One clue is in the name of the "CostCurrencyCalculator" class, or rather its "...or" suffix.
It's a "doer" class.
Linguistically, the class name is an _agent noun_, derived from a verb and meaning no more than an entity that performs the action identified by the verb.

Another clue is in the data that the class holds.
The traveller's currency and ExchangeRates are the context for the calculation.
They are created elsewhere in the application and held by `CostCurrencyCalculator` so that it can use them in its calculations.
The other field is the mutable map of `currencyTotals` -- transient, intermediate results of the calculation that are discarded when the calculation is complete.
The class doesn't have any long-lived data of its own.

The `CostCurrencyCalculator` class doesn't represent a concept in our application domain model, but a _function_ that we perform upon elements of our domain model.
In Kotlin, we usually implement functions not with classes but with, well, functions.

Let's refactor the calculation from mutable classes to functions that work with immutable data.


=== Converting to Kotlin

Convert the two classes to idiomatic Kotlin leaves us with "Java in Kotlin syntax", a starting point from which we can start refactoring away the mutability.

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val totals = ArrayList(currencyTotals.values)
        totals.sortWith(comparing { m: Money -> m.currency.currencyCode })

        val summary = CostSummary(userCurrency)
        for (total in totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency))
        }
        return summary
    }

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency)
        private set

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

From here, we'll work from the inside, gradually pushing immutability outwards.
We'll start by making CostSummary an immutable value type, and then see what we can do about the CostSummaryCalculator.

If CostSummary was immutable, client code would have to pass the list of lines to its constructor instead of calling its `addLine` method.
We can baby-step our way there by adding a secondary constructor to the CostSummary class that takes a list of lines and calls addLine for each one:

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency)
        private set

    constructor(
        userCurrency: Currency,
        lines: List<CurrencyConversion>
    ): this(userCurrency) {
        lines.forEach(::addLine)
    }

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

Now we can change the `CostSummaryCalculator.summarise` method to call the new constructor, treating the `CostSummary` class as if it was an immutable value type.
While we are about it, we'll sort the totals by currency code with Kotlin's `List.sortedBy` function, instead of a mutable ArrayList and Java's in-place sort.

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt#summarise
[source,kotlin]
----
fun summarise() = CostSummary(
    userCurrency,
    currencyTotals.values
        .sortedBy { it.currency.currencyCode }
        .map { exchangeRates.convert(it, userCurrency) })
----
// end-insert

This allows us to remove mutation from the CostSummary class:

// begin-insert: tags/mutations.3:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency, val lines: List<CurrencyConversion>) {
    val total = lines
        .map { it.toMoney }
        .fold(Money.zero(userCurrency), Money::add)
}
----
// end-insert

We can apply a similar process to the CostSummaryCalculator.
In this case we won't add a secondary constructor.
Instead, we will add an overload of the `summarise` method that takes the costs, calls `addCost` for each one, and then returns the result of the original `summarise` method.

// begin-insert: tags/mutations.4:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(costs: Iterable<Money>): CostSummary {
        costs.forEach(::addCost)
        return summarise()
    }

    fun summarise() = CostSummary(
        userCurrency,
        currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) })

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

This draws a distinction between the context of cost summary calculations, which is passed to the constructor, and the arguments to a specific calculation, which are passed to the `summarise` method.

To switch over to using the new `summarise` method, we'll have to query the costs of the entities we want to summarise, rather than add their costs to a mutable calculator.
We'll end up using the calculator like this:

// begin-insert: tags/mutations.4:src/test/java/travelator/itinerary/Route_CostTest.kt#calculation
[source,kotlin]
----
val fx: ExchangeRates = ...
val userCurrency: Currency = ...

val calculator = CostSummaryCalculator(userCurrency, fx)

fun costSummary(r: Route): CostSummary =
    calculator.summarise(r.costs())
----
// end-insert

And we'll report the costs from our domain models like this:

// begin-insert: tags/mutations.4:src/main/java/travelator/itinerary/Route_Cost.kt
[source,kotlin]
----
fun Route.costs() = map { it.price }
----
// end-insert

// begin-insert: tags/mutations.4:src/main/java/travelator/itinerary/Itinerary.kt#costs
[source,kotlin]
----
fun Itinerary.costs() =
    route.costs() + stays.map { it.price }
----
// end-insert


Now the only method called on the CostSummaryCalculator is the overload of summarise that takes the costs as an argument.
We can move the calculation of the `currencyTotals` and `CostSummary` into that method:

// begin-insert: tags/mutations.5:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    fun summarise(costs: Iterable<Money>): CostSummary {
        val currencyTotals = costs
            .groupingBy { it.currency }
            .reduce { _, a, b -> a + b }

        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        return CostSummary(userCurrency, lines)
    }
}
----
// end-insert


This clearly shows us that we have a pure function that is applied to a collection of costs, and is evaluated in a context comprised of the exchange rates and traveller's preferred currency.
The class is not a calculator any more -- it holds the context for pricing calculations we do for a specific traveller.
Let's refactor to show that:

To be continued...

TODO:

We can see the shape of the calculation more clearly now.
It first aggregates data into intermediate form, and then calculates the final result from that intermediate form.

This is an example of the following design process:

* Transform inputs into outputs.
* If you can't do that easily in one step, transform inputs into an intermediate representation from which it is easy to transform into outputs.
* If you can't do _that_ easily in one step? Repeat until you can.


Where does mutation go?

* push mutation outwards towards the entry points
* or inwards and never let mutability escape local variables of a single function (this is an optimisation or when stdlib doesn't have the right HOF)
** a function can be referentially transparent to callers even if its implementation is not.
** In fact, that's how most of the HOFs in the standard library are implemented

