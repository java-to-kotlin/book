[[mutation-to-transformation]]
== From Mutation to Transformation

Recall the cost function we ended up with, after the refactoring in <<collections-and-transformation-pipelines>>:

// begin-insert: tags/mutations.0:src/main/java/travelator/money/Cost.kt
[source,kotlin]
----
fun ExchangeRates.cost(userCurrency: Currency, items: Iterable<Priced>): CostSummary {
    val calculator = CostSummaryCalculator(userCurrency, this)
    items.forEach { p ->
        calculator.addItem(p)
    }
    return calculator.summarise()
}
----
// end-insert

// suppress inspection "GrazieInspection"
The function uses a mutable object, the CostSummaryCalculator, to compute the cost summary for the journeys in a route, given the traveller's preferred currency and a source of exchange rates.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addItem(Priced item) {
        Money price = item.getPrice();
        currencyTotals.merge(price.getCurrency(), price, Money::add);
    }

    public CostSummary summarise() {
        var totals = new ArrayList<>(currencyTotals.values());
        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));

        CostSummary summary = new CostSummary(userCurrency);
        for (var total : totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }
        return summary;
    }
}
----
// end-insert

The full calculation of the summary is split between two classes.
The CostSummaryCalculator keeps a running total of costs in each currency as the Route.cost function adds journeys.
When asked for a summary, it converts those totals to the traveller's preferred currency and adds the conversion results to the `CostSummary`.
The `CostSummary` maintains a running total of the cost in the traveller's preferred currency as the CostSummaryCalculator adds the conversion results.

// begin-insert: tags/mutations.0:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

The two classes intertwine the following responsibilities:

* Hold information about the context of the calculation needed to compute its result
* Calculate per-currency totals, so we don't accumulate rounding errors
* Convert costs to the user's preferred currency
* Calculate the total in the user's preferred currency
* Create a summary of the currency conversions and total, so that the application can report the summary to the user.
* Sort the lines of the summary in alphabetical order of the original currency code.

This intertwingling of responsibilities is a common outcome of using mutation of shared state.
We want to disentangle the responsibilities, but what's our end goal?

A clue is in the name of the "CostCurrencyCalculator" class, or rather the "or" suffix.
It's a "doer" class.
Linguistically, the class name is an _agent noun_, derived from a verb and meaning no more than an entity that performs the action identified by the verb.

Another clue is in the data that the class holds.
The user's currency and ExchangeRates are the _context_ for the calculation.
They are created elsewhere in the application and passed to the CostCurrencyCalculator's constructor so that it can use them in its calculations.
The other field is the mutable map of `currencyTotals`, which are transient, intermediate results of the calculation.
The class doesn't own any long-lived data.

It doesn't represent a concept in our application domain model, but a _function_ that we perform upon entities of our the domain model.
In Kotlin, we usually implement functions not with classes but with, well,  _functions_.

Let's refactor the calculation from mutable classes to functions that work with immutable data.


=== Converting to Kotlin

Let's convert the two classes to idiomatic Kotlin:

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addItem(item: Priced) {
        val price = item.price
        currencyTotals.merge(price.currency, price, Money::add)
    }

    fun summarise(): CostSummary {
        val totals = ArrayList(currencyTotals.values)
        totals.sortWith(comparing { m: Money -> m.currency.currencyCode })

        val summary = CostSummary(userCurrency)
        for (total in totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency))
        }
        return summary
    }
}
----
// end-insert

// begin-insert: tags/mutations.1:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency?) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency!!)
        private set

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

We'll start by making CostSummary an immutable value type, and then see what we can do about the CostSummaryCalculator.

If CostSummary was immutable, client code would have to pass the list of lines to its constructor instead of calling `addLine`.
We can baby-step our way there by adding a secondary constructor to the CostSummary class that takes a list of lines and calls addLine for each one:

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency?) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money.zero(userCurrency!!)
        private set

    constructor(
        userCurrency: Currency,
        lines: List<CurrencyConversion>
    ): this(userCurrency) {
        lines.forEach(::addLine)
    }

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

Now we can change the `CostSummaryCalculator.summarise` method to call the new constructor, treating the `CostSummary` class as if it was an immutable value type.
While we are about it, we'll use Kotlin's `List.sortedBy` function, instead of a mutable ArrayList and Java's in-place sort, to sort the totals by currency code.

// begin-insert: tags/mutations.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt#summarise
[source,kotlin]
----
fun summarise() = CostSummary(
    userCurrency,
    currencyTotals.values
        .sortedBy { it.currency.currencyCode }
        .map { exchangeRates.convert(it, userCurrency) })
----
// end-insert

In our codebase, the CostSummaryCalculator is the only class that creates or modifies CostSummary objects.
This allows us to remove mutation from the CostSummary class:

// begin-insert: tags/mutations.3:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency, val lines: List<CurrencyConversion>) {
    val total = lines
        .map { it.toMoney }
        .fold(Money.zero(userCurrency), Money::add)
}
----
// end-insert

To be continued...

TODO:

* refactoring loops and mutation to value types and transformations using the stdlib
** Aggregate data into intermediate form, calculate result from intermediate form.

Example of the following design process:

* Transform inputs into outputs.
* If you can't do that easily in one step, transform inputs into an intermediate representation from which it is easy to transform into outputs.
* Can't do _that_ easily in one step? Repeat until you can.


Where does mutation go?

* push mutation outwards towards the entry points
* or inwards and never let mutability escape local variables of a single function (this is an optimisation or when stdlib doesn't have the right HOF)
** a function can be referentially transparent to callers even if its implementation is not.
** In fact, that's how most of the HOFs in the standard library are implemented

