== Refactoring _to_ Data Transformation

Recall the function that calculated the cost of a Route:

// begin-insert: tags/transformations.1:src/main/java/travelator/itinerary/Route.kt#route_cost
[source,kotlin]
----
fun Route.cost(userCurrency: Currency, fx: ExchangeRates): CostSummary {
    val calculator = CostSummaryCalculator(userCurrency, fx)
    for (p in this) {
        calculator.addItem(p)
    }
    return calculator.summarise()
}
----
// end-insert

It uses a mutable object, the CostSummaryCalculator, to compute the cost summary for the journeys in a route, given the traveller's preferred currency and a source of exchange rates.

// begin-insert: tags/transformations.1:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addItem(Priced item) {
        Money price = item.getPrice();
        currencyTotals.merge(price.getCurrency(), price, Money::add);
    }

    public CostSummary summarise() {
        CostSummary summary = new CostSummary(userCurrency);

        for (var total : currencyTotals.values()) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }

        return summary;
    }
}
----
// end-insert

As the Route.cost function adds journeys to the CostSummaryCalculator, the calculator keeps a running total of prices by currency.  When asked for a summary, it converts those totals to the traveller's preferred currency and adds the conversion results to the `CostSummary`.

// begin-insert: tags/transformations.1:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.zero(userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

As the CostSummaryCalculator adds CurrencyConversions to the CostSummary, the CostSummary maintains a running total of the cost in the traveller's preferred currency.




TODO:


* refactoring loops and mutation to value types and transformations using the stdlib
** CostSummary.calculate example
** Aggregate data into intermediate form, calculate result from intermediate form.

Example of the following design process:

* Transform inputs into outputs.
* If you can't do that easily in one step, transform inputs into an intermediate representation from which it is easy to transform into outputs.
* Can't do _that_ easily in one step? Repeat until you can.


Where does mutation go?

* push mutation outwards towards the entry points
* or inwards and never let mutability escape local variables of a single function (this is an optimisation or when stdlib doesn't have the right HOF)
** a function can be referentially transparent to callers even if its implementation is not.
** In fact, that's how most of the HOFs in the standard library are implemented

