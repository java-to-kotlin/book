[[multi-to-single-expression-functions]]
== Multi to Single-Expression Functions

****
Nat and Duncan both love Kotlin's single-expression function definitions.
When should we use this form, why might we prefer it, and what Kotlin features can we use to make more functions single-expressions?
****

As with Java, the code in a Kotlin function is usually {defined inside braces} and use
`return` to define the result of the function, (unless it is `void`/`Unit`).

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#add
[source,kotlin]
----
fun add(a: Int, b: Int): Int {
    return a + b
}
----
// end-insert

If the top-level of the code is a single expression though, we can optionally drop the result type, and define the code with an equals sign `=` and the expression.

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#addToo
[source,kotlin]
----
fun addToo(a: Int, b: Int): Int = a + b
----
// end-insert

This is nice to read - it's saying the result of function `add` equals `a + b`.
Which makes sense for a single-expression, but can also read nicely when that expresion is itself composed of sub-expressions.

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#max
[source,kotlin]
----
fun max(a: Int, b: Int): Int =
    when {
        a > b -> a
        else -> b
    }
----
// end-insert

This form is less suitable for functions that have side effects, especially those that perform IO or write to mutable state.

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#printTwice
[source,kotlin]
----
fun printTwice(s: String): Unit = println("$s\n$s")
----
// end-insert

We can't read this as the result of `printTwice` equals `println(..)` as `println` doesn't have a result, or at least it doesn't return one.
Side effects are the difference between actions and calculations that we explore in <<actions-to-calculations>> - in short, we want as many of our functions to be calculations as we can.

[[single-expresssion-functions-for-calculations]]
[TIP]
.Reserve Single-Expression Functions for Calculations
====
If we adopt a convention of reserving single-expression functions for calculations (<<calculations>>), then we have a way of communicating our intent when we use them.
When we see a single-expression function, we will know that it isn't an action (<<actions>>), and so is much safer to refactor.

In practice this means that single-expression functions shouldn't return Unit, or read or write from mutable state, including IO.
====

Your authors have found that attempting to make as many functions as possible into single expressions improves our software.
For one thing, if we reserve the single-expression form for calculations, then this will decrease the proportion of our code which is <<actions,actions>>, and so make it easier to understand and to modify.
Single-expressions will also tend to be shorter than the alternative, limiting the complexity of each function.
When a function does get too large to be easily understood, single-expression style lets us more easily refactor for clarity, because there is less risk of breaking logic that depends on side effects and the order in which actions are performed.

There is also value in expressions as opposed to statements.
Expressions are _declarative_: we declare what we want the function to calculate and let the Kotlin compiler and runtime decide _how_ to compute that calculation.
We don't have to run the code in a simulated computer in our heads to figure out what the function does.

For example, at the end of <<java-to-kotlin-classes>> we were left with this code for `EmailAddress`:

// begin-insert: tags/multi-to-single-expression-functions.0:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString() = "$localPart@$domain"

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

The `toString` method is already a nice simple single expression.
As we said at the time though, the amount of code required in the `parse` method adds insult to the injury of having to declare static methods in a companion object.
Maybe focusing on making the function into a simple single expression would help?

Before we go on, we should say that lots of the refactoring sequences presented in this book are of the form _here's one I prepared earlier_.
We show you the successful take.
Real life refactorings, like writing code from scratch, aren't like that.
We try things that don't work at all, or we take a much more circuitous route than we show in the final edit.
As this is an otherwise small example, we've taken this opportunity to show what actually happened when we tried to convert `parse` to a single expression.
We think that there are valuable lessons in the journey, but if you just want the destination, you should skip ahead to <<take-4>>.

=== Take 1 - Inlining

Let's analyse the code and see what is preventing this function from being a nice single expression.

// begin-insert: tags/multi-to-single-expression-functions.1:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@') // <1>
    require(!(atIndex < 1 || atIndex == value.length - 1)) { // <2>
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress( // <3>
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

<1> Assigning to `atIndex` is statement.
<2> `require` is a statement.
<3> Creating the `EmailAddress` is a single expression, depending on `value` and `atIndex`.

We have three statements in this function.
If we can whittle it down to just the `return` statement we can convert it to the single expression form.

The first statement is the assignment to `atIndex`.
In Kotlin assignment is a statement, not an expression (unlike Java, where we can chain assignments).
It also matters when we run it - it has to happen here in the code in order for the value of `atIndex` to be available to compile the rest of the function.
The expression `value.lastIndexOf(Char)` is a calculation though - it will always return the same result for the same arguments (`this` is considered an argument when we call methods).
So we could inline `atIndex` to remove the variable:

// begin-insert: tags/multi-to-single-expression-functions.2:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    require(!(
        value.lastIndexOf('@') < 1 ||
            value.lastIndexOf('@') == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, value.lastIndexOf('@')),
        value.substring(value.lastIndexOf('@') + 1)
    )
}
----
// end-insert

This version won't produce the same bytecode, nor run as fast (probably, it's notoriously difficult to second guess HotSpot), but it will return the same result.
It's hard to argue that it's better though, so let's revert the change and try another tack.

=== Take 2 - Introduce a Function

The solution to the time-sensitivity of assignment is to have a scope where `atIndex` is always defined.
A function could be such a scope, as a function binds a single evaluation of its arguments to its parameters.
We can see this by selecting all but the code before the assignment and extracting a function `emailAddress`:

// begin-insert: tags/multi-to-single-expression-functions.3:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return emailAddress(value, atIndex)
}

private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Now we can inline the `atIndex` variable in `parse`, as the `atIndex` parameter has captured its value for us.

// begin-insert: tags/multi-to-single-expression-functions.4:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    return emailAddress(value, value.lastIndexOf('@'))
}

private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Now `parse` is a single expression, but `emailAddress(...)` isn't, so let's not declare victory just yet.
That `require` is always going to cause us some problems, because its job is to prevent evaluation proceeding.
This is the opposite of an expression, which needs to evaluate to a value.

Often when we reach this sort of impasse when refactoring, inlining the cause of the problem will let us see the way ahead.
So we inline `require`.
Suspend disbelief for now, things are going to get worse before they get better.

// begin-insert: tags/multi-to-single-expression-functions.6:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if (!!(atIndex < 1 || atIndex == value.length - 1)) {
        val message = "EmailAddress must be two parts separated by @"
        throw IllegalArgumentException(message.toString())
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

There's an awful lot of redundancy that we can remove there.
Alt-Enter on the `if` condition will remove the double-negation `!!`, then Alt-Enter on the redundant `toString` will remove it.
This allows us to inline `message`, yielding:

// begin-insert: tags/multi-to-single-expression-functions.7:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Now we can introduce an `else` to see the structure:

// begin-insert: tags/multi-to-single-expression-functions.8:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        return EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

At this point we have a function with two statements chosen by an `if`.
This is so tantalisingly close to a single expression that even IntelliJ can feel it - Alt-Enter on the `if`, and the IDE offers to "Lift return out of 'if'":

// begin-insert: tags/multi-to-single-expression-functions.9:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    return if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

There it is - our single expression.
Alt-Enter on the `return` offers "Convert to expression body":

// begin-insert: tags/multi-to-single-expression-functions.10:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress =
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
// end-insert

When we're defining a function as a single expression, `when` is often clearer than `if`.
IntelliJ will do this for us if we Alt-Enter on the `if`.
Here we've also removed unnecessary braces, inlined `message`, and finally converted `parse` to a single expression:

// begin-insert: tags/multi-to-single-expression-functions.11:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String) =
    emailAddress(value, value.lastIndexOf('@'))

private fun emailAddress(value: String, atIndex: Int): EmailAddress =
    when {
        atIndex < 1 || atIndex == value.length - 1 ->
            throw IllegalArgumentException(
                "EmailAddress must be two parts separated by @"
            )
        else -> EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
// end-insert

For comparison, here is the original:

// begin-insert: tags/multi-to-single-expression-functions.12:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Are we happy with the result?

Not really.
We now have _more_ code, and that `emailAddress` function doesn't feel like it's adding any value except for capturing `atIndex`.

Refactoring is sometimes a process of exploration.
We have a goal in mind, but don't always know how it will turn out.
It's our (your authors') experience that trying to find a single expression form of a function often improves our code, but we can't look you in the eye and say that has happened here.

We could give up on the idea, or push on and try to get there from here.
Instead though, let's revert and try a third approach, informed by the experience we've just gained.

=== Take 3 - Let

The reason we extracted the `emailAddress` function was to give us a scope where `atIndex` value is defined throughout the block, rather than having to be assigned to a local variable.
Where we only have one variable we need to replace, a `let` block gives us this facility without having to define a function.
We can get there in baby steps by first surrounding the code after the assignment with a `let`:

// begin-insert: tags/multi-to-single-expression-functions.13:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    atIndex.let {
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        return EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

Note that you can't actually use `let` this way in a top-level function, as it needs a receiver.
In this case, `parse` is a method on our companion object, and the compiler will bind to that for now.

Now we can lift the return out of the `let` - unfortunately IntelliJ doesn't offer to help us this time:

// begin-insert: tags/multi-to-single-expression-functions.14:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return atIndex.let {
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

Currently, `atIndex` in the `let` block refers to the local that we are trying to remove.
If we add a lambda parameter with the same name, it will bind to that instead:

// begin-insert: tags/multi-to-single-expression-functions.15:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return atIndex.let { atIndex -> // <1>
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

<1> `Warning Name shadowed: atIndex` - which is the point.

Inline the `atIndex` variable and we have our single expression:

// begin-insert: tags/multi-to-single-expression-functions.16:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    return value.lastIndexOf('@').let { atIndex ->
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

Now Alt-Enter on the return lets us "Convert to expression body":

// begin-insert: tags/multi-to-single-expression-functions.17:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress =
    value.lastIndexOf('@').let { atIndex ->
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
// end-insert

We've reached the point of no return!
Are we happy with the result?

Duncan is writing this, and he _is_ pretty relieved to have got here after 15 refactoring steps.
The example has certainly served its purpose of showing some tricks to allow us to get to single-expression functions.
Nonetheless, he isn't convinced that it has demonstrated that seeking single expressions has a significant payoff.
This still seems to be a lot of code, and none of it feels like it is earning its keep.

Can we make this better by raising the level of abstraction?
Let's try a fourth tack.

[[take-4]]
=== Take 4 - Stepping Back

If we step out from the mechanical refactorings, we can see that what we are doing is creating an `EmailAddress` from two non-empty strings separated by a particular character, `@` in this case.
Finding two non-empty strings separated by a character sounds like a higher-level concept that we could refactor towards.

One last revert then:

// begin-insert: tags/multi-to-single-expression-functions.18:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

This time we'll concentrate not on `atIndex`, but those `substring` calls.
We'll pull them out into variables:

// begin-insert: tags/multi-to-single-expression-functions.19:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = value.substring(0, atIndex)
    val rightPart = value.substring(atIndex + 1)
    return EmailAddress(
        leftPart,
        rightPart
    )
}
----
// end-insert

Now, one more time with feeling, we can extract a function of all but the return statement:

// begin-insert: tags/multi-to-single-expression-functions.20:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val (leftPart, rightPart) = split(value)
    return EmailAddress(
        leftPart,
        rightPart
    )
}

private fun split(value: String): Pair<String, String> {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = value.substring(0, atIndex)
    val rightPart = value.substring(atIndex + 1)
    return Pair(leftPart, rightPart)
}
----
// end-insert

IntelliJ turns out to be really quite clever there, making the result a `Pair` as it has two values to return.

This `split` would be a nice generic function that we might use in other places if it was parameterised with the character.
"Introduce Parameter" on the `'@'` makes that so.
We "Convert parameter to receiver" on `value` while we're there to get a little local extension function:

// begin-insert: tags/multi-to-single-expression-functions.21:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val (leftPart, rightPart) = value.split('@')
    return EmailAddress(
        leftPart,
        rightPart
    )
}

private fun String.split(divider: Char): Pair<String, String> {
    val atIndex = lastIndexOf(divider)
    require(!(atIndex < 1 || atIndex == length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = substring(0, atIndex)
    val rightPart = substring(atIndex + 1)
    return Pair(leftPart, rightPart)
}
----
// end-insert

Now we can introduce of `let` as we did previously to get:

// begin-insert: tags/multi-to-single-expression-functions.22:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress =
    value.split('@').let { (leftPart, rightPart) ->
        EmailAddress(leftPart, rightPart)
    }
----
// end-insert

This, finally, is a single-expression function that feels worth the effort!

To finish, we can apply the techniques from this chapter to `split` to make it a single-expression.
Here then is the final `EmailAddress.kt`:

// begin-insert: tags/multi-to-single-expression-functions.23:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString() = "$localPart@$domain"

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress =
            value.splitAroundLast('@').let { (leftPart, rightPart) ->
                EmailAddress(leftPart, rightPart)
            }
    }
}

private fun String.splitAroundLast(divider: Char): Pair<String, String> =
    lastIndexOf(divider).let { index ->
        require(index >= 1 && index != length - 1) {
            "string must be two non-empty parts separated by $divider"
        }
        substring(0, index) to substring(index + 1)
    }
----
// end-insert

`splitAroundLast` felt like a better name which doesn't clash with the standard `String.split`, and hints that both sides of the split must be non-empty.
Words like _around_, which are unusual in identifiers, should prompt readers of the code to suspend their assumptions about what a function does and actually look it up.

While `splitAroundLast` does feel like a generally applicable utility function, if we want to promote it to be public we should probably write some unit tests for it.
We've spent enough time for today though, so we'll make a mental note that we have a `String.splitAroundLast` lying around if we ever need one, and finally commit the change.

.What Should Parse Return?
****
Before we leave this example, we should observe that this refactoring would have been easier had `parse` not thrown an exception on error.
`throw` is an expression that returns `Nothing` - it doesn't complete, and so doesn't sit well when we are trying to decompose into expressions.
<<exceptions-to-errors>> talks about this in detail, but had we written `EmailAddress` from scratch in Kotlin we would probably have returned `EmailAddress?` from `parse`, and null on failure.
That doesn't sit well with Java clients, where the type system doesn't warn about nullability.
So we would probably end up with two parsing methods, one for legacy code and one for Kotlin, removing the exception version when there were no Java clients left.
We explore how to support both language's conventions during a gradual conversion from Kotlin to Java in <<functions-to-operators>>.
****

=== Conclusion

Defining our calculations as single-expression functions lets us communicate that they are different to side-effecting actions.
Trying to express functions as a simple single-expressions is a useful discipline that can lead to well factored, clean code.
To achieve single-expression form we usually have to factor out subexpressions into their own functions.

Single-expression form is declarative: the expression describes the function's result in terms of its parameters, rather than the actions that the computer must perform to compute the result.
Our need to factor subexpressions into their own functions prompts us to think about what those subexpressions should be denoting, and so guides us to write code of greater clarity.
For example, `String.splitAroundLast('@')` better described what we wanted to calculate than `emailAddress(value: String, atIndex: Int)`.

At a deeper level, this chapter is not really about single expressions.
It's about how thinking about how we can rearrange our code without changing its behaviour.
Refactoring is the art of finding a better arrangement, and getting there safely.
The more arrangements we can visualise, and the more safe routes we can plan, the more options we have to make our code better.

Many different arrangements will have the same resultSo while you can see that let straight away, I believe that looking at the different arrangements, and working our way painstakingly through different options, has value in showing readers how to invent and implement refactorings.

Refactorings don't always succeed the first, or second, time we try them.
As developers, we don't always have the luxury of repeated attempts, but the more we practice improving our communication in code, the more often we'll get there before we give up.
