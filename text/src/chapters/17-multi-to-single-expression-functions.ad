[[multi-to-single-expression-functions]]
== Multi to Single Expression Functions

Duncan in particular loves Kotlin's single-expression function definitions.
When should we use this form, and what Kotlin features can we use to make more code into a single expression?

As with Java, the code in a Kotlin functions is usually {defined inside braces} and with one or more `return` statements defining the result (unless `void`/`Unit`).

// begin-insert: src/main/kotlin/single_expression_functions/functions.kt#add
[source,kotlin]
----
fun add(a: Int, b: Int): Int {
    return a + b
}
----
// end-insert

If the top level of the code is a single expression though, we can optionally drop the result type, and define the code with an `=` and the expression.

// begin-insert: src/main/kotlin/single_expression_functions/functions.kt#addToo
[source,kotlin]
----
fun addToo(a: Int, b: Int): Int = a + b
----
// end-insert

This is nice to read - it's saying the function `add` equals `a + b`.
Which makes sense for a single expression, but can also read nicely when that expresion is itself composed of sub-expressions.

// begin-insert: src/main/kotlin/single_expression_functions/functions.kt#max
[source,kotlin]
----
fun max(a: Int, b: Int): Int =
    when {
        a > b -> a
        else -> b
    }
----
// end-insert

This form is less suitable for functions that have side effects, especially writing.

// begin-insert: src/main/kotlin/single_expression_functions/functions.kt#printTwice
[source,kotlin]
----
fun printTwice(s: String): Unit = println("$s\n$s")
----
// end-insert

This compiles, but if we adopt a convention of reserving single expression functions for calculations (see <<actions-to-calculations>>), then we have a way of communicating our intent when we use them.

Of course lots of pure calculations consist of more than one top-level expression.
Your authors have found though, that attempting to make as many as possible into simple single expression functions can improve our software.
This is because we end up with more pure functions, and they will have reduced complexity.
As pure functions themselves reduce complexity, this is a double-action complexity reduction.

For example, at the end of <<java-to-kotlin-classes>> we were left with this code for `EmailAddress`:

// begin-insert: tags/multi-to-single-expression-functions.0:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString() = "$localPart@$domain"

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

The `toString` method is already a nice simple single expression.
We said at the time though, that the amount of code required in the `parse` method added insult to the injury of having to declare static methods in a companion object.
Maybe focusing on making it into a simple single expression would help.

Let's analyse the code and see what is preventing this function from being a nice single expression.

// begin-insert: tags/multi-to-single-expression-functions.1:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@') // <2>
    require(!(atIndex < 1 || atIndex == value.length - 1)) { // <3>
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress( // <1>
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

<1> Creating the `EmailAddress` is a single expression, depending on `value` and `atIndex`.
<2> Assigning to `atIndex` is statement.
<3> `require` is a statement.

Even if we use immutable `val` declarations, assigning to variables is an action not a calculation in the scheme we introduce in <<actions-to-calculations>>.
Actions are code that depend on when or whether they are executed.
Assignment is an action because we can't move it later in this function without affecting the behaviour.
In this case the language scoping rules will forbid the move, as `atIndex` is required to compile the later expressions.

The expression `value.lastIndexOf(Char)` is a calculation though - it will always return the same result for the same arguments (`this` is considered an argument when we call methods).
So we could inline `atIndex` to remove the variable:

// begin-insert: tags/multi-to-single-expression-functions.2:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    require(!(
        value.lastIndexOf('@') < 1 ||
            value.lastIndexOf('@') == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, value.lastIndexOf('@')),
        value.substring(value.lastIndexOf('@') + 1)
    )
}
----
// end-insert

This won't produce the same bytecode, nor run as fast (probably, it's notoriously difficult to second guess HotSpot), but it will return the same result.
It's hard to argue that it's better though, so let's revert the change and try another tack.

The solution to the time-sensitivity of assignment is to have a scope where `atIndex` is always defined.
A function could be such a scope, as a function binds a single evaluation of its arguments to its parameters.
We can see this by selecting all but the code before the assignment and extracting a function `emailAddress`:

// begin-insert: tags/multi-to-single-expression-functions.3:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return emailAddress(value, atIndex)
}

private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Now we can inline the `atIndex` variable, as the `atIndex` parameter has captured its value for us.

// begin-insert: tags/multi-to-single-expression-functions.4:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    return emailAddress(value, value.lastIndexOf('@'))
}

private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Now `parse` is a single expression, but `emailAddress(...)` isn't, so let's not declare victory just yet.
That `require` is always going to cause us some problems, as its job is to prevent evaluate proceeding, which is the opposite of an expression, which needs to evaluate to a value.

Often when we reach this sort of impass when refactoring, inlining the cause of the problem will let us see the way ahead.
Irritatingly IntelliJ won't let us inline `require` (despite showing us its source) because it isn't part of our project.
Let's just copy it in to our file (at the time of writing we have to remove some contracts lines):

// begin-insert: tags/multi-to-single-expression-functions.5:src/main/java/travelator/EmailAddress.kt#require
[source,kotlin]
----
inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {
    if (!value) {
        val message = lazyMessage()
        throw IllegalArgumentException(message.toString())
    }
}
----
// end-insert

Now we can inline our local copy.
Suspend disbelief for now, things are going to get worse before they get better:

// begin-insert: tags/multi-to-single-expression-functions.6:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if (!!(atIndex < 1 || atIndex == value.length - 1)) {
        val message = ({
            "EmailAddress must be two parts separated by @"
        })()
        throw IllegalArgumentException(message.toString())
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

There's an awful lot of redundancy that we can remove there.
Alt-Enter on the `toString` will remove it, and another Alt-Enter on the `if` condition will remove the double-negation `!!`.
Then we can short-cut the creation and immediate evaluation of the lambda to get the `message`, yielding:

// begin-insert: tags/multi-to-single-expression-functions.7:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Now we can introduce an `else` to see the structure:

// begin-insert: tags/multi-to-single-expression-functions.8:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        return EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

At this point we have a function with two statements chosen by an `if`.
This is so tantalisingly close to a single expression that even IntelliJ can feel it - Alt-Enter on the `if`, and it offers to "Lift return out of 'if'":

// begin-insert: tags/multi-to-single-expression-functions.9:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    return if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

There it is - our single expression.
Alt-Enter on the `return` offers "Convert to expression body":

// begin-insert: tags/multi-to-single-expression-functions.10:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress =
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
// end-insert

When we're defining a function as a single expression, `when` is often clearer than `if`.
IntelliJ will do this for us if we Alt-Enter on the `if`.
Here we've also removed unnecessary braces, inlined `message`, and finally converted `parse` to a single expression:

// begin-insert: tags/multi-to-single-expression-functions.11:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String) =
    emailAddress(value, value.lastIndexOf('@'))

private fun emailAddress(value: String, atIndex: Int): EmailAddress =
    when {
        atIndex < 1 || atIndex == value.length - 1 ->
            throw IllegalArgumentException(
                "EmailAddress must be two parts separated by @"
            )
        else -> EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
// end-insert

For comparison, here is the original:

// begin-insert: tags/multi-to-single-expression-functions.12:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

Are we happy with the result?

Silence was the stern reply.
We now have _more_ code, and that `emailAddress` function doesn't feel like it's adding any value except for capturing `atIndex`.

Refactoring is sometimes a process of exploration.
We have a goal in mind, but don't always know how it will turn out.
It's our (your authors') experience that trying to find a nice single expression form of a function often improves our code, but we can't look you in the eye and say that has happened here.

We could give up on the idea, or push on and try to get there from here.
Instead though, let's try reverting and trying another tack, informed by the experience we've just gained.

Where we only have one variable we need to replace, a `let` block gives us us a scope where the value is defined rather than having to be assigned to a local - the reason we extracted the function `emailAddress` last time we tried.
We can get there in baby steps by first surrounding the code after the assignment with a `let`:

// begin-insert: tags/multi-to-single-expression-functions.13:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    let {
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        return EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

Now we can lift the return out of the `let` - unfortunately IntelliJ doesn't offer to help us this time:

// begin-insert: tags/multi-to-single-expression-functions.14:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return let {
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

The trick now is to thread the value of `atIndex` through the `let` by making it the receiver and the parameter:

// begin-insert: tags/multi-to-single-expression-functions.15:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return atIndex.let { atIndex -> // <1>
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

<1> `Warning Name shadowed: atIndex` - which is the point.

Inline the `atIndex` variable and we have our single expression:

// begin-insert: tags/multi-to-single-expression-functions.16:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    return value.lastIndexOf('@').let { atIndex ->
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
// end-insert

Now Alt-Enter on the return lets us "Convert to expression body":

// begin-insert: tags/multi-to-single-expression-functions.17:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress =
    value.lastIndexOf('@').let { atIndex ->
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
// end-insert

We've reached the point of no return!
Are we happy with the result?

Duncan is writing this, and he _is_ pretty relieved to have got here after 17 refactoring steps.
The example has certainly served its purpose of showing some tricks to allow us to get to single expression functions.
Nonetheless, he isn't convinced that it has demonstrated that seeking single expressions has a significant payoff.
This still seems to be a lot of code, and none of it feels like it is earning its keep.

Can we make this better by raising the level of abstraction?
Let's try a third tack.

If we step out from the mechanical refactorings, we can see that what we are doing is creating an `EmailAddress` from two non-empty strings separated by a particular character, `@` in this case.
Finding two non-empty strings separated by a character sounds like a higher-level concept that we could refactor towards.

One last revert then:

// begin-insert: tags/multi-to-single-expression-functions.18:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
// end-insert

This time we'll concentrate not on `atIndex`, but those `substring` calls.
We'll pull them out into variables:

// begin-insert: tags/multi-to-single-expression-functions.19:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = value.substring(0, atIndex)
    val rightPart = value.substring(atIndex + 1)
    return EmailAddress(
        leftPart,
        rightPart
    )
}
----
// end-insert

Now, one more time with feeling, we can extract a function of all but the return statement:

// begin-insert: tags/multi-to-single-expression-functions.20:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val (leftPart, rightPart) = split(value)
    return EmailAddress(
        leftPart,
        rightPart
    )
}

private fun split(value: String): Pair<String, String> {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = value.substring(0, atIndex)
    val rightPart = value.substring(atIndex + 1)
    return Pair(leftPart, rightPart)
}
----
// end-insert

IntelliJ turns out to be really quite clever there, making the result a `Pair` as it has two values to return.

This `split` would be a nice generic function that we might use in other places if it was parameterised with the character.
"Introduce Parameter" on the `"@"` makes that so.
We "Convert parameter to receiver" on `value` while we're there to get a little local extension function:

// begin-insert: tags/multi-to-single-expression-functions.21:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val (leftPart, rightPart) = value.split('@')
    return EmailAddress(
        leftPart,
        rightPart
    )
}

private fun String.split(divider: Char): Pair<String, String> {
    val atIndex = lastIndexOf(divider)
    require(!(atIndex < 1 || atIndex == length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = substring(0, atIndex)
    val rightPart = substring(atIndex + 1)
    return Pair(leftPart, rightPart)
}
----
// end-insert

Now we can replay our introduction of `let` in `parse(...)` to get:

// begin-insert: tags/multi-to-single-expression-functions.22:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress =
    value.split('@').let { (leftPart, rightPart) ->
        EmailAddress(leftPart, rightPart)
    }
----
// end-insert

This, finally, is a single expression function that feels worth the effort!

To finish, we can apply the techniques from this chapter to `split` to make it a single expression.
Here then is the final `EmailAddress.kt`:

// begin-insert: tags/multi-to-single-expression-functions.23:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString() = "$localPart@$domain"

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress =
            value.splitAround('@').let { (leftPart, rightPart) ->
                EmailAddress(leftPart, rightPart)
            }
    }
}

private fun String.splitAround(divider: Char): Pair<String, String> =
    lastIndexOf(divider).let { index ->
        require(index >= 1 && index != length - 1) {
            "string must be two parts separated by $divider"
        }
        substring(0, index) to substring(index + 1)
    }
----
// end-insert

`splitAround` felt like a better name with doesn't clash with the standard `String.split`, and hints that both sides of the split must be non-empty.
If we want to promote it to a public function we should probably write some unit tests for it - we've probably sunk enough time for today, so we'll make a mental note that we have a `String.splitAround` lying around if we ever need one, and wrap this refactoring up.

=== Conclusion

Defining our calculations as single expression functions lets us communicate that they are different to side-effecting actions.
Trying to express them as a simple single expression is a useful discipline that can lead to well factored, clean code.


