[[static-methods-to-top-level-functions]]
== Static Methods to Top-Level Functions

Stand-alone functions are one of the fundamental building blocks of software.
In Java, they have to be declared as methods on a class, but in Kotlin we can declare them as top-level entities.
When should we prefer top-level functions, and how do we refactor our way there from Java?

=== Java Statics

All values and functions in a Java program have to belong to a class: they are _members_ of that class.
Java calls member-values _fields_, and member-functions _methods_.
By default, fields values are per-instance of the class: different instances have different values.
Methods are also per-instance, in that they have access to the state of the instance that they are invoked on.
If we mark fields as `static` though, they are shared between all instances of the class.
Static methods only have access to this shared state (and public static fields in other classes), but in return for this restriction we can invoke them without needing an instance of the class.

To simplify the language, the Java designers made the decision to have all code and data tied to classes.
We have class-scoped static state, so we need class-scoped static methods.
They could have added free-standing data and functions, but static fields and methods will do.
If the language had options, then developers would have to choose between them, and less choice is often better.
The designers then carried this language design decision forward to the Java Virtual Machine, which in turn has no way to express top-level code or data.

.Static State
****
In the early days of Java, static state was a lot more prevalent than it is today.
We wrote singletons, and argued about how to initialise them in a lazy but safe way.
We used static fields to implement per-class caches of instances.
Then the new millennium fad for testing code all-but killed static state.
That's because it's very difficult to isolate one test from another when they are coupled by state, and very hard to uncouple them when that state is static and so shared between all tests in a JVM.
(Note that _state_ here refers to mutable data. Immutable data is less of an issue.)

So we learned to keep otherwise-static state in object fields and used dependency injection to arrange for there to be one shared instance of the object in our application.
When we say "dependency injection" here your authors mean "passing an object to a constructor", rather than the use of a framework.

For the rest of this chapter we restrict our examination to static methods rather than fields, but many of the same discussions and techniques also apply to the latter.
****

Sometimes we have a class with both non-static and static methods acting on the same type - static factories are common as we saw in <<java-to-kotlin-classes>>.
Often though we end up with a class of just static methods.
When there is no static state for them to share, these methods are really just stand-alone functions grouped together and called via their class name.
Like the methods from the `java.util.Collections` class for example:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#scopedMax
[source,java]
----
var max = Collections.max(list);
----
// end-insert

Amazingly the industry didn't really notice how much of a pain that `Collections.` prefix was for a while.
This was because we wrote our programs by adding more and more methods to types that we owned, and so rarely needed static functions.
Static functions are useful when want to add functionality _without_ adding a (non-static) method.
This might be because our classes are already sagging under the weight of all the methods that we have already added to them.
It might be because we don't own the class and so can't add the method to it.
Or it might be because the function only applies to some instantiations of a generic type, and so cannot be declared as a member of the generic.
For example, `Collections.max` only applies to a collection with comparable elements.

Over time, we began to appreciate the advantages of using standard interfaces, like the Java collections, instead of working with our own abstractions.
Java 5 (with its generics) was the first release that allowed us to use collections directly, rather than wrapping them with our own classes.
It's no accident then that Java 5 also brought the ability to `import static java.util.Collections.max` so that we could then write:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#importedMax
[source,java]
----
var m = max(list);
----
// end-insert

Because the JVM only supports static methods rather than true top-level functions this is really only  a convenience provided by the compiler.
For the same reason, while Kotlin does have top-level functions, they too are implemented as static methods when running on the JVM.

=== Kotlin Top-Level Functions, Objects and Companion Objects

Kotlin allows functions (and properties and constants) to be declared outside of classes.
In this case the compiler creates a class declaration with static members for the top-level declarations, as the JVM has nowhere else for them to go.
By default, it derives the name of the class from the name of the file defining the functions.
For example, functions defined in `top-level.kt` end up as static methods on a class called `Top_levelKt`.
If we know the name of the class we can reference it from Java, and either static import or directly invoke `Top_levelKt.foo()`.
If we don't like the name `Top_levelKt`, then we can add a `file:JvmName` annotation to the top of the file as we'll see later.

As well as these top-level functions, Kotlin also allows us to define properties and functions scoped to a class like Java.
Instead of just marking these as `static`, Kotlin borrows from Scala and collects them together into `object` declarations.
`object` declarations define singletons - there is only one instance of each type.
All the members of an `object` will be compiled to members of a class with the same name as the object.
They won't actually be static methods unless specifically marked with an `@JvmStatic` though.
This is because Kotlin allows objects to extend other types, and that's incompatible with static declarations.

Where we need to group static and non-static members in the same class, we declare the static parts in a `companion object` inside the (otherwise non-static) class declaration.
This groups them in the file, allows the collection of static methods to implement an interface, and code in a `companion object` is able to access private state in instances of its containing class.
It also makes everything just a bit too cumbersome if we just want to define one or two static methods.

All things being equal, in Kotlin we favour top-level functions over methods on an `object`.
When referenced from Kotlin, top-level declarations can be moved from file to file within a package without affecting client code (but see the caveat in <<moving-top-level-functions>>.
This flexibility is nice, as is the lack of irritating indentation associated with objects.
We will use an `object` instead of top-level functions where we need the ability to implement an interface.
We have no choice but to use a `companion object` when we need to mix static and non-static behaviour within a class.
This happens largely for factory methods, allowing us to write for example `MyType.of(...)`, and also access private constructors.

=== Refactoring From Static Methods to Top-Level Functions

While we prefer to use top-level declarations where possible when writing Kotlin code from scratch, the Java to Kotlin conversion built into IntelliJ doesn't.
It converts our Java statics into object methods.
Let's see how to refactor from Java, through object declarations, to top-level functions.

In <<java-to-kotlin-collections>> we saw how the grain of Java nudges us to write classes that hold static functions to act on collections.
We have similar code in other parts of the application.

// TODO explain what this is used for

// begin-insert: tags/static-to-object-to-functions.0:src/main/java/travelator/Shortlists.java#functions
[source,java]
----
public class Shortlists {
    public static <T> List<T> shortlistOf(Collection<T> items) {
        return List.copyOf(items);
    }

    public static <T> List<T> sorted(List<T> shortlist, Comparator<? super T> ordering) {
        return shortlist.stream().sorted(ordering).collect(toUnmodifiableList());
    }

    public static <T> List<T> removeItemAt(List<T> shortlist, int index) {
        return Stream.concat(
            shortlist.stream().limit(index),
            shortlist.stream().skip(index + 1)
        ).collect(toUnmodifiableList());
    }

    public static Comparator<HasRating> byRating() {
        return comparingDouble(HasRating::getRating).reversed();
    }

    public static Comparator<HasPrice> byPriceLowToHigh() {
        return comparing(HasPrice::getPrice);
    }

    public static <T extends HasPrice & HasRating> Comparator<T> byValue() {
        return comparingDouble((T t) -> t.getRating() / t.getPrice()).reversed();
    }

    ... and other comparators
}
----
// end-insert

Converting this to Kotlin we get:

// begin-insert: tags/static-to-object-to-functions.5:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
object Shortlists {
    @JvmStatic
    fun <T> shortlistOf(items: Collection<T>): List<T> {
        return java.util.List.copyOf(items)
    }

    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return shortlist.stream().sorted(ordering)
            .collect(toUnmodifiableList())
    }

    @JvmStatic
    fun <T> removeItemAt(shortlist: List<T>, index: Int): List<T> {
        return Stream.concat(
            shortlist.stream().limit(index.toLong()),
            shortlist.stream().skip((index + 1).toLong())
        ).collect(toUnmodifiableList())
    }

    @JvmStatic
    fun byRating(): Comparator<HasRating> {
        return comparingDouble(HasRating::rating).reversed()
    }

    @JvmStatic
    fun byPriceLowToHigh(): Comparator<HasPrice> {
        return comparing(HasPrice::price)
    }

    @JvmStatic
    fun <T> byValue(): Comparator<T> where T : HasPrice, T : HasRating {
        return comparingDouble { t: T -> t.rating / t.price }.reversed()
    }

    ... and other comparators
}
----
// end-insert

In <<java-to-kotlin-classes>>, we saw that converting a Java class with static and non-static methods produced a Kotlin class with a companion object.
Here we have no class, just a top-level object.
That's because the Java in this case had no non-static methods, so they don't have to share a namespace with any instances.
Had the conversion instead produced a class with a companion object, that would have been a sign that this is a less suitable candidate for conversion to top-level functions.

We can't just move the functions out of the scope of the object, because they are called from Java, and Java doesn't understand top-level Kotlin functions.
At the moment, due to the `@JvmStatic` annotations, the Java code is seeing them as static methods on a `Shortlists` class.
For example:

// begin-insert: tags/static-to-object-to-functions.5:src/test/java/travelator/ShortlistsTest.java#example_usage
[source,java]
----
var reordered = Shortlists.sorted(items, Shortlists.byValue());
----
// end-insert

The methods of the `Shortlists` class are usually imported statically by the code that uses them, and are named to be read better that way:

// begin-insert: tags/static-to-object-to-functions.5:src/test/java/travelator/ShortlistsTest.java#example_usage_imported
[source,java]
----
var reordered = sorted(items, byPriceLowToHigh());
----
// end-insert

We can't _just_ move the methods out of the scope of the object, but we _can_ move them if we tell the Kotlin compiler that we would like it to host the top-level functions in a class called `Shortlists`.
That's the job of the `file:JvmName` annotation we mentioned earlier.
However, There's no nice automated refactoring here.
We have to manually add the annotation at the top of the file, and remove the `object` scope and `@JvmStatic` annotations to get:

// begin-insert: tags/static-to-object-to-functions.11:src/main/java/travelator/Shortlists.kt#all_functions
[source,kotlin]
----
@file:JvmName("Shortlists")
package travelator

...

fun <T> shortlistOf(items: Collection<T>) =
    java.util.List.copyOf(items)

fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())


fun <T> removeItemAt(shortlist: List<T>, index: Int) =
    Stream.concat(
        shortlist.stream().limit(index.toLong()),
        shortlist.stream().skip((index + 1).toLong())
    ).collect(toUnmodifiableList())

fun byRating() =
    comparingDouble(HasRating::rating).reversed()

fun byPriceLowToHigh() =
    comparing(HasPrice::price)

fun <T> byValue() where T : HasPrice, T : HasRating =
    comparingDouble { t: T -> t.rating / t.price }.reversed()

... and other comparators
----
// end-insert

This keeps our Java happy, but irritatingly breaks Kotlin code that was calling the methods.
This was importing the methods as, for example `import travelator.Shortlists.sorted`, but Kotlin can't see top-level functions that way, even though they are hosted in a JVM class called `Shortlists`.
Ho hum, the fix is to manually change to `import travelator.sorted`, or even remove the import altogether if the calling code is in the same package.
Easy enough if the change affects a few classes, but if the change is wide-ranging, we should -- and can -- make better use of our IDE's refactoring tools.

Let's revert and take another run at it.

=== Take 2

This time, we will _extract_ the bodies of the object methods to top-level functions in the same source file, using the "Extract/Introduce > Function to Scope" item on the "Refactor" menu.

To avoid name clash, we have to -- temporarily -- give the functions a different name to the methods they were extracted from.
So we'll name them after the method but prefixed with an underscore, and name them back when we can remove the object declaration.
While we're about it, we'll also make them public so that code outside this class can call them.

Extracting all the methods to public, top-level functions leaves the code looking like this:

// begin-insert: tags/static-to-object-to-functions.7:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
object Shortlists {
    @JvmStatic
    fun <T> shortlistOf(items: Collection<T>): List<T> {
        return _shortlistOf(items)
    }

    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return _sorted(shortlist, ordering)
    }

    ... etc.
}

fun <T> _shortlistOf(items: Collection<T>) =
    java.util.List.copyOf(items)

fun <T> _sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())

... etc.
----
// end-insert

To make our Kotlin code call the top-level functions instead of the object, we apply the "Inline Function" refactoring to all the object methods, choosing the option "Inline all references and keep the function".

For methods called from Java, IntelliJ shows a dialog telling us that it "Cannot inline reference from Kotlin to Java" and asking if we want to continue.
Yes we do.
We _want_ to leave the Java code unchanged, and will later make it call the top-level functions with the `@file:JvmName` annotation.

This leaves the Java code calling the `Shortlists` object, and the Kotlin code calling the top-level functions.
However, because we prefixed the names of those functions with an underscore, we have changed the Kotlin code from:

// begin-insert: tags/static-to-object-to-functions.7:src/test/java/travelator/hotels/ShortlistScenarioTest.kt#usage
[source,kotlin]
----
val hotelsByPrice = sorted(hotels, byPriceLowToHigh())
----
// end-insert

to:

// begin-insert: tags/static-to-object-to-functions.8:src/test/java/travelator/hotels/ShortlistScenarioTest.kt#usage
[source,kotlin]
----
val hotelsByPrice = _sorted(hotels, _byPriceLowToHigh())
----
// end-insert

Don't worry, this ugliness will be short lived.
We will now rename the top-level functions to remove those underscores so that the functions have the same name as the methods of the `Shortlists` object.
That will allow us to safely switch from object to functions by manually editing the `Shortlists.kt` file to add the `file:JvmName` annotation.

As we do the renames, IntelliJ changes the bodies of the object methods to refer to the functions by fully qualified name, to ensure there is no name clash.

When we're done, we can use the `@file:JvmName` annotation to make the Java code call the top level functions.
This now takes only two small edits in the `Shortlists.kt` file, and no other code changes.
We add the annotation at the top of the file, and insert an underscore at the start of the object's name -- _not_ with a Rename refactoring, but by editing the text.
The JVM class name `Shortlists` refers to the file of top level functions instead of the object declaration.

// begin-insert: tags/static-to-object-to-functions.10:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
@file:JvmName("Shortlists")
package travelator

...

object _Shortlists {
    @JvmStatic
    fun <T> shortlistOf(items: Collection<T>): List<T> {
        return travelator.shortlistOf(items)
    }

    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return travelator.sorted(shortlist, ordering)
    }

    ... etc.
}

fun <T> shortlistOf(items: Collection<T>) =
    java.util.List.copyOf(items)

fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())

... etc.
----
// end-insert

Nothing refers to the `_Shortlists` object any more.
IntelliJ highlights it as unused and we can safely delete it with the "Safe Delete" refactoring, or hitting Alt-Enter on the name of the object.
(Even when I'm sure there are no references, I like to use the "Safe Delete" refactoring for peace of mind).

That leaves us with only the top-level functions we saw earlier.
We can tidy them up a bit more by using the Kotlin standard library instead of the Java Stream and Comparator methods, which removes some lingering warnings our use of platform types, and leaves us with:

// begin-insert: tags/static-to-object-to-functions.12:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
fun <T> shortlistOf(items: Collection<T>) =
    listOf(items)

fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.sortedWith(ordering)

fun <T> removeItemAt(shortlist: List<T>, index: Int) =
    shortlist.take(index) + shortlist.drop(index + 1)

fun byRating() =
    compareByDescending(HasRating::rating)

fun byPriceLowToHigh() =
    compareBy(HasPrice::price)

fun <T> byValue() where T : HasPrice, T : HasRating =
    compareByDescending<T> { it.rating / it.price }

... and other comparators
----
// end-insert

That's a good place to pause and take stock.
We now have top-level functions that we can call from Java and Kotlin.
The `file:JvmName` annotation is harmless, but if we want to remove it we can update our Java classes to refer to `ShortlistsKt` instead of `Shortlists`.
That's also the easiest technique if you're writing new Java code that needs to reference top-level Kotlin functions that you either can't, or can't be bothered, to add the annotation to.

[[moving-top-level-functions]]
.Moving Top-Level Functions
[WARNING]
====
We can move a Kotlin top-level function between files within a package without changing the Kotlin source that calls it.
But, unless we use a `file:@JvmName` annotation to fix things, a move will change the host class file, the name of which is compiled into the client code.
If we publish Kotlin library code in a jar file, all is fine provided we compile against the same version of the library as we run against.

Unfortunately, build systems have to pick one version of each library from the set of versions declared by all dependencies.
This can lead to running code compiled against one library version running against a newer version.
If this happens, and a called top-level function has moved, we can get `NoSuchMethodError` thrown at runtime.
None of our tests or example code will have had to change to warn us about the breakage - we just have to take extra care if we move top-level functions published in a library.

// TODO discuss the @JvmMultifileClass annotation here
====

=== Conclusion

Static functions are the bread and butter of our programs.
In Java these have to be static methods on a class, but in Kotlin we can and should default to defining them as top-level functions.
Converting a Java class of static methods to Kotlin will, however, create an `object` declaration.
This can be converted to top level functions by a sequence of safe refactoring steps that does not affect the code that uses the object and minimises manual editing.


// TODO talk about refactoring to reduce the amount of editing to the bare minimum

// TODO talk about taking multiple runs at a refactoring, and link to <<multi-to-single-expression-functions>> for deeper discussion.

// TODO talk about refactoring making it worse to allow it to get better -- trough of disillusionment

Some of the top-level functions we ended up with are good candidates to refactor to _extension functions_.
Extension functions can make our Kotlin code more concise, and are easier to discover with autocomplete.
We discuss extension functions in more detail in <<functions-to-extension-functions>>.
