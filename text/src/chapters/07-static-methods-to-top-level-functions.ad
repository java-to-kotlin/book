[[static-methods-to-top-level-functions]]
== Static Methods to Top-Level Functions

Stand-alone functions are one of the fundamental building blocks of software.
In Java, they have to be declared as methods on a class, but in Kotlin we can declare them as top-level entities.
When should we prefer top-level functions, and how do we refactor our way there from Java?

=== Java Statics

// TODO We don't need to explain classes, objects and statics to our readers.  Rewrite to explain differences between Java and Kotlin and how the compiler targets the JVM.

All values and functions in a Java program have to belong to a class: they are _members_ of that class.
Java calls member-values _fields_, and member-functions _methods_.
By default, fields values are per-instance of the class: different instances have different values.
Methods are also per-instance, in that they have access to the state of the instance that they are invoked on.
If we mark fields as `static` though, they are shared between all instances of the class.
Static methods only have access to this shared state (and public static fields in other classes), but in return for this restriction we can invoke them without needing an instance of the class.

To simplify the language, the Java designers made the decision to have all code and data tied to classes.
We have class-scoped static state, so we need class-scoped static methods.
They could have added free-standing data and functions, but static fields and methods will do.
If the language had options, then developers would have to choose between them, and less choice is often better.
The designers then carried this language design decision forward to the Java Virtual Machine, which in turn has no way to express top-level code or data.

.Static State
****
In the early days of Java, static state was a lot more common than it is today.
We wrote singletons, and argued about how to initialise them in a lazy but safe way.
We used static fields to implement per-class caches of instances.
Then the new millennium fad for testing code all-but killed static state.
That's because it's very difficult to isolate one test from another when they are coupled by state, and very hard to uncouple them when that state is static and so shared between all tests in a JVM.
(Note that _state_ here refers to mutable data. Immutable data -- constants -- are less of an problem.)

So we learned to keep otherwise-static state in object fields and used dependency injection to arrange for there to be one shared instance of the object in our application.
When we say "dependency injection" here your authors mean "passing an object to a constructor", rather than the use of a framework.

For the rest of this chapter we restrict our examination to static methods rather than fields, but many of the same discussions and techniques also apply to the latter.
****

Sometimes we have a class with both non-static and static methods acting on the same type - static factories are common as we saw in <<java-to-kotlin-classes>>.
Often though we end up with a class of just static methods.
When there is no static state for them to share, these methods are really just stand-alone functions grouped together and called via their class name.
Like the methods from the `java.util.Collections` class for example:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#scopedMax
[source,java]
----
var max = Collections.max(list);
----
// end-insert

Amazingly the industry didn't really notice how much of a pain that `Collections.` prefix was for a while.
This was because we wrote our programs by adding more and more methods to types that we owned, and so rarely needed static functions.
Static functions are useful when want to add functionality _without_ adding a (non-static) method.
This might be because our classes are already sagging under the weight of all the methods that we have already added to them.
It might be because we don't own the class and so can't add the method to it.
Or it might be because the function only applies to some instantiations of a generic type, and so cannot be declared as a member of the generic.
For example, `Collections.max` only applies to a collection with comparable elements.

Over time, we began to appreciate the advantages of using standard interfaces, like the Java collections, instead of working with our own abstractions.
Java 5 (with its generics) was the first release that allowed us to use collections directly, rather than wrapping them with our own classes.
It's no accident then that Java 5 also brought the ability to `import static java.util.Collections.max` so that we could then write:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#importedMax
[source,java]
----
var m = max(list);
----
// end-insert

Because the JVM only supports static methods rather than true top-level functions this is really only  a convenience provided by the compiler.
For the same reason, while Kotlin does have top-level functions, they too are implemented as static methods of classes when running on the JVM.

=== Kotlin Top-Level Functions, Objects and Companion Objects

Kotlin allows functions (and properties and constants) to be declared outside of classes.
In this case, because the JVM has nowhere else for them to go, the compiler generates a class with static members for the top-level declarations.
By default, it derives the name of the class from the name of the file defining the functions.
For example, functions defined in `top-level.kt` end up as static methods on a class called `Top_levelKt`.
If we know the name of the class we can reference it from Java, and either static import or directly invoke `Top_levelKt.foo()`.
If we don't like the name `Top_levelKt`, we can explicitly name the generated class by adding a `file:JvmName` annotation to the top of the file, as we'll see later.

As well as these top-level functions, Kotlin also allows us to define properties and functions scoped to a class like Java.
Instead of just marking these as `static`, Kotlin borrows from Scala and collects them together into `object` declarations.
An `object` declaration define a singleton - there is only one instance of each type.
All the members of an `object` will be compiled to members of a class with the name of the object.
They won't actually be static methods unless specifically marked with an `@JvmStatic` though.
This is because Kotlin allows objects to extend other types, and that's incompatible with static declarations.

Where we need to group static and non-static members in the same class, we declare the static parts in a `companion object` inside the (otherwise non-static) class declaration.
This groups them in the file, allows the collection of static methods to implement an interface, and code in a `companion object` is able to access private state in instances of its containing class.
It also makes everything just a bit too cumbersome if we just want to define one or two static methods.

All things being equal, in Kotlin we favour top-level functions over methods on an `object`.
When referenced from Kotlin, top-level declarations can be moved from file to file within a package without affecting client code (but see the caveat in <<moving-top-level-functions>>.
We use an `object` instead of top-level functions where we need the ability to implement an interface.
We have no choice but to use a `companion object` when we need to mix static and non-static behaviour within a class.
This happens largely for factory methods, allowing us to write for example `MyType.of(...)`, and allow the methods of the companion object to access private features of the class.

=== Refactoring From Static Methods to Top-Level Functions

While we prefer to use top-level declarations where possible when writing Kotlin code from scratch, the Java to Kotlin conversion built into IntelliJ doesn't.
It converts our Java statics into object methods.
Let's see how to refactor from Java, through object declarations, to top-level functions.

Here's an example from Travelator for manipulating shortlists.
Our users may build a shortlist of hotel rooms when searching for accomodation, or a shortlist of routes when planning their trip.
The user can rank items in a shortlist by different criteria and discarded items to narrow down the results to a final choice.
A shortlist is stored as an immutable list, and the functions for manipulating a shortlist are implemented as static methods of the `Shortlists` class.

// begin-insert: tags/static-to-object-to-functions.0:src/main/java/travelator/Shortlists.java#functions
[source,java]
----
public class Shortlists {
    public static <T> List<T> sorted(
        List<T> shortlist,
        Comparator<? super T> ordering
    ) {
        return shortlist.stream()
            .sorted(ordering)
            .collect(toUnmodifiableList());
    }

    public static <T> List<T> removeItemAt(List<T> shortlist, int index) {
        return Stream.concat(
            shortlist.stream().limit(index),
            shortlist.stream().skip(index + 1)
        ).collect(toUnmodifiableList());
    }

    public static Comparator<HasRating> byRating() {
        return comparingDouble(HasRating::getRating).reversed();
    }

    public static Comparator<HasPrice> byPriceLowToHigh() {
        return comparing(HasPrice::getPrice);
    }

    ... and other comparators
}
----
// end-insert

Converting this to Kotlin we get:

// begin-insert: tags/static-to-object-to-functions.5:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
object Shortlists {
    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return shortlist.stream().sorted(ordering)
            .collect(toUnmodifiableList())
    }

    @JvmStatic
    fun <T> removeItemAt(shortlist: List<T>, index: Int): List<T> {
        return Stream.concat(
            shortlist.stream().limit(index.toLong()),
            shortlist.stream().skip((index + 1).toLong())
        ).collect(toUnmodifiableList())
    }

    @JvmStatic
    fun byRating(): Comparator<HasRating> {
        return comparingDouble(HasRating::rating).reversed()
    }

    @JvmStatic
    fun byPriceLowToHigh(): Comparator<HasPrice> {
        return comparing(HasPrice::price)
    }

    ... and other comparators
}
----
// end-insert

In <<java-to-kotlin-classes>>, we saw that converting a Java class with static and non-static methods produced a Kotlin class with a companion object.
Here we have no class, just a top-level object.
That's because in this case the Java had no non-static methods, so they don't have to share a namespace with any instance methods.
Had the conversion instead produced a class with a companion object, that would have been a sign that this is a less suitable candidate for conversion to top-level functions.

We can't just move the functions out of the scope of the object, because they are called from Java, and Java doesn't understand top-level Kotlin functions.
At the moment, due to the `@JvmStatic` annotations, the Java code is seeing them as static methods on a `Shortlists` class.
For example:

// begin-insert: tags/static-to-object-to-functions.5:src/test/java/travelator/ShortlistsTest.java#example_usage
[source,java]
----
var reordered = Shortlists.sorted(items, Shortlists.byValue());
----
// end-insert

The methods of the `Shortlists` class are usually imported statically by the code that uses them, and are named to read better that way:

// begin-insert: tags/static-to-object-to-functions.5:src/test/java/travelator/ShortlistsTest.java#example_usage_imported
[source,java]
----
var reordered = sorted(items, byPriceLowToHigh());
----
// end-insert

We can't _just_ move the methods out of the scope of the object, but we _can_ move them if we tell the Kotlin compiler that we would like it to host the top-level functions in a class called `Shortlists`.
That's the job of the `file:JvmName` annotation we mentioned earlier.
However, There's no nice automated refactoring that can transform an object to a file of top-level functions that will appear the same to Java code.

We can manually add the annotation at the top of the file, and remove the `object` scope and `@JvmStatic` annotations to get:

// begin-insert: tags/static-to-object-to-functions.11:src/main/java/travelator/Shortlists.kt#all_functions
[source,kotlin]
----
@file:JvmName("Shortlists")
package travelator

...

fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())


fun <T> removeItemAt(shortlist: List<T>, index: Int) =
    Stream.concat(
        shortlist.stream().limit(index.toLong()),
        shortlist.stream().skip((index + 1).toLong())
    ).collect(toUnmodifiableList())

fun byRating() =
    comparingDouble(HasRating::rating).reversed()

fun byPriceLowToHigh() =
    comparing(HasPrice::price)

fun <T> byValue() where T : HasPrice, T : HasRating =
    comparingDouble { t: T -> t.rating / t.price }.reversed()

... and other comparators
----
// end-insert


This keeps our Java happy, but irritatingly breaks any Kotlin code that was calling the methods.
This was importing the methods as, for example `import travelator.Shortlists.sorted`, but Kotlin can't see top-level functions that way, even though they are hosted in a JVM class called `Shortlists`.
Ho hum, the fix is to manually change to `import travelator.sorted`, or even remove the import altogether if the calling code is in the same package.
Easy enough if the change affects a few classes, but if the change is wide-ranging, we should -- and can -- make better use of our IDE's refactoring tools.

// TODO: talk more about trade-offs between text edits and automatic refactoring

Let's revert and take another run at it.

=== Take 2: Refactoring Steps That Minimise Text Edits

This time we'll do as much as we can with our IDE's automatic refactoring to keep the amount of text editing we need to do to an absolute minimum.
We will _extract_ top-level functions from the object's methods, _inline_ the object methods into the Kotlin code to make it call those top level functions, and finally use the @file:JvmName annotation to make the Java code call the top-level functions as well.

We extract the bodies of the object methods to top-level functions in the same source file by using the "Extract/Introduce > Function to Scope" refactoring.
To avoid name clash, we have to -- temporarily -- give the functions a different name to the methods they were extracted from.
So we'll name them after the method but prefixed with an underscore, and name them back when we can remove the object declaration.
While we're about it, we'll also make them public so that code outside this class can call them.

Extracting all the methods to public, top-level functions leaves the code looking like this:

// begin-insert: tags/static-to-object-to-functions.7:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
object Shortlists {
    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return _sorted(shortlist, ordering)
    }

    ... etc.
}

fun <T> _sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())

... etc.
----
// end-insert

To make our Kotlin code call the top-level functions instead of the object, we apply the "Inline Function" refactoring to all the object methods, choosing the option "Inline all references and keep the function".

For methods called from Java, IntelliJ shows a dialog telling us that it "Cannot inline reference from Kotlin to Java" and asking if we want to continue.
Yes we do.
We _want_ to leave the Java code unchanged, and will later make it call the top-level functions with the `@file:JvmName` annotation.

This leaves the Java code calling the `Shortlists` object, and the Kotlin code calling the top-level functions.
However, because we prefixed the names of those functions with an underscore, we have changed the Kotlin code from:

// begin-insert: tags/static-to-object-to-functions.7:src/test/java/travelator/hotels/ShortlistScenarioTest.kt#usage
[source,kotlin]
----
val hotelsByPrice = sorted(hotels, byPriceLowToHigh())
----
// end-insert

to:

// begin-insert: tags/static-to-object-to-functions.8:src/test/java/travelator/hotels/ShortlistScenarioTest.kt#usage
[source,kotlin]
----
val hotelsByPrice = _sorted(hotels, _byPriceLowToHigh())
----
// end-insert

Don't worry, this ugliness will be short lived.
We will now rename the top-level functions to remove those underscores so that the functions have the same name as the methods of the `Shortlists` object.
That will allow us to safely switch from object to functions by manually editing the `Shortlists.kt` file to add the `file:JvmName` annotation.

As we do the renames, IntelliJ changes the bodies of the object methods to refer to the functions by fully qualified name, to ensure there is no name clash.

// begin-insert: tags/static-to-object-to-functions.9:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
package travelator

... imports

object Shortlists {
    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return travelator.sorted(shortlist, ordering)
    }

    ... etc.
}

fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())

... etc.
----
// end-insert

When we're done, we can use the `@file:JvmName` annotation to make the Java code call the top level functions.
This now takes only two small edits in the `Shortlists.kt` file, and no other code changes.
We add the annotation at the top of the file, and insert an underscore at the start of the object's name -- _not_ with a Rename refactoring, but by editing the text.
The JVM class name `Shortlists` refers to the file of top level functions instead of the object declaration.

// begin-insert: tags/static-to-object-to-functions.10:src/main/java/travelator/Shortlists.kt#switch
[source,kotlin]
----
@file:JvmName("Shortlists")
package travelator

...

object _Shortlists {
    ...
}

...
----
// end-insert

Nothing refers to the `_Shortlists` object any more.
IntelliJ highlights it as unused and we can safely remove it with the "Safe Delete" refactoring, or hitting Alt-Enter on the name of the object.
(Even when I'm sure there are no references, I like to use the "Safe Delete" refactoring for peace of mind).

That leaves us with only the top-level functions we saw earlier.
We can tidy them up a bit more by using the Kotlin standard library instead of the Java Stream and Comparator methods, which removes some lingering warnings about our use of platform types, and leaves us with:

// begin-insert: tags/static-to-object-to-functions.12:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.sortedWith(ordering)

fun <T> removeItemAt(shortlist: List<T>, index: Int) =
    shortlist.take(index) + shortlist.drop(index + 1)

fun byRating() =
    compareByDescending(HasRating::rating)

fun byPriceLowToHigh() =
    compareBy(HasPrice::price)

... and other comparators
----
// end-insert

That's a good place to pause and take stock.
We now have top-level functions that we can call from Java and Kotlin.
The `file:JvmName` annotation is harmless, but if we want to remove it we can update our Java classes to refer to `ShortlistsKt` instead of `Shortlists`.
That's also the easiest technique if you're writing new Java code that needs to reference top-level Kotlin functions that you either can't, or can't be bothered, to add the annotation to.

[[moving-top-level-functions]]
.Moving Top-Level Functions
[WARNING]
====
We can move a Kotlin top-level function between files within a package without changing the Kotlin source that calls it.
However, in the compiled output that function will now be defined as a static method of a different JVM class.

If we publish Kotlin library code in a JAR file, all is fine provided dependent code is recompiled against the new version.
The Kotlin compiler generates classfiles with metadata sections that let it map Kotlin names to JVM classes and methods.
All may _not_ be fine if dependent code uses our JAR as a binary dependency, and upgrades without recompiling.
The JVM doesn't use the metadata that the Kotlin compiler generated.
If a top-level function has moved from one class to another between versions of a binary dependency, dependent code can get `NoSuchMethodError` thrown at runtime.

We can use the `@JvmMultifileClass` and `@JvmName` annotations to control how our top-level declarations appear in JVM classfiles, so that moving declarations between source files won't break binary compatibility.
However, non of our Kotlin test or example code will have changed, so we can't rely on them to warn is about this kind of breakage.
We just have to take extra care if we move top-level functions published in a library.
====

=== Conclusion

Static functions are the bread and butter of our programs.
In Java these have to be static methods on a class, but in Kotlin we can and should default to defining them as top-level functions.
Converting a Java class of static methods to Kotlin will, however, create an `object` declaration.
We have to refactor that object into top-level functions.

As we described in <<minimise-text-edits>>, refactoring by editing text is tedious and error prone.
We prefer to use the IDE's refactoring tools whenever we can.
However, IntelliJ does not have an automatic refactoring that can transform an object to top-level functions.
Therefore, we used a combination of automatic refactorings -- extract, inline and rename -- to transform the code to a state that let us swap out the object for the top-level functions with the absolute minimum of manual text editing,
and then further automatic refactorings to tidy up the code.

A counterintuitive aspect of the refactoring steps we took in this chapter was that we had to make the code worse before we could make it better.
Extracting top-level functions from the `Shortlist` object's method made the code in `Shortlists.kt` more complicated.
Inlining the object's methods into out Kotlin code made their awkward temporary names visible across our codebase.
Subsequent steps tidied everything up to an implementation that was simpler than where we started.
This is quite common when refactoring.
We have to break down existing structures in order to introduce better ones, which is fine as long as we don't stop half way through.

It took us a couple of attempts to find the right sequence of refactorings.
This is par for the course -- design is an exploratory and iterative process, especially in an unfamiliar language.
We will see this again in <<multi-to-single-expression-functions>>.

Some of the top-level functions we ended up with are good candidates to refactor to _extension functions_.
Extension functions can make our Kotlin code more concise, and are easier to discover with autocomplete.
We discuss extension functions in more detail in <<functions-to-extension-functions>>.
