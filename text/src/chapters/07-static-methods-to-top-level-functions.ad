[[static-methods-to-top-level-functions]]
== Static Methods to Top Level Functions

Static functions are one of the fundamental building blocks of software.
In Java, they have to be declared as methods on a class, but in Kotlin we can declare them as top-level entities.
When should we prefer this form, and how do we migrate from the Java to the Kotlin style?

=== Java Statics

All values and functions in a Java program have to belong to a class: they are _members_ of that class.
Java calls member-values _fields_, and member-functions _methods_.
By default, fields values are per-instance of the class, and methods are also per-instance, in that they have access to the state of the instance that they are invoked on.
If we mark fields as `static` though, they are shared between all instances of the class.
Static methods only have access to this shared state (and public static fields in other classes), but in return for this restriction we can invoke them without needing an instance of the class.

The language designers made the decision to have all code and data tied to classes to simplify the language.
We have class-scoped static state, so we need class-scoped static methods.
They could have added free-standing data and functions, but static fields and methods will do.
If the language had options, then developers would have to choose which to use when, and less choice is often better.
The designers then logically carried this language design decision forward to the Java Virtual Machine, which in turn has no way to express free-standing code or data.

.Static State
****
In the early days of Java, static state was a lot more prevalent than it is today.
We wrote singletons, and argued about how to initialise them in a lazy but safe way.
We used static fields to implement per-class caches of instances.
Then the new millennium fad for testing code all-but killed static state.
That's because it's very difficult to isolate one test from another when they are coupled by state, and very hard to uncouple them when that state is static and so shared between all tests in a JVM.
(Note that state here refers to mutable data. Immutable data is less of an issue.)

As a result we learned to keep otherwise-static state in object fields and to arrange for there to be one shared instance of the object in application scope with dependency injection.
By which your authors mean "passing an object to a constructor", rather than "Spring".

For the rest of this chapter we restrict our examination to static methods rather than fields, but many of the same discussions and techniques also apply to the latter.
****

Sometimes we have a class with both non-static and static methods acting on the same type.
Often though we end up with a class of just static methods.
When there is no static state for them to share, these methods are really just stand-alone functions grouped together and called via their class name:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#scopedMax
[source,java]
----
var max = Collections.max(list);
----
// end-insert

Amazingly the industry didn't really notice how much of a pain that `Collections.` prefix was for a while.
This was because we wrote our programs by adding more and more methods to types that we owned, and so rarely needed static functions.
Static functions are useful when want to add functionality _without_ adding a (non-static) method.
This might be because our classes are already sagging under the weight of all the methods that we have already added to them, or it might be because we don't own the class and so can't add the method to it.

Over time, we began to appreciate the advantages of using standard interfaces, like the Java collections, instead of working with our own abstractions.
It's no accident then that the Java release that allowed us to use collections this way, Java 5, also brought the ability to `import static java.util.Collections.max` so that we could then write:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#importedMax
[source,java]
----
var m = max(list);
----
// end-insert

Because the JVM only really supports static methods rather than true top-level functions this is only really a convenience provided by the compiler.
And while Kotlin does have top-level functions, they too will have to be implemented as methods when running on the JVM.

=== Kotlin Top-Level Functions and Companion Objects

Kotlin allows functions (and properties and constants) to be declared outside of classes.
In this case the compiler creates a class declaration with static members for the top-level declarations, as the JVM has nowhere else for them to go.
By default, the name of the class is derived from the name of the file defining the functions.
For example, functions defined in `top-level.kt` end up as static methods on a class called `Top_levelKt`.
If you know the name of the class you can reference it from Java, and either import or directly invoke `Top_levelKt.foo()`.
Don't like the name `Top_leveKt`?
Then you can add a `file:JvmName` annotation to the top of the file as we'll see later.

As well as top-level functions Kotlin also allows us to define properties and functions scoped to a class.
Instead of just marking these as `static` like Java, Kotlin borrows from Scala and collects them together into a companion object.
This groups them together, allows the collection of static methods to implement an interface, and makes everything a bit more cumbersome if we just want to define one or two static methods.

In general then, we favour top-level functions in Kotlin.
When referenced from Kotlin, they can be moved from file to file within a package without affecting client code.
This flexibility is nice, as is the lack of irritating indentation and syntax associated with companion objects.
The main exception is where we need to keep compatibility with Java, in particular as we are migrating part of a system.
Another reason to use companion object methods is that they have access to the private state of instances of their class.
As we use private state a lot less in Kotlin (immutable objects have less reason to hide their implementation) this is rarely useful.
The final main use for companion objects is for factory methods, allowing us to write for example `MyType.of(...)`.

Top-level functions then should be our default in Kotlin.
Let's look at migrating some utilities defined as static Java methods to top-level Kotlin functions.

=== Migrating From Static Methods to Top-Level Functions

In <<java-to-kotlin-collections>> we saw a typical collection of static functions acting on collections.

// begin-insert: tags/java-to-kotlin-collections.7:src/main/java/travelator/Suffering.java
[source,java]
----
public class Suffering {

    public static int sufferScoreFor(List<Journey> route) {
        return sufferScore(
            longestJourneysIn(route, 3),
            getDepartsFrom(route));
    }

    static List<Journey> longestJourneysIn(List<Journey> journeys, int limit) {
        var actualLimit = Math.min(journeys.size(), limit);
        return sorted(journeys, comparing(Journey::getDuration).reversed())
            .subList(0, actualLimit);
    }

    public static List<List<Journey>> routesToShowFor(String itineraryId) {
        return bearable(routesFor(itineraryId));
    }

    private static List<List<Journey>> bearable(List<List<Journey>> routes) {
        return routes.stream()
            .filter(route -> sufferScoreFor(route) <= 10)
            .collect(toUnmodifiableList());
    }
}
----
// end-insert

Converting this to Kotlin we ended up with:

// begin-insert: tags/java-to-kotlin-collections.11:src/main/java/travelator/Suffering.kt
[source,kotlin]
----
object Suffering {
    @JvmStatic
    fun sufferScoreFor(route: List<Journey>): Int {
        return sufferScore(
            route.longestJourneys(3),
            Routes.getDepartsFrom(route)
        )
    }

    @JvmStatic
    fun List<Journey>.longestJourneys(limit: Int): List<Journey> =
        sortedByDescending { it.duration }.take(limit)

    @JvmStatic
    fun routesToShowFor(itineraryId: String): List<List<Journey>> {
        return bearable(routesFor(itineraryId))
    }

    private fun bearable(routes: List<List<Journey>>): List<List<Journey>> = routes
        .filter { sufferScoreFor(it) <= 10 }
}
----
// end-insert

In <<java-to-kotlin-classes>> we saw that converting a Java class with a static method produced a Kotlin class with a companion object.
Here we have no class, just a top-level object.
That's because the Java in this case had no non-static methods, so we don't have to share a namespace with any instances.
This is how we know that this is a good candidate for conversion to top-level functions.




Distinguish between factories etc which might stay on companion objects and others to move to top level.





Move to top level with @JvmName
Can remove @JvmName when there are no Java usages.

=== Conclusion

Related content <<java-to-kotlin-collections>>, <<encapsulated-collections-to-typealiases>>, <<functions-to-extension-functions>>.
