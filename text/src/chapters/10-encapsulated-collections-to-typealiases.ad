[[encapsulated-collections-to-typealiases]]
== Encapsulated Collections to Type Aliases

As we saw in <<java-to-kotlin-collections>>, the grain of Java and Kotlin are very different when it comes to collections.
Java's collection interfaces, in keeping with its object-oriented roots, are fundamentally mutable.
As a result, the fear of aliasing errors leads us to encapsulate those mutable collections within classes.
If we want value semantics, we encapsulate collections to prevent the collection being mutated.
If the class is mutable, we encapsulate collections to ensure that the class can maintain its state invariants, or always fires notifications when it changes state.

When we encapsulate a collection in a class, that class starts to "attract" behaviour.
We add operations to the class to process the data in the collection.
However, by doing this we _reduce_ the operations available for us to work with the data to only those defined by the encapsulating class.
Whenever we want to process that data in a new way, we have to add new operations to the class.
It's easy for encapsulation to end up _increasing_ the coupling between different parts of our application.

In contrast, immutable collections do not require encapsulation.
We don't need to ensure that state changes always go through the class's interface because there are no state changes.
If we make our domain model _be_ the appropriate data structure, rather than encapsulate and hide it behind a class boundary, we _extend_ the operations available for us to work with the data.
We have all the operations defined for the collection and the operations we have defined for our application.

=== A Class That Encapsulates a Collection

One of the core services of our Travelator application is route planning.

A route is a sequence of journeys that can take the traveller from one location to another.
Each journey in a route is a service provided by an operator, via some mode of transport -- ship, train, bus, camel, etc. -- departing from one location at a specific time and arriving at another location some time later.
Our routing service finds several possible routes, and our travellers can compare them by cost, duration, and so on, to choose the route they prefer.

The journeys along a route do not always have a convenient interchange between them.
Some services run only once a day, or once a week, so our travellers want to know when they will have to book somewhere to stay between the end of one journey and the start of the next.
This will let us improve the cost estimate for a route, because we can suggest places to stay and include the cost in the overall cost of the route.
We can make the feature earn its keep by booking their preferred choices and earning a commission.

Fundamental to this feature is the ability to find every interchange in a Route where the traveller will need to find somewhere to stay.
Currently, our Route class does not have that capability.
How best to add it?

Let's take a look at our Java Route class.

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys; // <1>

    public Route(List<Journey> journeys) {
        this.journeys = journeys; // <2>
    }

    public int size() { // <3>
        return journeys.size();
    }

    public Journey get(int index) { // <3>
        return journeys.get(index);
    }

    public Location getDepartsFrom() { // <4>
        return get(0).getDepartsFrom();
    }

    public Location getArrivesAt() { // <4>
        return get(size() - 1).getArrivesAt();
    }

    public Duration getDuration() { // <4>
        return Duration.between(
            get(0).getDepartureTime(),
            get(size() - 1).getArrivalTime());
    }

    ...
}
----
// end-insert

<1> A Route encapsulates a List of Journeys.
<2> To fully encapsulate the list, the constructor should take a defensive copy of the `journeys` parameter.
    However, we know that our system only creates Route objects in the JSON deserialiser or in tests, neither of which holds onto the list of journeys after creating the Route that uses it.
     There is, therefore, no risk of https://martinfowler.com/bliki/AliasingBug.html[_aliasing errors_], and we can save the cost of a copy whenever we create a Route.
<3> Because Lists are mutable -- or, at least, the type system offers no guarantee that the List is _not_ mutable -- the `Route` class does not expose the `journeys` list to code using `Route` objects.
    Instead it provides accessors for getting the size and individual elements by index.
    This is used in the front-end code that displays the route to the user.
<4> The `Route` class implements application logic that uses the contents of the encapsulated list.
    We will add another operation to report any accommodation required along the route.

To calculate the interchanges that require a stay, we will map every two contiguous Journeys in the Route to an Interchange between the end of the first journey and the start of the second, and filter the Interchanges to select only those that require one or more overnight stays.

In Java, neither the collection nor stream API provides an operation to return all the contiguous pairs of a collection.
If we wrote this logic in Java we would have to implement it imperatively, with a for loop and mutable list, like this:

[[required-stays-imperative]]
// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#imperative_algorithm
[source,java]
----
public List<Interchange> requiredAccommodation() {
    var results = new ArrayList<Interchange>();

    for (int i = 1; i < journeys.size(); i++) {
        var interchange =
            Interchange.between(journeys.get(i - 1), journeys.get(i));

        if (interchange.isAccommodationRequired()) {
            results.add(interchange);
        }
    }

    return results;
}
----
// end-insert

In Kotlin, the standard library provides operations on List that do exactly what we want.
We can write the logic as a concise pipeline of transformations where each phase in the pipeline corresponds to a step in our description of the logic, above.

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#declarative_algorithm
[source,kotlin]
----
fun requiredAccommodation() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isAccommodationRequired }
----
// end-insert

This lets us focus on our application's domain model and business rules, relying on the authors of the standard library functions to handle the edge cases and avoid fence-post errors.

First, we have to convert the Route class to Kotlin.
Here's the class after IntelliJ has worked its translation magic:

// begin-insert: tags/collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) {
    fun size(): Int {
        return journeys.size
    }

    operator fun get(index: Int): Journey {
        return journeys[index]
    }

    val departsFrom: Location
        get() = get(0).departsFrom

    val arrivesAt: Location
        get() = get(size() - 1).arrivesAt

    val duration: Duration
        get() = Duration.between(
            get(0).departureTime,
            get(size() - 1).arrivalTime
        )

    ...
}
----
// end-insert

Note that IntelliJ has helpfully translated the Java `get` method to an operator method, allowing Kotlin code to get elements with the more concise indexing syntax.
We can apply some automatic fixes to make the code even more concise and conventional Kotlin.

In Kotlin, collections usually report their size as a read-only property, not a method:

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#size_property
[source,kotlin]
----
val size
    get() = journeys.size
----
// end-insert

The get method with block syntax can be transformed to single-expression syntax.

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#get_single_expression
[source,kotlin]
----
operator fun get(index: Int) = journeys[index]
----
// end-insert

The `arrivesAt` and `duration` properties calculate the index of the last journey in the list.
The Kotlin standard library defines a `List.last()` extension method that expresses the intent of the code more clearly.
To make the code symmetrical, we'll also use the `List.first()` extension to get the first journey.

// begin-insert: tags/collections.4:src/main/java/travelator/itinerary/Route.kt#use_first_and_last
[source,kotlin]
----
val departsFrom
    get() = journeys.first().departsFrom

val arrivesAt
    get() = journeys.last().arrivesAt

val duration
    get() = Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime
    )
----
// end-insert

We are now ready to add the `requiredStays` method to our Kotlin class.
That leaves the Route class as:

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) {
    val size
        get() = journeys.size

    operator fun get(index: Int) = journeys[index]

    val departsFrom
        get() = journeys.first().departsFrom

    val arrivesAt
        get() = journeys.last().arrivesAt

    val duration
        get() = Duration.between(
            journeys.first().departureTime,
            journeys.last().arrivalTime
        )

    fun requiredAccommodation() =
        journeys
            .windowed(2)
            .map { (j1, j2) -> Interchange.between(j1, j2) }
            .filter { it.isAccommodationRequired }

    ...
}
----
// end-insert


=== Do We Need to Encapsulate the Collection?

In Java, the Route class encapsulated a mutable list to ensure that it couldn't be mutated.
In Kotlin, the List type cannot be mutated, so there is nothing to encapsulate.
There is no compelling reason for the `journeys` field to be private.

The Route class also provides accessors -- properties and query methods -- that return useful information about the route.
Those accessors support different parts of the application, but were defined in the Route class because they used the private list of Journeys.
With the list of journeys public, we could define those as extension methods, and move them into the part of the application that uses them.
However, while we still have Java that uses Routes, those accessors have another responsibility: to provide a convenient API for use by our Java code.

As we translate the Java code using the Route class into Kotlin, we will get to the point where methods and properties are only called from Kotlin.
At that point we can convert the class features to extensions and, where it makes sense, move them into the module that uses them.
IntelliJ can do this automatically, leaving `Route` as:

// begin-insert: tags/collections.7:src/main/java/travelator/itinerary/Route.kt
[source,kotlin]
----
class Route(val journeys: List<Journey>)

val Route.size: Int
    get() = journeys.size

operator fun Route.get(index: Int) = journeys[index]

val Route.departsFrom
    get() = journeys.first().departsFrom

val Route.arrivesAt
    get() = journeys.last().arrivesAt

val Route.duration
    get() = Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime
    )
----
// end-insert

// begin-insert: tags/collections.7:src/main/java/travelator/rooms/Route_RequiredAccommodation.kt
[source,kotlin]
----
fun Route.requiredAccommodation() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isAccommodationRequired }
----
// end-insert

It is now glaringly obvious that a Route is nothing more than a list of Journeys.
The class wrapping the list is worse than superfluous: it prevents us easily using all those useful extension functions in Kotlin's standard library to construct, transform, and process Routes.
As Alan Perlis famously said: "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures."
We don't want a Route to _have_ a List of Journey's, we want it to _be_ a List of Journeys.
In Kotlin, we can express that with a `typealias`:

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
----
// end-insert

However, replacing the class definition with a typealias will break code that constructs Route objects or refers to the `journeys` property.
We need to refactor our definition of `Route` from a class to a typealias without breaking the code that depends on it.
The way we'll do this is to replace the class with a typealias _and_ temporary definitions that emulate the API of the class.

// begin-insert: tags/collections.12:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
fun Route(journeys: List<Journey>) = journeys
val Route.journeys get() = this
----
// end-insert

The `Route` function ensures the calls to the constructor still compile.
The `Route.journeys` extension property ensures that references to the `journeys` property of the Route class still compile when a Route is a List of Journeys.
Then we can inline those temporary definitions, leaving the code that used them working with Lists of Journeys.

However, IntelliJ cannot automatically replace a class definition with a typealias and temporary extensions.
It has to be done by manual editing.
But those edits will prevent code that refers to the `journeys` property from compiling, because the extension of Route  must now be imported.

So, we must refactor the class, and the code that depends on it, into a form that allows us to perform the manual edit without breaking any code.
In this case, this means converting the `journeys` property defined on the class into an extension property that is imported by the files that depend on it.
Then we can replace it with the definition above.
We can do this with a sequence of automated refactoring steps.

First, we apply the "Move to class body" refactoring to the declaration of the `journeys` property in the primary constructor definition.

// begin-insert: tags/collections.8:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    val journeys = journeys
}
----
// end-insert

Then we apply the "Introduce backing property" refactoring to the `journeys` property in the class body.

// begin-insert: tags/collections.9:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    private val _journeys = journeys
    val journeys: List<Journey>
        get() = _journeys
}
----
// end-insert

Now `journeys` is a calculated property, without a backing field, that can be refactored into an extension property on Route that is correctly imported into every file that refers to it.

We'll have to temporarily increase the visibility of the `_journeys` property so that extensions of `Route` can refer to it.

// begin-insert: tags/collections.10:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    internal val _journeys = journeys
    val journeys: List<Journey>
        get() = _journeys
}
----
// end-insert

Then we apply the `Convert to extension` refactoring to the `journeys` property.

// begin-insert: tags/collections.11:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    internal val _journeys = journeys
}

val Route.journeys: List<Journey>
    get() = _journeys
----
// end-insert

Now we can manually replace the Route class with the typealias, `Route` function and `Route.journeys` extension property:

// begin-insert: tags/collections.12:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
fun Route(journeys: List<Journey>) = journeys
val Route.journeys get() = this
----
// end-insert

Finally, we inline the `Route` function and `journeys` extension property.
Now a Route _is_ a List of Journeys, across our entire codebase.

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt
[source,kotlin]
----
typealias Route = List<Journey>

val Route.departsFrom
    get() = first().departsFrom

val Route.arrivesAt
    get() = last().arrivesAt

val Route.duration
    get() = Duration.between(first().departureTime, last().arrivalTime)
----
// end-insert

// begin-insert: tags/collections.13:src/main/java/travelator/rooms/Route_RequiredAccommodation.kt
[source,kotlin]
----
fun Route.requiredAccommodation() =
    this.windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isAccommodationRequired }
----
// end-insert


=== Conclusion

We started this chapter with a Java class that encapsulated a mutable collection to guarantee value semantics.
As we translated more of our code to Kotlin, we could rely on Kotlin's type system to prevent the collection being modified, and no longer needed to encapsulate it within the class.
That allowed us to convert operations from methods to extensions, and move their definitions close to where they are used.
Because our class encapsulated a single collection, we were able to eliminate the class altogether, and replace it with a typealias.

Immutable collections and extensions allow us to organise our code in different ways.
We can group all the logic required by a particular feature of the application, or group logic that bridges between different domains.
We continue this train of thought in <<organising-code-by-domain>>.

This chapter looked at how we prevent unwanted mutation, and how Kotlin makes this unnecessary.
In <<accumulating-objects-to-transformations>>, we look at a class designed to be mutable and explore how we can refactor code that relies on its mutability to instead work by transforming immutable data.
