[[interfaces-to-functions]]
== Interfaces to Functions

In Java, we use interfaces to specify a contract between code that defines some functionality, and code that needs it.
Those interfaces couple the two parties together, which can make our software harder to maintain.
How do function types help solve this problem?

Imagine, if you can, that you need to send email from some code that you are writing.
Just that for now - not receive mail, or list sent messages - just fire and forget.

This client code knows the information that makes up the email:

// begin-insert: src/main/java/encapsulation/Email.kt
[source,kotlin]
----
data class Email(
    val to: EmailAddress,
    val from: EmailAddress,
    val subject: String,
    val body: String
)
----
// end-insert

It would _like_ to call the simplest code possible, which is:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#send
[source,kotlin]
----
fun send(email: Email) {
    SOME_CODE()
}
----
// end-insert

Of course when we come to implement this function, we discover that, to actually send email, we require all sorts of other information.
Not information about the email itself, but rather configuration about how to send it.
Things like the sending server's IP address and security credentials - all the things that your non-technical relative doesn't know, but you need to set up their new computer.
We'll add three extra parameters to `sendEmail` to stand in for all this configuration:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#sendEmail
[source,kotlin]
----
fun sendEmail(
    email: Email,
    serverAddress: InetAddress,
    username: String,
    password: String
) {
    SOME_CODE()
}
----
// end-insert

As a client things have just gotten a lot less convenient.
Everywhere we want to send email has to know this configuration - we'll be passing it around from the top to the bottom of the codebase.
Solving that problem by hiding the details in global variables works fine until we discover that every run of the unit test suite now sends 50 emails!
There must be a better way of hiding these petty details.

=== Object-Oriented Encapsulation

Object-oriented languages have a ready-made solution to this problem - objects can encapsulate the data.

// begin-insert: src/main/java/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

Now, when we want to send email we need access to an EmailSender (rather than a static function).
Once we have one, instead of calling a function, we invoke a method, and we don't need to tell the method all the petty details because it already knows them - they are the fields of its class:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: EmailSender = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

In general, the place where we know the configuration, and the place where we want to send an email, will be separated in our code, often by many layers.
Usually in OO, the `sender` will be captured as a property of a class and used by its methods:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#oo_class
[source,kotlin]
----
// Where we know the configuration
val subsystem = Rescuing(
    EmailSender(
        inetAddress("smtp.travelator.com"),
        "username",
        "password"
    )
)

// Where we send the message
class Rescuing(
    private val emailSender: EmailSender
) {
    fun sendThanks() {
        emailSender.send(
            Email(
                to = parse("support@internationalrescue.org"),
                from = parse("support@travelator.com"),
                subject = "Thanks for your help",
                body = "..."
            )
        )
    }
}
----
// end-insert

Often we will extract an interface from a class:

// begin-insert: src/main/java/encapsulation/ISendEmail.kt
[source,kotlin]
----
interface ISendEmail {
    fun send(email: Email)
}
----
// end-insert

// begin-insert: src/main/java/encapsulation/EmailSender.kt#impl
[source,kotlin]
----
class EmailSender(
        ...
) : ISendEmail {
    override fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

If our client code depends on the `ISendEmail` interface rather than the `EmailSender` class, we can configure our tests to use a fake implementation of `ISendEmail` which erm, doesn't actually send emails, but instead allows us to check what will be sent from our live system.
Not only can we provide fakes that don't send emails at all, but also different non-fake implementations like `SmtpEmailSender` and `X400EmailSender`, each of which hides both its configuration and implementation from its clients.
We came for the information hiding, but stayed for the implementation hiding.

When we say _hiding_, it sounds a bit pejorative, but the hiding is useful to both client and implementor.
The former doesn't have the problem of having to supply the configuration details at the point of use; the latter is able to evolve separately from its users (provided it doesn't change API, expressed in the interface).

Before we leave the object-oriented realm, it's worth noting that we don't have to create a named class to implement `ISendEmail`; we can do it anonymously:

// begin-insert: src/main/java/encapsulation/anonymous-class.kt#anon
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): ISendEmail =
    object : ISendEmail {
        override fun send(email: Email) =
            sendEmail(
                email,
                serverAddress,
                username,
                password
            )
    }
----
// end-insert

Why might we want to do this?
Well in situations where we don't control all the clients of our code (we are publishing a library external to our organisation for example), then this gives us flexibility to change our implementation, safe in the knowledge that clients cannot depend on a specific implementation class by downcasting to it and calling other methods.
We call this object a _closure_, as it closes-over values that it requires from its enclosing context, capturing them for use later.

In Kotlin 1.4, we can declare our `ISendEmail` interface as a `fun interface` (one with only one abstract method).
This way we can define the implementation of the single operation with a lambda, rather than an object with a single method:

// begin-insert: src/main/java/encapsulation/anonymous-class.kt#anon2
[source,kotlin]
----
fun interface ISendEmail {
    fun send(email: Email)
}

fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
) = ISendEmail { email ->
    sendEmail(
        email,
        serverAddress,
        username,
        password
    )
}
----
// end-insert

Again, the lambda here is a closure, capturing the values of the parameters of its parent function.

=== Functional Encapsulation

Having seen how an OO programmer solves the problem of encapsulating pesky details so clients don't have to supply them at the point of use, how would a functional programmer approach the same problem?

Remember that we're trying to get to a function with this signature:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#send
[source,kotlin]
----
fun send(email: Email) {
    SOME_CODE()
}
----
// end-insert

We are given an implementation that looks like this:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#sendEmail
[source,kotlin]
----
fun sendEmail(
    email: Email,
    serverAddress: InetAddress,
    username: String,
    password: String
) {
    SOME_CODE()
}
----
// end-insert

In functional terms, this is an example of https://en.wikipedia.org/wiki/Partial_application[_partial application_] - fixing some of the arguments to a function to yield a function with fewer arguments.
While some languages provide built-in support for this, in Kotlin the easiest approach is to write a function to partially apply our configuration.

What we want is a function that takes the configuration, and returns a function that knows how to send a message:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender0
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit { // <1>
    SOME_CODE()
}
----
// end-insert

<1> The return type of our function is itself a function, that takes an `Email` and returns `Unit`.

`createEmailSender` is a constructor; not a class constructor, but a function taking the same role.
Both are `createEmailSender` and `::EmailSender` are functions that return an object that knows how to send a message.

To see how this works in functions, we can write this in longhand first, by defining an inner function that captures the arguments it requires from the parent:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender1
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit {

    fun result(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
    return ::result
}
----
// end-insert

We can then make the result a lambda expression:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender2
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit {

    val result: (Email) -> Unit =
        { email ->
            sendEmail(
                email,
                serverAddress,
                username,
                password
            )
        }
    return result
}
----
// end-insert

before inlining `result` and converting to a single expression to leave this functional definition:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender3
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit =
    { email ->
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
----
// end-insert

So `createEmailSender` is a function that returns a lambda that calls `sendEmail` combining the lambda's single `Email` argument with the configuration from `createEmailSender`.
This is a closure in functional land, and it's worth noting how similar this is to the OO versions with a fun interface or object definition.

To use this function, we can create it in one place and invoke it in another, very much as we did with the object solution.

// begin-insert: src/main/java/encapsulation/FP-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender( // <1>
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

Here we are showing the `invoke` call on `sender`, to allow us to see the similarity with the OO version:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#excerpt
[source,kotlin]
----
fun sendThanks() {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

Usually though, we would elide the call, to give us:

// begin-insert: src/main/java/encapsulation/FP-usage.kt#nonInvoke
[source,kotlin]
----
fun sendThanks() {
    sender(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert


In the unlikely event that you're joining us from JavaScript, or Clojure, the functional form will be much more familiar, but if you came to Kotlin from Java, this solution probably feels quite alien.

=== Function Types in Java

Both the object and functional forms have allowed us to encapsulate things (in this case configuration, but it could equally well have been collaborators)
to transport them from the place where they are known to the place where they are used.
Any data-structure could have done that, but because the object and the function both have an operation that can be run (`send` and `invoke` respectively), the client can remain oblivious to the details of the configuration and just pass the information that is specific to each invocation (the `Email`).

One way of unifying the functional and OO solutions is to view a function as an object with a single `invoke` method.
This is exactly what Java 8 did when it introduced lambdas.
To refer to a function type, Java uses interfaces with a _Single Abstract Method_ (SAM) that has the desired signature.
Lambdas are a syntax to allow us to implement a SAM interface.
The Java runtime defines SAM interfaces named by role: `Consumer`, `Supplier`, `Function`, `BiFunction`, `Predicate` etc for us.
It also provides primitive specialisations, like `DoublePredicate`, to avoid boxing issues.

Expressed in Java, our functional solution is

// begin-insert: src/main/java/encapsulation/FPUsage.java#foo
[source,java]
----
// Where we know the configuration
Consumer<Email> sender = createEmailSender(
    inetAddress("example.com"),
    "username",
    "password"
);

// Where we send the message
public void sendThanks() {
    sender.accept( // <1>
        new Email(
            parse("support@internationalrescue.org"),
            parse("support@travelator.com"),
            "Thanks for your help",
            "..."
        )
    );
}
----
// end-insert

<1> Accept is the name of the single abstract method on the `Consumer` interface.

`createEmailSender` can be implemented with a lambda:

// begin-insert: src/main/java/encapsulation/FPUsage.java#FPUsageLambda
[source,java]
----
static Consumer<Email> createEmailSender(
    InetAddress serverAddress,
    String username,
    String password
) {
    return email -> sendEmail(
        email,
        serverAddress,
        username,
        password
    );
}
----
// end-insert

This is equivalent to creating an anonymous implementation of the interface, a technique that will be very familiar to those of us who programmed in Java before Java 8:

// begin-insert: src/main/java/encapsulation/FPUsage.java#FPUsageLongHand
[source,java]
----
static Consumer<Email> createEmailSender(
    InetAddress serverAddress,
    String username,
    String password
) {
    return new Consumer<Email>() {
        @Override
        public void accept(Email email) {
            sendEmail(
                email,
                serverAddress,
                username,
                password
            );
        }
    };
}
----
// end-insert

We say "equivalent to creating an anonymous implementation of the interface," but under the hood, the implementation is more complex to avoid unnecessarily defining classes and instantiating objects.

It's worth noting at this point we can't assign the `(Email) -> Unit` result of the Kotlin `createEmailSender` to a variable of type `Consumer<Email>`.
This is because the Kotlin runtime has its own function types that it uses, and the compiler compiles `(Email) -> Unit` into `Function1<Email, Unit>`.
There are a whole series of Kotlin `FunctionN` interfaces for the different numbers of parameters.
(To get us used to their existence, IntelliJ helpfully introduces this function form rather than the `(P) -> R` syntax as the result of some automated refactorings in Kotlin.)

As the interfaces are not compatible, in order to mix Java and Kotlin at this functional level we are going to have to thunk sometimes.
Given a Kotlin function type `(Email) -> Unit`:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo1
[source,kotlin]
----
// Kotlin function type
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)
----
// end-insert

We can't just assign `sender` to `Consumer<Email`:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo2
[source,kotlin]
----
val consumer: Consumer<Email> = sender // Doesn't compile <1>
----
// end-insert

<1> `Type mismatch. Required: Consumer<Email> Found:(Email) -> Unit`

We can though convert with a lambda:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo3
[source,kotlin]
----
val consumer: Consumer<Email> = Consumer<Email> { email ->
    sender(email)
}
----
// end-insert

There is a situation where we don't have to convert, which is calling a Java method that takes a SAM parameter, for example, this constructor:

// begin-insert: src/main/java/encapsulation/Rescuing.java#foo
[source,java]
----
class Rescuing {
    private final Consumer<Email> emailSender;

    Rescuing(Consumer<Email> emailSender) {
        this.emailSender = emailSender;
    }
    ...
}
----
// end-insert

Here, the compiler _is_ able to convert `(Email) -> Unit` to `Consumer<Email>`:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo4
[source,kotlin]
----
Rescuing(sender)
----
// end-insert


<3> Kotlin will convert parameters automatically.

=== Mix and Match

There are two sides to an abstraction, the client code and the implementation code.
So far, both client and implementor have either been object-oriented or functional.
In the OO case, fields carry configuration, and the client invokes a method.
In the functional scheme, the function closes over the configuration, and the client invokes the function.

Can we unify these approaches, giving an OO implementation to a function-expecting client or vice versa?
Or, in Kotlin terms, can we convert `ISendEmail` to `(Email) -> Unit`, and the inverse.
Why yes we can!

Remember that in Java and Kotlin, function types are just interfaces.
Because of this `EmailSender` can implement the type `Consumer<Email>` or  `(Email) -> Unit` respectively, by defining a method with the signature of the function type.

Here it is in Java:

// begin-insert: src/main/java/encapsulation/MixedUsage.java#consumer
[source,java]
----
public class EmailSender
    implements ISendEmail,
        Consumer<Email> // <1>
{
        ...
    @Override
    public void accept(Email email) { // <2>
        send(email);
    }

    @Override
    public void send(Email email) {
        sendEmail(email, serverAddress, username, password);
    }
}
----
// end-insert

<1> Declare
<2> Implement

This is the Kotlin equivalent:

// begin-insert: src/main/java/encapsulation/EmailSender.kt#invoke
[source,kotlin]
----
class EmailSender(
        ...
) : ISendEmail,
    (Email) -> Unit // <1>
{
    override operator fun invoke(email: Email) =
        send(email) // <2>

    override fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

<1> Declare
<2> Implement

If we do this then we can use our class-based sender in place of our functional one.
We'll stick with Kotlin now:

// begin-insert: src/main/java/encapsulation/FP-usage.kt#bar
[source,kotlin]
----
// Where we know the configuration
val sender: (Email) -> Unit = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender( // <1>
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

<1> There is an implicit `invoke` here.

Now our OO implementation has gained an `invoke` method in order to fit in with the FP approach.
This calls into question the usefulness of our `ISendEmail` interface.
We can see that it is equivalent to the function type `(Email) -> Unit` : all it does is give the name `send` to what happens when you invoke it.
Maybe we could just use the type `(Email) -> Unit` everywhere in place of `ISendEmail`?

If you think that isn't expressive enough, then maybe you aren't a functional programmer.
Luckily there is a middle ground - we can use a type alias to give a name to the functional type, thus communicating our intent.

// begin-insert: src/main/java/encapsulation/typealias.kt#typealias
[source,kotlin]
----
typealias ISendEmail = (Email) -> Unit

class EmailSender(
    ...
) : ISendEmail {
    override fun invoke(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

Note that as the type alias is just an alias - it doesn't define a new type - you can write `ISendEmail` and `(Email) -> Unit` interchangeably, so that we don't have to retrofit `sendThanks` with the type alias in order to make this change.

.Expressive Function Types
****
Once we have our head in the functional mindset, `(Email) -> Unit` may be expressive enough to tell us the role of the function, especially combined with a variable name of `sender`.
What can you do with an email that doesn't return a result?
Well if it doesn't return a result it must be an action (<<actions>>), but deleting an email might also have a similar signature.
Objects have that advantage over functions - they get to name their methods (`send(email)` compared to `delete(email)`), at the expense of also having to name the type of the object or interface.

Kotlin has a feature that can help make function types more expressive - we can name the parameters.
So if it helps, we could write `(toSend: Email) -> Unit`.
It doesn't make a great difference here, but can be very useful in situations with parameters of the same type, for example `(username: String, password: String) -> AuthenticatedUser`.
If we use this form, IntelliJ will even helpfully name the parameters when we implement the function with a lambda or a class.
****

There is another way of bridging the OO-FP gap that doesn't involve making our classes implement function types - create a function reference at the point of translation.
Here is our old class-based solution:

// begin-insert: src/main/java/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

We can convert an instance of `EmailSender` to a function type with a lambda:

// begin-insert: src/main/java/encapsulation/mixed-usage.kt#foo
[source,kotlin]
----
val instance = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)
val sender: (Email) -> Unit = { instance.send(it) }
----
// end-insert

or just pass a method reference:

// begin-insert: src/main/java/encapsulation/mixed-usage.kt#bar
[source,kotlin]
----
val sender: (Email) -> Unit = instance::send
----
// end-insert

Whilst we've shown these conversions in Kotlin, they also work in Java (with a slightly different syntax).
They work with the `send` method on the `ISendEmail` interface too, although it's not clear that the interface is doing much for us if we are using the function type.

Can we do the opposite - pass our functional sender into something that expects an `ISendEmail`?
This requires more ceremony, as we have to create an anonymous object implementing `ISendEmail` to perform the thunk:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#bar
[source,kotlin]
----
val function: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

val sender: ISendEmail = object : ISendEmail {
    override fun send(email: Email) {
        function(email)
    }
}
----
// end-insert

If we had used a Kotlin 1.4 `fun interface`, we could again remove some boilerplate:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#baz
[source,kotlin]
----
fun interface ISendEmail {
    fun send(email: Email)
}

val sender = ISendEmail { function(it) }
----
// end-insert

=== Comparing the Approaches

Let's remind ourselves of the OO approach.

First we define a type

// begin-insert: src/main/java/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

then we create instances and call methods

// begin-insert: src/main/java/encapsulation/OO-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: EmailSender = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

In functional land we don't have to define a type, because `(Email) -> Unit` just exists, so we can just say:

// begin-insert: src/main/java/encapsulation/FP-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender( // <1>
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

<1> With or without the `invoke`.

Clients using the _object_ have to know to call the `send` method to send email; in contrast, clients using the _function_ just have to invoke it, but they only know that the function sends email because it has been assigned the name `sender`.
If that name got lost in the call hierarchy, we are left to guess what happends from the function signature..

The quid-pro-quo of the OO clients having to know to call the `send` method is that we could package up a number of email-related operations into an `EmailSystem`, with methods like `send`, `list`, and `delete`, and pass all this functionality to clients in one go.
Clients can then choose which they need in which context:

// begin-insert: src/main/java/encapsulation/EmailSystem.kt
[source,kotlin]
----
interface EmailSystem {
    fun send(email: Email)
    fun delete(email: Email)
    fun list(folder: Folder): List<Email>
    fun move(email: Email, to: Folder)
}
----
// end-insert

To achieve this in the functional context would require either passing individual functions around, or some sort of map of name to function, maybe an instance of a class itself:

// begin-insert: src/main/java/encapsulation/fp-email-system.kt#foo
[source,kotlin]
----
class EmailSystem(
    val send: (Email) -> Unit,
    val delete: (Email) -> Unit,
    val list: (folder: Folder) -> List<Email>,
    val move: (email: Email, to: Folder) ->  Unit
)
----
// end-insert

Clients with such an object could treat it very much like an implementation of the interface:

// begin-insert: src/main/java/encapsulation/fp-email-system.kt#bar
[source,kotlin]
----
fun sendThanks(sender: EmailSystem) {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

But this is not the same as the OO code.
Instead of invoking a `send` _method_; what is actually happening here is that we are calling `getSender` to access a property of function type, and then calling `invoke` on that function:

// begin-insert: src/main/java/encapsulation/fp-email-system.kt#baz
[source,kotlin]
----
fun sendThanks(sender: EmailSystem) {
    sender.send.invoke(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

The code may read the same, but it generates very different, and fundamentally incompatible, bytecode.

=== Coupling

An easy to overlook difference between expressing a dependency as an implementation of `ISendEmail` and an implementation of the function type `(Email) -> Unit` is the coupling between the client and the implementation, in particular when they are in different code bases.

`ISendEmail` has to be defined somewhere.
The client can't define it, because the implementor will depend on the interface, and the client on the implementation, leading to a circular dependency.
So the interface has to be defined either with the implemention, or in a separate place (package, JAR file) depended on by both implemention and its clients.
The later (an application of the https://en.wikipedia.org/wiki/Dependency_inversion_principle[Dependency Inversion Principle]) is in theory preferable but in practice more work and so often neglected.

With or without Dependency Inversion, the result is the client and implementation being coupled by the interface in ways which can make systems hard to reason with and refactor.
Any change to methods on `EmailSystem` might affect all code that depends on the interface.

In contrast, in the functional (`(Email) -> Unit`) case, the runtime defines all the function types, so they don't introduce a compile-time dependency between the client and an implementation.
Of course there will be a run-time dependency - the client has to be able to invoke the implementation code, and the constructor code needs to be visible where the dependency is created, but these tend to cause less coupling.
For example, when a dependency is expressed as a function type, we can rename `EmailSystem.send`, and the only change in our client code will be to use a different method reference - the internals of `sendThanks` are unaffected.

[TIP]
.Only Pass Types That You Own (and the Runtime)
====
An early rule of thumb for OO systems was that, on the inside of our systems, we should program in terms of types that we own, rather than those supplied by libraries.
That way we are insulated from changes that we don't control, and are more likely to write code that can be reused with different implementations..

An exception to this rule is taking a dependency on types provided by the runtime - these are very unlikely to change.
Function types allow us to easily convert from unstable to stable interfaces, allowing parts of our systems to evolve at different rates.
====

=== OO or Functional?

Both the OO and functional approaches can achieve the same goals, and with similar levels of expressiveness.
Which should we choose?

Let's consider this from the context of the client code.
If our client only needs to list email, it should have a dependency on a single `(Folder) -> List<Email>` function.
This way it is not coupled to an implementation, and the dependency can be satisfied by anything of the function type, including:

* a plain function
* an object implementing the function type
* method reference selecting a method with the desired signature
* a lambda with the desired signature.

Even if we already happen to have an interface, lets say `EmailSystem`, which defines the desired method along with send, move and delete, we shouldn't needlessly couple our client to this interface when the function type will do.

// begin-insert: src/main/java/encapsulation/EmailSystem.kt
[source,kotlin]
----
interface EmailSystem {
    fun send(email: Email)
    fun delete(email: Email)
    fun list(folder: Folder): List<Email>
    fun move(email: Email, to: Folder)
}
----
// end-insert

// begin-insert: src/main/java/encapsulation/narrowing.kt#one_method
[source,kotlin]
----
class Organiser(
    private val listing: (Folder) -> List<Email>
) {
    fun subjectsIn(folder: Folder): List<String> {
        return listing(folder).map { it.subject }
    }
}

val emailSystem: EmailSystem = SOME_CODE()
val organiser = Organiser(emailSystem::list)
----
// end-insert

Taking a wider interface misses the opportunity to communicate precisely which operations we require, and forces clients to provide an implementation of the whole interface.
This is particularly irritating in tests, and leads to the introduction of fake objects just to get our test code to compile.

The drives of communication and reduced coupling are so strong that even if our client needs to send and delete email, and in practice these are going to be supplied by a single `EmailSystem`, it should probably depend on two functions rather than the interface:

// begin-insert: src/main/java/encapsulation/narrowing.kt#two_methods
[source,kotlin]
----
class Organiser(
    private val listing: (Folder) -> List<Email>,
    private val deleting: (Email) -> Unit
) {
    fun deleteInternal(folder: Folder) {
        listing(rootFolder).forEach {
            if (it.to.isInternal()) {
                deleting.invoke(it)
            }
        }
    }
}

val organiser = Organiser(
    emailSystem::list,
    emailSystem::delete
)
----
// end-insert

Only at the point where the client requires three related operations does it feel like a multi-method interface should be the default:

// begin-insert: src/main/java/encapsulation/narrowing.kt#direct_dependency
[source,kotlin]
----
class Organiser(
    private val emails: EmailSystem
) {
    fun organise() {
        emails.list(rootFolder).forEach {
            if (it.to.isInternal()) {
                emails.delete(it)
            } else {
                emails.move(it, archiveFolder)
            }
        }
    }
}

val organiser = Organiser(emailSystem)
----
// end-insert

Even here, it might be better for the client to accept an object that only supports the desired operations.
We can do that with a new interface (`Dependencies` here), implemented with an `object`:

// begin-insert: src/main/java/encapsulation/narrowing.kt#interface
[source,kotlin]
----
class Organiser(
    private val emails: Dependencies
) {
    interface Dependencies {
        fun delete(email: Email)
        fun list(folder: Folder): List<Email>
        fun move(email: Email, to: Folder)
    }

    fun organise() {
        emails.list(rootFolder).forEach {
            if (it.to.isInternal()) {
                emails.delete(it)
            } else {
                emails.move(it, archiveFolder)
            }
        }
    }
}

val organiser = Organiser(object : Organiser.Dependencies {
    override fun delete(email: Email) {
        emailSystem.delete(email)
    }

    override fun list(folder: Folder): List<Email> {
        return emailSystem.list(folder)
    }

    override fun move(email: Email, to: Folder) {
        emailSystem.move(email, to)
    }
})
----
// end-insert

That's pretty irritating though, maybe this is a place where a class of functions would be better:

// begin-insert: src/main/java/encapsulation/narrowing.kt#object
[source,kotlin]
----
class Organiser(
    private val emails: Dependencies
) {
    class Dependencies(
        val delete: (Email) -> Unit,
        val list: (folder: Folder) -> List<Email>,
        val move: (email: Email, to: Folder) -> Unit
    )

    fun organise() {
        emails.list(rootFolder).forEach {
            if (it.to.isInternal()) {
                emails.delete(it)
            } else {
                emails.move(it, archiveFolder)
            }
        }
    }
}

val organiser = Organiser(
    Organiser.Dependencies(
        delete = emailSystem::delete,
        list = emailSystem::list,
        move = emailSystem::move
    )
)
----
// end-insert

So, until it becomes hard work, we should default to expressing our client's needs as function types.
Our implementation then can be just a function, or something implementing the function type, or a method converted to the function type through method references or lambdas, whichever makes most sense in context.

=== The Legacy of Java

While we said earlier that "our runtime defines all the functions types", that wasn't true of Java until Java 8 introduced `Supplier`, `Consumer`, `Predicate` etc, and the ability to implement them with method references or lambdas.

Because of this, legacy Java expresses dependencies with the same multi-method interfaces that we would use to group them by sub-system (like `EmailSystem` above), even when only one of those methods is required to implement the functionality.
This leads to the coupling problems described earlier.
It also leads to a need for mocking (or more pedantically faking) frameworks to create test implementations of broad interfaces where in practice only one method will be called.
These fakes then sprout the functionality to fail early if you call a method that you didn't mean to call, a problem that would be solved at compile-time if a single function expressed the dependency.

Once we have introduced a mocking framework into our codebase (or, more usually, two or three), they allow us to solve problems, like generating implementations for unused methods and stubbing out interactions with external systems.
Usually though, our code would be improved by restructuring to avoid the need for mocks.
Expressing dependencies as function types is one example, another is moving the interaction with external systems out of our code, as we will see in <<performing-io-to-passing-data>>.

[TIP]
.Faking in Kotlin
====
There will be times, even in Kotlin, where we want to implement just some of an interface's methods for testing.
On the JVM we can combine dynamic proxies with anonymous objects, delegation and selective overriding to write the following:

// begin-insert: src/main/java/encapsulation/faking.kt
[source,kotlin]
----
inline fun <reified T> fake(): T =
    Proxy.newProxyInstance(
        T::class.java.classLoader,
        arrayOf(T::class.java)
    ) { _, _, _ ->
        TODO("not implemented")
    } as T


val sentEmails = mutableListOf<Email>()
val testCollaborator: EmailSystem = object: EmailSystem by fake() {
    override fun send(email: Email) {
        sentEmails.add(email)
    }
}
----
// end-insert
====

=== Traceability

We should say that there is a downside to expressing dependencies with function types, and it is a common issue with adding a layer of indirection.
If we use IntelliJ to find the callers of `EmailSystem.send`, the trail goes cold at the point where `EmailSystem::send` is converted to `(Email) -> Unit`.
It's like our hero enters a river, and the posse have to scour both banks upstream and downstream to find where she gets out.

This is a price we pay for indirection with method calls too, but our tooling is wise to these, and can at least find all places where a particular method is implemented, and where an implementation is called through an interface.
No doubt tool support will improve its functional analysis, and in the meantime we can help by not passing function types too far from where they are defined to where they are used.

=== Refactoring from Interfaces to Functions

Travelator is quite well-designed in the Java fashion, with interfaces expressing the relations between components.
For example the `Recommendations` engine depends on `FeaturedDestinations` and a `DistanceCalculator`:

// begin-insert: tags/interfaces-to-functions.0:src/main/java/travelator/recommendations/Recommendations.java#setup
[source,java]
----
public class Recommendations {
    private final FeaturedDestinations featuredDestinations;
    private final DistanceCalculator distanceCalculator;

    public Recommendations(
        FeaturedDestinations featuredDestinations,
        DistanceCalculator distanceCalculator
    ) {
        this.featuredDestinations = featuredDestinations;
        this.distanceCalculator = distanceCalculator;
    }
    ...
}
----
// end-insert

The `FeaturedDestinations` interface has a few methods, grouping functionality that accesses a remote service:

// begin-insert: tags/interfaces-to-functions.0:src/main/java/travelator/destinations/FeaturedDestinations.java
[source,java]
----
public interface FeaturedDestinations {
    List<FeaturedDestination> findCloseTo(Location location);
    FeaturedDestination findClosest(Location location);

    FeaturedDestination add(FeaturedDestinationData destination);
    void remove(FeaturedDestination destination);
    void update(FeaturedDestination destination);
}
----
// end-insert

It looks like we've already converted the `DistanceCalculator` interface to Kotlin - it too has more than one method, and hides another service:

// begin-insert: tags/interfaces-to-functions.0:src/main/java/travelator/domain/DistanceCalculator.kt
[source,kotlin]
----
interface DistanceCalculator {
    fun distanceInMetersBetween(
        start: Location,
        end: Location
    ): Int

    fun travelTimeInSecondsBetween(
        start: Location,
        end: Location
    ): Int
}
----
// end-insert

Despite taking a dependency on a total of seven methods, `Recommendations` only actually uses two of them in its implementation:

// begin-insert: tags/interfaces-to-functions.0:src/main/java/travelator/recommendations/Recommendations.java#recommendationsFor
[source,java]
----
public List<FeaturedDestinationSuggestion> recommendationsFor(
    Set<Location> journey
) {
    var results = removeDuplicates(
        journey.stream()
            .flatMap(location ->
                recommendationsFor(location).stream()
            )
    );
    results.sort(distanceComparator);
    return results;
}

public List<FeaturedDestinationSuggestion> recommendationsFor(
    Location location
) {
    return featuredDestinations
        .findCloseTo(location) // <1>
        .stream()
        .map(featuredDestination ->
            new FeaturedDestinationSuggestion(
                location,
                featuredDestination,
                distanceCalculator.distanceInMetersBetween( // <2>
                    location,
                    featuredDestination.getLocation()
                )
            )
        ).collect(toList());
}
----
// end-insert

<1> Method on `FeaturedDestinations`
<2> Method on `DistanceCalculator`

`RecommendationsTests` uses mocks to provide implementations of its dependencies.
As we'll see, this isn't necessary, but is the Java way of providing test doubles for interfaces.
The details of which mocking framework are hidden behind some test methods as we'll see in a minute.
The key is that the dependencies are mocked, and the mocks passed to the instance of `Recommendations` that we will be testing:

// begin-insert: tags/interfaces-to-functions-2.1:src/test/java/travelator/recommendations/RecommendationsTests.java#setup
[source,java]
----
public class RecommendationsTests {

    private final DistanceCalculator distanceCalculator =
        mock(DistanceCalculator.class);
    private final FeaturedDestinations featuredDestinations =
        mock(FeaturedDestinations.class);
    private final Recommendations recommendations = new Recommendations(
        featuredDestinations,
        distanceCalculator
    );
    ...
}
----
// end-insert

The expected interactions with the mocks are hidden two methods, `givenFeaturedDestinationsFor` and `givenADistanceBetween`:

// begin-insert: tags/interfaces-to-functions-2.1:src/test/java/travelator/recommendations/RecommendationsTests.java#test1
[source,java]
----
@Test
public void returns_recommendations_for_multi_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    givenFeaturedDestinationsFor(alton,
        List.of(
            flowerFarm,
            watercressLine
        ));
    givenADistanceBetween(alton, flowerFarm, 5300);
    givenADistanceBetween(alton, watercressLine, 320);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(alton, watercressLine, 320),
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
        ),
        recommendations.recommendationsFor(Set.of(paris, alton))
    );
}
----
// end-insert

.Mock-Induced Test Damage
****
David Heinemeier Hansson coined the term https://dhh.dk/2014/test-induced-design-damage.html[Test Induced Design Damage] to refer to harm caused to systems in the name of testability.
In practice, your authors don't recognise this as much of a problem - we find that systems are usually improved by the decoupling required to test them well.
We _do_ often see tests ruined by mocks though, so much so that mocks have become a bit of a dirty word in our circles.
This despite the fact that these circles spawned the technique, and wrote the book (<<FP_GOOSGBT_2009,_Growing Object-Oriented Software Guided By Tests_>>).

The problem seems to be that, as well as implementing interfaces, mock frameworks allow us to specify the expected invocations of their methods, and what should be returned in those cases.
But expected calls and their results don't make for a human-readable description, as we'll see if we look at the inlined version of the last expectations:

// begin-insert: tags/interfaces-to-functions-2.2:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
when(featuredDestinations.findCloseTo(paris))
    .thenReturn(List.of(
        eiffelTower,
        louvre
    ));
when(distanceCalculator.distanceInMetersBetween(
    paris, eiffelTower.getLocation())
).thenReturn(5000);
when(distanceCalculator.distanceInMetersBetween(
    paris, louvre.getLocation())
).thenReturn(1000);

when(featuredDestinations.findCloseTo(alton))
    .thenReturn(List.of(
        flowerFarm,
        watercressLine
    ));
when(distanceCalculator.distanceInMetersBetween(
    alton, flowerFarm.getLocation())
).thenReturn(5300);
when(distanceCalculator.distanceInMetersBetween(
    alton, watercressLine.getLocation())
).thenReturn(320);
----
// end-insert

Defining methods like `givenADistanceBetween` allows us to express the relationship between the mock expectations and our test - they can hide the _how_ to expose the _why_.
In practice though, very few developers take this step, leading to cryptic tests which are blamed on the use of mocking.
****

==== Introduce Functions

Before we start refactoring, this is a Kotlin book, so let's convert at least something to Kotlin.
We'll start with `Recommendations`, because this is the class that currently expresses its dependencies with interfaces.
Converting to Kotlin and applying the refactorings introduced in <<streams-to-sequences>> and <<functions-to-extension-functions>> gives:

// begin-insert: tags/interfaces-to-functions-2.4:src/main/java/travelator/recommendations/Recommendations.kt
[source,kotlin]
----
class Recommendations(
    private val featuredDestinations: FeaturedDestinations,
    private val distanceCalculator: DistanceCalculator
) {
    fun recommendationsFor(
        journey: Set<Location>
    ): List<FeaturedDestinationSuggestion> =
        journey
            .flatMap { location -> recommendationsFor(location) }
            .deduplicated()
            .sortedBy { it.distanceMeters }

    fun recommendationsFor(
        location: Location
    ): List<FeaturedDestinationSuggestion> =
        featuredDestinations.findCloseTo(location)
            .map { featuredDestination ->
                FeaturedDestinationSuggestion(
                    location,
                    featuredDestination,
                    distanceCalculator.distanceInMetersBetween(
                        location,
                        featuredDestination.location
                    )
                )
            }
}

private fun List<FeaturedDestinationSuggestion>.deduplicated() =
    groupBy { it.suggestion }
        .values
        .map { suggestionsWithSameDestination ->
            suggestionsWithSameDestination.closestToJourneyLocation()
        }

private fun List<FeaturedDestinationSuggestion>.closestToJourneyLocation() =
    minByOrNull { it.distanceMeters } ?: error("Unexpected empty group")
----
// end-insert

In order to see how the internals of `Recommendations` would use a function rather than the interface, without having to change its interface (yet), we can add a property initialised from an interface method.
Let's add a property for `featuredDestinations::findCloseTo`, calling it `destinationFinder`:

// begin-insert: tags/interfaces-to-functions-2.8:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val featuredDestinations: FeaturedDestinations,
    private val distanceCalculator: DistanceCalculator
) {
    private val destinationFinder: // <1>
        (Location) -> List<FeaturedDestination> =
        featuredDestinations::findCloseTo

    ...

    fun recommendationsFor(
        location: Location
    ): List<FeaturedDestinationSuggestion> =
        destinationFinder(location) // <2>
            .map { featuredDestination ->
                FeaturedDestinationSuggestion(
                    location,
                    featuredDestination,
                    distanceCalculator.distanceInMetersBetween(
                        location,
                        featuredDestination.location
                    )
                )
            }
}
----
// end-insert

<1> Extract a function from the interface.
<2> Use it in place of the method.

This passes the tests, so we may be on to something.
It feels like there should be a refactoring to move `destinationFinder` into the constructor, but we haven't found anything better than cutting the definition and pasting where we want it:

// begin-insert: tags/interfaces-to-functions-2.9:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val featuredDestinations: FeaturedDestinations,
    private val distanceCalculator: DistanceCalculator,
    private val destinationFinder:
        (Location) -> List<FeaturedDestination> =
        featuredDestinations::findCloseTo
) {
----
// end-insert

Unfortunately Java doesn't understand the defaulted parameter, so we have to fix up the call sites to add the function parameter.
It doesn't really matter, as this is what we want really anyway:

// begin-insert: tags/interfaces-to-functions-2.9:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
private final Recommendations recommendations = new Recommendations(
    featuredDestinations,
    distanceCalculator,
    featuredDestinations::findCloseTo
);
----
// end-insert

Now nothing in `Recommendations` uses the `featuredDestinations` property, so we can remove it:

// begin-insert: tags/interfaces-to-functions-2.10:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val distanceCalculator: DistanceCalculator,
    private val destinationFinder: (Location) -> List<FeaturedDestination>
) {
----
// end-insert

The places in our code that create `Recommendations` now look like this:

// begin-insert: tags/interfaces-to-functions-2.10:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
private final Recommendations recommendations = new Recommendations(
    distanceCalculator,
    featuredDestinations::findCloseTo
);
----
// end-insert

If you're used to refactoring tests with mocks, it may surprise you that the tests have continued to pass through this refactoring.
We can reason that they _should_ pass - the effect of calling the function bound to `featuredDestinations::findCloseTo` is still to invoke the method on the mocked interface - but our reasoning is so often proved wrong by tests that we don't count our chickens.

We do like a single basket though, so let's do the same thing with the `distanceCalculator`, this time in a fell-swoop, whatever that is:

// begin-insert: tags/interfaces-to-functions-2.11:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val destinationFinder: (Location) -> List<FeaturedDestination>,
    private val distanceInMetersBetween: (Location, Location) -> Int
) {
    ...
    fun recommendationsFor(
        location: Location
    ): List<FeaturedDestinationSuggestion> =
        destinationFinder(location)
            .map { featuredDestination ->
                FeaturedDestinationSuggestion(
                    location,
                    featuredDestination,
                    distanceInMetersBetween( // <1>
                        location,
                        featuredDestination.location
                    )
                )
            }
}
----
// end-insert

<1> Calling the new function.

The constructor invocations are now:

// begin-insert: tags/interfaces-to-functions-2.11:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
private final Recommendations recommendations = new Recommendations(
    featuredDestinations::findCloseTo,
    distanceCalculator::distanceInMetersBetween
);
----
// end-insert

Note that a little thought around what to call functional variables can go a long way to making them seem natural in use, although that does sometimes make them a little cryptic where they are defined.

Again the tests still pass, giving us confidence that our production code will see the transformation the same way.
It's particularly nice that we have shown that we can simultaneously cross a method/function boundary, and a Java/Kotlin boundary - maybe this interop will work out OK after all!

==== Weaning Off Mocks

We're done with the production code now, but before we finish this chapter, let's return to the tests.

Before we finish finishing the chapter though, we should say that, frankly, the rest of the refactoring is only tangentially related to interfaces to functions.
If you came to this chapter for just that material (and goodness knows there has been enough of it) you may want to skip to the conclusion.
Otherwise, stay tuned, because the tests have interesting things to teach us about structuring code.

We recall that the tests used mocking because they had to implement two multi-method interfaces, even though most of those methods were not used.
Nat is keen to point out that the mocks that he and Steve Freeman wrote about (<<FP_GOOSGBT_2009,_Growing Object-Oriented Software Guided By Tests_>>) were never supposed to be used to implement query functionality.
Duncan doesn't recall noticing that being said, and is personally not against using mocks in this way, as they are still a nice way to specify what we expect of collaborators when practicing outside-in TDD, whether reading-from or writing-to.
In the end, maybe it doesn't matter, because in both of our experiences, most Java codebases have mocks that are used in this way, and most Kotlin codebases would be better off without them.

For now though, we are still mocking, but our refactoring has resulted in our passing narrow interfaces (the function types) to the code under test.
Now that we don't need to implement uncalled methods, do we still need the mocks?
Let's see where that takes us.

Before we go on, we'll convert the tests to Kotlin, as it has better support for function types.
We could stay in Java, but then we would have to work out which of the Java function types (`Function`, `BiFunction` etc) expresses the operations, and we'd still have Java.

The automated conversion is quite smooth, although for some reason the converter created lambdas rather than using method references in the `Recommendations` constructor call that we have to replace by hand, leaving the setup as:

// begin-insert: tags/interfaces-to-functions-2.12:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
[source,kotlin]
----
class RecommendationsTests {
    private val distanceCalculator = mock(DistanceCalculator::class.java)
    private val featuredDestinations = mock(FeaturedDestinations::class.java)

    private val recommendations = Recommendations(
        featuredDestinations::findCloseTo,
        distanceCalculator::distanceInMetersBetween
    )
    ...
----
// end-insert

We could use Kotlin reified types to avoid those `::class.java` arguments, but we're moving away from mocks, not towards them, so we resist.

`when` is a keyword in Kotlin, but the converter is smart enough to quote it where required:

// begin-insert: tags/interfaces-to-functions-2.12:src/test/java/travelator/recommendations/RecommendationsTests.kt#when
[source,kotlin]
----
private fun givenFeaturedDestinationsFor(
    location: Location,
    result: List<FeaturedDestination>
) {
    Mockito.`when`(featuredDestinations.findCloseTo(location))
        .thenReturn(result)
}
----
// end-insert

To see how to remove the mocking, it helps to view a function type as a mapping between its input parameters (as a tuple) and its result.
So `destinationFinder` is a mapping between a single `Location` and a `List<FeaturedDestination>.
`distanceInMetersBetween` is a mapping between `Pair<Location, Location>` and `Int`.
++Map++s are our way of expressing a set of mappings, the name isn't accidental after all.
So we can fake a function by populating a `Map` with parameter keys and result values and replacing the function call with a lookup of the supplied parameters.
You may have used this trick to cache the result of expensive calculations.
Here, we won't cache, but seed the `Map` with the parameters and result that we expect to see.

Taking the `destinationFinder` case first, we'll create a property to hold the `Map` - `featuredDestinations`:

// begin-insert: tags/interfaces-to-functions-2.14:src/test/java/travelator/recommendations/RecommendationsTests.kt#featuredDestinations
[source,kotlin]
----
private val featuredDestinations =
    mutableMapOf<Location, List<FeaturedDestination>>()
        .withDefault { emptyList() }
----
// end-insert

`givenFeaturedDestinationsFor` can populate the `destinationLookup` Map` rather than setting expectations on a mock:

// begin-insert: tags/interfaces-to-functions-2.14:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenFeaturedDestinationsFor
[source,kotlin]
----
private fun givenFeaturedDestinationsFor(
    location: Location,
    destinations: List<FeaturedDestination>
) {
    featuredDestinations[location] = destinations.toList()
}
----
// end-insert

If we make `Recommendations` read out of `featuredDestinations` we have passing tests:

// begin-insert: tags/interfaces-to-functions-2.14:src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations
[source,kotlin]
----
private val recommendations =
    Recommendations(
        featuredDestinations::getValue,
        distanceCalculator::distanceInMetersBetween
    )
----
// end-insert

`getValue` is an extension on `Map` that respects the defaults set up by the `Map.withDefault`, and hence does not return `null`.

It won't surprise you when we do the same for `distanceInMetersBetween`, removing all trace of the formal mocking:

// begin-insert: tags/interfaces-to-functions-2.15:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
[source,kotlin]
----
class RecommendationsTests {

    private val featuredDestinations =
        mutableMapOf<Location, List<FeaturedDestination>>()
            .withDefault { emptyList() }
    private val distanceInMetersBetween =
        mutableMapOf<Pair<Location, Location>, Int>()
            .withDefault { -1 }

    private val recommendations =
        Recommendations(
            featuredDestinations::getValue,
            { l1, l2 -> distanceInMetersBetween.getValue(l1 to l2) }
        )
    ...
}
----
// end-insert

// begin-insert: tags/interfaces-to-functions-2.15:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenADistanceFrom
[source,kotlin]
----
private fun givenADistanceFrom(
    location: Location,
    destination: FeaturedDestination,
    distanceInMeters: Int
) {
    distanceInMetersBetween[location to destination.location] =
        distanceInMeters
}
----
// end-insert

It might take a couple of passes to see how that works, or let it go for now and come back to it if you need it.

Having to use a lambda rather than a method reference in the `Recommendations` constructor invocation is a bit irritating.
We can tidy that up with a local `getValue` extension function.
Did we mention how much we like extension functions?

// begin-insert: tags/interfaces-to-functions-2.16:src/test/java/travelator/recommendations/RecommendationsTests.kt#getValue
[source,kotlin]
----
class RecommendationsTests {

    private val featuredDestinations =
        mutableMapOf<Location, List<FeaturedDestination>>()
            .withDefault { emptyList() }
    private val distanceInMetersBetween =
        mutableMapOf<Pair<Location, Location>, Int>()
            .withDefault { -1 }

    private val recommendations =
        Recommendations(
            featuredDestinations::getValue,
            distanceInMetersBetween::getValue
        )

    ...
}

private fun <K1, K2, V> Map<Pair<K1, K2>, V>.getValue(k1: K1, k2: K2) =
    getValue(k1 to k2)
----
// end-insert

Oh, and we can improve the readability of the test methods with some judicious parameter naming and helper methods.
Previously we had plain function calls:

// begin-insert: tags/interfaces-to-functions-2.16:src/test/java/travelator/recommendations/RecommendationsTests.kt#test2
[source,kotlin]
----
@Test
fun deduplicates_using_smallest_distance() {
    givenFeaturedDestinationsFor(
        alton,
        flowerFarm, watercressLine
    )
    givenFeaturedDestinationsFor(
        froyle,
        flowerFarm, watercressLine
    )
    givenADistanceFrom(alton, flowerFarm, 5300)
    givenADistanceFrom(alton, watercressLine, 320)
    givenADistanceFrom(froyle, flowerFarm, 0)
    givenADistanceFrom(froyle, watercressLine, 6300)
    assertEquals(
        listOf(
            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),
            FeaturedDestinationSuggestion(alton, watercressLine, 320)
        ),
        recommendations.recommendationsFor(setOf(alton, froyle))
    )
}
----
// end-insert

A little effort yields:

// begin-insert: tags/interfaces-to-functions-2.17:src/test/java/travelator/recommendations/RecommendationsTests.kt#sugar
[source,kotlin]
----
@Test
fun deduplicates_using_smallest_distance() {
    givenFeaturedDestinationsFor(alton, of(flowerFarm, watercressLine))
    givenADistanceFrom(alton, to = flowerFarm, of = 5300)
    givenADistanceFrom(alton, to = watercressLine, of = 320)

    givenFeaturedDestinationsFor(froyle, of(flowerFarm, watercressLine))
    givenADistanceFrom(froyle, to = flowerFarm, of = 0)
    givenADistanceFrom(froyle, to = watercressLine, of = 6300)

    assertEquals(
        listOf(
            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),
            FeaturedDestinationSuggestion(alton, watercressLine, 320)
        ),
        recommendations.recommendationsFor(setOf(alton, froyle))
    )
}
----
// end-insert

Sometimes a tiny method like `of` can go a long way to letting our brains just read code rather than spending effort interpreting it:

// begin-insert: tags/interfaces-to-functions-2.17:src/test/java/travelator/recommendations/RecommendationsTests.kt#of
[source,kotlin]
----
private fun of(vararg destination: FeaturedDestination)
    = destination.toList()
----
// end-insert

==== Have We Really Weaned Off Mocks Though?

Ah, now that is a good question!

In some ways we have just implemented a poor imitation of a mocking framework - we have no parameter matchers, no way of failing if a method isn't called, no way of expressing execution order.

Looked at another way though, we have implemented the recommendation engine's dependencies as two maps.
`Recommendations.recommendationsFor` is beginning to look like a simple calculation (<<calculations>>).
The result of that calculation depends on the `journey` parameter, and the contents of those maps that enable us to lookup featured destinations and distances.
We know that in reality _when_ we call `recommendationsFor` does matter - it is really an action (<<actions>>).
The distance between locations probably won't change over time, but which destinations we find around a location will, as we add or remove them from whatever database they are held in.
In our tests though, the distinction is moot, and we could treat `recommendationsFor` as a calculation, in much the same way as we saw with `InMemoryTrips` in <<actions-to-calculations>>.
Calculations are easier to test than actions - we just check that a given input returns a given output - so let's pull on this thread.

At the moment, _when_ we call `recommendationsFor` in the tests matters too, because the result will depend on the contents of the `featuredDestinations` and `distanceInMetersBetween` maps.
These are initially empty, and are populated by calls to `givenFeaturedDestinationsFor` and `givenADistanceFrom` - that's a time-sensitivity right there.
What we need is some way to convert an action to a calculation, and we can do that by manipulating scope.
At the beginning of this chapter, we saw that we can view methods as functions with some of their arguments partially applied by capturing them as fields.
In tests, we can reverse this process - we can write a function that creates the object from its dependencies, once for each invocation.
If we call the populated object the subject of the tests, we can create it from the test state like this:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#subjectFor
[source,kotlin]
----
private fun subjectFor(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>
): Recommendations {
    val destinationsLookup = featuredDestinations.withDefault { emptyList() }
    val distanceLookup = distances.withDefault { -1 }
    return Recommendations(destinationsLookup::getValue, distanceLookup::getValue)
}
----
// end-insert

Here we create a new instance of `Recommendations` every call, so that it can capture immutable maps representing the rest of the data.

Now we can write a `resultFor` function that uses `subjectFor`:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#resultFor
[source,kotlin]
----
private fun resultFor(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>,
    locations: Set<Location>
): List<FeaturedDestinationSuggestion> {
    val subject = subjectFor(featuredDestinations, distances)
    return subject.recommendationsFor(locations)
}
----
// end-insert

Outside of the scope `resultFor` function there is no time-sensitivity - so it is effectively a calculation.

Now that we have a simple mapping of input to output, we can write simple tests that call it.
Each test can just specify the input parameters and check the result is as expected, with no need for state in the test at all.

Every test can then be of the form:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#check
[source,kotlin]
----
private fun check(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>,
    recommendationsFor: Set<Location>,
    shouldReturn: List<FeaturedDestinationSuggestion>
) {
    assertEquals(
        shouldReturn,
        resultFor(featuredDestinations, distances, recommendationsFor)
    )
}
----
// end-insert

This gives a pleasing simplicity to the previously confusing tests:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#excerpt
[source,kotlin]
----
class RecommendationsTests {
    companion object {
        val distances = mapOf(
            (paris to eiffelTower.location) to 5000,
            (paris to louvre.location) to 1000,
            (alton to flowerFarm.location) to 5300,
            (alton to watercressLine.location) to 320,
            (froyle to flowerFarm.location) to 0,
            (froyle to watercressLine.location) to 6300
        )
    }

    ...

    @Test
    fun returns_no_recommendations_when_no_featured() {
        check(
            featuredDestinations = emptyMap(),
            distances = distances,
            recommendationsFor = setOf(paris),
            shouldReturn = emptyList()
        )
    }

    ...

    @Test
    fun returns_recommendations_for_multi_location() {
        check(
            featuredDestinations = mapOf(
                paris to listOf(eiffelTower, louvre),
                alton to listOf(flowerFarm, watercressLine),
            ),
            distances = distances,
            recommendationsFor = setOf(paris, alton),
            shouldReturn = listOf(
                FeaturedDestinationSuggestion(alton, watercressLine, 320),
                FeaturedDestinationSuggestion(paris, louvre, 1000),
                FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
                FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
            )
        )
    }
    ...
}
----
// end-insert

It's instructive to compare this with an original test:

// begin-insert: tags/interfaces-to-functions-2.1:src/test/java/travelator/recommendations/RecommendationsTests.java#test1
[source,java]
----
@Test
public void returns_recommendations_for_multi_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    givenFeaturedDestinationsFor(alton,
        List.of(
            flowerFarm,
            watercressLine
        ));
    givenADistanceBetween(alton, flowerFarm, 5300);
    givenADistanceBetween(alton, watercressLine, 320);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(alton, watercressLine, 320),
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
        ),
        recommendations.recommendationsFor(Set.of(paris, alton))
    );
}
----
// end-insert

Admittedly this is broken up a bit by the `givenADistanceBetween` calls, but you can see how this refactoring has migrated our tests from woolly functions that may or may not have a common structure, to a clear testing of inputs against outputs.

=== Conclusion

