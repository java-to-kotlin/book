[[performing-io-to-passing-data]]
== Performing IO to Passing Data

Input and output are problematic in code.
Our program is subject to errors talking to the outside world when files disappear or network sockets fail.
IO is also an action (<<actions>>) and so limits our ability to reason with and refactor our code.
How can we limit the scope of the problems that IO causes?

Now that earlier chapters have built some foundations, we're going to up the pace here, going straight into refactoring and learning lessons as we go.

=== Starting Point

In <<functions-to-extension-functions>>, we looked at some Java code that produced a report for marketing.
When we left the code, we had introduced extension functions to the `HighValueCustomersReport`, giving us:

// begin-insert: tags/bonus.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#all
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

Here are the tests, after conversion to Kotlin:

// begin-insert: tags/bonus.0.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#all
[source,kotlin]
----
class HighValueCustomersReportTests {

    @Test
    fun test() {
        check(
            inputLines = listOf(
                "ID\tFirstName\tLastName\tScore\tSpend",
                "1\tFred\tFlintstone\t11\t1000.00",
                "4\tBetty\tRubble\t10\t2000.00",
                "2\tBarney\tRubble\t0\t20.00",
                "3\tWilma\tFlintstone\t9\t0.00"
            ),
            expectedLines = listOf(
                "ID\tName\tSpend",
                "4\tRUBBLE, Betty\t2000.00",
                "1\tFLINTSTONE, Fred\t1000.00",
                "\tTOTAL\t3000.00"
            )
        )
    }

    ...
    private fun check(
        inputLines: List<String>,
        expectedLines: List<String>
    ) {
        val output = StringWriter()
        generate(
            StringReader(inputLines.joinToString("\n")),
            output
        )
        assertEquals(expectedLines.joinToString("\n"), output.toString())
    }
}
----
// end-insert

=== Listening to the Tests

We didn't really look at the tests in <<functions-to-extension-functions>>, but if we do now, what stands out in the light of our chapter (<<actions-to-calculations>>) discussing calculations and actions?
In particular, look at that `check` function.

`check` is evidently not a calculation (<<calculations>>), as it works entirely by throwing an exception not returning a value.
But look at it this way:

// begin-insert: tags/bonus.0.6:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    val reader = StringReader(inputLines.joinToString("\n"))
    generate(reader, output)
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
// end-insert

This is to all intents and purposes the same code, but now can see that we have a calculation, taking `inputLines` and yielding `outputLines`, before we go on to the assertion.
Even though `generate` is an action, relying on the side effects of reading and writing to and from its parameters, we can convert it to a calculation by limiting the scope of its side effects to local variables.

If we stop for a moment and listen, we may hear the tests talking to us.
They are saying, "Look, that report generation is fundamentally a calculation - it converts a `List<String>` to a `List<String>`.
We know it does, because that's what we are checking."

So the tests are telling us that the fundamental signature of `generate` is `generate(lines: List<String>): List<String>`.
If this was the signature, then it would not have to declare that it throws `IOException` either, because all the IO would happen outside the function.
IO has to happen somewhere, but, in common with other actions, the further to the top of our system we we can move it, the more we can deal in nice easy calculations.

Shall we refactor towards this goal?
You're right, that was a rhetorical question.

As the first stage in our refactor, let's try to wean `generate` off of its `reader` parameter.
The code is currently:

// begin-insert: tags/bonus.2:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

We can convert `generate` to read from a `List` by invoking "Introduce parameter" on the `reader.readLines()` expression, naming the parameter `lines`.
As the expression is the only use of the existing `reader` parameter, IntelliJ removes `reader` for us:

// begin-insert: tags/bonus.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

The refactoring has also moved the `readLines()` out into the callers - here is the result in test:

// begin-insert: tags/bonus.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    val reader = StringReader(inputLines.joinToString("\n"))
    generate(output, reader.readLines())
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
// end-insert

This now shouts what the test was whispering all along.
We were having to create a `StringReader` from a list of lines just in order to parse the lines back out in `generate`.
Now the steps are in the same place in the test we can elide them to remove the `Reader`:

// begin-insert: tags/bonus.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    generate(output, inputLines)
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
// end-insert

We are now reading from a `List`.
Let's go back and look at how to return a `List` too rather than modifying the `Writer`.
Here is the code:

// begin-insert: tags/bonus.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#writer
[source,kotlin]
----
writer.appendLine("ID\tName\tSpend")
for (customerData in valuableCustomers) {
    writer.appendLine(customerData.outputLine)
}
writer.append(valuableCustomers.summarised())
----
// end-insert

Instead of thinking imperatively about the ways that we want to mutate the writer, lets think in terms of the data that we want written and create that:

// begin-insert: tags/bonus.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#resultLines
[source,kotlin]
----
val resultLines = listOf("ID\tName\tSpend") +
    valuableCustomers.map(CustomerData::outputLine) +
    valuableCustomers.summarised()
----
// end-insert

Then we write it in one lump to `writer`:

// begin-insert: tags/bonus.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    val resultLines = listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
    writer.append(resultLines.joinToString("\n"))
}
----
// end-insert

If we now "Extract function" with all but the last line, making it public and calling it `generate` too, we get the following:

// begin-insert: tags/bonus.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val resultLines = generate(lines)
    writer.append(resultLines.joinToString("\n"))
}

fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    val resultLines = listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
    return resultLines
}
----
// end-insert

Inlining the two vestigial `resultLines` gives:

// begin-insert: tags/bonus.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    writer.append(generate(lines).joinToString("\n"))
}

fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

One more inline then, this time of the old `generate` function.
That replaces its invocation in client code - this is the code in the test:

// begin-insert: tags/bonus.9:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    output.append(generate(inputLines).joinToString("\n"))
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
// end-insert

Once again we now have now-redundant IO in our tests, and can simplify everything to:

// begin-insert: tags/bonus.10:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(expectedLines, generate(inputLines))
}
----
// end-insert

This was, after all, what we were aiming for.
Another way of looking at this is that our original `Writer` was an accumulating object, we have replaced it with a transformation as we saw in <<accumulating-objects-to-transformations>>.

Let's take stock of our new `generate`:

// begin-insert: tags/bonus.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)
----
// end-insert

Now that `generate` is doing so much less, it isn't clear that `List<String>.toValuableCustomers()` is worthwhile.
Looking at it afresh we see that it is working at mixed levels, converting and filtering.
Let's inline it:

// begin-insert: tags/bonus.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

That's better, assigning to the local variable does a good job of telling us what the expression means, and the list operations spell out the implementation in place.
This is a case where a single-expression function (<<multi-to-single-expression-functions>>) would probably make things worse, so we'll leave the local alone.
We'll also resist the temptation to make it an extension function, `List<String>.toReport()`, at least for now.

.Refactoring for Readability
****
Refactoring for readability is often this way.
We extract a function to make something more readable in context, but when the context changes the function makes things worse.
Sometimes, something that we felt was quite expressive when we wrote it, turns out to be less so when we read it back later.
Even in the best-gelled teams, individuals also differ in their preferences.
****

=== Efficient Writing

We're quite pleased with this refactor.
It has simplified our tests and the production code, and we have moved from imperative code that mixes IO and logic to a nice pure function with no side-effects.
For a while all is fine in production too, but with the easing of COVID-19 travel restrictions, Travelator becomes the roaring success that we all knew it would be.
Eventually marketing start complaining that the report generation is failing with an `OutOfMemoryError`.
Could we look into it?

We haven't bothered you with the details so far, but there is a `main` method that invokes our report.
It is designed to be invoked with shell redirection, reading from a file piped as the standard input, and writing to a file collected from the standard output.
It started out as Java:

// begin-insert: tags/functions-to-extension-methods.0:src/main/java/travelator/marketing/HighValueCustomersMain.java
[source,java]
----
public class HighValueCustomersMain {

    public static void main(String[] args) throws IOException {
        try (
            var reader = new InputStreamReader(System.in);
            var writer = new OutputStreamWriter(System.out)
        ) {
            HighValueCustomersReport.generate(reader, writer);
        }
    }
}
----
// end-insert

You can see that by reading and writing this way we don't have to worry about reading filenames from the command-line.
We have had two issues with errors in living memory.
Both these times the input file turned out to have been malformed, but marketing sit next door and just call us over to help if these occur.
They give us cake in these cases, so we're hardly incentivized to do a better job of error handling for now (but see <<bonus-error-handling>>).
If we can fix the `OutOfMemoryError` quickly we think we saw some crumpets...

At some point we converted `main` to Kotlin:

// begin-insert: tags/bonus.0:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    InputStreamReader(System.`in`).use { reader ->
        OutputStreamWriter(System.out).use { writer ->
            generate(reader, writer)
        }
    }
}
----
// end-insert

Then it was refactored with the change to the `generate` parameters:

// begin-insert: tags/bonus.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.append(
                generate(
                    reader.readLines()
                ).joinToString("\n")
            )
        }
    }
}
----
// end-insert

Ah, there's our problem.
We're reading the whole of the input into memory (`readLines()`), processing it, and then creating the entire output in memory (`joinToString()`) before writing it back out.

We sometimes run into problems like these with functional decomposition.
Less often than we might anticipate, but in this case it's ironic that the original `Reader` and `Writer` code did not have this issue, so we have brought it on ourselves in the name of good style.
We could quickly revert our changes and go and see if there are any crumpets left, or we could find a more functional solution.

Let's go back to `generate` and see what leeway we have.

// begin-insert: tags/bonus.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

Concentrating on the output for now, we can see that we are building a list of the lines of the output
 - each of those strings won't be sharing any memory with the data that we parsed from the input.
This is then combined into one large string in `main`, that again doesn't share any memory with the lines that created it.
In these situations we want to defer the creation of the intermediates, and, as we saw in <<streams-to-sequences>> `Sequences` are designed for just that.
As we'll see, they aren't a panacea, but here they will do nicely.

We can convert `generate` to return a sequence methodically or quickly - for once we'll choose quickly and just replace `listOf` with `sequenceOf` in our `return` expression:

// begin-insert: tags/bonus.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

Now we will only be creating the output lines one at a time when the stream is iterated -- each line can be disposed of quickly rather than hanging around until we have written the whole file.

The tests have to change to convert the `Sequence` to a `List`:

// begin-insert: tags/bonus.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(
        expectedLines,
        generate(inputLines).toList()
    )
}
----
// end-insert

Interestingly though, `main` does not:

// begin-insert: tags/bonus.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.append(
                generate(
                    reader.readLines()
                ).joinToString("\n")
            )
        }
    }
}
----
// end-insert

`main` needs to be _recompiled_ now that `generate` returns a `Sequence` rather than a `List`, but its source doesn't need to be changed.
This is because there are extension functions `joinToString(...)` defined on both `Iterable` and `Sequence`, both returning `String`.

It might not _need_ to change, but unless `main` _does_ change, we are still creating one large string of all the output.
To avoid that we need to get imperative again:

// begin-insert: tags/bonus.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            generate(
                reader.readLines()
            ).forEach { line ->
                writer.appendLine(line)
            }
        }
    }
}
----
// end-insert

The pedantic reader (don't worry, you're amongst friends) will have spotted that this behaviour is subtly different to the `joinToString("\n")` version.
We're quietly confident that a trailing newline won't break anything, so we press on.

We can always pretend we aren't looping by hiding the iteration inside a `Writer::appendLines` extension function that we assumed the Kotlin standard library would define, but doesn't seem to:

// begin-insert: tags/bonus.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(reader.readLines())
            )
        }
    }
}

fun Writer.appendLines(lines: Sequence<CharSequence>): Writer {
    return this.also {
        lines.forEach(this::appendLine)
    }
}
----
// end-insert

Note that while the result of `Writer::appendLines` is a single expression, we agreed in <<multi-to-single-expression-functions>> to use long-form where functions are actions, and `appendLines` is defiantly that.

Now each `CustomerData::outputLine` inside `generate` will only be called when its line is required to be written to the `Writer`.
This saves memory, but has the interesting effect that the code inside `generate` can throw an `IOException` if the writing fails.
For now, we're going to put that aside, but it will play on our minds until we find a resolution.
The truth is that ++Sequence++s let us pretend that we are programming with values and calculations rather than actions, but they are a leaky abstraction.

On the other hand, they have dug us out of a hole here, and writing to a `Sequence` has fewer leaks than reading from one.
So we'll push this, having bought ourselves lots of memory headroom with few changes and earned our crumpets.
Do marketing have any butter?

=== Efficient Reading

We would be remiss if we didn't finish the job and pretend that we also need to save memory on reading too.
Let's try a `Sequence` again:

// begin-insert: tags/bonus.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

We aren't going to be able to stream data straight through `generate` because of that `sortedBy`.
In order to sort, we have to have all the elements in memory at once.
Where we can make savings is in the new instances of `List` that are being created for each of the stages of that pipeline - each one has a non-trivial overhead per item.
In addition, we are keeping each line of the input in memory even after we've split it out into the fields of `CustomerData`.
Reading from a `Sequence` will solve these problems, but bring a few of its own.

We can see this if we change the code in `generate` to convert the `lines` to a `Sequence`, and fix up the methods that did take `List`.

// begin-insert: tags/bonus.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .asSequence()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun Sequence<String>.withoutHeader() = drop(1)

private fun Sequence<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

This passes the tests.
Are we done?
Is this another rhetorical question?

Let's cut to the chase and say that the issue is that we end up iterating through the `Sequence` twice.
Once before we return from `generate` in that `sumByDouble`, and again when we fetch the whole report.
We will be doing twice as much work as we need to.
Worse, when we finally get around to passing a `Sequence` reading from a file, we won't be able to iterate over that twice, giving an `IllegalStateException`.
As we saw in <<streams-to-sequences>>, in the same way that there are differences in the runtime behaviour of ++Lists++s that are not expressed in the type system, instances of ++Sequence++s differ, and they also carry hidden state.
Iterating over a `Sequence` looks like iterating over from a `List`, but will change the `Sequence` itself by consuming its contents.

We can show that we are abusing this `Sequence` by adding a `.constrainOnce()` call:

// begin-insert: tags/bonus.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
    val valuableCustomers = lines
        .asSequence()
        .constrainOnce()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
----
// end-insert

This will cause our tests to fail with an `IllegalStateException`.
The simplest fix is to resolve the `Sequence` with a `.toList()` call.

// begin-insert: tags/bonus.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
    val valuableCustomers = lines
        .asSequence()
        .constrainOnce()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
----
// end-insert

This will lead to our terminating the whole sequence (and hence ultimately reading the whole file) in that statement, but at least it will only try once, and the memory for each line can be discarded as soon as it is parsed.

Now we can replay the "Introduce parameter" refactoring with the `lines.asSequence().constrainOnce()` expression to convert `generate` to take `Sequence<String>`:

// begin-insert: tags/bonus.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: Sequence<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

Converting a `List` to a `Sequence` will have been pulled up into the tests:

// begin-insert: tags/bonus.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(
        expectedLines,
        generate(
            inputLines.asSequence().constrainOnce()
        ).toList()
    )
}
----
// end-insert

It will also have been pulled up into `main`:

// begin-insert: tags/bonus.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(
                    reader.readLines().asSequence().constrainOnce()
                )
            )
        }
    }
}
----
// end-insert

Instead of reading all the lines as once and converting to a `Sequence`, we can get a `Sequence` from the `Reader` with `buffered().lineSequence()`:

// begin-insert: tags/bonus.19.5:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(
                    reader.buffered().lineSequence()
                )
            )
        }
    }
}
----
// end-insert

We're now really quite efficient in our use of memory, and run pleasingly quickly.
Can we resist one last tinker?
How much nicer would `main` read with more extension functions?

// begin-insert: tags/bonus.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            reader
                .asLineSequence()
                .toHighValueCustomerReport()
                .writeTo(writer)
        }
    }
}
----
// end-insert

Which finally answers the question we posed back in <<functions-to-extension-functions>> - yes we do end up with report generation as an extension function:

// begin-insert: tags/bonus.20:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

=== Conclusion

That completes our moving of the input and output from the inside of `generate` to the outside of our program.
Actually, we technically refactored IO out, converting `generate` to a calculation on `List<String>`, only until that became too inefficient.
Calculations take and return values, and forming a value of the entire contents of large files may be too much for even today's computers.

At this point we resorted to converting our ++List++s to ++Sequence++s.
Sequences have state and are not values, but with a little care we can treat them like lazy values -- lazy in that we don't need all their contents up front, but can read or supply them on demand.
They aren't as simple as values, but their compatible Kotlin API allows something of the best of both worlds.

Before we go, we should note that while the original version of `generate` had to worry about `IOExceptions`, the new version doesn't.
Or at least, the new version doesn't worry about IO errors because they are hidden from it by the `Sequence` abstractions wrapping the `Reader` and `Writer`.
That doesn't mean that they can't happen, just that `generate` isn't warned that they can.
We'll take a break to see if marketing have any more batter-based rewards before addressing that topic in <<bonus-error-handling>>.
