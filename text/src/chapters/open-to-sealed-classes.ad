[[open-to-sealed-classes]]
== Open to Sealed Classes

In Java, we can define polymorphic methods on classes. We can use interfaces to define sets of polymorphic. methods, independently of any class that implements them.  Later, we can define a class that implements the interface and the implementations of the methods of that interface for that class.

Calling polymorphic methods is supported by the type checker: we cannot call a method if the class does not implement it.

The drawback of interfaces is that you have to declare that a class implements an interface in the definition of a class.  You can't add an interface to a class without changing its definition.  Java programmers turn to design patterns, like the Adapter, Bridge and Decorator patterns, to work around the fact that we cannot add interfaces to a class without recompiling it.

As a result, key types in a Java application's domain model tend to become "God Objects" with many methods that support different aspects of the application.  Or methods gets moved from the domain model class into "Helper" or "Util" classes that end up a grab-bag of loosely related functionality that is awkward to use compared to a method on the class itself.

As a last resort, when classes do not define a common interfaces, or the operations we want to perform are very different for different types, Java programmers resort to run-time type checks , using the `instanceof` and downcast operators to run different code for different classes of object.
This is risky: the type checker cannot tell if we have forgotten necessary cases, nor if we are covering _unnecessary_ cases.
As we change code, it is easy to introduce bugs or leave dead code in the codebase that is hard to identify and remove.

God Objects, Helper classes, and run-time type checks are all considered to be "code smells" -- visible symptoms of design flaws.
But what's the alternative?
At the time of writing, Javafootnote:[At least up to Java 14. A future version of Java will have sealed classes.] only gives us classes, methods, and interfaces for modelling.
The code smells we see in Java are a consequence of this limited set of abstraction mechanisms.

Kotlin classes, like Java classes, can have polymorphic methods and implement interfaces, and classes must be declared to implement an interface.
This simplifies interop with Java, but means that, like Java, you cannot introduce polymorphism to an object without changing its class definition.

However, Kotlin has another mechanism for organising classes and behaviour: _sealed classes_.
A sealed class is an abstract class with a fixed set of subclasses, defined in the same source file.
The compiler prevents you from subclassing the sealed class elsewhere.
Thanks to this restriction, run-time type checks on sealed class hierarchies do not have the same drawbacks as run-time type checks in Java.
The type checker can guarantee that `when` expressions that test the subtype of a sealed class cover all possible cases and only possible cases.

Object-oriented polymorphism assumes that the set of operations varies infrequently, and the set of types the operations apply to varies frequently.  It is much easier to extend a program by adding another class that implements an interface than it is to add another method to an interface implemented by many classes.  The JVM can even load new classes into a running program, as long as they implement an interface compiled into the program.

Sealed class hierarchies and `when` expressions assume the opposite: that the set of operations varies more frequently than the set of types they apply to.
It is much easier to write another function that is conditional on the concrete subclass of a sealed class than it is to add another subclass to every existing when expressions.

Kotlin has no mechanism that lets you define a type and operations in a way that let you easily vary both the types that the operations apply to, and the operations that apply to the types, with static type safety and without modifying existing code.
You have to choose which approach you'll use for a class based on which aspect, subtypes or operations, you expect to vary most frequently as the program evolves.


=== Itinerary -- A Core Type in Our Application

We can see this tension play out in the evolution of the `Itinerary` type.
The traveller's itinerary is a core concept in our travel planning application.
Many features of the application present views of, alter the contents of, or calculate information about Itinerary objects.

In <<accumulating-objects-to-transformations>> we modelled the itinerary as a data class with fields holding the route and a list of accommodation required along the route.
As we extended the application and added more types of item to the itinerary, we found it increasingly cumbersome to hold each type of itinerary item in a separate collection.
Too much of our code involved combining those collections or applying the same filters and transforms to separate collections.
We decided to maintain a single collection of itinerary items rather than keep each type of itinerary item in a separate collection.
In this model, an `Itinerary` _is_ a list of `ItineraryItem`, just as we defined a `Route` to be a list of `Journey` in <<encapsulated-collections-to-typealiases>>.

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt
[source,kotlin]
----
typealias Itinerary = List<ItineraryItem>
----
// end-insert

ItineraryItem is an interface, implemented by the concrete item types: `Journey`, `Accommodation`, `Restaurant` and `Attraction`.

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
interface ItineraryItem {
    fun description(): String
    fun costs(): Sequence<Money>
    fun geoShape(): GeoShape
    fun timespan(): ClosedRange<ZonedDateTime>?
    fun sufferScore(): Int = 0
    ... and other methods
}
----
// end-insert

.Aside
****
This design the pleasing effect that a `Route`, which we get back from our routing service, already _is_ an `Itinerary`.
Because a `Journey` is a subtype `ItineraryItem`, and List declared as `List<out T>` because it is unmodifiable, a `List<Journey>` is a subtype of `List<ItineraryItem>`.
We can receive a Route from our routing service and start using it as an Itinerary -- for example, to add accommodation -- without having to copy elements from one type to the other.
****

Giving all itinerary items a polymorphic interface means the itinerary operations do not depend on the concrete type of the items in the itinerary.
For example:

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryCosts.kt
[source,kotlin]
----
fun Itinerary.costs() = flatMap(ItineraryItem::costs)
----
// end-insert

This lets us easily add new types of `ItineraryItem` to our application.
However, in practice we do this very rarely.
`Itinerary` and `ItineraryItem` are such fundamental types in our system, that we are far more likely to add operations to `ItineraryItem` to support new features of the application than to add new types of `ItineraryItem`.
The more things we want to to do with itineraries, the more methods we end up adding to the `ItineraryItem` interface.
Clearly a polymorphic interface is the wrong mechanism to support the variability we need for our application.
Interfaces work well when we have a stable set of operations and a varying set of concrete types that those operations apply to.
We have a stable set of ItineraryItem types, but a frequently changing set of operations.

In Java, we might be tempted to hive each of those operations off into static methods of a helper class, and use run time type checks, with the `instanceof` operator and type casts, to switch on the concrete type of the `ItineraryItem`.
... write about drawbacks and risks here ...
... explain why: no support from the type checker.

To be type safe, we might use https://wiki.c2.com/?DoubleDispatch[Double Dispatch], but this involves  a lot of boilerplate code and, in Java, does not play well with checked exceptions.

Those options are possible in Kotlin too, and carry the same overheads and risks.
Luckily in Kotlin we have another option: _sealed classes_.
A sealed class has a fixed set of subclasses, that must all be defined in the same source file.
This allows the compiler to check that run time type checks are exhaustive.   If you do not have a branch for each subclass, compilation fails.  If you do have an exhaustive run time type check, you do not need an `else` clause, and compilation will fail if you add a new subclass and forget to update all the conditional logic.


=== Converting the Interface to a Sealed Class

First move interface and implementations to the same file.

Then make interface a sealed class and the implementations extend the class.

Can't do this automatically.
Have to do it by manual editing.
At least having them all in the same file makes that a bit easier.

// begin-insert: tags/open-to-sealed.2:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem {
    abstract fun description(): String
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    abstract fun timespan(): ClosedRange<ZonedDateTime>?
    open fun sufferScore(): Int = 0
    ... and other methods
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    override fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}

... and other subclasses
----
// end-insert

Now we can move operations from being polymorphic methods defined on the sealed class and into extension functions that use `when` expressions to switch on the type of item.

Let's do this with the `costs` method.

When we Alt-Enter on the definition of costs in `ItineraryItem`, the context menu includes the action "Convert member to extension".
Can it really be that easy?
Unfortunately, no.
That gets us part of the way there, but leaves `override` modifiers on the `costs` methods in the concrete subclasses that longer override anything, and implements the extension function merely with a `TODO` that throws `UnsupportedOperationException`.
We'll have to fix it up by hand by removing the `override` modifiers, and implementing the extension method with when expression that switches on the type of `ItineraryItem` and calls the now monomorphic `costs` method on each concrete class.

// begin-insert: tags/open-to-sealed.3:src/main/java/travelator/itinerary/ItineraryCosts.kt
[source,kotlin]
----
fun Itinerary.costs() = flatMap(ItineraryItem::costs)

fun ItineraryItem.costs() = when (this) {
    is Journey -> costs()
    is Accommodation -> costs()
    is Restaurant -> costs()
    is Attraction -> costs()
}
----
// end-insert

Intellij highlights each monomorphic call to `costs` to indicate that the compiler is "smart casting" the `this` reference from ItineraryItem to the correct subclass thanks to flow typing.
While we are writing the `when` expression, Intellij marks it as an error, and the compiler will report a type error, until it covers every subclass of `ItineraryItem`.

We can now inline those `costs` methods into the extension function, removing them from the concrete classes.

// begin-insert: tags/open-to-sealed.4:src/main/java/travelator/itinerary/ItineraryCosts.kt
[source,kotlin]
----
fun Itinerary.costs() = flatMap(ItineraryItem::costs)

fun ItineraryItem.costs() = when (this) {
    is Journey -> sequenceOf(price)
    is Accommodation -> sequenceOf(totalPrice)
    is Restaurant -> emptySequence()
    is Attraction -> emptySequence()
}
----
// end-insert

// begin-insert: tags/open-to-sealed.4:src/main/java/travelator/itinerary/Itinerary.kt#accommodation
[source,kotlin]
----
data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun geoShape(): GeoShape = pointShape(location.position)
    override fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}
----
// end-insert


TBD below here....

[TIP]
.Only typecast down a sealed class hierarchy
****

Only use typecasts to cast from the root of a sealed class hierarchy to one of the children in an exhaustive when expression.

Otherwise, don't cast your way out of the static types.

Example of errors that can occur if casting: listOf(1,2,3) returns a the List interface of a mutable list.  If you cast it to MutableList you can mutate a list that code is expecting to be (and typed) as unmodifiable.
****



[WARNING]
.When statements are not checked for exhaustiveness
****
When expressions are checked for exhaustiveness but when _statements_ are not.  If all the branches of a `when` expression evaluate to `Unit` and the value of the entire `when` expression is never used, the `when` is considered to be a statement. In that case, even if downcasting an instance of a sealed class, the branches will not be checked for exhaustiveness.

You can force an exhaustive check by using the `Unit` value of the when statement.  For example, the following extension function will use the `Unit` value it is called upon.

----
val Unit.exhaustive get() = this
----

It can be used like this to make the compiler check a `when` statement for exhaustiveness.

----
when (instanceOfSealedClass) {
    is SubclassA => { println("A") }
    is SubclassB => { println("B") }
}.exhaustive
----
****


