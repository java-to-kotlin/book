[[open-to-sealed-classes]]
== Open to Sealed Classes

A constant challenge of software design is managing _variability_: how can we add new behaviour without having to change many parts of the code at once.
We can think of variability as affecting two dimensions: the set of data types in our system, and the set of operations we need to apply to those data types.
Different language features, and different languages, provide more or less support for variation along each dimension.

Java's principal feature to support variability is object-oriented polymorphism.
We define operations as polymorphic methods on classes or interfaces that can be implemented or overridden by subclasses.
It is easy to add new types that have their own implementation of existing operations.
However, every time we want to add a new operation, we have to add it to the supertype and add an implementation to all existing subtypes.
Also, because we must define operations on the types, interfaces or superclasses tend to "attract" behaviour to support distantly related parts of the application.
Paradoxically, where we need variability of operations rather than data types, object-oriented polymorphism can _increase_ coupling!

Java doesn't have a mechanism to support variability when the set of operations changes more frequently than the set of data types.
Design patterns that help us work around this limitation , such as Double Dispatch or Visitor, require boilerplate code and don't play well with Java's checked exceptions.
As a last resort, Java programmers turn to run time type checks, using the `instanceof` and downcast operators, to run different code for different classes of object.
This is risky. The compiler can type check our use of polymorphic methods, but cannot tell if our run time type checks cover all necessary cases, or if they cover _unnecessary_ cases.
When we change code, it is easy to introduce bugs or leave dead code in the codebase that is hard to recognise and remove.

Kotlin classes, like Java classes, can have polymorphic methods and implement interfaces.
However, Kotlin has another mechanism for organising classes and behaviour: _sealed classes_.
A sealed class is an abstract class with a fixed set of subclasses, defined in the same source file.
The compiler prevents you from subclassing the sealed class elsewhere.
Thanks to this restriction, run-time type checks on sealed class hierarchies do not have the same drawbacks as run-time type checks in Java.
The static type checker can guarantee that `when` expressions that perform run time type checks for a subtype of a sealed class cover all possible cases and only possible cases.
It is much easier to write another function that is conditional on the concrete subclass of a sealed class than it is to add another subclass to every existing when expressions.

Managing variability in a Kotlin codebase means recognising when to apply these two mechanisms: object-oriented polymorphism when the set of data types varies more frequently than the set of operations on those data types, and run time type checks of sealed class hierarchies when the set of operations varies more frequently than the set of data types they apply to.
Unlike Haskell, Scala, Rust or Swift, Kotlin has no mechanism that lets you vary both types _and_ operations without modifying existing code.
You have to choose which approach you'll use for a class based on which dimension, types or operations, you expect to vary most frequently as the program evolves.


=== Itinerary -- A Core Type in Our Application

We can see this tension play out in the evolution of the `Itinerary` type.
The traveller's itinerary is a core concept in our travel planning application.
Many features of the application present views of, alter the contents of, or calculate information about Itinerary objects.

In <<accumulating-objects-to-transformations>> we modelled the itinerary as a data class with fields holding the route and a list of accommodation required along the route.
As we extended the application and added more types of item to the itinerary, we found it increasingly cumbersome to hold each type of itinerary item in a separate collection.
Too much of our code involved combining those collections or applying the same filters and transforms to separate collections.
We decided to maintain a single collection of itinerary items rather than keep each type of itinerary item in a separate collection.
In this model, an `Itinerary` _is_ a list of `ItineraryItem`, just as we defined a `Route` to be a list of `Journey` in <<encapsulated-collections-to-typealiases>>.

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt
[source,kotlin]
----
typealias Itinerary = List<ItineraryItem>
----
// end-insert

ItineraryItem is an interface, implemented by the concrete item types: `Journey`, `Accommodation`, `Restaurant` and `Attraction`.

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
interface ItineraryItem {
    fun description(): String
    fun costs(): Sequence<Money>
    fun geoShape(): GeoShape
    fun timespan(): ClosedRange<ZonedDateTime>?
    fun sufferScore(): Int = 0
    ... and other methods
}
----
// end-insert

.Aside
****
This design the pleasing effect that a `Route`, which we get back from our routing service, already _is_ an `Itinerary`.
Because a `Journey` is a subtype `ItineraryItem`, and List declared as `List<out T>` because it is unmodifiable, a `List<Journey>` is a subtype of `List<ItineraryItem>`.
We can receive a Route from our routing service and start using it as an Itinerary -- for example, to add accommodation -- without having to copy elements from one type to the other.
****

Giving all itinerary items a polymorphic interface means the itinerary operations do not depend on the concrete type of the items in the itinerary.
For example:

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryTimespan.kt
[source,kotlin]
----
fun Itinerary.timespan(): ClosedRange<ZonedDateTime>? =
    map(ItineraryItem::timespan)
        .filterNotNull()
        .reduceOrNull { a, b ->
            minOf(a.start, b.start)..maxOf(a.endInclusive, b.endInclusive)
        }
----
// end-insert

This lets us easily add new types of `ItineraryItem` to our application.
However, in practice we do this very rarely.
`Itinerary` and `ItineraryItem` are such fundamental types in our system, that we are far more likely to add operations to `ItineraryItem` to support new features of the application than to add new types of `ItineraryItem`.
The more things we want to to do with itineraries, the more methods we end up adding to the `ItineraryItem` interface.
Clearly a polymorphic interface is the wrong mechanism to support the variability we need for our application.
Interfaces work well when we have a stable set of operations and a varying set of concrete types that those operations apply to.
We have a stable set of ItineraryItem types, but a frequently changing set of operations.

In Java, we might be tempted to implement those operations as static methods of a helper class that use run time type checks, with the `instanceof` operator and type casts, to switch on the concrete type of the `ItineraryItem`.
For example:

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItems.java#type_switch
[source,java]
----
if (item instanceof Journey) {
    var journey = (Journey) item;
    return ...
} else if (item instanceof Accommodation) {
    var accommodation = (Accommodation) item;
    return ...
} else if (item instanceof Restaurant) {
    var restaurant = (Restaurant) item;
    return ...
} else {
    throw new IllegalStateException("should never happen");
}
----
// end-insert

There are two problems with this approach.
If returning a value from the method, we have to write an else clause to return a dummy value or throw an exception, even if we have branches for every subclass of `ItineraryItem` and the else clause cannot possibly be executed.
The type checker cannot tell if our conditional statement is _exhaustive_ -- has tested for all possible subclasses.
We might miss an existing subclass, or add a new case sometime later and not realise that we have to also update conditional statements in other classes.
In this example, we _have_ missed a subclass: our application will throw an exception when an Itinerary contains an `Attraction``.

To ensure type safety we could consider https://wiki.c2.com/?DoubleDispatch[Double Dispatch], but this pattern involves a lot of boilerplate code and, because it does not play well with checked exceptions, is not widely used in Java.

Those options are available in Kotlin too, and carry the same overheads and risks.
However, Kotlin provides an alternative that is safer than typechecks and downcasting and more convenient than Double Dispatch: _sealed classes_.

A sealed class has a fixed set of subclasses, that must all be defined in the same source file.
This allows the compiler to ensure that run time type checks are exhaustive.
Compilation fails if you do not have a branch for every subclass.
If run time type checks are exhaustive, we do not have to write an `else` clause.

Let's convert `ItineraryItem` from an interface with polymorphic methods into a sealed class hierarchy and free-standing functions.


=== Converting the Interface to a Sealed Class

A sealed class and all its subclasses must be defined in the same file.  So we must first use the IDE's Move Class refactoring to move the implementations of `ItineraryItem` into the same file as the interface.

Now we can turn the interface and its implementations into a sealed class hieararchy.
IntelliJ does not have an automated refactoring for this, so we have to do it by manually editing the code.
At least this is made easier by now having all the classes in the same file.

/// begin-insert: tags/open-to-sealed.2:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem { // <1>
    abstract fun description(): String // <2>
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    abstract fun timespan(): ClosedRange<ZonedDateTime>?
    open fun sufferScore(): Int = 0 // <3>
    ... and other methods
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() { // <4>
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    override fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}

... and other subclasses
----
/// end-insert

<1> The class declaration is marked with the `sealed` modifier.

<2> Because `ItineraryItem` is now a class, not an interface, abstract methods must now be explicitly declared as `abstract`.

<3> Any methods of the interface that had a default implementation must be declared as `open` so they can be overridden by subclasses.

<4> The declaration of the interface in the concrete item classes must be replaced with a call to the superclass constructor, which in our case has no arguments.

Now we can move operations from being polymorphic methods defined on the sealed class and into extension functions that use `when` expressions to switch on the type of item.

Let's do this with the `timespan` method.

When we Alt-Enter on the definition of `timespan` in `ItineraryItem`, the context menu includes the action "Convert member to extension".
Can it really be that easy?
Unfortunately, no.
At the time of writing, the IDE action only gets us part of the way there and leaves us with code that does not compile.

/// begin-insert: tags/open-to-sealed.3:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem {
    abstract fun description(): String
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    open fun sufferScore(): Int = 0 // <1>
    ... and other methods
}

fun ItineraryItem.timespan(): ClosedRange<ZonedDateTime>? { // <2>
    TODO("Not yet implemented")
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    override fun timespan() = checkInFrom..checkOutBefore // <3>
    ... and other methods
}

... and other subclasses
----
/// end-insert

<1> The IDE removed the timespan method from the `ItineraryItem` class
<2> but it generated a `timespan` extension function that contains only a `TODO` that throws `UnsupportedOperationException`.
<3> and left `override` modifiers on the `timespan` methods in the concrete subclasses, which no longer have a method in the superclass to override.

We'll have to fix it up by hand by removing the `override` modifiers, and implementing the body extension method as a when expression that switches on the type of `ItineraryItem` and calls the now monomorphic `timespan` method on each concrete class.

/// begin-insert: tags/open-to-sealed.4:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem {
    abstract fun description(): String
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    open fun sufferScore(): Int = 0
    ... and other methods
}

fun ItineraryItem.timespan(): ClosedRange<ZonedDateTime>? {
    return when (this) {
        is Accommodation -> timespan()
        is Journey -> timespan()
        is Restaurant -> timespan()
        is Attraction -> timespan()
    }
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}

... and other subclasses
----
/// end-insert

While we are writing the `when` expression, Intellij marks it as a type error until it covers all subclasses of `ItineraryItem`.
Intellij also highlights each monomorphic call to `timespan` to show that the compiler's flow-sensitive typing is "smart casting" the `this` reference from `ItineraryItem` to the correct subclass.

[WARNING]
.When statements are not checked for exhaustiveness
****
The compiler checks when expressions for exhaustiveness but does not check when _statements_.
It considers a `when` to be a statement if the value of the entire `when` expression is never used.

You can force the compiler to check for exhaustiveness by using the value of the when statement, even though it is of type `Unit`.
If the `when` is the only statement in the body of a function, you can refactor the function to single-expression form.
If the body of the function has multiple statements and the `when` is the last statement, you can explicitly use its value with the `return` keyword.
If the `when` statement is in the middle of the function body you can extract it to its own function if that makes sense.
When none of those options apply, you can use the following utility function to use value of the `when` statement and force an exhaustiveness check:

/// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_definition
[source,kotlin]
----
val <T> T.exhaustive get() = this
----
/// end-insert

It can be used like this to make the compiler check a `when` statement for exhaustiveness:

/// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_usage
[source,kotlin]
----
when (instanceOfSealedClass) {
    is SubclassA -> println("A")
    is SubclassB -> println("B")
}.exhaustive
----
/// end-insert
****


We can inline those `timespan` methods into the extension function, removing them from the concrete classes.

/// begin-insert: tags/open-to-sealed.6:src/main/java/travelator/itinerary/Itinerary.kt#inlined
[source,kotlin]
----
fun ItineraryItem.timespan() = when (this) {
    is Accommodation -> checkInFrom..checkOutBefore
    is Journey -> departureTime..arrivalTime
    is Restaurant -> time..time + Duration.ofHours(2)
    is Attraction -> null
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    ... and other methods
}

... and other subclasses
----
/// end-insert

The `ItineraryItem.timespan` does not need to be defined in the same file as the ItineraryItem class hierarchy.
We can move it to a file or package that is more convenient:
a good place is next to `Itinerary.timespan`

/// begin-insert: tags/open-to-sealed.7:src/main/java/travelator/itinerary/ItineraryTimespan.kt
[source,kotlin]
----
fun Itinerary.timespan(): ClosedRange<ZonedDateTime>? =
    map(ItineraryItem::timespan)
        .filterNotNull()
        .reduceOrNull { a, b ->
            minOf(a.start, b.start)..maxOf(a.endInclusive, b.endInclusive)
        }

fun ItineraryItem.timespan() = when (this) {
    is Accommodation -> checkInFrom..checkOutBefore
    is Journey -> departureTime..arrivalTime
    is Restaurant -> time..time + Duration.ofHours(2)
    is Attraction -> null
}
----
/// end-insert

[WARNING]
.Only typecast down a sealed class hierarchy
****
Only use typecasts to cast from the root of a sealed class hierarchy to one of the children in an exhaustive when expression.
Otherwise, it is risky to cast away from the static type.
The actual class used to implement a value may have operations that violate the constraints expressed by the static type.
For example, as we saw in <<java-to-kotlin-collections>>, the static type List prevents mutation, but Kotlin's higher-order functions return an object of a class that can be mutated if you downcast from List to MutableList.
Doing so will likely introduce bugs in code that does not expect a value of type List returned from a higher-order function to ever change.
****


=== Conclusion

One of the many difficulties in software design is managing _variability_: how can we add new behaviour without having to change many parts of the code at once.
We can think of variability on two axes: the set of data types in our system, and the set of operations we need to apply to those data types.
Object-oriented polymorphism helps programmers cope with variability when the set of data types changes more frequently than the set of operations.
Java doesn't have a mechanism supporting variability in the opposite case: when the set of operations changes more frequently than the set of data types.
Programmers have had to work around it by using run time type checks, which make it more difficult and risky to introduce new types when you do need to because the type system cannot help you, or by using double dispatch, which involves a lot of boilerplate code and doesn't play nicely with checked exceptions.

In Kotlin we can use sealed classes when the set of operations is likely to change frequently than the set of types they apply to.
Our use of sealed classes is checked by the type system, and involves little boilerplate code.

The functional language Haskell introduced _type classes_, which allow you to easily vary both data types _and_ their operations.
This has been adopted by other languages, such as Scala, Rust and Swift.
Kotlin does not have a mechanism that supports varying both data types and their operations.
When modelling your domain you have to make a choice whether operations will be dispatched by object-oriented polymorphism or by testing for subtypes of a sealed class.
If your bet turns out to have been wrong, you can refactor from one form to the other.
