[[open-to-sealed-classes]]
== Open to Sealed Classes

In Java, we can define polymorphic methods on classes. We can use interfaces to define sets of polymorphic. methods, independently of any class that implements them.  Later, we can define a class that implements the interface and the implementations of the methods of that interface for that class.

Calling polymorphic methods is supported by the type checker: we cannot call a method if the class does not implement it.

The drawback of interfaces is that you have to declare that a class implements an interface in the definition of a class.  You can't add an interface to a class without changing its definition.  Java programmers turn to design patterns, like the Adapter, Bridge and Decorator patterns, to work around the fact that we cannot add interfaces to a class without recompiling it.

As a result, key types in a Java application's domain model tend to become "God Objects" with many methods that support different aspects of the application.  Or methods gets moved from the domain model class into "Helper" or "Util" classes that end up a grab-bag of loosely related functionality that is awkward to use compared to a method on the class itself.

As a last resort, when classes do not define a common interfaces, or the operations we want to perform are very different for different types, Java programmers resort to run-time type checks , using the `instanceof` and downcast operators to run different code for different classes of object.
This is risky: the type checker cannot tell if we have forgotten necessary cases, nor if we are covering _unnecessary_ cases.
As we change code, it is easy to introduce bugs or leave dead code in the codebase that is hard to identify and remove.

God Objects, Helper classes, and run-time type checks are all considered to be "code smells" -- visible symptoms of design flaws.
But what's the alternative?
At the time of writing, Javafootnote:[At least up to Java 14. A future version of Java will have sealed classes.] only gives us classes, methods, and interfaces for modelling.
The code smells we see in Java are a consequence of this limited set of abstraction mechanisms.

Kotlin classes, like Java classes, can have polymorphic methods and implement interfaces, and classes must be declared to implement an interface.
This simplifies interop with Java, but means that, like Java, you cannot introduce polymorphism to an object without changing its class definition.

However, Kotlin has another mechanism for organising classes and behaviour: _sealed classes_.
A sealed class is an abstract class with a fixed set of subclasses, defined in the same source file.
The compiler prevents you from subclassing the sealed class elsewhere.
Thanks to this restriction, run-time type checks on sealed class hierarchies do not have the same drawbacks as run-time type checks in Java.
The type checker can guarantee that `when` expressions that test the subtype of a sealed class cover all possible cases and only possible cases.

Object-oriented polymorphism assumes that the set of operations varies infrequently, and the set of types the operations apply to varies frequently.  It is much easier to extend a program by adding another class that implements an interface than it is to add another method to an interface implemented by many classes.  The JVM can even load new classes into a running program, as long as they implement an interface compiled into the program.

Sealed class hierarchies and `when` expressions assume the opposite: that the set of operations varies more frequently than the set of types they apply to.
It is much easier to write another function that is conditional on the concrete subclass of a sealed class than it is to add another subclass to every existing when expressions.

Kotlin has no mechanism that lets you define a type and operations in a way that let you easily vary both the types that the operations apply to, and the operations that apply to the types, with static type safety and without modifying existing code.
You have to choose which approach you'll use for a class based on which aspect, subtypes or operations, you expect to vary most frequently as the program evolves.


=== Itinerary -- A Core Type in Our Application

We can see this tension play out in the evolution of the `Itinerary` type.
The traveller's itinerary is a core concept in our travel planning application.
Many features of the application present views of, alter the contents of, or calculate information about Itinerary objects.

In <<accumulating-objects-to-transformations>> we modelled the itinerary as a data class with fields holding the route and a list of accommodation required along the route.
As we extended the application and added more types of item to the itinerary, we found it increasingly cumbersome to hold each type of itinerary item in a separate collection.
Too much of our code involved combining those collections or applying the same filters and transforms to separate collections.
We decided to maintain a single collection of itinerary items rather than keep each type of itinerary item in a separate collection.
In this model, an `Itinerary` _is_ a list of `ItineraryItem`, just as we defined a `Route` to be a list of `Journey` in <<encapsulated-collections-to-typealiases>>.

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt
[source,kotlin]
----
typealias Itinerary = List<ItineraryItem>
----
// end-insert

ItineraryItem is an interface, implemented by the concrete item types: `Journey`, `Accommodation`, `Restaurant` and `Attraction`.

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
interface ItineraryItem {
    fun description(): String
    fun costs(): Sequence<Money>
    fun geoShape(): GeoShape
    fun timespan(): ClosedRange<ZonedDateTime>?
    fun sufferScore(): Int = 0
    ... and other methods
}
----
// end-insert

.Aside
****
This design the pleasing effect that a `Route`, which we get back from our routing service, already _is_ an `Itinerary`.
Because a `Journey` is a subtype `ItineraryItem`, and List declared as `List<out T>` because it is unmodifiable, a `List<Journey>` is a subtype of `List<ItineraryItem>`.
We can receive a Route from our routing service and start using it as an Itinerary -- for example, to add accommodation -- without having to copy elements from one type to the other.
****

Giving all itinerary items a polymorphic interface means the itinerary operations do not depend on the concrete type of the items in the itinerary.
For example:

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryTimespan.kt
[source,kotlin]
----
fun Itinerary.timespan(): ClosedRange<ZonedDateTime>? =
    map(ItineraryItem::timespan)
        .filterNotNull()
        .reduceOrNull { a, b ->
            minOf(a.start, b.start)..maxOf(a.endInclusive, b.endInclusive)
        }
----
// end-insert

This lets us easily add new types of `ItineraryItem` to our application.
However, in practice we do this very rarely.
`Itinerary` and `ItineraryItem` are such fundamental types in our system, that we are far more likely to add operations to `ItineraryItem` to support new features of the application than to add new types of `ItineraryItem`.
The more things we want to to do with itineraries, the more methods we end up adding to the `ItineraryItem` interface.
Clearly a polymorphic interface is the wrong mechanism to support the variability we need for our application.
Interfaces work well when we have a stable set of operations and a varying set of concrete types that those operations apply to.
We have a stable set of ItineraryItem types, but a frequently changing set of operations.

In Java, we might be tempted to implement those operations as static methods of a helper class that use run time type checks, with the `instanceof` operator and type casts, to switch on the concrete type of the `ItineraryItem`.
For example:

// begin-insert: tags/open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItems.java#type_switch
[source,java]
----
if (item instanceof Journey) {
    var journey = (Journey) item;
    return ...
} else if (item instanceof Accommodation) {
    var accommodation = (Accommodation) item;
    return ...
} else if (item instanceof Restaurant) {
    var restaurant = (Restaurant) item;
    return ...
} else {
    throw new IllegalStateException("should never happen");
}
----
// end-insert

There are two problems with this approach.
If returning a value from the method, we have to write an else clause to return a dummy value or throw an exception, even if we have branches for every subclass of `ItineraryItem` and the else clause cannot possibly be executed.
The type checker cannot tell if our conditional statement is _exhaustive_ -- has tested for all possible subclasses.
We might miss an existing subclass, or add a new case sometime later and not realise that we have to also update conditional statements in other classes.
In this example, we _have_ missed a subclass: our application will throw an exception when an Itinerary contains an `Attraction``.

To ensure type safety we could consider https://wiki.c2.com/?DoubleDispatch[Double Dispatch], but this pattern involves a lot of boilerplate code and, because it does not play well with checked exceptions, is not widely used in Java.

Those options are available in Kotlin too, and carry the same overheads and risks.
However, Kotlin provides an alternative that is safer than typechecks and downcasting and more convenient than Double Dispatch: _sealed classes_.

A sealed class has a fixed set of subclasses, that must all be defined in the same source file.
This allows the compiler to ensure that run time type checks are exhaustive.
Compilation fails if you do not have a branch for every subclass.
If run time type checks are exhaustive, we do have to write an `else` clause.

Let's convert `ItineraryItem` from an interface with polymorphic methods into a sealed class hierarchy and free-standing functions.


=== Converting the Interface to a Sealed Class

A sealed class and all its subclasses must be defined in the same file.  So we must first use the IDE's Move Class refactoring to move the implementations of `ItineraryItem` into the same file as the interface.

Then make interface a sealed class and the implementations extend the class.

Can't do this automatically.
Have to do it by manual editing.
At least having them all in the same file makes that a bit easier.

// begin-insert: tags/open-to-sealed.2:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem { // <1>
    abstract fun description(): String // <2>
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    abstract fun timespan(): ClosedRange<ZonedDateTime>?
    open fun sufferScore(): Int = 0 // <3>
    ... and other methods
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    override fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}

... and other subclasses
----
// end-insert

<1> The class declaration is marked with the `sealed` modifier.

<2> Because `ItineraryItem` is now a class, not an interface, abstract methods must now be explicitly declared as `abstract`.

<3> Any methods of the interface that had a default implementation must be declared as `open` so they can be overridden by subclasses.

Now we can move operations from being polymorphic methods defined on the sealed class and into extension functions that use `when` expressions to switch on the type of item.

Let's do this with the `timespan` method.

When we Alt-Enter on the definition of `timespan` in `ItineraryItem`, the context menu includes the action "Convert member to extension".
Can it really be that easy?
Unfortunately, no.
That gets us part of the way there, but leaves `override` modifiers on the `timespan` methods in the concrete subclasses that longer override anything, and implements the extension function merely with a `TODO` that throws `UnsupportedOperationException`.

// begin-insert: tags/open-to-sealed.3:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem {
    abstract fun description(): String
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    open fun sufferScore(): Int = 0
    ... and other methods
}

fun ItineraryItem.timespan(): ClosedRange<ZonedDateTime>? {
    TODO("Not yet implemented")
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    override fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}

... and other subclasses
----
// end-insert

We'll have to fix it up by hand by removing the `override` modifiers, and implementing the extension method with when expression that switches on the type of `ItineraryItem` and calls the now monomorphic `timespan` method on each concrete class.

// begin-insert: tags/open-to-sealed.4:src/main/java/travelator/itinerary/Itinerary.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem {
    abstract fun description(): String
    abstract fun costs(): Sequence<Money>
    abstract fun geoShape(): GeoShape
    open fun sufferScore(): Int = 0
    ... and other methods
}

fun ItineraryItem.timespan(): ClosedRange<ZonedDateTime>? {
    return when (this) {
        is Accommodation -> timespan()
        is Journey -> timespan()
        is Restaurant -> timespan()
        is Attraction -> timespan()
    }
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    fun timespan() = checkInFrom..checkOutBefore
    ... and other methods
}

... and other subclasses
----
// end-insert

Intellij highlights each monomorphic call to `timespan` to indicate that the compiler is "smart casting" the `this` reference from ItineraryItem to the correct subclass thanks to flow typing.
While we are writing the `when` expression, Intellij highlights it as a type error until it covers all subclasses of `ItineraryItem`.

// TODO: check if this also applies to if statements
[WARNING]
.Statements are not checked for exhaustiveness
****
The compiler checks when expressions for exhaustiveness but does not check when _statements_.
It considers a `when` to be a statement if the value of the entire `when` expression is never used.

You can force an exhaustive check by using the value of the when statement.
For example, the following extension function will use the value it is called upon.

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_definition
[source,kotlin]
----
val <T> T.exhaustive get() = this
----
// end-insert

It can be used like this to make the compiler check a `when` statement for exhaustiveness:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_usage
[source,kotlin]
----
when (instanceOfSealedClass) {
    is SubclassA -> println("A")
    is SubclassB -> println("B")
}.exhaustive
----
// end-insert
****


We can inline those `timespan` methods into the extension function, removing them from the concrete classes.

// begin-insert: tags/open-to-sealed.6:src/main/java/travelator/itinerary/Itinerary.kt#inlined
[source,kotlin]
----
fun ItineraryItem.timespan() = when (this) {
    is Accommodation -> checkInFrom..checkOutBefore
    is Journey -> departureTime..arrivalTime
    is Restaurant -> time..time + Duration.ofHours(2)
    is Attraction -> null
}

data class Accommodation(
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Duration.between(checkInFrom, checkOutBefore).toDays().toInt()
    val totalPrice: Money = pricePerNight * nights

    override fun description() = "$nights nights at ${location.userReadableName}"
    override fun costs() = sequenceOf(totalPrice)
    override fun geoShape(): GeoShape = pointShape(location.position)
    ... and other methods
}

... and other subclasses
----
// end-insert

The `ItineraryItem.timespan` does not need to be defined in the same file as the ItineraryItem class hierarchy.
We can move it to a file or package that is more convenient:
a good place is next to `Itinerary.timespan`

// begin-insert: tags/open-to-sealed.7:src/main/java/travelator/itinerary/ItineraryTimespan.kt
[source,kotlin]
----
fun Itinerary.timespan(): ClosedRange<ZonedDateTime>? =
    map(ItineraryItem::timespan)
        .filterNotNull()
        .reduceOrNull { a, b ->
            minOf(a.start, b.start)..maxOf(a.endInclusive, b.endInclusive)
        }

fun ItineraryItem.timespan() = when (this) {
    is Accommodation -> checkInFrom..checkOutBefore
    is Journey -> departureTime..arrivalTime
    is Restaurant -> time..time + Duration.ofHours(2)
    is Attraction -> null
}
----
// end-insert

TBD below here....

[TIP]
.Only typecast down a sealed class hierarchy
****

Only use typecasts to cast from the root of a sealed class hierarchy to one of the children in an exhaustive when expression.

Otherwise, don't cast your way out of the static types.

Example of errors that can occur if casting: listOf(1,2,3) returns a the List interface of a mutable list.  If you cast it to MutableList you can mutate a list that code is expecting to be (and typed) as unmodifiable.
****
