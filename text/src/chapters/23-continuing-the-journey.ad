== Continuing the Journey
//TODO finish the final chapter

We've come to the end of the book, but not the end of the journey.
From here, you'll have to continue alone...

...but before you go, let's look back at the main ideas that underpin this book.

We started with the idea that programming languages have a "grain" that influences the design of the programs we write in those languages.
The grain makes certain design styles easy to apply, and makes others arduous or risky.

The grain of Kotlin is different to that of Java.
Java's grain favours mutable objects and reflection, over type safety and composition, although functional features have been introduced in recent revisions.
In contrast, Kotlin favours the transformation of immutable values, free standing functions, and has a type system that is unobtrusive and helpful.

Java and Kotlin can coexist in the same codebase.
The interop boundary is almost seamless, although there are some risks when you pass information from the strictly typed world of Kotlin to the more loosely typed world of Java.

It is easy to convert Java to Kotlin with the IntelliJ IDE, but we end up with "Java in Kotlin syntax."
To make the most of Kotlin, we have to change the way we design to work with the grain of the new language:
separate calculations and data from actions;
move I/O and other effects outwards;
move mutation and mutable state outwards (towards where I/O happens) or inwards (to become the responsibility of the runtime).

We can transform code from idiomatic Java to idiomatic Kotlin in small, safe steps, using automated refactoring tools where possible and editing text as a last resort.
We can support the conventions of both languages at the same time if we must maintain Java code while we are converting code it depends on to Kotlin.

=== Functional Thinking

As we've seen in some of our history lessons, the grain of Java was formed in the 1990s, when we thought that object-oriented programming might be the mythical silver bullet.
When OO turned out not to solve all our problems, mainstream programming languages, and even Java itself, began to adopt ideas from functional programming.
Kotlin was born from Java in this age, and, like our children are better equipped for the next 50 years than we are, it is more suited to modern programming than Java.

What do we mean by function thinking?
Answering that question has been the reason for this journey, and having accompanied you on its many legs, here's our take.

Our software is ultimately limited by our ability to understand it.
Complexity drives lack of understanding, and a lot of that complexity arises over confusion about _when_ things happen.
Functional programmers have learned that the easiest way to tame that complexity is simply to have things _happen_ a lot less.
They call things happening an _effect_: a change that is observable in some scope.

Mutating a variable or a collection _inside_ a function is an effect, but unless that variable is shared _outside_ the function it doesn't _affect_ any other code.
When the scope of an effect is local to a function, we don't have to consider it when reasoning about what our system does.
As soon as we mutate shared state (a parameter to the function perhaps, or a global variable, or a file or network socket) our local effect becomes an effect in whatever scope can see the shared thing, and that quickly increases complexity and reduces understanding.

It isn't enough that a function doesn't _actually_ mutate shared state -- if it _can_ mutate it we have to examine the source of the function (and, recursively, every function that it calls that can also access that state) to be sure that it doesn't mutate anything if we are to understand what our system does.
Every piece of global mutable state makes every function suspect.
Similarly, if we program in an environment in which every function can write to the database, we lose the ability to predict when such writes can occur and plan accordingly.

So functional programmers tame complexity by reducing mutation.
Sometimes they program in languages (like Clojure and Haskell) that enforce controls on mutation.
Otherwise, they work by convention.
If we adopt these conventions in more general languages, we gain the ability to reason with our code in proportion to how much we adopt the conventions.
Kotlin chooses not to enforce the control of effects, but the language and its runtime come with some built-in conventions to nudge us in the right direction.
Compared to Java we have, for example: `val` rather than a non-default `final` modifier, read-only views of collections, and data classes to encourage copy-on-write rather than mutation.
Many of this book's chapters describe more subtle conventions with the same aim - <<beans-to-values>>, <<java-to-kotlin-collections>>, <<actions-to-calculations>>, <<accumulating-objects-to-transformations>> and <<performing-io-to-passing-data>>.

There is of course much more to functional programming than simply not mutating shared state,
but, if we just focus on solving problems without mutation (or where mutation is the point, we minimise its scope), our systems become easier to understand and to change.
Like https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[Don't Repeat Yourself] (aka https://wiki.c2.com/?OnceAndOnlyOnce[Once and Only Once]) assiduous application of a simple rule has profound effects.
Both rules share another property though -- if we aren't careful their application can  increase complexity faster than they reduce it.
We need to learn techniques that allow us to manage mutation (and remove duplication, and facilitate testing, and so on) without making our code even harder to understand, and to recognise these techniques for what they are when we see them.
These techniques will tend to be different in different languages, environments and domains, and are the craft of our profession.

As you research functional techniques, you will come across a lot of anti-object sentiment.
This seems to be rooted in a perception that OO is all about mutable objects, but we shouldn't throw the message-passing baby out with the mutable bathwater.
Whilst we can use OO to manage shared mutable state, in practice these days we generally use it to encapsulate immutable state, or to represent services and their service dependencies.
We saw in <<interfaces-to-functions>> that we can use both functions with closure, and classes with properties, to encapsulate data.
Both can also hide code details, and allow a client to work with different implementations.
We need these points of inflection to build flexible, robust and testable systems.
Where in Java we traditionally reach for subclassing as tool; Kotlin, with its default-closed classes, encourages a more compositional style.
Instead of overriding a protected method, we have a function-typed property representing an inflection.
We should favour this style, but not be embarrassed to define class and sub-class hierarchies where they simplify our implementation.
Similarly, extension functions <<functions-to-extension-functions>> are all very well, and they can work wonders to reduce coupling between disparate concerns in our codebases, but they are no substitute for polymorphic methods when that is what we need.

=== Functional Programming and Textual Reasoning

// in progress... pushed to sync

When we finished this book, we realised -- to our surprise -- that we had not included any software design diagrams.

When we've written about object-oriented design, we've relied on diagrams -- particularly object and sequence diagrams -- to show the dynamic structure and behaviour of the software and how changes to the source will change the dynamic behaviour.
In object-oriented software, that dynamic structure -- the graph of objects and how messages flow between them -- is largely implicit.
This makes it hard to relate what you see in the source to what will happen at runtime, so visualisation is a vital part of object-oriented programming.
Through the 1980's and 1990's, software design luminaries created a variety of diagramming formats to visualise object-oriented software.
In the mid 1990's, the designers of the most popular notations, Grady Booch, Ivar Jacobson and James Rumbaugh, combined their efforts into the _Unified Modelling Language_ (UML).

A functional style makes it easier to reason by manipulating the textual expressions in our source code, rather than thinking hard about mechanisms that are not immediately apparent in the source and have to be visualised to be understood.

Typing & referential transparency are all related to reasoning with the syntax alone.


=== Refactoring

Refactoring is a key component of this book.
Refactoring plays an important part in our professional lives because if we don't know enough about the eventual form of our system to get its design right, we are going to have to transform what we have into what we need at some point, and your authors have never known enough about the eventual form of a system to get its design right.
Even those applications where we started with detailed requirements ended up very different from those specifications by the time they were delivered.
The problem is that late in a project and against schedule pressure is no time to learn how to refactor your code.

Instead, we take every opportunity to practice refactoring.
As we saw in <<creating-to-reusing-types>>, even when writing code from scratch we will often hard-code values to get a test to pass, and then refactor to remove duplication between the tests and production code.
We are always looking for new ways to get tests passing quickly and then refactor our way into code that looks like we planned it that way.
Sometimes we discover a new automated refactoring built into IntelliJ, other times we find a way to combine existing refactorings to achieve our aims.

When the scope of a change is small, we can get away with handing-editing a definition and then its uses to match, or sometimes more usefully the other way around.
This becomes tedious and error-prone when a change affects many files though, so practicing using the tools to achieve even small changes will equip us when faced with larger refactoring challenges.
Where we do have a multi-stage refactor, or where we have to manually apply changes in multiple places, <<expand-contract>> refactoring allows us to keep the system building and working throughout the process.
This is vital when a change may take multiple days or even weeks, because it allows us to merge our work with other changes in the system.
Once you've thrown away a fortnight of work because a big-bang merge at the end proved impossible, you come to appreciate the value of this technique, and want to practice it even when it isn't strictly necessary.

We hope that the refactorings in this book expand your ambition.
Your authors have been lucky enough to work with some world-class practitioners, the sort of people who consider a compile error during a refactoring to be a moral failing.
The refactorings we have shown may not be optimal (and even if they were, the state of the art will change with tooling and language changes), but they are genuine, and they do reflect how we write and transform code.


=== Refactoring and Functional Thinking

As we've seen on our tour, there is a relationship between functional thinking and refactoring.
Refactoring is a rearrangement of our code, and where that code represents <<actions>> -- code that depends on when you run it, the rearrangement may change when actions are run and so the functioning of the software.
In contrast, calculations <<calculations>> are safe to rearrange, but ultimately impotent (without reading and writing our code is simply generating heat).
Functional thinking encourages us to recognise and control actions, and by doing so, makes refactoring much safer.

Your authors learned this the hard way.
We learned to refactor in the days of mutable objects, and introduced bugs when we failed to predict the consequences.
This could have lead us to abandon refactoring, but we still weren't clever enough to design our systems right in the first place.
Instead, we discovered that a certain style of programming, using OO but with immutable objects, was expressive and understandable, refactorable and safe.
When we adopted that style in our Java code it was often working against the grain, but despite this more it was more productive, both individually and in teams, than the other techniques we tried.
When we discovered Kotlin, we realised that this was the sweet spot.
Now we could use a modern language where function thinking was part of the design, objects were still well-supported, and refactoring tooling was not an afterthought.

It took some time to learn how to make Kotlin work for us, and we are still learning as the language evolves.
This book is by no means a catalog of all the techniques that we use, but we hope that, if you think the way we do, it will help you on your journey.


=== Rules of Thumb

Whilst it's fun to extract principles from our experience, this book is at its heart a deeply practical work.
So lets finish it with some rules of thumb to take into our next coding sessions, even if we can't work on Travelator together any more.

Start with Kent Beck's Rules of Simple Design:

* Passes the tests
* Reveals intention
* No duplication
* Fewest elements

Either add a lazer-focus on controlling effects, or consider effects to be one of the key features of revealing intention - after all, if we don't know when we are having an effect, what did we intend.


=== Nat's Notes


We didn't mention it until now.
This book is based on an implicit "big idea" that we so take for granted that we didn't think of writing about it.
That big idea is: all programming is program transformation.
Text is just a presentation of the program. It is not _the_ program.
The program is the graph of which the text is a projection.
Programming is applying transformations to that graph.

We refactor all the time.
"Make the change easy, then make the easy change" -- Kent Beck.


