[[actions-to-calculations]]
== Actions to Calculations

Neither Java nor Kotlin make any formal distinction between imperative and functional code, although Kotlin's emphasis on immutability and expressions generally lead to more functional programs.
Can we improve our code by making more of it functional?

[[functions]]
=== Functions

As an industry we have invented a lot of phrases to describe callable sub-programs withing a larger program.
We have the very generic _subroutine_.
Some languages (notable Pascal) distinguish between _functions_ that return a result, and _procedures_, which don't; but most developers use the terms interchangeably.
Then there are _methods_, which are subroutines associated with an object (or a class, in the case of static methods).

The C language calls them all functions, but has a special `void` type to represent the absence of a return value.
This was carried forward into Java.
Kotlin uses `Unit` in almost the same way, except that `Unit` is not the absence of a return value, but rather the singleton value that is returned instead.

In this book we use the term function to refer to both result-returning and non-result-returning subroutines, whether free-standing or associated with an object.
Where they are associated with an object, we'll often refer to them as methods.

Whatever we call them, functions are one of fundamental building blocks of our software.
We define them with some sort of notation, generally the programming language we are using.
We also tend to view their definitions as fixed during a run of the program - in static languages at least we don't usually redefine functions on the fly.

This is in contrast to the other fundamental building block: data.
We expect data to vary as we run our program and different data is bound to variables.
Variables are called variables because they are, wait for it, variable.
Even when they are `final`, or `val`, they are usually bound to different data in different invocations of a function.

We hinted earlier at a subdivision of functions into those that return a result, and those that do not.
This might seem like a fundamental difference, but in practice there is a more useful way to divide functions - into _calculations_ and _actions_.

Actions are functions that depend on when or how many times they are run, calculations are functions that are timeless.
Most functions that we write are actions, as we have to take special care to write code that doesn't depend on when it is run.
How would we go about doing that?

[[calculations]]
=== Calculations

In order to be a calculation, a function must always return the same result given the same inputs.
As the inputs to a function are its parameters, this means that a calculation always returns the same result when called with the same arguments.

This function:

[source,kotlin]
----
fun fullName(customer: Customer) = "${customer.givenName} ${customer.familyName}"
----

is a calculation, as it will always return the same value when supplied the same `Customer`.
This is true only if `Customer` is immutable (or at least `givenName` and `familyName` cannot change).
To keep things simple, we'll say that calculations can only have value (as defined in <<beans-to-values>>) parameters.

Methods, and the disguised methods that are member-properties, can also be calculations:

[source,kotlin]
----
data class Customer(
    val givenName: String,
    val familyName: String
) {
    fun upperCaseGivenName() = givenName.toUpperCase()

    val fullName get() = "$givenName $familyName"
}
----

To see when they are, we consider any data accessed via `this` to be an input to the function, so both `upperCaseGivenName` and `fullName` are calculations because `givenName` and `familyName` are both values.

An extension function or property:

[source,kotlin]
----
fun Customer.fullName() = "$givenName $familyName"

val Customer.fullName get() = "$givenName $familyName"
----

can also be a calculation if the data it depends on is a value.

.Computed Property or Function?
****
You may have wondered when to define a computed property and when to have a function that returns a value.
Computed properties are confusing if they return different results at different types, at least when defined on value types (and you'll be realising by now that your authors think that most of our types should be value types).
So a good rule of thumb is to reserve computed properties for calculations.

We expand on this topic in <<methods-to-properties>>.
****

The result of a calculation may depend on data that is not passed as parameters, but only if that data cannot change.
Otherwise the function's result would be different before and after the change, which would make it an action.
Even if a function always returns the same result for the same parameters, it may still be an action if it mutates something (either a parameter or an external resource such as a global variable or a database).
For example:

[source,kotlin]
----
println("hello")
----

`println` always returns the same `Unit` result given the same `hello` input, but it is not a calculation.
It is an action.

[[actions]]
=== Actions

`println` is an action because it _does_ depend on when and how many times it is run.
If we don't call it, nothing is output, which is different from calling it once, which is different from calling it twice.
The order that we call `println` with different arguments also matters to the results we see on the console.

We call `println` for its _side effect_ - the effect it has on its environment.
_Side effect_, is a bit of a misleading term, because, unlike drug side effects, they are often exactly the thing that we want to happen.
Maybe _outside effect_ would be a better name, to emphasise that they are external to a function's parameters, local variables and return value.
In any case, functions with observable side effects are actions not calculations.
As we saw previously, code that reads from external mutable state must also be an action (provided that anything does actually mutate the state).

Let's look at a `Customers` service:

[source,kotlin]
----
class Customers {
    fun save(data: CustomerData) {
        ...
    }
    fun find(id: String): Customer? {
        ...
    }
}
----

Both `save` and `find` are actions, as find's result depends on whether it is run before or after a customer with that id has been saved.
Functions returning `void` or `Unit` are a dead giveaway for actions, because if they do anything they have to do it by side effect.

Functions that have no parameters (so this doesn't include methods or extension functions which can have implicit parameters accessed via `this`) must also either be returning a constant, or be reading from some other source and so be categorised as actions.
So we can deduce that the top-level function:

[source,kotlin]
----
fun requestRate(): Double {
    ...
}
----

is probably an action, reading from some global mutable state, whereas:

[source,kotlin]
----
class Metrics(
   ...
) {

    fun requestRate(): Double {
        ...
    }
}
----

is probably a calculation with an explicit parameter that is a property of `Metrics` (provided `Metrics` is immutable).
We say probably, because in languages like Java or Kotlin that allow IO or accessing global mutable data from any code, there is no way to be sure if a function represents a calculation or action short of examining it, and all the functions that it calls.
We'll return to that problem soon.

=== Why Should We Care?

We should obviously pay special attention to some actions in our software.
Sending the same email to every user twice is a bug, as is not sending it at all.
We care exactly how many times it is sent.
We may even care that it is sent at exactly 8:07am, so that our offer for a free first-class upgrade is at the top of our customer's inbox when they read their email over breakfast.

Other seemingly innocuous actions may be more nocuous than we think.
Changing the order of read and write actions causes concurrency bugs.
Error handling is much more complicated if the second of two sequential actions fails after the first succeeded.
Actions prevent us having free-reign to refactor our code, because doing so may change when or whether they are invoked.

Calculations on the other hand can be invoked at any time, with no consequences to calling them again and again with the same arguments except a waste of time and energy.
If we are refactoring code and find that we don't need the result of a calculation, we can safely not invoke it.
If it is an expensive calculation, we can safely cache its result; if it is inexpensive, we can safely recalculate it on demand if that simplifies things.
It is this feeling of safety that puts the smug smile on the faces of functional programmers.
Well, that and knowing that a monad is just a monoid in the category of endofunctors.

.Procedural Code
****
Nat and Duncan are both old enough to have learned to program in Sinclair BASIC. This dialect had no local variables, no immutable data, and no concept of defining a function with parameters that could return values.
It requires real discipline to program in such a system, because practically every line of code is an action, and hence potentially affects the functioning of every other statement.

This is in fact very close to the way that our computers actually work, with mutable values held in registers and global memory, manipulated by machine-code actions.
The evolution of programming languages has been a process of restricting the ultimate flexibility of this model, in order that humans can better reason with the code that they create.
****

=== Why Prefer Calculations?

We like calculations because they are so much easier to work with, but ultimately our software needs to have an effect on the world, which is an action.
There is no overlap though, code can't be an action and a calculation, both timeless and time-dependent.
If we take some code that is a calculation and have it invoke an action, then it becomes an action, because it will now depend on when or whether it is called.
We can think of calculations as the purer code, where code inherits the most tainted level of all of its dependencies.
We see the same thing with susceptibility to errors <<exceptions-to-errors>>.
If we value purity (which in all these cases brings ease of reasoning and refactoring), we must strive to pull the boundary between impure and pure code to the outer layers of our system - those closest to the entry points.
If we succeed, then a significant proportion of our code can be calculations, and hence easily tested, reasoned-with, and refactored.

What if we don't succeed in keeping actions at the top of our call-stack?
Then we can fix things with refactoring.

=== Refactoring Actions to Calculations

Let's have a look at recognising and refactoring actions in existing code.

==== Existing Code

There is an HTTP endpoint in Travelator that allows the client app to fetch information about the customers current trip.

// begin-insert: tags/effects.0:src/main/java/travelator/handlers/CurrentTripsHandler.java
[source,java]
----
public class CurrentTripsHandler {

    private final ITrackTrips tracking;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public CurrentTripsHandler(ITrackTrips tracking) {
        this.tracking = tracking;
    }

    public Response handle(Request request) {
        try {
            var customerId = request.getQueryParam("customerId").stream()
                .findFirst();
            if (customerId.isEmpty())
                return new Response(HTTP_BAD_REQUEST);
            var currentTrip = tracking.currentTripFor(customerId.get());
            return currentTrip.isPresent() ?
                new Response(HTTP_OK,
                    objectMapper.writeValueAsString(currentTrip)) :
                new Response(HTTP_NOT_FOUND);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert

Actions are code that is sensitive to time, so words like _current_ in `CurrentTripsHandler` are a dead give-away.
The `handle` method is an action, and that's OK: things on the edge of our systems often are.

The handler delegates to some business logic, implemented in `Tracking`.

// begin-insert: tags/effects.0:src/main/java/travelator/Tracking.java
[source,java]
----
class Tracking implements ITrackTrips {

    private final Trips trips;

    public Tracking(Trips trips) {
        this.trips = trips;
    }

    @Override
    public Optional<Trip> currentTripFor(String customerId) {
        var candidates = trips.currentTripsFor(customerId).stream()
            .filter((trip) -> trip.getBookingStatus() == BOOKED)
            .collect(toList());
        if (candidates.size() == 1)
            return Optional.of(candidates.get(0));
        else if (candidates.size() == 0)
            return Optional.empty();
        else
            throw new IllegalStateException(
                "Unexpectedly more than one current trip for " + customerId
            );
    }
}
----
// end-insert

Using the _current_ rule `Tracking.currentTripFor` is evidently an action too, as is `Trips.currentTripsFor`.
Here is its implementation in `InMemoryTrips`, which is used for testing in place of a version implemented with database queries.

// begin-insert: tags/effects.0:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
public class InMemoryTrips implements Trips {

    ...
    @Override
    public Set<Trip> currentTripsFor(String customerId) {
        return tripsFor(customerId).stream()
            .filter(trip -> trip.isPlannedToBeActiveAt(clock.instant()))
            .collect(toSet());
    }
}
----
// end-insert

The conversion from `Set<Trip>` (the result of `Trips.currentTripsFor`) and to `Optional<Trip>` (returned from `Tracking.currentTripFor`) seems to be because there is some business rule around there being only one active trip at any time that is not enforced in the persistence layer.

Until we got here, we have been relying on our knowledge of the meanings of words (in particular _current_) to deduce that Java methods represent actions rather than calculations.
Here though there is a smoking gun.
Can you spot it?

Yes - `clock.instant()`.
That definitely depends on when we call it.
(If you found another action, well done, but keep it to yourself for now, we'll come back to it.)

Even if we chose not go on with the rest of this refactoring, there is one change that we should make now.
We have discussed calculations and actions as applying to named blocks of code, but they also apply at the expression level.
Once you start to differentiate actions from calculations, it makes sense not to throw a random action into an otherwise pure calculation.
Let's pull the action out so that the remainder of the expression is pure - select `clock.instant()` and "Introduce Variable", calling it `now`

// begin-insert: tags/effects.0.5:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
@Override
public Set<Trip> currentTripsFor(String customerId) {
    return tripsFor(customerId).stream()
        .filter(trip -> {
            Instant now = clock.instant();
            return trip.isPlannedToBeActiveAt(now);
        })
        .collect(toSet());
}
----
// end-insert

That's still in the middle of the expression, let's move it up (and convert to a `var` on the way):

// begin-insert: tags/effects.1:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
@Override
public Set<Trip> currentTripsFor(String customerId) {
    var now = clock.instant();
    return tripsFor(customerId).stream()
        .filter(trip -> trip.isPlannedToBeActiveAt(now))
        .collect(toSet());
}
----
// end-insert

This one simple act has allowed us to realise that we were previously comparing every trip against a slightly different time!
Was that a problem?
Probably not here, but you may have worked on systems where it would be.
Duncan for one has recently finished diagnosing an issue where half of a banking transaction could be accounted for in one day, and the other half in the next.

As well as making it harder to refactor our code, actions make it harder to test too.
Let's see how that is manifested:

// begin-insert: tags/effects.0:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
public class TrackingTests {

    final StoppedClock clock = new StoppedClock();

    final InMemoryTrips trips = new InMemoryTrips(clock);
    final Tracking tracking = new Tracking(trips);

    @Test
    public void returns_empty_when_no_trip_planned_to_happen_now() {
        clock.now = anInstant();
        assertEquals(
            Optional.empty(),
            tracking.currentTripFor("aCustomer")
        );
    }

    @Test
    public void returns_single_active_booked_trip() {
        var diwaliTrip = givenATrip("cust1", "Diwali",
            "2020-11-13", "2020-11-15", BOOKED);
        givenATrip("cust1", "Christmas",
            "2020-12-24", "2020-11-26", BOOKED);

        clock.now = diwaliTrip.getPlannedStartTime().toInstant();
        assertEquals(
            Optional.of(diwaliTrip),
            tracking.currentTripFor("cust1")
        );
    }

    ...
}
----
// end-insert

In order to give predictable results we have had to use a fake clock, injected into `InMemoryTrips`.
Having said that `clock.instant()` depends on when we call it; in our tests it doesn't (at least, not in the same way).
We could instead have set up trips relative to the time that the tests are being run - this makes our tests harder to understand and subject to failure if you run them around midnight.

.2015 was the End of Time
****
Duncan and Nat returned to work after Christmas holidays at the beginning of 2015 to find a slew of previously-passing unit tests now failing.
It turns out that 2015-01-01T00:00:00 had been used as a constant for a time that would always be in the future.
When it became in the past, all the tests that relied on before and after relationships began failing.

The solution was the refactoring that we are presenting here.
****

Is having to inject a clock https://dhh.dk/2014/test-induced-design-damage.html[Test-Induced Design Damage]?
In this case it is.
The fake clock has allowed us to solve a testing problem, but at the expense of making the code more complicated.
It has also allowed us to avoid a rethink that might lead to a better design.

==== A Better Design

What would a better design look like here?

In order to make this code less time-dependant, we can simply supply the time as an argument to the method.
Whilst this forces the caller to know the time, it is as easy for our caller to ask the time as it is for this method.
This is a special case of the way that we refactor to avoid dependencies on other global variables - instead of calling out to read, pass the value into the function.

Let's start the refactor by adding an (as yet unused) `Instant` parameter to the `Trips.currentTripsFor(customerId)` method.
Before this was:

// begin-insert: tags/effects.0:src/main/java/travelator/Trips.java#foo
[source,java]
----
public interface Trips {
    ...
    Set<Trip> currentTripsFor(String customerId);
}
----
// end-insert

We use IntelliJ's "Change Signature" refactoring to add the parameter, calling it `at`.
When we add a parameter we need to tell IntelliJ what value it should use when updating the callers of our function.
As we aren't using the value in the method yet, we should be able to use `null` without breaking anything.
Running the tests shows that we are right - they still pass.

`Trips` now looks like this:

// begin-insert: tags/effects.2:src/main/java/travelator/Trips.java#foo
[source,java]
----
public interface Trips {
    ...
    Set<Trip> currentTripsFor(String customerId, Instant at);
}
----
// end-insert

Here is the method being called:

// begin-insert: tags/effects.2:src/main/java/travelator/Tracking.java#foo
[source,java]
----
class Tracking implements ITrackTrips {
    ...

    @Override
    public Optional<Trip> currentTripFor(String customerId) {
        var candidates = trips.currentTripsFor(customerId, null) // <1>
            .stream()
            .filter((trip) -> trip.getBookingStatus() == BOOKED)
            .collect(toList());
        if (candidates.size() == 1)
            return Optional.of(candidates.get(0));
        else if (candidates.size() == 0)
            return Optional.empty();
        else
            throw new IllegalStateException(
                "Unexpectedly more than one current trip for " + customerId
            );
    }
}
----
// end-insert

<1> IntelliJ uses `null` as the argument value.

Remember that we aren't using the value of the time in our implementations of `Trips` yet, just trying to supply it on the outside of our system in order to convert as much code as possible to calculations.
`Tracking` isn't the outside yet, so we take select the `null` `Instant`, and "Introduce Parameter" to add it to the signature of `Tracking.currentTripFor`:

// begin-insert: tags/effects.3:src/main/java/travelator/Tracking.java#foo
[source,java]
----
class Tracking implements ITrackTrips {
    ...

    @Override
    public Optional<Trip> currentTripFor(String customerId, Instant at) { // <1>
        var candidates = trips.currentTripsFor(customerId, at)
            .stream()
            .filter((trip) -> trip.getBookingStatus() == BOOKED)
            .collect(toList());
        if (candidates.size() == 1)
            return Optional.of(candidates.get(0));
        else if (candidates.size() == 0)
            return Optional.empty();
        else
            throw new IllegalStateException(
                "Unexpectedly more than one current trip for " + customerId
            );
    }
}
----
// end-insert

<1> Our new `Instant` parameter.

When we "Introduce Parameter", IntelliJ knows to use the value from the body of the method (`null` in this case) as the value in callers, so that `CurrentTripsHandler` still compiles:

// begin-insert: tags/effects.3:src/main/java/travelator/handlers/CurrentTripsHandler.java#foo
[source,java]
----
public class CurrentTripsHandler {
    ...
    public Response handle(Request request) {
        try {
            var customerId = request.getQueryParam("customerId").stream()
                .findFirst();
            if (customerId.isEmpty())
                return new Response(HTTP_BAD_REQUEST);
            var currentTrip = tracking.currentTripFor(customerId.get(), null); // <1>
            return currentTrip.isPresent() ?
                new Response(HTTP_OK,
                    objectMapper.writeValueAsString(currentTrip)) :
                new Response(HTTP_NOT_FOUND);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert

<1> `null` argument value.

`TrackingTests` is similarly fixed up:

// begin-insert: tags/effects.3:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
public class TrackingTests {

    final StoppedClock clock = new StoppedClock();

    final InMemoryTrips trips = new InMemoryTrips(clock);
    final Tracking tracking = new Tracking(trips);

    @Test
    public void returns_empty_when_no_trip_planned_to_happen_now() {
        clock.now = anInstant();
        assertEquals(
            Optional.empty(),
            tracking.currentTripFor("cust1", null) // <1>
        );
    }

    @Test
    public void returns_single_active_booked_trip() {
        var diwaliTrip = givenATrip("cust1", "Diwali",
            "2020-11-13", "2020-11-15", BOOKED);
        givenATrip("cust1", "Christmas",
            "2020-12-24", "2020-11-26", BOOKED);

        clock.now = diwaliTrip.getPlannedStartTime().toInstant();
        assertEquals(
            Optional.of(diwaliTrip),
            tracking.currentTripFor("cust1", null) // <1>
        );
    }

    ...
}
----
// end-insert

<1> New arguments are `null`.

At this point everything compiles and passes the tests, but we aren't actually using the (`null`) time that we are passing down from our handler.
Let's fix that in `InMemoryTrips`, where we started.
We did have:

// begin-insert: tags/effects.3:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
public class InMemoryTrips implements Trips {

    ...
    @Override
    public Set<Trip> currentTripsFor(String customerId, Instant at) {
        var now = clock.instant();
        return tripsFor(customerId).stream()
            .filter(trip -> trip.isPlannedToBeActiveAt(now))
            .collect(toSet());
    }
}
----
// end-insert

Now we have the time as a parameter, we can use that rather than asking the `clock`:

// begin-insert: tags/effects.4:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
public class InMemoryTrips implements Trips {

    ...
    @Override
    public Set<Trip> currentTripsFor(String customerId, Instant at) {
        return tripsFor(customerId).stream()
            .filter(trip -> trip.isPlannedToBeActiveAt(at))
            .collect(toSet());
    }
}
----
// end-insert

This causes the tests that use `InMemoryTrips` to fail with ++NullPointerException++s, because the method is now using the value of the parameter, and the tests are passing `null`.

// begin-insert: tags/effects.4:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
@Test
public void returns_empty_when_no_trip_planned_to_happen_now() {
    clock.now = anInstant();
    assertEquals(
        Optional.empty(),
        tracking.currentTripFor("cust1", null) // <1>
    );
}

@Test
public void returns_single_active_booked_trip() {
    var diwaliTrip = givenATrip("cust1", "Diwali",
        "2020-11-13", "2020-11-15", BOOKED);
    givenATrip("cust1", "Christmas",
        "2020-12-24", "2020-11-26", BOOKED);

    clock.now = diwaliTrip.getPlannedStartTime().toInstant();
    assertEquals(
        Optional.of(diwaliTrip),
        tracking.currentTripFor("cust1", null) // <1>
    );
}
----
// end-insert

<1> These `nulls` are now being dereferenced inside `InMemoryTrips`.

Instead of `null`, we need to pass the value that the tests were setting into the `clock`.
A cunning refactor (suggested by Jordan Stewart) is to replace the ++null++s with `clock.now`:

// begin-insert: tags/effects.5:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
@Test
public void returns_empty_when_no_trip_planned_to_happen_now() {
    clock.now = anInstant();
    assertEquals(
        Optional.empty(),
        tracking.currentTripFor("cust1", clock.now)
    );
}

@Test
public void returns_single_active_booked_trip() {
    var diwaliTrip = givenATrip("cust1", "Diwali",
        "2020-11-13", "2020-11-15", BOOKED);
    givenATrip("cust1", "Christmas",
        "2020-12-24", "2020-11-26", BOOKED);

    clock.now = diwaliTrip.getPlannedStartTime().toInstant();
    assertEquals(
        Optional.of(diwaliTrip),
        tracking.currentTripFor("cust1", clock.now)
    );
}
----
// end-insert

This gets our tests to pass, because we are now passing the correct time as the argument, albeit via setting and immediately reading a field in the `StoppedClock`.
To fix that, we can search and replace `clock.now =` with `var clockNow =` and then `clock.now` with `clockNow`.
This cleverness disintermediates the clock.

// begin-insert: tags/effects.6:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
@Test
public void returns_empty_when_no_trip_planned_to_happen_now() {
    var clockNow = anInstant();
    assertEquals(
        Optional.empty(),
        tracking.currentTripFor("cust1", clockNow)
    );
}

@Test
public void returns_single_active_booked_trip() {
    var diwaliTrip = givenATrip("cust1", "Diwali",
        "2020-11-13", "2020-11-15", BOOKED);
    givenATrip("cust1", "Christmas",
        "2020-12-24", "2020-11-26", BOOKED);

    var clockNow = diwaliTrip.getPlannedStartTime().toInstant();
    assertEquals(
        Optional.of(diwaliTrip),
        tracking.currentTripFor("cust1", clockNow)
    );
}
----
// end-insert

Now we have simply to inline all the uses of `clockNow` to have a nice functional expression of the tests.
Taking the opportunity to remove the now unused `clock` from the tests and `InMemoryTrips` we have:

// begin-insert: tags/effects.7:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
public class TrackingTests {

    final InMemoryTrips trips = new InMemoryTrips();
    final Tracking tracking = new Tracking(trips);

    @Test
    public void returns_empty_when_no_trip_planned_to_happen_now() {
        assertEquals(
            Optional.empty(),
            tracking.currentTripFor("cust1", anInstant())
        );
    }

    @Test
    public void returns_single_active_booked_trip() {
        var diwaliTrip = givenATrip("cust1", "Diwali",
            "2020-11-13", "2020-11-15", BOOKED);
        givenATrip("cust1", "Christmas",
            "2020-12-24", "2020-11-26", BOOKED);

        assertEquals(
            Optional.of(diwaliTrip),
            tracking.currentTripFor("cust1",
                diwaliTrip.getPlannedStartTime().toInstant())
        );
    }

    ...
}
----
// end-insert

==== End Game

We're nearly almost done now (refactoring is never completely done).
Now neither of our `currentTripFor` methods fetch the time, leaving that to the handler, tests for the handler may well require us to control _now_.
So we'll probably inject the clock into `CurrentTripHandler` rather than call the raw `Instant.now()`.

Then there is the production implementation of `Trips` that reads from a database table.
We are lucky and find that this passes the current time into the SQL query - so now we can just use a rendering of the new `at` in `Trips.currentTripsFor(String customerId, Instant at)`.
Actions are so pervasive that it isn't unusual to find the time fetched inside the SQL query itself, using some variant of `CURRENT_TIMESTAMP` or `NOW`.
In this case we would have to update the query to accept the value from our function rather than reading it from the database server itself.

Oh, and we haven't converted the code to Kotlin!

This last observation is quite significant.
This way of thinking about calculations and actions is not exclusive to Kotlin.
It is certainly possible to make the distinction in any language, and the grain of Java is becoming more functional with time.
We find though that Kotlin's more natural support for immutable data and other functional constructs means that the costs of making the distinction are lower, and so the cost/benefit ratio looks more favourable.
It's also worth observing that a lot of the refactoring steps taken in this chapter (and others) are safe only because we are moving around the invocation of calculations and not actions.

Before we finish this chapter, what about the other action we hinted at?
Here is the implementation of `InMemoryTrips`, now converted to Kotlin:

// begin-insert: tags/effects.8:src/test/java/travelator/InMemoryTrips.kt
[source,kotlin]
----
class InMemoryTrips : Trips {
    private val trips: MutableMap<String, MutableSet<Trip>> = mutableMapOf()

    fun addTrip(trip: Trip) {
        val existingTrips = trips.getOrDefault(trip.customerId, mutableSetOf())
        existingTrips.add(trip)
        trips[trip.customerId] = existingTrips
    }

    override fun tripsFor(customerId: String) =
        trips.getOrDefault(customerId, emptySet<Trip>())

    override fun currentTripsFor(customerId: String, at: Instant): Set<Trip> =
        tripsFor(customerId)
            .filter { it.isPlannedToBeActiveAt(at) }
            .toSet()
}
----
// end-insert

That `MutableMap` of ``MutableSet``s is a sign that something can change over time - in this case if we add a trip for a customer the result of `tripsFor` may change.
`tripsFor` is an action not a calculation.
If `tripsFor` is an action, then anything that calls it is an action, including our `currentTripsFor`.
The same will obviously be true of the production version of `Trips` that reads and writes to the database.
After all this work, we haven't actually promoted our action to a calculation after all!

Should we be downhearted?
No.
Despite our previous assertion that functions are either calculations _or_ actions, the truth is that in practice action-ness is graduated, they can be more or less susceptible to time.
In this case, unless other code _in this interaction_ is also going to fetch the trips for a customer and find an inconsistency, we can treat `Trips` as effectively immutable, and so `tripsFor`, and by extension `currentTripsFor`, are effectively calculations.
In this respect our `InMemoryTrips` is less safe than our database implementation, because if accessed on multiple threads it can mutate the collection returned by `tripsFor`, leading to potential `ConcurrentModificationExceptions` in the `filter` implementation.
Categorising our code into calculations and actions has helped us see these issues, and given us a framework for deciding if they are important in context.

Lastly, it is worth noting that one place in which Kotlin makes this categorisation easier is in its default use of immutable data.
When you see `List` in Java you have to find the places in which it is created or referenced in order to establish its mutability, and hence the likelihood that code accessing it can be an action.
In Kotlin when you see `MutableList` you can infer an action, although as we have seen with `InMemoryTrips`, exposing a mutable collection with a read-only alias can lead to actions pretending to be calculations.

=== Conclusion

Categorising code into calculations and actions (along with data) is a formalism introduced by Eric Normand in his book https://www.manning.com/books/grokking-simplicity[Grokking Simplicity].

In <<beans-to-values>> we refactored from a mutable bean to an immutable value.
Similarly, in <<java-to-kotlin-collections>> we refactored from mutable to immutable collections.
In both cases we trade mutating an object for returning an amended copy -- converting an action into a calculation.
In doing so, we gain the advantages we've seen in this chapter: better comprehension, easier testing and predictable refactoring.
The more of our code is calculations, the better off we are.

We will return to the topic of moving from actions to calculations in <<accumulating-objects-to-transformations>>.

