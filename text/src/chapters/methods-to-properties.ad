[[methods-to-properties]]
== Methods to Properties

Java does not distinguish between property access methods and other types.
Kotlin on the other hand, treats properties differently to member functions.
When should we prefer a computed property to a function returning a result?

=== Fields, Accessors and Properties

Most programming languages allow us to group data together in some way, giving names (and often types) to the properties of an entity.

Here, for example, is a _record_, composed of 3 _fields_, in ALGOL W:

[source,algol-w]
----
RECORD PERSON (
    STRING(20) NAME;
    INTEGER AGE;
    LOGICAL MALE;
);
----

Things were different then, real programmers only had CAPITAL LETTERS, and gender was a boolean.

We can also see by the `STRING(20)` that this record really cares about its layout in memory.
That's because when we write an expression like

[source,algol-w]
----
AGE(WILMA) := AGE(WILMA) + 1;
----

the compiler is going to add the number of bytes taken by 20 characters to the place that it has stored `WILMA` in order to know where to find the bytes representing her age, and increment it.
Records, also known as _structs_ in other languages, are a convenience for grouping together variables - there is no information hiding going on.

Most early object-oriented systems (C++ in particular) were based on this record mechanism.
Instance variables were simply record fields, and member functions (aka methods) were record fields holding pointers to functions.
Smalltalk was different.
Smalltalk objects can have instance variables, but access to this state is by sending a message to the object asking it for the person.
Messages not fields is the fundamental abstraction.

The Java implementors took a little of each approach.
Objects can have public fields, but clients can't just reach into their memory to retrieve them; they have to call bytecode instructions to access their values.
This allows us to treat classes as records, whilst allowing the runtime to enforce `private` field access.

While direct access to fields was _permitted_, from the outset it was discouraged.
If its clients access fields directly, then an implementation cannot change its internal representation without recompiling those clients.
We also cannot maintain any invariant relationships between fields if clients can mutate them directly, and as we've seen in <<beans-to-values>>, in those days objects were all about the mutation.
Finally, direct field access is not polymorphic, so subclasses cannot change its implementation, and in those days objects were all about the subclassing too.

Instead of direct field access then, we write _accessor_ methods - getters and (historically) setters.
They almost always do nothing mediate access to a field, but sometimes may maintain invariants, or compute a person from other fields rather than access storage.
Within a codebase that we own, the arguments for encapsulating data are less persuasive, but as developers we ape the patterns we see in the standard APIs and libraries that we use.
They by definition are catering to clients who don't own them, and so make more use of encapsulation then we have to locally.

Where are we going with this?
Well, sometimes data is just data.
When it is, then records, or public fields of classes, are perfectly acceptable, especially when we have immutable values.
As our models become more sophisticated we will person a uniform way of accessing values from either a field or a calculation, or polymorphically, and in these cases accessor methods come into their own.

The Kotlin designers choose to take the decision away from us and only support accessor methods.
The language simply does not support giving direct access to the fields of its classes.
It will generate code to access to public fields of Java classes, but has no way of defining public fields itself.
Instead, it allows us to generate both a private member-variable and an accessor in a single _property_ declaration.

So in Java we can give access to a field directly:

// begin-insert: src/main/java/properties/PersonWithPublicFields.java#excerpt
[source,java]
----
public class PersonWithPublicFields {
    public final String givenName;
    public final String familyName;
    public final LocalDate dateOfBirth;

    public PersonWithPublicFields(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }
}
----
// end-insert

Alternatively, we can write our own accessor:

// begin-insert: src/main/java/properties/PersonWithAccessor.java#excerpt
[source,java]
----
public class PersonWithAccessor {
    private final String givenName;
    private final String familyName;
    private final LocalDate dateOfBirth;

    public PersonWithAccessor(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }

    public String getGivenName() {
        return givenName;
    }

    ...
}
----
// end-insert

In Kotlin, we cannot give access to the field directly:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#excerpt
[source,kotlin]
----
class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
}
----
// end-insert

This declaration will emit a private field called `givenName`, an accessor method `getGivenName()`, and a constructor to initialise `givenName`.

In Java, we can access (visible) fields directly, or call accessors:

// begin-insert: src/main/java/properties/Calling.java#excerpt
[source,java]
----
public static void print(PersonWithPublicFields person) {
    System.out.println(person.givenName); // <1>
}

public static void print(PersonWithAccessor person) {
    System.out.println(person.getGivenName()); // <2>
}

public static void print(PersonWithProperties person) {
    System.out.println(person.getGivenName()); // <3>
}
----
// end-insert

<1> Accessing the field
<2> Calling the Java `getGivenName()`
<3> Calling the Kotlin `getGivenName()`

In Kotlin, we can access visible fields directly, or call accessors as if they were fields:

// begin-insert: src/main/java/properties/calling.kt
[source,kotlin]
----
fun print(person: PersonWithPublicFields) {
    println(person.givenName) // <1>
}

fun print(person: PersonWithAccessor) {
    println(person.givenName) // <2>
}

fun print(person: PersonWithProperties) {
    println(person.givenName) // <3>
}
----
// end-insert

<1> Accessing the field
<2> Calling the Java `getGivenName()`
<3> Calling the Kotlin `getGivenName()`

Properties are a convenience backed by some compiler magic in Kotlin.
They make it as simple to use fields and accessors as plain old fields in Java, and so we will naturally write code that can take advantage of the encapsulation provided by accessors.
For example, we might find that we want to define a property in an interface, or compute a property that we used to store

Computed properties are those not backed by a field.
If we have `givenName` and `familyName` backed by fields, there is no need to store `fullName`, we can compute it when we need it.

// begin-insert: src/main/java/properties/PersonWithPublicFields.java
[source,java]
----
public class PersonWithPublicFields {
    public final String givenName;
    public final String familyName;
    public final LocalDate dateOfBirth;

    public PersonWithPublicFields(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }

    public String getFullName() {
        return givenName + " " + familyName;
    }
}
----
// end-insert

In this direct-field-access case in Java, there is now a difference between the stored and computed properties when we come to access them.

// begin-insert: src/main/java/properties/CallingComputed.java#excerpt
[source,java]
----
public static void print2(PersonWithPublicFields person) {
    System.out.println(
        person.givenName + " " +
        person.getFullName()
    );
}
----
// end-insert

This isn't the case in Kotlin, even when accessing the Java fields and methods.
This uniformity is a goal of properties.

// begin-insert: src/main/java/properties/calling-computed.kt
[source,kotlin]
----
fun print2(person: PersonWithPublicFields) {
    println(
        person.givenName + " " +
        person.fullName
    )
}
----
// end-insert

We define computed properties outside the constructor in Kotlin:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#PwP
[source,kotlin]
----
class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val fullName get() = "$givenName $familyName"
}
----
// end-insert

So, in Java, we _can_ access fields directly, but should generally write and call accessors, which are just methods, although often with a `get` (and maybe `set`) prefix.
In Kotlin, we cannot _publish_ direct field access, but we can auto-generate accessors, and call them as if they were field access if they match a naming convention.

=== How to Choose

Returning to the question at the beginning of the chapter, given that computed properties are just methods with sugar on top, when should we choose a computed property, and when should we choose a method?

Our rule of thumb is to use a property when it depends only on other properties of the type, and is cheap to compute.
This applies to `fullName`, so that is a good computed property.
What about age?

We can compute age easily (if only roughly) from the `dateOfBirth` property, so we might be tempted in Java to write `fred.getAge()`, but this is suspect.
It may be very unlikely, but the fact that the expression `fred.age == fred.age` may return `false` is the clue.
Age is an action (<<actions>>) - its result depends on when it is called.
Properties should be calculations (<<calculations>>) - timeless and dependent only on their inputs - in this case the `dateOfBirth` property.

What about a cryptographic hash of all the other properties of the object?
This is a calculation, but if it is expensive to compute, it should not be a property.
We can fudge this by calculating it up-front and storing it in a field:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash
[source,kotlin]
----
class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val hash: ByteArray =
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
}
----
// end-insert

This has the disadvantage of making every instance slow to create, whether or not `hash` is required.
We might split the difference with a lazy property:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash2
[source,kotlin]
----
class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val hash: ByteArray by lazy {
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
    }
}
----
// end-insert

In a limited scope this would be fine, but if the class was more widely used, your authors would revert to hinting at  the potential first-invocation performance issue by hiding the computed property behind a function.

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash3
[source,kotlin]
----
class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    private val hash: ByteArray by lazy {
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
    }
    fun hash() = hash
}
----
// end-insert

=== Refactoring to Properties



=== Conclusion

Short answer:

* when it's defined on a value
* and depends only on the value
* and is not expensive to compute