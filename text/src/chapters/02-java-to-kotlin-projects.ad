[[java-to-kotlin-projects]]
== Java To Kotlin Projects

What is the first step of the journey from pure Java to a mixed and then increasingly Kotlin codebase?

=== Where To Start?

The first time your authors Nat and Duncan introduced Kotlin to a Java codebase, we were a small team that included six developers, building a relatively greenfield project.
We had already deployed some web applications with Kotlin, but our enterprise architects insisted that we write the new system in Java 8.
This was shortly after Kotlin 1.0 had been released, but before Google announced that Kotlin was an official language for Android, so the architects were understandably wary about committing to a language with an uncertain future for a strategic system that they expected to be around for decades.

In Java, we leaned towards a functional approach, designing the core application domain model as immutable data types transformed by pipelines.
However, we kept bumping into Java's limitations: the verbosity required to implement immutable value types, the distinction between primitive and reference types, null references, Streams lacking common higher-order functions.
Meanwhile, we could see Kotlin being adopted at an ever-increasing rate across the industry, and even within the company.
When we saw Google's announcement, we decided to start converting our Java to Kotlin.

Our judgement was that starting in the core domain model would give us the biggest bang for our buck.
Kotlin's data classes shrunk the code significantly, in some cases replacing hundreds of lines of code with a single declaration.
We started carefully, using IntelliJ to convert a small value class that had no dependencies on other classes beyond those in the standard library, and examined how that affected the rest of our Java codebase.
It had no effect at all!
Emboldened by this success we picked up the pace.
Whenever a new feature needed changes to a Java domain model class, we would first convert it to a Kotlin data class, commit the conversion, and then implement the feature.

As more of the domain model logic became pure Kotlin, we were able to make better use of Kotlin features.
For example, we replaced calls to the Stream API with Kotlin's standard functions on collections and sequences.
The biggest improvement though, was replacing our use of Java's Optional type with nullable references.
This simplified our code and gave us greater confidence in its null safety.

Another project in the company adopted Kotlin for a different reason.
They had a mature Java system that was built on a dependency injection framework.
The developers found that the framework's use of reflection and annotations made the code difficult to understand and navigate in the IDE.
Kotlin's lightweight syntax for closures offered a way to define the structure of their application and distinguish between object graphs instantiated for the whole application, for each HTTP request, or each database transaction.
They gradually refactored the underpinnings of their system from a framework that obscured the architecture to a style that composed functions and made the architecture visible in the code.
This work became the https://http4k.org[http4k] web programming toolkit.

As these two examples show, your choice of starting point should depend on a number of factors including why your team is adopting Kotlin, how large the codebase is, and how frequently it changes.
Your know your project and can decide what is most important to change.

If you are choosing Kotlin for its language features it makes sense to convert the classes you are working in most frequently, as we did in the first example above.
If you are choosing Kotlin to use a specific library then it makes sense to start writing Kotlin against the API, annotate it to make your Kotlin code convenient to the Java code in the rest of the app, and continue from there.

In a small team it’s easy to establish the Kotlin coding style for your system (beyond the standard style guide) — eg error handling conventions, how code is to be organised into files, what should be a top-level declaration and what should be in an object, etc.

Above a certain size, you run the risk of Kotlin code becoming inconsistent as people establish their own conventions in different parts of the system.
So it may be worth starting with a small sub-team working in one area of the system, who establish conventions and build up a body of example code.
Once there are some established conventions, you can expand the effort to the rest of the team and other parts of the system.

In the rest of this book we will examine in detail how to progress, how to keep your Java code maintainable while you are introducing Kotlin that it depends upon, and how to take advantage of Kotlin's features to further simplify the code after IntelliJ has performed its conversion magic.
But all that follows the first small step.

=== Adding Kotlin Support to a Java Build

If we want to refactor our Java to Kotlin, the first change we must make is to give ourselves the ability to write Kotlin code in our codebase.
Happily, the Kotlin build tools and IDE make this very straightforward.
It takes a few additional lines in our Gradle build configuration for it to compile Kotlin as well as Java.
The IntelliJ IDE will pick up that configuration when we resync the build file, allowing us to navigate, autocomplete and refactor across both languages almost seamlessly.

To add Kotlin to our Gradle build we need to add the Kotlin plugin.
There is a different plugin for each target that Kotlin supports (JVM, JavaScript and native code), and a plugin for building multiplatform projects.
Because we have a Java project, we can ignore other platforms and use the Kotlin JVM plugin.

We also need to add the Kotlin standard library to our dependencies, and specify the minimum JVM version that the output bytecode will support.
Our project targets JDK 11 (the latest LTS at the time of writing).
At the time of writing, the Kotlin compiler can generate bytecode compatible with JDK 1.6 or JDK 1.8. JDK 1.8 bytecode is more efficient and runs fine on JDK 11, so we will pick that.

Here are the relevant parts of our `build.gradle` before the changes:

// begin-insert: tags/baseline.0:build.gradle#java_build
[source,groovy]
----
plugins {
    id("java")
}

java.sourceCompatibility = JavaVersion.VERSION_11
java.targetCompatibility = JavaVersion.VERSION_11
// ... and other project settings ...

dependencies {
    implementation "com.fasterxml.jackson.core:jackson-databind:2.10.0"
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.10.0"
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.10.0"
    // ... and the rest of our app's implementation dependencies

    testImplementation "org.junit.jupiter:junit-jupiter-api:5.4.2"
    testImplementation "org.junit.jupiter:junit-jupiter-params:5.4.2"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:5.5.2"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher:1.4.2"
    // ... and the rest of our app's test dependencies
}

// ... and the rest of our build rules
----
// end-insert

After we have added the Kotlin plugin, our build file looks like this:

// begin-insert: tags/baseline.1:build.gradle#kotlin_plugin
[source,groovy]
----
plugins {
    id 'org.jetbrains.kotlin.jvm' version "1.5.0"
}

java.sourceCompatibility = JavaVersion.VERSION_11
java.targetCompatibility = JavaVersion.VERSION_11
// ... and other project settings ...

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    // ... and the rest of our app's dependencies
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {
    kotlinOptions {
        jvmTarget = "11"
        javaParameters = true
        freeCompilerArgs = ["-Xjvm-default=all"]
    }
}

// ... and the rest of our build rules
----
// end-insert:

Given those changes, we can rerun our build, and see that ...

...

... the build still works!

If we resync the Gradle project in IntelliJ (this may happen automatically on saving), we can run our tests and programs within the IDE.

Our tests still pass, so we haven't broken anything, but neither have we proved that we can use Kotlin in our project.
Let's test that by writing a "hello world" program.
We create a file, `HelloWorld.kt`, in the root package of our Java source tree, `src/main/java`:

.HelloWorld.kt
// begin-insert: tags/baseline.1:src/main/java/HelloWorld.kt
[source,kotlin]
----
fun main() {
    println("hello, world")
}
----
// end-insert

[TIP]
.Where to Put Kotlin Source
====
The Kotlin build plugin adds additional source roots, `src/main/kotlin` and `src/test/kotlin`, and compiles Kotlin source files found in any of their subdirectories.

It will also compile Kotlin source found in Java source trees, in particular `src/main/java` and `src/test/java`.
Whilst you can separate your source files by language, putting Java files in the `java` directories and Kotlin into `kotlin`, in practice your authors don't bother.
It's nice to be able to look into a directory and see all the source for the the corresponding package rather than casting around the filesystem.
In order to make this work though, we keep Kotlin source in directories mirroring the package structure, rather than taking advantage of Kotlin's ability to have files in a single directory but multiple packages.

In a similar vein, while Kotlin does allow multiple public classes to be defining in a single class, when we are mixing Java and Kotlin in a project we tend to stick to one class per file for consistency.
====

We can run that within the IDE by clicking on the little green arrow in the left hand margin next to "fun main()".

And we can run our build, and then run it from the command line with the `java` command.
Compiling the source file named HelloWorld.kt creates a Java class file named `HelloWorldKt`.
We'll look into how Kotlin source gets translated into Java class files in more detail later, but for now, we can run our program with the `java` command like so:

[source,text]
----
$ java -cp build/classes/kotlin/main HelloWorldKt
hello, world
----

It lives!

Let's delete HelloWorld.kt -- it's done its job -- commit and push.

We now have the _option_ to use Kotlin in our project - the first part of this chapter gives some pointers to _where_ to start using it.

.Other Build Systems
****
We've chosen to show the changes necessary to add Kotlin support to a Gradle build here, but you can use Maven or Ant by following the instructions provided in the Tools section at https://KotlinLang.org[https://kotlinlang.org/docs/reference/].
This also gives instructions for using the command-line compiler, `kotlinc`.

If you use Gradle, there is the option to use Kotlin, rather than the traditional Groovy, as the build definition language.
This has the advantage of providing better tool support through strong typing, at the expense of having to translate historical StackOverflow answers into a new language.

As we are Java and Kotlin developers rather than Java and Groovy developers, your authors start new projects with the Kotlin DSL, but we don't feel the need to convert existing Groovy builds, at least not immediately.
As with the Java and Kotlin in production code, we can mix and match Kotlin and Groovy in our build, so this is a conversion that we can take our time over.
We certainly don't recommend that you switch your build from Groovy to Kotlin as your first act of conversion, and don't look to us to write a Gradle Groovy to Kotlin book!
****

=== Conclusion

Adding Kotlin to a Java build is straightforward, even if we expect the instructions here to be out of date for most of the life of this book.

Devising a strategy for moving code from Java to Kotlin is more complicated and context-specific.
Individual projects should examine where Java is and isn’t working for them, and where using Kotlin would alleviate problems and improve the code.
In <<java-to-kotlin-classes>>, we'll look at what is involved in converting an existing Java class to Kotlin.


