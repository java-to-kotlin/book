[[streams-to-sequences]]
== Streams to Sequences

Java and Kotlin both allow us to transform and summarise collections.
They have different design goals and implementations though.
What does Kotlin use instead of Java streams, when should we convert, and how?

=== Java Streams

Java 8 introduced streams in 2014, making good use of the new lambdas.
Previously we might have written:

// begin-insert: src/main/java/sequences/Streams.java#loop
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    var sum = 0;
    for (var s : strings) {
        if (!s.isBlank())
            sum += s.length();
    }
    return sum / (double) strings.size();
}
----
// end-insert

Now we could `filter`, `map` and `reduce` by converting the `List` to a `Stream`.

// begin-insert: src/main/java/sequences/Streams.java#stream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .stream()
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

If we are really in a hurry for those results we can even write:

// begin-insert: src/main/java/sequences/Streams.java#parallelStream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .parallelStream() // <1>
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

<1> `parallelStream` will divide the work across multiple threads.

We soon learned that ++Stream++s are lazy: `strings.filter(...).mapToInt(...)` does nothing but set up a pipeline for some terminal operation (`sum()` in this case) to suck values out of.
On the subject of sucking and performance, we also discovered that streams could be surprisingly slow for small collections.
They are great for large-scale data crunching where we want to throw all available cores at a problem; not so great for summing the cost of 5 items in a shopping cart.

=== Kotlin Iterables

Instead of defining a new interface to host collections operations, Kotlin provides extension functions on `Iterable`.
The simplest Kotlin expression of the same algorithm is:

// begin-insert: src/main/java/sequences/sequences.kt#lists
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .filter { it.isNotBlank() }
        .map(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

Here `filter` is an extension function on `Iterable`.
Unlike the `Stream.filter` though, which returns another `Stream`, the Kotlin `filter` returns a `List`.
As does `map`, so the net result is that this single expression creates two additional lists in memory.
The first is a `List` of the non-blank strings, the second is a `List` of the lengths of those strings.
When (if) we care about performance, this can be a problem, because both of those lists will take time to populate and memory to support.
The `List` of lengths is a particular issue, because the integers will have had to be boxed (wrapped in an `Integer` object) to fit in the list.
The Java streams example used `mapToInt(String::length)` to avoid this problem.
`IntStream` (and `LongStream` and `DoubleStream`, but curiously not `BooleanStream` or `CharStream`) were created to prevent streams having to boxing and unbox, but you have to remember to use them, and `IntStream` is not a `Stream<Integer>`.

Anyway, should we care about performance?
Mostly no - the Kotlin will be fast enough _unless_ we have large collections; the opposite of streams, which are only fast enough _if_ we have large collections.
When we do have large collections, we can switch over to sequences.

=== Kotlin Sequences

The Kotlin `Sequence` abstraction offers the same lazy evaluation as Java streams.
`map` on a `Sequence` returns another `Sequence`: the operations in a filter chain are only performed when some terminal operation requires their evaluation.
`Iterable.asSequence()` converts a collection to a `Sequence`, after that the API is suspiciously familiar:

// begin-insert: src/main/java/sequences/sequences.kt#sequences
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .asSequence()
        .filter { it.isNotBlank() }
        .map(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

The familiarity is suspicious because all those operations (`filter`, `map`, `sum`) are now extensions not on `Iterable` but `Sequence`, and they don't return a `List`, they return another `Sequence`.
Except for `sum`, which can't even pretend to do its job without reading all the data, and so is a terminal operation.

.Swapping Iterables and Sequences
****
`Iterable<T>` and `Sequence<T>` have the same single method signature: `public operator fun iterator(): Iterator<T>`
They both also have extension functions for `map`, `filter`, `reduce` etc which take the same parameters.
But they are not the same type.
They are different types because their semantics are very different.
The operations on `Iterable` are eager, whilst those on `Sequence` are lazy - so we cannot swap one for the other with impunity (as we will see later in this chapter).

Nevertheless, the fact that they have such similar APIs means that in situations like this, we can often change very little (source) code when we swap between them.
****

This sequence version won't pay the price of creating intermediate collections, but it will still box the lengths, albeit one at a time rather than creating a whole list of them.
In many cases the API designers will have provided a clever solution to remove boxing: in this case it is `sumBy`:

// begin-insert: src/main/java/sequences/sequences.kt#sumBy
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .asSequence()
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / strings.size.toDouble())
----
// end-insert

`sumBy` avoids the boxing by taking a function that returns an `int`.
IntelliJ is getting increasingly good at spotting when pipeline stages can be merged like this, although it failed to spot this one.
There are also times when it will suggest converting an `Iterable` chain to a `Sequence` chain, although the heuristics that it uses seem to vary over Kotlin plugin releases.

[[sequences-multiple-operations]]
=== Multiple Iterations

If you are used to using Java streams, you will probably have tried to do something like this:

// begin-insert: src/main/java/sequences/Streams.java#consumingTwice
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return averageNonBlankLength(strings.stream());
}

public static double averageNonBlankLength(Stream<String> strings) {
    return strings
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.count();
}
----
// end-insert

This looks very plausible, we've extracted a function taking a `Stream`, and then used `Stream.count()` rather than `List.size()`.
When we run it though, we get `java.lang.IllegalStateException: stream has already been operated upon or closed`.

The problem is that a `Stream` has hidden state.
Once we have consumed all its items (and `sum()` does just that), we can't go round again to `count()` them, even though the `sum` is actually on an `IntStream`.
Consuming the `IntStream` needs to consume the `Stream<String>.

In Java this is enough to put you off extracting `Stream` operations into functions.
Let's try the same thing with a Kotlin `Sequence`:

// begin-insert: src/main/java/sequences/sequences.kt#consumingTwice
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    averageNonBlankLength(strings.asSequence())

fun averageNonBlankLength(strings: Sequence<String>): Double =
    (strings
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / strings.count().toDouble())
----
// end-insert

In Kotlin, we can call the `Sequence` version from the `List` version and all is fine.

For now.

It's easy to convert from an `Iterator` to a `Sequence` - let's add an function for that too:

// begin-insert: src/main/java/sequences/sequences.kt#iterator
[source,kotlin]
----
fun averageNonBlankLength(strings: Iterator<String>): Double =
    averageNonBlankLength(strings.asSequence())
----
// end-insert

If we call this function, we now get `java.lang.IllegalStateException: This sequence can be consumed only once.` (Kotlin developers seem to be more grammatically pedantic than the JVM developers).
Now the `Sequence` is acting like a Java `Stream`, but previously it wasn't.
It turns out that some ++Sequence++s can safely be iterated over multiple times - those backed by a collection which is held in memory for example.
Others cannot.
In this case if we tried to reuse the `strings` `Iterator` it would immediately return false from `hasNext()`, `strings.count()` would be `0`, and `averageNonBlankLength` would always return `Infinity` if there was any input.
The other canonical example of a `Sequence` that cannot be consumed more than once is one obtained by reading from an external resource, such a file or network socket.

Unfortunately the difference between the two types of `Sequence` is not reflected in the type system, so we will only discover any incompatibility between our algorithm and our input at runtime.
As we will see in <<kotlin-from-scratch>>, this is exacerbated by the happy path of using ++List++s converted to ++Sequence++s as our test data - these ++Sequence++s do support multiple iterations and won't warn us of the problem.

In practice this problem is usually only an irritation, causing some wasted time and reworking.
It will tend not to happen if you are converting from streams code, as that will not have had the issue in the first place, but rather when applying a `Sequence` from scratch, or converting from an `Iterable`.
In this case we can make things work by keeping count of items as they whizz past in the first iteration, rather than counting again at the end:

// begin-insert: src/main/java/sequences/sequences.kt#peekCount
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double {
    var count = 0
    return (strings
        .onEach { count++ }
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / count.toDouble())
}
----
// end-insert

At the time of writing, this is the first problem that we have solved in the book text with a mutable variable!
We can hide our shame inside a more generally useful utility class:

// begin-insert: src/main/java/sequences/sequences.kt#CountingSequence
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double =
    CountingSequence(strings).let { counter ->
        (counter
            .filter { it.isNotBlank() }
            .sumBy(String::length)
            / counter.count.toDouble())
    }

class CountingSequence<T>(
    private val wrapped: Sequence<T>
) : Sequence<T> {
    var count = 0

    override fun iterator() =
        wrapped.onEach { count++ }.iterator()
}
----
// end-insert

This is something of a recurrent theme in implementing Kotlin algorithms - we might occasionally need to stoop to mutation to implement something in a sensible way, but we can often hide the details in a way that both reduces its visibility and makes for a useful abstraction.
In this case this is aided by the fact that `Sequence` is an interface with just one method, making it very easy to implement it ourselves.
Java's `Stream` is also an interface, but with 42 methods, and no `AbstractStream` class to provide default implementations!

Finally, you may have been silently fuming from point at which we introduced `Stream.count()`.
The point of `Stream` and `Sequence` is that they allow us to work on arbitrarily large datasets, and finding the size of these by counting them individually is not very efficient, even if it can be sometimes be done.
In general, even if we can in practice iterate over a `Sequence` more than once, it is likely to be inefficient in the use-cases that caused us to chose to use `Sequence` in the first place.
So when we remember, your authors like to use `Sequence.constrainOnce()` on test data to prevent us from cutting corners on the straight and narrow path.

=== Choosing between Streams, Iterables and Sequences

If you already have code using Java streams, it will continue to run just fine on the JVM, even when converted to Kotlin.
It will even look a little nicer, as Kotlin will move the lambda outside the method, and allow the use of `it`.

// begin-insert: src/main/java/sequences/sequences.kt#streams
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .stream()
        .filter { it.isNotBlank() }
        .mapToInt(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

In addition, we can use extension functions to 'add' operations to ++Stream++s, in the same way as Kotlin defines its `Sequence` operations.

If your code is working on large collections, and in particular using `parallelStream()`, then the default should be to leave it using ++Stream++s, as these are well optimised by HotSpot.
The Kotlin standard library even provides extensions `Stream<T>.asSequence()` and `Sequence<T>.asStream()` to swap horses.
For smaller collections, or when writing from scratch in Kotlin, `Iterable` pipelines are simple, generally quick, and easy to reason with.
Your authors will often convert ++Stream++s to ++Iterables++ in order to take advantage of the far richer API that Kotlin provides.
If ++Iterable++s prove too slow (or sometimes too greedy for memory) with large collections, then we can convert to ++Sequence++s.
If that still isn't enough, we can move (hopefully not back) to ++Stream++s, and maybe even take advantage of parallelism.

=== Refactoring from Streams to Sequences

Travelator logs operational events as it runs, so that we know that it is working as we expect
These

=== Conclusion
