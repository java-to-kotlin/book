[[streams-to-sequences]]
== Streams to Sequences

Java and Kotlin both allow us to transform and reduce collections.
They have different design goals and implementations though.
What does Kotlin use instead of Java streams, when should we convert, and how?

=== Java Streams

Java 8 introduced streams in 2014, making good use of the new lambdas.
Say we want to work out the average length of some strings, where blank strings count as 0 characters.
Previously we might have written:

// begin-insert: src/main/java/sequences/Streams.java#loop
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    var sum = 0;
    for (var s : strings) {
        if (!s.isBlank())
            sum += s.length();
    }
    return sum / (double) strings.size();
}
----
// end-insert

Feel free to suggest a better name for the function!
Name aside, with streams we can now `filter`, `map` and `reduce` by converting the `List` to a `Stream`.

// begin-insert: src/main/java/sequences/Streams.java#stream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .stream()
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

If we are really in a hurry for those results we can even write:

// begin-insert: src/main/java/sequences/Streams.java#parallelStream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .parallelStream() // <1>
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

<1> `parallelStream` will divide the work across multiple threads.

Note that there are different types of fundamental operations going on here.
`map` changes the type of items, but there are the same number of them.
`filter` keeps or rejects items depending on some property, but keeps their type the same.
`sum' is a _reduction_ of the collection to a single property.
Not shown in this example are the operations `skip(int n)` and `limit(int n)`.
These return streams without the first and last `n` elements respectively.

We soon learned that streams are lazy: `strings.filter(...).mapToInt(...)` does nothing but set up a pipeline for some terminal operation (`sum()` in this case) to suck values out of.
Laziness allows later pipeline stages to limit the amount of work performed by earlier stages.
Consider translating a list of words until we see the word `STOP`.
The loop version might look like this:

// begin-insert: src/main/java/sequences/Streams.java#translatingLoop
[source,java]
----
public static List<String> translatedWordsUntilSTOP(List<String> strings) {
    var result = new ArrayList<String>();
    for (var word: strings) {
        String translation = translate(word);
        if (translation.equalsIgnoreCase("STOP"))
            break;
        else
            result.add(translation);
    }
    return result;
}
----
// end-insert

By breaking out of the loop we only don't translate all the words, only the minimum we need.
Java 9 introduced `dropWhile` and `takeWhile`, which allow us to translate this to:

// begin-insert: src/main/java/sequences/Streams.java#translatingStream
[source,java]
----
public static List<String> translatedWordsUntilSTOP(List<String> strings) {
    return strings
        .stream()
        .map(word -> translate(word))
        .takeWhile(translation -> !translation.equalsIgnoreCase("STOP"))
        .collect(toList());
}
----
// end-insert

This works because the `collect` causes values to be sucked through the pipeline, and `takeWhile` stops sucking when its predicate fails.

On the subject of sucking, we also discovered that streams could be surprisingly slow for small collections.
They are great for large-scale data crunching where we want to throw all available cores at a problem; not so great for summing the cost of 5 items in a shopping cart.

The problem is that Java streams were designed to solve several problems, and they can't do them all well.
Kotlin provides two abstractions that support transforming and reducing collections, iterables and sequences, with fewer compromises provide we make the right choice.

=== Kotlin Iterables

Instead of defining a new interface to host collections operations, Kotlin provides extension functions on `Iterable`.
The simplest Kotlin expression of the same algorithm is:

// begin-insert: src/main/java/sequences/sequences.kt#lists
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .filter { it.isNotBlank() }
        .map(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

Here `filter` is an extension function on `Iterable`.
Unlike the `Stream.filter` though, which returns another `Stream`, the Kotlin `filter` returns a `List`.
As does `map`, so the net result is that this single expression creates two additional lists in memory.
The first is a `List` of the non-blank strings, the second is a `List` of the lengths of those strings.
When (if) we care about performance, this can be a problem, because both of those lists will take time to populate and memory to support.
The `List` of lengths is a particular issue, because the integers will have had to be boxed (wrapped in an `Integer` object) to fit in the list.
The Java streams example used `mapToInt(String::length)` to avoid this problem.
`IntStream` (and `LongStream` and `DoubleStream`, but curiously not `BooleanStream` or `CharStream`) were created to prevent streams having to boxing and unbox, but you have to remember to use them, and `IntStream` is not a `Stream<Integer>`.

Anyway, should we care about performance?
Mostly no - the Kotlin will be fast enough _unless_ we have large collections; the opposite of streams, which are only fast enough _if_ we have large collections.
When we do have large collections, we can switch over to sequences.

=== Kotlin Sequences

The Kotlin `Sequence` abstraction offers the same lazy evaluation as Java streams.
`map` on a `Sequence` returns another `Sequence`: the operations in the chain are only performed when some terminal operation requires their evaluation.
If we have a `Collection`, `Iterable`, or even an `Iterator`, there are `asSequence()` extension functions to convert, after that the API is suspiciously familiar:

// begin-insert: src/main/java/sequences/sequences.kt#sequences
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .asSequence()
        .filter { it.isNotBlank() }
        .map(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

The familiarity is suspicious because all those operations (`filter`, `map`, `sum`) are now extensions not on `Iterable` but `Sequence`, and they don't return a `List`, they return another `Sequence`.
Except for `sum`, which can't even pretend to do its job without reading all the data, and so is a terminal operation.

.Swapping Iterables and Sequences
****
`Iterable<T>` and `Sequence<T>` have the same single method signature: `public operator fun iterator(): Iterator<T>`
They both also have extension functions for `map`, `filter`, `reduce` etc which take the same parameters.
But they are not the same type.
They are different types because their semantics are very different.
The operations on `Iterable` are eager, whilst those on `Sequence` are lazy - so we cannot swap one for the other with impunity (as we will see later in this chapter).

Nevertheless, the fact that they have such similar APIs means that in situations like this, we can often change very little (source) code when we swap between them.
****

The sequence version of `averageNonBlankLength` won't pay the price of creating intermediate collections, but for small numbers of items, the cost of setting up and executing the pipeline may be higher still.
In this case the `Int` lengths will still be boxed as `Integer`, albeit one at a time rather than creating a whole list of them.
In many cases the API designers will have provided a clever solution to remove boxing: in this case it is `sumBy`:

// begin-insert: src/main/java/sequences/sequences.kt#sumBy
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .asSequence()
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / strings.size.toDouble())
fun averageNonBlankLength(strings: List<String>): Double =
    strings
        .map { if (it.isBlank()) 0 else it.length }
        .average()
----
// end-insert

`sumBy` (also available as an extension on `Iterable`) avoids the boxing by taking a function that returns an `Int`.
IntelliJ is getting increasingly good at spotting when pipeline stages can be merged like this, although it failed to spot this one.
There are also times when it will suggest converting an `Iterable` chain to a `Sequence` chain, although the heuristics that it uses seem to vary over Kotlin plugin releases.

[[sequences-multiple-operations]]
=== Multiple Iterations

If you are used to using Java streams, you will probably have tried to do something like this:

// begin-insert: src/main/java/sequences/Streams.java#consumingTwice
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return averageNonBlankLength(strings.stream());
}

public static double averageNonBlankLength(Stream<String> strings) {
    return strings
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.count();
}
----
// end-insert

This looks very plausible, we've extracted a function taking a `Stream` rather than the `List`.
There is no `size` property on `Stream`, but `count()` gives the same result, so we use that.
When we run it though, we get `java.lang.IllegalStateException: stream has already been operated upon or closed`.

The problem is that a `Stream` has hidden state.
Once we have consumed all its items (and `sum()` does just that), we can't go round again to `count()` them.
(Even though the `sum` is actually on an `IntStream`, consuming the `IntStream` needs to consume the `Stream<String>.)

In Java this is enough to put you off extracting `Stream` operations into functions.
Let's try the same thing with a Kotlin `Sequence`:

// begin-insert: src/main/java/sequences/sequences.kt#consumingTwice
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    averageNonBlankLength(strings.asSequence())

fun averageNonBlankLength(strings: Sequence<String>): Double =
    (strings
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / strings.count().toDouble())
----
// end-insert

In Kotlin, we can call the `Sequence` version from the `List` version and all is fine.

For now.

We are storing up trouble though.
To see why, let's step out another layer and add a function that takes an `Iterator`:

// begin-insert: src/main/java/sequences/sequences.kt#iterator
[source,kotlin]
----
fun averageNonBlankLength(strings: Iterator<String>): Double =
    averageNonBlankLength(strings.asSequence())
----
// end-insert

If we call this function, we now get `java.lang.IllegalStateException: This sequence can be consumed only once.` (The Kotlin developers seem to be more grammatically pedantic than the JVM developers.)
Now the `Sequence` is acting like a Java `Stream`, but previously it wasn't.
What gives?

It turns out that some sequences can safely be iterated over multiple times - those backed by a collection which is held in memory for example.
Others cannot.
In this case if we tried to reuse the `strings: Iterator<String>` it would immediately return false from `hasNext()`; `strings.count()` would be `0`; and `averageNonBlankLength` would always return `Infinity` if there was any input.
This sort of behaviour is, erm, undesirable, so sequences wrapping iterators are deliberately hobbled with `constrainOnce()` to prevent this.

The other canonical example of a `Sequence` that cannot be consumed more than once is one backed by reading from an external resource, such a file or network socket - we can't in general just go back and replay input to iterate again.

Unfortunately the difference between the two types of `Sequence` is not reflected in the type system, so we will only discover any incompatibility between our algorithm and our input at runtime.
As we will see in <<kotlin-from-scratch>>, this is exacerbated by the common technique of using `List.asSequence()` as our test data - these sequences _do_ support multiple iterations and won't warn us of the problem.

In practice this problem is usually only an irritation, causing some wasted time and reworking.
It will tend not to happen if you are converting from streams code, as that will not have had the issue in the first place, but rather when applying a `Sequence` from scratch, or converting from an `Iterable`.

In this particular case we can make things work by keeping count of items as they whizz past in the first iteration, rather than counting again at the end:

// begin-insert: src/main/java/sequences/sequences.kt#peekCount
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double {
    var count = 0
    return (strings
        .onEach { count++ }
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / count.toDouble())
}
----
// end-insert

When we wrote this, it was the first problem that we solved in the book text with a mutable variable!
We can hide our shame inside a more generally useful utility class:

// begin-insert: src/main/java/sequences/sequences.kt#CountingSequence
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double =
    CountingSequence(strings).let { counter ->
        (counter
            .filter { it.isNotBlank() }
            .sumBy(String::length)
            / counter.count.toDouble())
    }

class CountingSequence<T>(
    private val wrapped: Sequence<T>
) : Sequence<T> {
    var count = 0

    override fun iterator() =
        wrapped.onEach { count++ }.iterator()
}
----
// end-insert

This a recurrent theme in implementing Kotlin algorithms - we might occasionally need to stoop to mutation to implement something in a sensible or efficient way, but we can often hide the mutation in a way that both reduces its visibility and makes for a useful abstraction.
In this case this is aided by the fact that `Sequence` is an interface with just one method, making it very easy to implement it ourselves.
Java's `Stream` is also an interface, but with 42 methods, and no `AbstractStream` class to provide default implementations!

Finally, you may have been silently fuming from point at which we introduced `Stream.count()`.
One of the points of `Stream` and `Sequence` is that they allow us to work on arbitrarily large datasets, and finding the size of these by counting them individually is not very efficient, even if it can be sometimes be done.
In general, even if we can in practice iterate over a `Sequence` more than once, it is likely to be inefficient in the use-cases that caused us to chose to use `Sequence` in the first place.

[TIP]
.Only Iterate Over a Sequence Once
====
As a rule of thumb, if they operate on a `Sequence`, our algorithms should complete in a single pass.
This way they will be able to work with sequences that do not support multiple iteration, and be efficient with large numbers of items.

We can use `Sequence.constrainOnce()` in our tests to make sure that we don't accidentally go round again.
====

=== Choosing between Streams, Iterables and Sequences

If we already have code using Java streams, it will continue to run just fine on the JVM, even when converted to Kotlin.
It will even look a little nicer, as Kotlin will move the lambda outside the method, and allow the use of `it`.

// begin-insert: src/main/java/sequences/sequences.kt#streams
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .stream()
        .filter { it.isNotBlank() }
        .mapToInt(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

In addition, we can use extension functions to 'add' operations to streams, in the same way as Kotlin defines its `Sequence` operations.

If our code is working on large collections, and in particular using `parallelStream()`, then the default should be to leave it using streams, as these are well optimised by the JVM.
The Kotlin standard library even provides extensions `Stream<T>.asSequence()` and `Sequence<T>.asStream()` to swap horses.

If we decide to convert to a Kotlin abstraction, either `Iterable` or `Sequence`, then we can choose which depending on whether the streams code needs lazy evaluation or not.

Lazy evaluation is required if:

* We need to produce results before we have finished reading the input.
* We need to process more data than we can fit into memory (including intermediate results).

Lazy evaluation may give better performance for:

* Large collections with many pipeline stages, where building intermediate collections may be slow.
* Pipelines where later stages may limit the amount of work required by previous stages.

We can illustrate the last point with the same translation example we saw with streams.
If we convert this to use `Iterable`:

// begin-insert: src/main/java/sequences/sequences.kt#translatingList
// end-insert

then all words in the input `List` will be converted by `map`, and then we will form another `List` of only those until `STOP`.
Passing through a `Sequence`:

// begin-insert: src/main/java/sequences/sequences.kt#translatingSequence
// end-insert

will translate only the words until we translate one to `STOP`.

If we don't need lazy evaluation, and for smaller collections, or when writing from scratch in Kotlin, `Iterable` pipelines are simple, generally quick, and easy to reason with.
Your authors will often convert streams to iterables in order to take advantage of the far richer API that Kotlin provides.
If iterables prove too slow (or sometimes too greedy for memory) with large collections, then we can convert to sequences.
If that still isn't enough, we can move (hopefully not back) to ++Stream++s, and maybe even take advantage of parallelism.

=== Refactoring from Streams to Sequences

Travelator logs operational events as it runs, so that we know that it is working as we expect.
These are sent as JSON to an indexing server, which can generate pretty graphs and alerts with its own query language.
Somehow though, those nice people in marketing are always asking questions that we don't know how to write queries for.
In these cases we fetch events and process them locally.
All the marshalling and paging of the events is hidden behind a simple interface which returns a `Iterator<Map<String, Object>`, where `Map<String, Object>` represents a JSON object.
We can use that `Iterator` as a `Stream` with a simple conversion:

// begin-insert: tags/streams-to-sequences.0:src/main/java/travelator/analytics/EventStore.java
[source,java]
----
public interface EventStore {

    Iterator<Map<String, Object>> query(String query);

    default Stream<Map<String, Object>> queryAsStream(String query) {
        Iterable<Map<String, Object>> iterable = () -> query(query);
        return StreamSupport.stream(iterable.spliterator(), false);
    }
}
----
// end-insert

Here is the sort of thing that we find ourselves having to write - it calculates the average number of interactions a customer made to successfully complete a booking:

// begin-insert: tags/streams-to-sequences.0:src/main/java/travelator/analytics/MarketingAnalytics.java#excerpt
[source,java]
----
public double averageNumberOfEventsPerCompletedBooking(
    String timeRange
) {
    Stream<Map<String, Object>> eventsForSuccessfulBookings =
        eventStore
            .queryAsStream("type=CompletedBooking&timerange=" + timeRange)
            .flatMap(event -> {
                String interactionId = (String) event.get("interactionId");
                return eventStore.queryAsStream("interactionId=" + interactionId);
            });
    Map<String, List<Map<String, Object>>> bookingEventsByInteractionId =
        eventsForSuccessfulBookings.collect(groupingBy(
            event -> (String) event.get("interactionId"))
        );
    var averageNumberOfEventsPerCompletedBooking =
        bookingEventsByInteractionId
            .values()
            .stream()
            .mapToInt(List::size)
            .average();
    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN);
}
----
// end-insert

This contains two types of `Stream` interactions.
The first type, the query responses, are of indeterminate length - we don't know even after the first results are returned how many more pages the server will find.
The second type, the `Stream` of `Map.values()`, are all in-memory when we create the `Stream`.
Keep this distinction in mind as we convert to Kotlin.

Here is the result of the automated conversion:

// begin-insert: tags/streams-to-sequences.1:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsStream("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event: Map<String?, Any?> ->
            val interactionId = event["interactionId"] as String?
            eventStore.queryAsStream("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
        Collectors.groupingBy(
            Function { event: Map<String, Any> -> event["interactionId"] as String? })
    )
    val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
        .values
        .stream()
        .mapToInt { obj: List<Map<String, Any>> -> obj.size }
        .average()
    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)
}
----
// end-insert

Let's start by tidying up nullability, removing the vestigial `Function`, and simplifying that ugly `mapToInt` lambda:

// begin-insert: tags/streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsStream("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore.queryAsStream("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
        groupingBy { event -> event["interactionId"] as String }
    )
    val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
        .values
        .stream()
        .mapToInt { it.size }
        .average()
    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)
}
----
// end-insert

The Java code before conversion mixed some old-style explicitly typed variables, `Stream<Map<String, Object>>` for example, with the implicit `var averageNumberOfEventsPerCompletedBooking`.
The Kotlin seems to less comprehensible without the explicit types - we'll leave it for now but review our decision before we finish.

[TIP]
.Implicit or Explicit Types
====
Sometimes a variable's type is essential to understanding how code works, other times it just clutters an already wordy block.
In this respect explicit types are like comments, but they have the added advantage that they are checked and enforced by the compiler.
As with comments, we should strive to write code that doesn't need explicit variable types.
Good naming can help, as can refactoring into functions where the return type can be shown.

If these fail though, there is no shame in showing the type of a variable if it improves the readability of the code, and we should certainly prefer to communicate in types than comments.
====

At this point we have code that runs just fine calling Java streams from Kotlin.
We could leave it alone - Travelator is a huge success, there are many thousands of completed bookings a day, so streams are a good choice for throughput.
You didn't buy this book for that sort of attitude though, so we'll push on under the pretense that we are measuring performance at every stage and will stop if we see it degrade.

We noted that the code has two reasons for using ++Stream++s.
The first stage processes an input of determinant length, producing a collection in memory:

// begin-insert: tags/streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore.queryAsStream("interactionId=$interactionId")
    }
val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
    groupingBy { event -> event["interactionId"] as String }
)
----
// end-insert

The second processes that collection:

// begin-insert: tags/streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
    .values
    .stream()
    .mapToInt { it.size }
    .average()
return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)
----
// end-insert

Acting on in-memory data is easier to reason with, so we'll convert `averageNumberOfEventsPerCompletedBooking` first.
Until IntelliJ comes up with automated refactoring, we are left having to do this by hand.
Usually we would have tests to make this safer, but this fast-moving and arbitrary analytics code, so it turns out we cut corners.
We write a quick test that talks to production and shows that the result for yesterday was 7.44 - now we can keep running that to check that it doesn't change.

We know that we can apply collection operations directly to `Map.values` in Kotlin (those on `Iterable`), so we can remove the `.stream()` and type in a translation of the Java:

// begin-insert: tags/streams-to-sequences.3:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
    .values
    .map { it.size }
    .average()
return averageNumberOfEventsPerCompletedBooking
----
// end-insert

Where `IntStream.average()` returns an empty `OptionalDouble` if the stream has no elements, Kotlin's `Iterable<Int>.average()` returns _Not A Number_, which is convenient for us.
Has this been a good change though?

Looking at the code, we are now creating an intermediate `List<Int>` on which to call `average()`.
This will result in boxing each value, and this time there is no `averageBy()` as there was `sumBy()` to prevent this.
Whether or not this code performs better than the stream version will probably depend on the number of values in the `Map`, how our particular JVM optimizes boxing, how heavily HotSpot has optimized this path - only measuring in real conditions will tell.
If we have to choose a generic solution then we should probably write our own `List.averageBy` - that way we can leverage knowing the size of a `List`.
We can do this by extracting `values` and using `sumBy()`:

// begin-insert: tags/streams-to-sequences.4:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val values = bookingEventsByInteractionId.values
return values.sumBy { it.size } / values.size.toDouble()
----
// end-insert

Now "Extract Function" `averageBy`:

// begin-insert: tags/streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val values = bookingEventsByInteractionId.values
return averageBy(values)
----
// end-insert

// begin-insert: tags/streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun averageBy(values: MutableCollection<MutableList<MutableMap<String, Any>>>): Double {
    return values.sumBy { it.size } / values.size.toDouble()
}
----
// end-insert

Eeek, it turns out that the type of `bookingEventsByInteractionId` was a lot more mutable than we wanted - `Collectors.groupingBy` only has Java collections to return after all.
We'll just solidify the `MutableCollection` for now, and then "Introduce Parameter" named `selector` on the lambda:

// begin-insert: tags/streams-to-sequences.6:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun averageBy(
    values: Collection<MutableList<MutableMap<String, Any>>>,
    selector: (MutableList<MutableMap<String, Any>>) -> Int
): Double {
    return values.sumBy(selector) / values.size.toDouble()
}
----
// end-insert

Now we don't want to care about the actual type of items in the `Collection`.
If we select the `MutableList<MutableMap<String, Any>>` and "Extract/Introduce Type Parameter", we get the following:

// begin-insert: tags/streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun <T : MutableList<MutableMap<String, Any>>> averageBy(
    values: Collection<T>,
    selector: (T) -> Int
): Double {
    return values.sumBy(selector) / values.size.toDouble()
}
----
// end-insert

That's clever enough that we don't begrudge having to tell IntelliJ that `T` can be anything really:

// begin-insert: tags/streams-to-sequences.8:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun <T> averageBy(
    values: Collection<T>,
    selector: (T) -> Int
): Double {
    return values.sumBy(selector) / values.size.toDouble()
}
----
// end-insert

For some reason the invocation also became a little generic-tastic:

// begin-insert: tags/streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val values = bookingEventsByInteractionId.values
return averageBy<MutableList<MutableMap<String, Any>>>(values) { it.size }
----
// end-insert

We'll fix that at the same time as making `averageBy` a tidy single-expression inline extension function:

// begin-insert: tags/streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
inline fun <T> Collection<T>.averageBy(selector: (T) -> Int): Double =
    sumBy(selector) / size.toDouble()
----
// end-insert

This version doesn't box integers, nor iterate more than once, so it is probably as efficient as we are going to get, but again only measuring in our specific circumstances will tell for sure.

Returning to the entry point we now have:

// begin-insert: tags/streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsStream("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore.queryAsStream("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
        groupingBy { event -> event["interactionId"] as String }
    )
    return bookingEventsByInteractionId.values.averageBy { it.size }
}
----
// end-insert

The variable `bookingEventsByInteractionId` is only really there to give a checkpoint in the algorithm, somewhere to pause before we go on.
We can convert the `collect(groupintBy())` to Kotlin with `asSequence().groupBy` - the lambda remains unchanged:

// begin-insert: tags/streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val bookingEventsByInteractionId = eventsForSuccessfulBookings
    .asSequence()
    .groupBy { event ->
        event["interactionId"] as String
    }
----
// end-insert

Swapping out one method for another method (or extension function) with a similar name that takes a compatible lambda is a good sign that we are on the right track.

Now for that `flatMap`, used to fetch all the events for any interaction that had a completed booking:

// begin-insert: tags/streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore.queryAsStream("interactionId=$interactionId")
    }
----
// end-insert

This would also _probably just work_ if we had a `queryAsSequence` to replace `queryAsStream`.
Thankfully, we can know how to convert:

// begin-insert: tags/streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .asSequence()
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsStream("interactionId=$interactionId")
            .asSequence()
    }
----
// end-insert

Awesomely this continues to compile and to pass our (cursory) test!
It works because while we have changed the type of `eventsForSuccessfulBookings` from `Stream` to `Sequence`, the following expression:

// begin-insert: tags/streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val bookingEventsByInteractionId = eventsForSuccessfulBookings
    .asSequence()
    .groupBy { event ->
        event["interactionId"] as String
    }
----
// end-insert

is then resolved as `Sequence.asSequence()`, which is a no-op.
We can inline the function to prove it:

// begin-insert: tags/streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val bookingEventsByInteractionId = eventsForSuccessfulBookings
    .groupBy { event ->
        event["interactionId"] as String
    }
----
// end-insert

Introducing an extension function:

// begin-insert: tags/streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt#queryAsSequence
[source,kotlin]
----
fun EventStore.queryAsSequence(query: String) =
    this.queryAsStream(query).asSequence()
----
// end-insert

allows us to remove the other duplication, yielding:

// begin-insert: tags/streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore
                .queryAsSequence("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings
        .groupBy { event ->
            event["interactionId"] as String
        }
    return bookingEventsByInteractionId.values.averageBy { it.size }
}
----
// end-insert

Looked at like this, the three statements seem quite an arbitrary partitioning of the pipeline.
Sometimes we can gain greater insight by inlining everything and seeing what we have:

// begin-insert: tags/streams-to-sequences.13:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore
                .queryAsSequence("interactionId=$interactionId")
        }.groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}
----
// end-insert

It looks like the part starting with flatMap` and ending before `groupBy` might make a nice function - lets see how to extract part of a pipeline.

First we select from the start of the pipeline to the last stage we want to include, so from `eventStore` up to but not including `.groupBy`.
"Extract Function", calling it, in this case, `allEventsInSameInteractions`:

// begin-insert: tags/streams-to-sequences.14:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return allEventsInSameInteractions(timeRange)
        .groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}

private fun allEventsInSameInteractions(timeRange: String) = eventStore
    .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsSequence("interactionId=$interactionId")
    }
----
// end-insert

Now select the bits of the pipeline that we don't want in the new function, so `eventStore` to before `.flatMap`, and "Introduce Parameter".
Accept any name that IntelliJ chooses - it won't live long.:

// begin-insert: tags/streams-to-sequences.15:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return allEventsInSameInteractions(
        eventStore
            .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
    )
        .groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}

private fun allEventsInSameInteractions(
    sequence: Sequence<MutableMap<String, Any?>>
) = sequence
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsSequence("interactionId=$interactionId")
    }
----
// end-insert

That's really ugly, but once we convert the parameter to `allEventsInSameInteractions` to a receiver and reformat we have:

// begin-insert: tags/streams-to-sequences.16:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .allEventsInSameInteractions()
        .groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}

fun Sequence<Map<String, Any?>>.allEventsInSameInteractions() =
    flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsSequence("interactionId=$interactionId")
    }
----
// end-insert

It's still a little clunky, and no doubt we could make it more efficient by not creating lists in the grouping, but that will probably do.
Oh, except for a wafer-thing type alias and extension property:

// begin-insert: tags/streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt#event
[source,kotlin]
----
typealias Event = Map<String, Any?>

val Event.interactionId: String? get() =
    this["interactionId"] as? String
----
// end-insert

This lets us concentrate on the hard stuff:

// begin-insert: tags/streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
class MarketingAnalytics(
    private val eventStore: EventStore
) {
    fun averageNumberOfEventsPerCompletedBooking(
        timeRange: String
    ): Double = eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .allEventsInSameInteractions()
        .groupBy(Event::interactionId)
        .values
        .averageBy { it.size }

    fun Sequence<Event>.allEventsInSameInteractions() =
        flatMap { event ->
            eventStore.queryAsSequence(
                "interactionId=${event.interactionId}"
            )
        }
}

inline fun <T> Collection<T>.averageBy(selector: (T) -> Int): Double =
    sumBy(selector) / size.toDouble()

fun EventStore.queryAsSequence(query: String) =
    this.queryAsStream(query).asSequence()
----
// end-insert

In passing, note that `allEventsInSameInteractions` is an example of a extension function as method that we discussed in <<functions-to-extension-functions>>.
It has access to both `this` from `MarketingAnalytics` and `this` from `Sequence<Event>`.


REMINDER - INLINE allows us to break out of loops
REMINDER - righting a function that works on both Sequence and Iterable

=== Conclusion
