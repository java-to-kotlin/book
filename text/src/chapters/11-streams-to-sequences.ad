[[streams-to-sequences]]
== Streams to Iterables to Sequences

****
Java and Kotlin both allow us to transform and reduce collections.
They have different design goals and implementations though.
What does Kotlin use instead of Java streams, when should we convert, and how?
****

=== Java Streams

Java 8 introduced streams in 2014, making good use of the new lambdas.
Say we want to work out the average length of some strings, except that blank strings (those with only whitespace characters) should be treated as if they are empty.
Previously we might have written:

// begin-insert: src/main/java/sequences/Streams.java#loop
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    var sum = 0;
    for (var s : strings) {
        if (!s.isBlank())
            sum += s.length();
    }
    return sum / (double) strings.size();
}
----
// end-insert

With Java streams we can express this algorithm as `filter`, `map` and `reduce` by first converting the `List` to a `Stream` and applying transformations:

// begin-insert: src/main/java/sequences/Streams.java#stream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .stream()
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

Rather than having to run the for-loop in our heads to see what this code is doing, we can see the steps of the algorithm declared line by line, and rely on the runtime to implement those steps for us.

If we are really in a hurry for those results we can even write:

// begin-insert: src/main/java/sequences/Streams.java#parallelStream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .parallelStream() // <1>
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

<1> `parallelStream` will divide the work across multiple threads.

There are different types of fundamental operations going on here.
`map` changes the type of items, not their number.
`filter` keeps or rejects items depending on some property, but keeps their type the same.
`sum` is a reduction of the collection to a single property.
Not shown in this example are the operations `skip(n)` and `limit(n)`.
These return streams without the first and last `n` elements respectively.

Java streams are lazy: `strings.filter(...).mapToInt(...)` does nothing but set up a pipeline for some terminal operation, `sum` in this case, to suck values through.
Laziness means that later pipeline stages can limit the amount of work performed by earlier stages.
Consider translating a list of words until we see the word `STOP`.
The loop version might look like this:

// begin-insert: src/main/java/sequences/Streams.java#translatingLoop
[source,java]
----
public static List<String> translatedWordsUntilSTOP(List<String> strings) {
    var result = new ArrayList<String>();
    for (var word: strings) {
        String translation = translate(word);
        if (translation.equalsIgnoreCase("STOP"))
            break;
        else
            result.add(translation);
    }
    return result;
}
----
// end-insert

By breaking out of the loop we don't translate all the words, only the minimum we need.
Java 9 introduced `dropWhile` and `takeWhile`, which allow us to express this as:

// begin-insert: src/main/java/sequences/Streams.java#translatingStream
[source,java]
----
public static List<String> translatedWordsUntilSTOP(List<String> strings) {
    return strings
        .stream()
        .map(word -> translate(word))
        .takeWhile(translation -> !translation.equalsIgnoreCase("STOP"))
        .collect(toList());
}
----
// end-insert

This works because the `collect` causes values to be sucked through the pipeline, and `takeWhile` stops sucking from its predecessor when its predicate returns `false`.

On the subject of sucking, streams can be surprisingly slow for small collections.
They are great for large-scale data crunching where we want to throw all available cores at a problem; not so great for summing the cost of 5 items in a shopping cart.
The problem is that Java streams were designed to provide general collection transformations, lazy evaluation, _and_ parallel processing, and these have different demands.
Kotlin doesn't try to implement parallel operations, leaving two abstractions: iterables are good for transforming and reducing collections, while sequences give lazy evaluation.

=== Kotlin Iterables

Instead of creating a new interface to define collections operations, Kotlin provides extension functions on `Iterable`.
The simplest Kotlin expression of the same algorithm is:

// begin-insert: src/main/java/sequences/sequences.kt#lists
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .filter { it.isNotBlank() }
        .map(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

Here `filter` is an extension function on `Iterable`.
Unlike the `Stream.filter` though, which returns another `Stream`, the Kotlin `filter` returns a `List` (which is `Iterable`, so we can continue the chain).
`map` returns a `List` too, so this single expression creates two additional lists in memory.

The first is a `List` of the non-blank strings, the second is a `List` of the lengths of those strings.
When (if) we care about performance, this can be a problem, because both of those lists will take time to populate and memory to support.

The `List` of lengths is a particular issue, because the integers will have been _boxed_ (wrapped in an `Integer` object) to fit in the list.
The Java streams example used `mapToInt(String::length)` to avoid this problem.
`IntStream` (and `LongStream` and `DoubleStream`, but curiously not `BooleanStream` or `CharStream`) were created to prevent streams having to boxing and unbox, but you have to remember to use them, and `IntStream` is not a `Stream<Integer>`.

Should we care about performance?
Mostly no - this Kotlin will be fast _unless_ we have large collections; the opposite of streams, which are only fast _if_ we have large collections.
When we do have large collections, we can switch over to sequences.

=== Kotlin Sequences

The Kotlin `Sequence` abstraction offers the same lazy evaluation as Java streams.
The `map` operation on a `Sequence` returns another `Sequence`: the operations in the chain are only performed when some terminal operation requires their evaluation.
If we have a `Collection`, `Iterable`, or even an `Iterator`, there are `asSequence()` extension functions to convert.
After that the API is suspiciously familiar:

// begin-insert: src/main/java/sequences/sequences.kt#sequences
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .asSequence()
        .filter { it.isNotBlank() }
        .map(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

The familiarity is suspicious because all those operations (`filter`, `map`, `sum`) are now extensions not on `Iterable` but `Sequence`; and they don't return a `List`, they return another `Sequence`.
Except that is for `sum`, which can't even pretend to do its job without reading all the data, and so is a terminal operation.
This code reads the same as the iterable version, but each of the functions is actually different.

.Swapping Iterables and Sequences
****
`Iterable<T>` and `Sequence<T>` have the same single method signature: `public operator fun iterator(): Iterator<T>`.
They both also have extension functions for `map`, `filter`, `reduce` etc which take the same parameters.
But they are not the same type, because their semantics are very different.
The operations on `Iterable` are eager, whilst those on `Sequence` are lazy - so we cannot swap one for the other with impunity (as we will see later in this chapter).

Nevertheless, the fact that they have such similar APIs means that in situations like this, we can often change very little (source) code when we do want to swap between them.
****

The sequence version of `averageNonBlankLength` won't pay the price of creating the intermediate lists to hold the results of each stage, but for small numbers of items, the cost of setting up and executing the pipeline may be higher than creating the lists.
In this case the `Int` lengths will still be boxed as `Integer`, albeit one at a time rather than creating a whole list of them.
In many cases the API designers will have provided a clever solution to remove boxing.
In this case it is `sumBy`:

// begin-insert: src/main/java/sequences/sequences.kt#sumBy
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .asSequence()
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / strings.size.toDouble())
----
// end-insert

`sumBy` (also available as an extension on `Iterable`) avoids boxing by taking a function that returns an `Int`.
It can do this because it is a terminal operation and so doesn't return another sequence or collection.

ifdef::optional-content[]
IntelliJ is getting increasingly good at spotting when pipeline stages can be merged like this, although at the time of writing it failed to spot this opportunity.
There are also times when it will suggest converting an `Iterable` chain to a `Sequence` chain, although the heuristics that it uses seem to vary over Kotlin plugin releases.
Bear in mind that IntelliJ doesn't know how large our collections will be, see <<choosing-sequences>> for how we can use that information to choose.
endif::[]

[[sequences-multiple-operations]]
=== Multiple Iterations

If you use Java streams, you have probably tried to do something like this:

// begin-insert: src/main/java/sequences/Streams.java#consumingTwice
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return averageNonBlankLength(strings.stream());
}

public static double averageNonBlankLength(Stream<String> strings) {
    return strings
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.count();
}
----
// end-insert

This looks very plausible: we've just extracted a function taking a `Stream` parameter rather than the `List`.
There is no `size` property on `Stream`, but `count()` gives the same result, so we use that.
When we run it though, we get `java.lang.IllegalStateException: stream has already been operated upon or closed`.

The problem is that a `Stream` has hidden state.
Once we have consumed all its items (and `sum` does just that), we can't go round again to `count` them.
Even though `sum` is actually a method on `IntStream`, each stream in the pipeline consumes its predecessor, so the input `strings` is consumed by the `sum`.

In Java this is enough to put you off extracting `Stream` operations into functions.
Let's try the same thing with a Kotlin `Sequence`:

// begin-insert: src/main/java/sequences/sequences.kt#consumingTwice
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    averageNonBlankLength(strings.asSequence())

fun averageNonBlankLength(strings: Sequence<String>): Double =
    (strings
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / strings.count().toDouble())
----
// end-insert

In Kotlin, we can call the `Sequence` version from the `List` version and all is fine ... for now.

We are storing up trouble though.
To see why, let's step out another layer and add a function that takes an `Iterator`:

// begin-insert: src/main/java/sequences/sequences.kt#iterator
[source,kotlin]
----
fun averageNonBlankLength(strings: Iterator<String>): Double =
    averageNonBlankLength(strings.asSequence())
----
// end-insert

If we call this function, we now get `java.lang.IllegalStateException: This sequence can be consumed only once.` (Comparing this to the streams error, we see that the Kotlin developers seem to be more grammatically pedantic than the JVM developers.)
Now the `Sequence` is acting like a Java `Stream`, but previously it wasn't.
What changed?

It turns out that some sequences can safely be iterated over multiple times - those backed by a collection which is held in memory, for example.
Others cannot.
Now that our `Sequence` is provided by an `Iterator`, the first run through (to calculate the `sum`) continued until `Iterator.hasNext()` returned `false`.
If we were to try to run through the `Sequence` again (to `count`) the `Iterator` state has not changed, so `hasNext()` will immediately return `false`.
This would lead `strings.count()` to return `0`; and `averageNonBlankLength` would always return `Infinity` (if there was any input).

This sort of behaviour is, erm, _undesirable_, so sequences wrapping iterators are deliberately hobbled with `Sequence.constrainOnce()` to prevent this.
It is `constrainOnce()` that throws the `IllegalStateException` if we try to consume twice.

The other canonical example of a `Sequence` that cannot be consumed more than once is one backed by reading from an external resource, such a file or network socket - we can't in general just go back and replay input to iterate again.

Unfortunately the difference between the two types of `Sequence` is not reflected in the type system, so we will only discover any incompatibility between our algorithm and our input at runtime.
As we will see in <<performing-io-to-passing-data>>, this is exacerbated by the common technique of using `sequenceOf(...)` or `List.asSequence()` as our test data - these sequences _do_ support multiple iterations and won't warn us of the problem.

In practice this problem is usually only an irritation, causing some wasted time and reworking.
It will tend not to happen if you are converting from streams code, as that will not have had the issue in the first place, but rather when applying a `Sequence` from scratch, or converting from an `Iterable`.

In this particular case we can make things work by keeping count of items as they whizz past in the first iteration, rather than counting again at the end:

// begin-insert: src/main/java/sequences/sequences.kt#peekCount
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double {
    var count = 0
    return (strings
        .onEach { count++ }
        .filter { it.isNotBlank() }
        .sumBy(String::length)
        / count.toDouble())
}
----
// end-insert

This is the first problem that we have solved in this book with a mutable local variable!
We can hide our shame inside a more generally useful utility class: `CountingSequence`:

// begin-insert: src/main/java/sequences/sequences.kt#CountingSequence
[source,kotlin]
----
class CountingSequence<T>(
    private val wrapped: Sequence<T>
) : Sequence<T> {
    var count = 0
    override fun iterator() =
        wrapped.onEach { count++ }.iterator()
}

fun averageNonBlankLength(strings: Sequence<String>): Double {
    val countingSequence = CountingSequence(strings)
    return (countingSequence
            .filter { it.isNotBlank() }
            .sumBy(String::length)
            / countingSequence.count.toDouble())
}
----
// end-insert

This a recurrent theme in Kotlin algorithms -- we might occasionally need to stoop to mutation to implement something in a sensible or efficient way, but we can usually hide the mutation in a way that both reduces its visibility and makes for a useful abstraction.
In this case this is aided by the fact that `Sequence` is an interface with just one method, making it very easy to implement it ourselves.
Java's `Stream` is also an interface, but with 42 methods, and no `AbstractStream` class to provide default implementations!

Before we leave this section, you may have been silently fuming ever since we introduced `Stream.count()`.
If not, can you see what the issue is?

One of the points of `Stream` and `Sequence` is that they allow us to work on arbitrarily large datasets, and finding the size of these datasets by counting them individually is not very efficient, even if it can be sometimes be done.
In general, even if we can in practice iterate over a `Sequence` more than once, it is likely to be inefficient in the use-cases that caused us to use `Sequence` in the first place.

[TIP]
.Only Iterate Over a Sequence Once
====
As a rule of thumb, if they operate on a `Sequence`, our algorithms should complete in a single pass.
This way they will be able to work with sequences that do not support multiple iteration, and can be efficient with large numbers of items.

We can use `Sequence.constrainOnce()` in our tests to make sure that we don't accidentally go round again.
====

[[choosing-sequences]]
=== Choosing between Streams, Iterables and Sequences

If we already have code using Java streams, it will continue to run just fine on the JVM, even when converted to Kotlin.
It will even look a little nicer, since Kotlin can move the lambda outside the method, and allow the use of the implicit `it` lambda parameter.

// begin-insert: src/main/java/sequences/sequences.kt#streams
[source,kotlin]
----
fun averageNonBlankLength(strings: List<String>): Double =
    (strings
        .stream()
        .filter { it.isNotBlank() }
        .mapToInt(String::length)
        .sum()
        / strings.size.toDouble())
----
// end-insert

In addition, we can use extension functions to 'add' operations to streams, in the same way as Kotlin defines its `Sequence` operations.

If our code is working on large collections, and in particular using `parallelStream()`, then the default should be to leave the streams alone, as in these cases they are well optimised by the JVM.
The Kotlin standard library even provides extensions `Stream<T>.asSequence()` and `Sequence<T>.asStream()` that allow us to swap horses mid, erm, `Stream`.

If we decide to convert to a Kotlin abstraction, then we can choose `Iterable` or `Sequence` depending on whether the streams code takes advantage of lazy evaluation.

Lazy evaluation is required if:

* We need to produce results before we have finished reading the input.
* We need to process more data than we can fit into memory (including intermediate results).

Lazy evaluation may give better performance for:

* Large collections with many pipeline stages, where building intermediate collections may be slow.
* Pipelines where early stages could be skipped depending on information only available in later stages.

We can illustrate the last point with the same translation example we saw with streams:

// begin-insert: src/main/java/sequences/Streams.java#translatingStream
[source,java]
----
public static List<String> translatedWordsUntilSTOP(List<String> strings) {
    return strings
        .stream()
        .map(word -> translate(word))
        .takeWhile(translation -> !translation.equalsIgnoreCase("STOP"))
        .collect(toList());
}
----
// end-insert

We can convert this to the equivalent iterable expression:

// begin-insert: src/main/java/sequences/sequences.kt#translatingList
[source,kotlin]
----
fun translatedWordsUntilSTOP(strings: List<String>): List<String> =
    strings
        .map { translate(it) }
        .takeWhile { !it.equals("STOP", ignoreCase = true) }
----
// end-insert

But then _all_ words in the input `List` will be translated to another `List` by `map`, even those after `STOP`.
Using a `Sequence` avoids translating words we aren't going to return:

// begin-insert: src/main/java/sequences/sequences.kt#translatingSequence
[source,kotlin]
----
fun translatedWordsUntilSTOP(strings: List<String>): List<String> =
    strings
        .asSequence()
        .map { translate(it) }
        .takeWhile { !it.equals("STOP", ignoreCase = true) }
        .toList()
----
// end-insert

If we don't need lazy evaluation, and for smaller collections, or when writing from scratch in Kotlin, `Iterable` pipelines are simple, generally quick, and easy to reason with.
Your authors will often convert streams to iterables in order to take advantage of the far richer API that Kotlin provides.
If iterables prove too slow (or sometimes too greedy for memory) with large collections, then we can convert to sequences.
If that still isn't enough, we can move (hopefully not back) to streams, and maybe even take advantage of parallelism.

=== Algebraic Transformation

Laziness and parallelism will of course affect _when_ the stages of our pipeline are invoked.
If any of our algorithm depends on the order of operations it may be broken if we swap between streams, iterables and sequences.
What we want is code with a predictable _algebra_ - a set of rules for manipulating operations while preserving behaviour.

We saw in <<actions-to-calculations>> that we can categorise functions (actually any code, including lambdas), according to whether they depend on when they are run.
Calculations (<<calculations>>) are safe to refactor because we can move their invocations around without affecting their result, or the result of any other code.
In contrast, moving an action (<<actions>>) from an iterable to a sequence, or vice-verse, may change when it is invoked, and hence the outcome of our program.
The more of our code is expressed as calculations, the more we can treat its representation as something that we can transform according to rules.

We can also apply another algebra -- arithmetic -- to simplify our definition of `averageNonBlankLength`.
This is currently:

// begin-insert: src/main/java/sequences/sequences.kt#CountingSequence
[source,kotlin]
----
class CountingSequence<T>(
    private val wrapped: Sequence<T>
) : Sequence<T> {
    var count = 0
    override fun iterator() =
        wrapped.onEach { count++ }.iterator()
}

fun averageNonBlankLength(strings: Sequence<String>): Double {
    val countingSequence = CountingSequence(strings)
    return (countingSequence
            .filter { it.isNotBlank() }
            .sumBy(String::length)
            / countingSequence.count.toDouble())
}
----
// end-insert

All that complication arises because we don't want the simple average, but the average where blank strings are counted as if empty.
Filtering the blanks from the sum, but not the count, is one way to do this.
Mathematically though, it is equivalent to the following:

// begin-insert: src/main/java/sequences/sequences.kt#average
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double =
    strings
        .map { if (it.isBlank()) 0 else it.length }
        .average()
----
// end-insert

This is a mathematical rearrangement, and, as with our code refactoring, works only if all the operations are calculations.
It is also dangerously seductive, because we have slipped back to boxing our integers to pass them to `average`.

What we need is an `averageBy` analogue of `sumBy`.
We can do that by mating the Kotlin runtime definitions of `Sequence.sumBy` with `Sequence.average` to give:

// begin-insert: src/main/java/sequences/sequences.kt#averageBy
[source,kotlin]
----
inline fun <T> Sequence<T>.averageBy(selector: (T) -> Int): Double {
    var sum: Double = 0.0
    var count: Int = 0
    for (element in this) {
        sum += selector(element)
        checkCountOverflow(++count)
    }
    return if (count == 0) Double.NaN else sum / count
}
----
// end-insert

This again stoops to mutation in the name of efficiency, and finally allows us to write:

// begin-insert: src/main/java/sequences/sequences.kt#useAverageBy
[source,kotlin]
----
fun averageNonBlankLength(strings: Sequence<String>): Double =
    strings.averageBy {
        if (it.isBlank()) 0 else it.length
    }
----
// end-insert

Why did we not just write it that way in the first place?
Sometimes we see these equivalences, sometimes we don't!
Remember that we started here:

// begin-insert: src/main/java/sequences/Streams.java#loop
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    var sum = 0;
    for (var s : strings) {
        if (!s.isBlank())
            sum += s.length();
    }
    return sum / (double) strings.size();
}
----
// end-insert

Given this code, it is natural to translate the `if` statement to a `filter`:

// begin-insert: src/main/java/sequences/Streams.java#stream
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .stream()
        .filter(s -> !s.isBlank())
        .mapToInt(String::length)
        .sum()
        / (double) strings.size();
}
----
// end-insert

What if our original code had been more slightly more functional, selecting the value to be added to the `sum` (with a ternary operator), rather than whether to add (with an `if` statement)?

// begin-insert: src/main/java/sequences/Streams.java#loop2
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    var sum = 0;
    for (var s : strings) {
        sum += s.isBlank() ? 0 : s.length();
    }
    return sum / (double) strings.size();
}
----
// end-insert

Ah -- then our initial translation would probably have been:

// begin-insert: src/main/java/sequences/Streams.java#stream2
[source,java]
----
public static double averageNonBlankLength(List<String> strings) {
    return strings
        .stream()
        .mapToInt(s -> s.isBlank() ? 0 : s.length())
        .average()
        .orElse(Double.NaN);
}
----
// end-insert

In that case we would have had a shorter chapter, but learned less.

=== Refactoring from Streams to Iterables and Sequences

Travelator logs operational events as it runs, so we know that it is working as we expect.
These are sent as JSON to an indexing server, which can generate pretty graphs and alerts specified with its own query language.
Somehow though, those nice people in marketing are always asking questions that we can't write queries for.

In these cases we fetch events from the server and process them locally.
The querying, marshalling and paging of the events is hidden behind a simple `EventStore` interface that returns an `Iterator<Map<String, Object>>`, where `Map<String, Object>` represents JSON objects.

// begin-insert: tags/streams-to-sequences.0:src/main/java/travelator/analytics/EventStore.java
[source,java]
----
public interface EventStore {

    Iterator<Map<String, Object>> query(String query);

    default Stream<Map<String, Object>> queryAsStream(String query) {
        Iterable<Map<String, Object>> iterable = () -> query(query);
        return StreamSupport.stream(iterable.spliterator(), false);
    }
}
----
// end-insert

The interface contains its own conversion of the `Iterator` to a `Stream` for our happy convenience (amazingly there is no conversion function built in to the JDK).

Here is the sort of thing that we haven't been able to write in the indexing server's query language.
It calculates the average number of interactions customers make to successfully complete a booking:

// begin-insert: tags/streams-to-sequences.0:src/main/java/travelator/analytics/MarketingAnalytics.java#excerpt
[source,java]
----
public double averageNumberOfEventsPerCompletedBooking(
    String timeRange
) {
    Stream<Map<String, Object>> eventsForSuccessfulBookings =
        eventStore
            .queryAsStream("type=CompletedBooking&timerange=" + timeRange)
            .flatMap(event -> {
                String interactionId = (String) event.get("interactionId");
                return eventStore.queryAsStream("interactionId=" + interactionId);
            });
    Map<String, List<Map<String, Object>>> bookingEventsByInteractionId =
        eventsForSuccessfulBookings.collect(groupingBy(
            event -> (String) event.get("interactionId"))
        );
    var averageNumberOfEventsPerCompletedBooking =
        bookingEventsByInteractionId
            .values()
            .stream()
            .mapToInt(List::size)
            .average();
    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN);
}
----
// end-insert

We did our best when we wrote this to make it understandable.
We named intermediate variables, and specified their types when and only when it seemed to help, and formatted carefully, and still it looks like a cleaner knocked the code on the floor and tried to put it back together in the hope that we didn't notice.
We sometimes end up in a losing battle like this: we could extract a function to simplify code at the call site, but if we can't give that function a good name, then we have just kicked the can down the source file.

[TIP]
.Implicit or Explicit Types
====
Sometimes a variable's type is essential to understanding how code works, other times it just clutters an already wordy block.
In this respect explicit types are like comments, but they have the added advantage that they are checked and enforced by the compiler.
As with comments, we should try to write code that doesn't need explicit variable types.
Good naming can help, as can refactoring into functions where the return type can be shown.

If these fail though, there is no shame in showing a variables type if it improves the readability of the code, and we should certainly prefer to communicate in types than comments.
====

We're going to convert this code to Kotlin, in the fervent hope that our favourite language will allow us to do a better job.
Here is the result of the automated conversion:

// begin-insert: tags/streams-to-sequences.1:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsStream("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event: Map<String?, Any?> ->
            val interactionId = event["interactionId"] as String?
            eventStore.queryAsStream("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
        Collectors.groupingBy(
            Function { event: Map<String, Any> ->
                event["interactionId"] as String?
            }
        )
    )
    val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
        .values
        .stream()
        .mapToInt { obj: List<Map<String, Any>> -> obj.size }
        .average()
    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)
}
----
// end-insert

At the time of writing, the Java to Kotlin converter is not as clever as it might be mapping between lambdas in the two languages.
This is particularly noticeable in streams code, because that is where most Java lambdas are to be found.
Most of the issues can be fixed with Alt-Enter on the odd code and accepting a quick-fix.
Let's start by tidying up nullability, removing the vestigial `Function`, and simplifying that ugly `mapToInt` lambda:

// begin-insert: tags/streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsStream("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore.queryAsStream("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
        groupingBy { event -> event["interactionId"] as String }
    )
    val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
        .values
        .stream()
        .mapToInt { it.size }
        .average()
    return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)
}
----
// end-insert

The Java code before conversion mixed some old-style explicitly typed variables: `Stream<Map<String, Object>>` for example; with the implicit `var averageNumberOfEventsPerCompletedBooking`.
The conversion has dropped the explicit types.
It is certainly less intimidating this way, but also less comprehensible if we actually care how it is doing whatever it is doing.
We'll leave it this way for now but review our decision before we finish.

At this point we have Kotlin code using Java streams that runs just fine.
We could leave it alone.
Travelator is a huge success, with many thousands of completed bookings a day, streams are a good choice for throughput, so why convert to Kotlin?
You didn't buy this book for that sort of attitude though, so we'll push on under the pretense that we are measuring performance at every stage and will stop if we see it degrade.

==== Iterables First

Looking at the code we see that it has two stages.
The first stage processes an input of indeterminate length, producing a collection in memory:

// begin-insert: tags/streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore.queryAsStream("interactionId=$interactionId")
    }
val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
    groupingBy { event -> event["interactionId"] as String }
)
----
// end-insert

The second processes that collection:

// begin-insert: tags/streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
    .values
    .stream()
    .mapToInt { it.size }
    .average()
return averageNumberOfEventsPerCompletedBooking.orElse(Double.NaN)
----
// end-insert

As we saw earlier, Java uses streams for both these cases, whereas in Kotlin we would tend to use a `Sequence` to process input of unknown length, and an `Iterable` to process data in memory.
Acting on in-memory data is easier to reason with, so we'll convert `averageNumberOfEventsPerCompletedBooking` first.

Until IntelliJ comes up with automated refactoring, we are left having to do this by hand.
Usually we would have tests to make this safer, but this is fast-moving and arbitrary analytics code, so it turns out we cut corners.
Before we begin refactoring proper we write a quick test that talks to production and shows that the result for yesterday was 7.44 - now we can keep running that to check that it doesn't change.

We know that we can apply collection operations directly to `Map.values` in Kotlin (those on `Iterable`), so we can remove the `.stream()`.
`average()` is an operation on `IntStream` in Java, but Kotlin conveniently declares `Iterable<Int>.average()`, so we don't have to `mapToInt`, just `map`.
Finally, where `IntStream.average()` returns an empty `OptionalDouble` if the stream has no elements, Kotlin's `Iterable<Int>.average()` returns `NaN` (Not A Number), which means we can use the result directly:

// begin-insert: tags/streams-to-sequences.3:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val averageNumberOfEventsPerCompletedBooking = bookingEventsByInteractionId
    .values
    .map { it.size }
    .average()
return averageNumberOfEventsPerCompletedBooking
----
// end-insert

Has this been a good change though?

Looking at the code, we are now creating an intermediate `List<Int>` on which to call `average()`.
This will result in boxing each value, and this time there is no `averageBy()` (as there was `sumBy()` in the previous example) to prevent this.

Whether this code performs better or worse than the stream version will depend on the number of values in the `Map`, how our particular JVM optimizes boxing, and how heavily HotSpot has optimized this path -- only measuring in real conditions will tell.
If we have to choose a generic solution then we should probably write our own `List.averageBy` - that way we can leverage knowing the size of a `List`.
We could use the one we prepared earlier in the chapter (albeit for `Sequence`), or refactor from here.
We can refactor from here by extracting `values` and using `sumBy()`:

// begin-insert: tags/streams-to-sequences.4:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val values = bookingEventsByInteractionId.values
return values.sumBy { it.size } / values.size.toDouble()
----
// end-insert

Now "Extract Function" `averageBy` on the returned expression:

// begin-insert: tags/streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val values = bookingEventsByInteractionId.values
return averageBy(values)
----
// end-insert

// begin-insert: tags/streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun averageBy(
    values: MutableCollection<MutableList<MutableMap<String, Any>>>
): Double {
    return values.sumBy { it.size } / values.size.toDouble()
}
----
// end-insert

Eeek!
It turns out that the type of `bookingEventsByInteractionId` was a lot more mutable than we wanted.
It came from `Collectors.groupingBy`, a stream operation which only has Java collections to return after all.
We'll change it to use `Collection` in place of the `MutableCollection` for now, and then "Introduce Parameter" named `selector` on the lambda:

// begin-insert: tags/streams-to-sequences.6:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun averageBy(
    values: Collection<MutableList<MutableMap<String, Any>>>,
    selector: (MutableList<MutableMap<String, Any>>) -> Int
): Double {
    return values.sumBy(selector) / values.size.toDouble()
}
----
// end-insert

Now we don't want to care about the actual type of items in the `Collection`.
If we select the `MutableList<MutableMap<String, Any>>` and "Extract/Introduce Type Parameter", we get the following:

// begin-insert: tags/streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun <T : MutableList<MutableMap<String, Any>>> averageBy(
    values: Collection<T>,
    selector: (T) -> Int
): Double {
    return values.sumBy(selector) / values.size.toDouble()
}
----
// end-insert

That refactoring is clever enough that we don't begrudge having to tell IntelliJ that `T` can be anything really (by removing the `MutableList<MutableMap<String, Any>>` type restriction):

// begin-insert: tags/streams-to-sequences.8:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
private fun <T> averageBy(
    values: Collection<T>,
    selector: (T) -> Int
): Double {
    return values.sumBy(selector) / values.size.toDouble()
}
----
// end-insert

IntelliJ also added the type to the call for some reason:

// begin-insert: tags/streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val values = bookingEventsByInteractionId.values
return averageBy<MutableList<MutableMap<String, Any>>>(values) { it.size }
----
// end-insert

So we remove the `MutableList<MutableMap<String, Any>>` from there too.

Finally, we can make `averageBy` the tiny single-expression inline extension function it was born to be (see <<functions-to-extension-functions>> and <<multi-to-single-expression-functions>>):

// begin-insert: tags/streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageBy
[source,kotlin]
----
inline fun <T> Collection<T>.averageBy(selector: (T) -> Int): Double =
    sumBy(selector) / size.toDouble()
----
// end-insert

This version doesn't box integers, nor iterate more than once, so it is probably as efficient as we are going to get.
But again, only measuring in our specific circumstances will tell for sure.

Note that when we wrote `Sequence.averageNonBlankLength` earlier, we had to count the number of items.
By defining `averageBy` as an extension on `Collection` rather than `Iterable`, we can make use of the fact that we can ask the `size` of in-memory collections to avoid the tedious book-keeping.

==== Then Sequences

So far we have converted the in-memory pipeline.
Now we are left with the code that reads an unknown number of events from the `eventStore` -- we will want to keep this code lazy.

Returning to the entry point we now have:

// begin-insert: tags/streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsStream("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore.queryAsStream("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings.collect(
        groupingBy { event -> event["interactionId"] as String }
    )
    return bookingEventsByInteractionId.values.averageBy { it.size }
}
----
// end-insert

Now the variable `bookingEventsByInteractionId` is only really there to give a checkpoint in the algorithm: it names an intermediate in the hope that it aids understanding.
Moving up the function,`eventsForSuccessfulBookings` is a `Stream`, so we can convert the `collect(groupingBy(...))` to Kotlin with `asSequence().groupBy {...}` -- the lambda remains unchanged:

// begin-insert: tags/streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val bookingEventsByInteractionId = eventsForSuccessfulBookings
    .asSequence()
    .groupBy { event ->
        event["interactionId"] as String
    }
----
// end-insert

Swapping out one method for another method (or extension function) with a similar name that takes a compatible lambda is a good sign that we are on the right track.

Now for that `flatMap`, used to fetch all the events for any interaction that had a completed booking:

// begin-insert: tags/streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore.queryAsStream("interactionId=$interactionId")
    }
----
// end-insert

This would also _probably just workâ„¢_ if we had a sequences rather than streams.
Thankfully, we know how to convert from the `Stream` to a `Sequence` - it's the `.asSequence()` extension provided by the Kotlin JDK interop.
We need to apply it to both streams:

// begin-insert: tags/streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .asSequence()
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsStream("interactionId=$interactionId")
            .asSequence()
    }
----
// end-insert

Awesomely, this continues to compile and to pass our (cursory) test!
It compiles because, while we have changed the type of `eventsForSuccessfulBookings` from `Stream` to `Sequence`, we then call `eventsForSuccessfulBookings.asSequence()`:

// begin-insert: tags/streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val bookingEventsByInteractionId = eventsForSuccessfulBookings
    .asSequence()
    .groupBy { event ->
        event["interactionId"] as String
    }
----
// end-insert

This resolves to `Sequence.asSequence()`, which is a no-op.
We can inline `asSequence` to prove it:

// begin-insert: tags/streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt#part2
[source,kotlin]
----
val bookingEventsByInteractionId = eventsForSuccessfulBookings
    .groupBy { event ->
        event["interactionId"] as String
    }
----
// end-insert

Returning to `eventsForSuccessfulBookings`, we now have:

// begin-insert: tags/streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt#part1
[source,kotlin]
----
val eventsForSuccessfulBookings = eventStore
    .queryAsStream("type=CompletedBooking&timerange=$timeRange")
    .asSequence()
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsStream("interactionId=$interactionId")
            .asSequence()
    }
----
// end-insert

What we really wanted was for `EventStore` to support `queryAsSequence` - we can do this without modifying it by introducing an extension function:

// begin-insert: tags/streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt#queryAsSequence
[source,kotlin]
----
fun EventStore.queryAsSequence(query: String) =
    this.queryAsStream(query).asSequence()
----
// end-insert

This allows us to remove the `asSequence` calls from the calling function:

// begin-insert: tags/streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    val eventsForSuccessfulBookings = eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore
                .queryAsSequence("interactionId=$interactionId")
        }
    val bookingEventsByInteractionId = eventsForSuccessfulBookings
        .groupBy { event ->
            event["interactionId"] as String
        }
    return bookingEventsByInteractionId.values.averageBy { it.size }
}
----
// end-insert

OK, time to review.
We've converted our Java to Kotlin, and are using iterables to process the in-memory operations, and sequences (backed by streams in `EventStore`) to process the unbounded operations.
We really can't claim, though, that the structure of the algorithm has become much clearer.
A little less noisy yes, but hardly expressive.

The function is currently divided into three parts, and if we're honest, they are pretty arbitrary.
Sometimes we can gain greater insight by inlining everything and seeing what we have, let's do that:

// begin-insert: tags/streams-to-sequences.13:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .flatMap { event ->
            val interactionId = event["interactionId"] as String
            eventStore
                .queryAsSequence("interactionId=$interactionId")
        }.groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}
----
// end-insert

It looks like the part starting with `flatMap` and ending before `groupBy` might stand-alone.
Let's see how to extract part of a pipeline into its own function.

[[extracting-part-of-a-pipeline]]
==== Extracting Part of a Pipeline

First we select from the start of the pipeline to the last stage we want to include, so from `eventStore` up to but not including `.groupBy`.
"Extract Function", calling it, in this case, `allEventsInSameInteractions`:

// begin-insert: tags/streams-to-sequences.14:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return allEventsInSameInteractions(timeRange)
        .groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}

private fun allEventsInSameInteractions(timeRange: String) = eventStore
    .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsSequence("interactionId=$interactionId")
    }
----
// end-insert

Now we select the bits of the pipeline that we don't want in the new function, so `eventStore` to before `.flatMap`, and "Introduce Parameter".
Accept any name that IntelliJ chooses - it won't live long.:

// begin-insert: tags/streams-to-sequences.15:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return allEventsInSameInteractions(
        eventStore
            .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
    )
        .groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}

private fun allEventsInSameInteractions(
    sequence: Sequence<MutableMap<String, Any?>>
) = sequence
    .flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsSequence("interactionId=$interactionId")
    }
----
// end-insert

That's really ugly, but once we convert the `sequence` parameter of `allEventsInSameInteractions` to a receiver and reformat we have:

// begin-insert: tags/streams-to-sequences.16:src/main/java/travelator/analytics/MarketingAnalytics.kt#averageNumberOfEventsPerCompletedBooking
[source,kotlin]
----
fun averageNumberOfEventsPerCompletedBooking(
    timeRange: String
): Double {
    return eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .allEventsInSameInteractions()
        .groupBy { event ->
            event["interactionId"] as String
        }.values
        .averageBy { it.size }
}

fun Sequence<Map<String, Any?>>.allEventsInSameInteractions() =
    flatMap { event ->
        val interactionId = event["interactionId"] as String
        eventStore
            .queryAsSequence("interactionId=$interactionId")
    }
----
// end-insert

As we discussed in <<functions-to-extension-functions>>, extension functions really come into their own when we are chaining operations.
In Java, we couldn't extend the streams API with `allEventsInSameInteractions()`, so we end up breaking the chain, either by calling a function or introducing an explaining variable.

==== Final Tidy

This is still a little clunky, and we could probably make it more efficient by not creating lists in the grouping, but that will do.
Oh, except for a wafer-thin type alias and extension property:

// begin-insert: tags/streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt#event
[source,kotlin]
----
typealias Event = Map<String, Any?>

val Event.interactionId: String? get() =
    this["interactionId"] as? String
----
// end-insert

This lets us concentrate on the hard stuff when we read the code:

// begin-insert: tags/streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt#excerpt
[source,kotlin]
----
class MarketingAnalytics(
    private val eventStore: EventStore
) {
    fun averageNumberOfEventsPerCompletedBooking(
        timeRange: String
    ): Double = eventStore
        .queryAsSequence("type=CompletedBooking&timerange=$timeRange")
        .allEventsInSameInteractions()
        .groupBy(Event::interactionId)
        .values
        .averageBy { it.size }

    private fun Sequence<Event>.allEventsInSameInteractions() =
        flatMap { event ->
            eventStore.queryAsSequence(
                "interactionId=${event.interactionId}"
            )
        }
}

inline fun <T> Collection<T>.averageBy(selector: (T) -> Int): Double =
    sumBy(selector) / size.toDouble()

fun EventStore.queryAsSequence(query: String) =
    this.queryAsStream(query).asSequence()
----
// end-insert

In passing, note that `allEventsInSameInteractions` is an example of a extension function as method that we discussed in <<functions-to-extension-functions>>.
It has access to both `this` from `MarketingAnalytics` (to access `eventStore`) and `this` from `Sequence<Event>`.

=== Conclusion

We aren't going to claim that the refactored Kotlin code in this example is beautiful, but we do think that it is a significant improvement on the original Java.
Extension functions, Kotlin's lambda syntax, and improved type-inference, combine to reduce a lot of the noise associated with Java streams.
When we have in-memory collections, using iterables rather than streams can also be more efficient as well as cleaner.

// TODO some more linking to other themes