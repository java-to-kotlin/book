[[kotlin-from-scratch]]
== Kotlin From Scratch

In this book we've largely concentrated on converting our Java code to Kotlin.
Often the conversion has led to some rethinking of the interfaces to our code, and simplifying its implementation.
In this chapter we'll apply the lessons we've learned to write some Kotlin from scratch.

=== Our Mission

As we've seen in other chapters, Travelator has to import data from a lot of sources, much of it tabular, which is to say, in regular rows and columns.
Often, but not always, these tables will have a header row naming the columns for the remaining rows.
In <<bonus-refactoring>> we saw that one team had created their own parser, in other places we use the tried-and-trusted http://commons.apache.org/proper/commons-csv/[Apache Commons CSV library].
Honestly, for most uses we would still use Commons CSV, because it works out of the box, is nicely configurable for special cases, and plays really nicely with Kotlin.
Today though we're going to see what a clean-room Kotlin parser would look like.
When we're done, we'll compare what we come up with to the Commons CSV functionality, so that we can see how the Kotlin and Java approaches differ.

=== An Acceptance Test

Your authors are still Extreme Programmers at heart, and like to write code test-first, starting with a high-level acceptance test.
We're working on a table reader, so we create a class `TableReaderAcceptanceTests` with a stub method and check that it runs:

// begin-insert: tags/table-reader.0.0:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt
[source,kotlin]
----
class TableReaderAcceptanceTests {
    @Test
    fun test() {
    }
}
----
// end-insert

It does run (and even passes;-), so now we can start coding-proper.

Part of the acceptance test's job is to help us decide what our interface should look like.
Having parsed a few files in our time, we know that what we almost always want to do is to read a file and return a list of values, one for each (non-header) row.
Let's sketch that as our test:

// begin-insert: tags/table-reader.0.1:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt
[source,kotlin]
----
class TableReaderAcceptanceTests {
    data class Measurement(
        val t: Double,
        val x: Double,
        val y: Double,
    )

    @Test
    fun `acceptance test`() {
        val input = listOf(
            "time,x,y",
            "0.0,  1,  1",
            "0.1,1.1,1.2",
            "0.2,1.2,1.4",
        )
        val expected = listOf(
            Measurement(0.0, 1.0, 1.0),
            Measurement(0.1, 1.1, 1.2),
            Measurement(0.2, 1.2, 1.4)
        )
        assertEquals(
            expected,
            someFunction(input)
        )
    }

    private fun someFunction(input: List<String>): List<Measurement> {
        TODO("Not yet implemented")
    }
}
----
// end-insert


Here `Measurement` is a value type that represents the data that we want to extract from each row of the table.
In Java, we might start by creating a `TableReader` class, but we can see that reading a table is simply a calculation: a mapping of the input lines to a list of the data that we want (<<calculations>>).
So we'll default to using a top-level `someFunction` until that becomes more work than it is worth.

We could imagine all sorts of magic ways that our API could implement `someFunction`, but unless it has some special knowledge of the `Measurement` type, we are going to have to tell it how to map from some representation of a row to a `Measurement`.
That's twice we've used the word _map_, maybe map holds the key?
What if `someFunction` looked like this:

// begin-insert: tags/table-reader.0.2:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt#someFunction
[source,kotlin]
----
private fun someFunction(input: List<String>): List<Measurement> =
    readTable(input).map { record ->
        Measurement(
            record["time"].toDouble(),
            record["x"].toDouble(),
            record["y"].toDouble(),
        )
    }
----
// end-insert

This doesn't compile, because we don't have `readTable` yet, but Alt-Enter on the error and IntelliJ will create something for us:

// begin-insert: tags/table-reader.0.2:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt#readTable
[source,kotlin]
----
private fun readTable(input: List<String>): Any {
    TODO("Not yet implemented")
}
----
// end-insert

We haven't given IntelliJ enough clues about the return type of `readTable`, so it chose `Any`, and so `someFunction` still doesn't compile.
What type could we return to fix that?
Well if we return a `List` from `readTable` then we can `map` over it.
And if that `List` contained `<Map<String, String>>` then that would be the type of `record`, so we could call `record["time"]` etc.
The only issue is that `Map.get` returns a nullable value.
That's close enough - let's take account of it in `someFunction` and write:

// begin-insert: tags/table-reader.0.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt#excerpt
[source,kotlin]
----
private fun someFunction(input: List<String>): List<Measurement> =
    readTable(input).map { record ->
        Measurement(
            record["time"]?.toDoubleOrNull() ?: error("in time"),
            record["x"]?.toDoubleOrNull() ?: error("in x"),
            record["y"]?.toDoubleOrNull() ?: error("in y"),
        )
    }

fun readTable(input: List<String>): List<Map<String, String>> {
    TODO("Not yet implemented")
}
----
// end-insert

This compiles, although obviously the `TODO` fails the test.
With our client hats on we can see that we can at least use `readTable` to convert lines to a list of `Measurement`.
Now that we have a plausible API, we can move the definition of `readTable` into `src/main/travelator/tableReading/table-reading.kt` and inline `someFunction` to give us an acceptance test like this:

// begin-insert: tags/table-reader.0.4:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt#excerpt
[source,kotlin]
----
@Disabled
@Test
fun `acceptance test`() {
    val input = listOf(
        "time,x,y",
        "0.0,  1,  1",
        "0.1,1.1,1.2",
        "0.2,1.2,1.4",
    )
    val expected = listOf(
        Measurement(0.0, 1.0, 1.0),
        Measurement(0.1, 1.1, 1.2),
        Measurement(0.2, 1.2, 1.4)
    )
    assertEquals(
        expected,
        readTable(input).map { record ->
            Measurement(
                t = record["time"]?.toDoubleOrNull() ?: error("in time"),
                x = record["x"]?.toDoubleOrNull() ?: error("in x"),
                y = record["y"]?.toDoubleOrNull() ?: error("in y"),
            )
        }
    )
}
----
// end-insert

Note that we have disabled the test, as it will be a while before we get it running.
For now, it has done its job, helping us sketch a simple API that we can aim for.

Before we go on, let's just reflect on the fact that we have managed to define the interface to our parser without defining any new types.
Not only that, but by using standard types, we know that we have rich Kotlin APIs to supply the `List` that are reading from, and to interpret the `List` of ++Map++s that we are returning.

=== Unit Testing

Now that we know the interface we are aiming for, we can park the acceptance test and write a minimal unit test.
What is minimal?
We like to start with empty - what should happen if we read an empty file?

// begin-insert: tags/table-reader.0.5:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
class TableReaderTests {
    @Test
    fun `empty list returns empty list`() {
        val input: List<String> = emptyList()
        val expectedResult: List<Map<String, String>> = emptyList()
        assertEquals(
            expectedResult,
            readTable(input)
        )
    }
}
----
// end-insert

The simplest way to get this to pass is to hard-code the result in `readTable`:

// begin-insert: tags/table-reader.1:src/main/java/travelator/tablereader/table-reading.kt
[source,kotlin]
----
fun readTable(input: List<String>): List<Map<String, String>> {
    return emptyList()
}
----
// end-insert

This passes.
It may seem trivial, but it's always a good idea to have a test for empty input - the more complicated our algorithm, the more it is likely to fail in this case.
But it's also a poor parser that always returns an empty result, so let's crack on.
Following Test Driven Development, let's add a failing test first to give us a reason to change the implementation:

// begin-insert: tags/table-reader.2:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `empty list returns empty list`() {
    assertEquals(
        emptyList<Map<String, String>>(),
        readTable(emptyList())
    )
}

@Test
fun `one line of input with default field names`() {
    assertEquals(
        listOf(
            mapOf("0" to "field0", "1" to "field1")
        ),
        readTable(listOf(
            "field0,field1"
        ))
    )
}
----
// end-insert

Here we are reading a table without a header row.
Weâ€™ve made the design decision to name the fields with the `String` representation of
their position in the row.
Why?
Well if the field names are to be a `String`, but in the absence of a header all we have is their index, then converting the index to a `String` is the simplest thing we can do.
We don't have information to make a better choice at the moment, so _the simplest thing that could possibly work_ it is.
We _could_ instead have made `readTable` return `<Map<Int, String>>` when we don't have a header row.
If you have some spare time, that might be a path worth following to see where it leads.

Back in our current predicament, we have a failing test, and we can be clever, or we can be quick.
We choose to get the test passing straight away by hard-coding the result again:

// begin-insert: tags/table-reader.2:src/main/java/travelator/tablereader/table-reading.kt
[source,kotlin]
----
fun readTable(lines: List<String>): List<Map<String, String>> {
    return if (lines.isEmpty())
        emptyList()
    else listOf(
        mapOf("0" to "field0", "1" to "field1")
    )
}
----
// end-insert

Now we can refactor, with our tests passing, to remove the duplication between the test and the code.
We could do this straight away, but we can simplify what we have by noticing that we want a line in the output for every line in the input (excluding header).
This would happen naturally if we used `map`, so we can remove the `if` and `emptyList()`:

// begin-insert: tags/table-reader.4:src/main/java/travelator/tablereader/table-reading.kt
[source,kotlin]
----
fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine)
}

private fun parseLine(line: String) = mapOf("0" to "field0", "1" to "field1")
----
// end-insert

That's nicer, and `parseLine` gives us the place to build each `Map`.
We'll start removing the hard-coded values by splitting the pairs:

// begin-insert: tags/table-reader.5:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = listOf("field0", "field1")
    val keys = listOf("0", "1")
    return keys.zip(values).toMap()
}
----
// end-insert

We're still resolutely cheating, but we can now see the pattern in the keys and generate these:

// begin-insert: tags/table-reader.6:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = listOf("field0", "field1")
    val keys = values.indices.map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

For the `values`, we can split the line around the commas:

// begin-insert: tags/table-reader.7:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.split(",")
    val keys = values.indices.map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert


We haven't talked about how fields are separated from each other yet.
Obviously this is something we'd like to parameterise at some point, but that doesn't feel like much of a risk, so we'll leave it for now.
We have no other hard-coded values, and running the tests they all pass, so some of our credibility is restored.

Maybe not all though.
If you are as old as your authors (or younger and gifted) you may have developed spidey-senses for code, and they may be tingling when you look at that `split`.
Splitting things is odd if there is nothing to split around, so let's write a test to see what happens with an empty line:

// begin-insert: tags/table-reader.8:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `empty line returns empty map`() {
    assertEquals(
        listOf(
            emptyMap<String, String>()
        ),
        readTable(listOf(
            ""
        ))
    )
}
----
// end-insert

Aha!

----
org.opentest4j.AssertionFailedError:
Expected :[{}]
Actual   :[{0=}]
----

Digging a little, it seems that `split` on an empty `String` returns a `List` with one empty `String` in it.
Maybe that makes sense in other applications, but it messes us up, so we have to work around it:

// begin-insert: tags/table-reader.8:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = if (line.isEmpty()) emptyList() else line.split(",")
    val keys = values.indices.map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

That gets the tests passing, but muddies the waters of the `parseLine` function.
So we extract the muddy line to a function `splitFields`:

// begin-insert: tags/table-reader.10:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = splitFields(line)
    val keys = values.indices.map(Integer::toString)
    return keys.zip(values).toMap()
}

private fun splitFields(line: String): List<String> =
    if (line.isEmpty()) emptyList() else line.split(",")
----
// end-insert

If we make `splitFields` an extension function and pull the separators out as a parameter we get the function we always really wanted `split` to be:

// begin-insert: tags/table-reader.11:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(Integer::toString)
    return keys.zip(values).toMap()
}

private fun String.splitFields(separators: String): List<String> =
    if (isEmpty()) emptyList() else split(separators)
----
// end-insert

So far we have gotten the code working with an empty input, and then an input of a single line.
If we had we written an imperative solution we might now have to add a loop to handle more input, but `map` has our back.
We think that `readTable` should work for all the numbers known to programmers, 0, 1, and infinity.
Well, OK, maybe 2^32^ - 1 rather than actual infinity.
Trust but verify they say though, so we add a test:

// begin-insert: tags/table-reader.12:src/test/java/travelator/tablereader/TableReaderTests.kt#twoLines
[source,kotlin]
----
@Test
fun `two lines of input with default field names`() {
    assertEquals(
        listOf(
            mapOf("0" to "row0field0", "1" to "row0field1"),
            mapOf("0" to "row1field0", "1" to "row1field1")
        ),
        readTable(listOf(
            "row0field0,row0field1",
            "row1field0,row1field1"
        ))
    )
}
----
// end-insert

It passes, and we reason that 0, 1, 2 is close enough to 0, 1, 2147483647 that we are done for now.
This seems like a good place to check-in, make a fresh coffee and dispose of the last one before getting back to work.

=== Headers

Ready to go again?
OK, what about a header line?
First of all, how should our API know to expect one?
We could add a flag to `readTable` to tell it that our data has a header, or we can add another function.
Generally we prefer a different function for different functionality, so let's add a function named `readTableWithHeader`.

As before, we can add a test that calls the function that we wish we had:

// begin-insert: tags/table-reader.13:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `takes headers from header line`() {
    assertEquals(
        listOf(
            mapOf("H0" to "field0", "H1" to "field1")
        ),
        readTableWithHeader(
            listOf(
                "H0,H1",
                "field0,field1"
            )
        )
    )
}
----
// end-insert

Alt-Enter on the compilation error at `readTableWithHeader` and IntelliJ will create it for us, then we can name the parameters, and delegate to our original function for now:

// begin-insert: tags/table-reader.13:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine)
}
----
// end-insert

This compiles, but fails the tests, as we expect:

----
org.opentest4j.AssertionFailedError:
Expected :[{H0=field0, H1=field1}]
Actual   :[{0=H0, 1=H1}, {0=field0, 1=field1}]
----

To get the tests to pass, we could hard-code the result as before, but this time we're going to modify the code to make room for the functionality.
When we say _make room_, what we are aiming for is code that does the current thing (using `Integer::toString` field names), and which we augment rather than modify to support the new functionality as an addition rather than a modification (the https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle[Open Closed Principle]).
Currently, the field name information is buried in `parseLine`:

// begin-insert: tags/table-reader.13:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

We're going to pull it out from here to a place where we can use the header line to supply it.

`Integer::toString` is our current mapping from index to key.
Let's prepare to make this configurable by introducing a variable named `headerProvider`:

// begin-insert: tags/table-reader.14:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val headerProvider: (Int) -> String = Integer::toString
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

This still passes our tests, except for the new `takes headers from header line`, which is still failing.
We shouldn't really be refactoring with a failing test, as every time we run the tests we have to check that any failure is actually the one we expect.
We `@Disabled` it for now, so that we are only running tests for completed features while we are refactoring.

"Introduce Parameter" on the `headerProvider` line and naming it `headerProvider` will allow us to support  different behaviours:

// begin-insert: tags/table-reader.15:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

Unfortunately IntelliJ currently fails to make this refactor work, breaking `readTable`:

// begin-insert: tags/table-reader.15:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine) // <1>
}
----
// end-insert

<1> We could use the function reference when `parseLine` only had one parameter. Now it needs two arguments, but `map` can only supply one.

"Replace function reference with lamba" before the refactor would have made everything OK, but we'll fail forward by replacing the lamba now and adding `Integer::toString` as the `headerProvider` to get things compiling again:

// begin-insert: tags/table-reader.16:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map { parseLine(it, Integer::toString) }
}
----
// end-insert

All our tests still pass, so we're quietly confident that we haven't broken anything.

Where are we going with this?
Our new `readTableWithHeader` should be able to parse the header line to create a `headerProvider` to pass to `parseLine`.
`readTableWithHeader` calls `readTable`, which calls `parseLine`, so we need to pull the `headerProvider` out as a parameter to `readTable`.
So its "Introduce Parameter" (with "Introduce Default Value") again, this time on `Integer::toString` in `readTable`:

// begin-insert: tags/table-reader.17:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(
    lines: List<String>,
    headerProvider: KFunction1<Int, String> = Integer::toString // <1>
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
----
// end-insert

<1> Doesn't compile: `Unresolved reference: KFunction1`

It's hard to say why IntelliJ (at the time of writing) sometimes uses function types and sometimes `KFunctionN` types when refactoring.
It would be nice if it was consistent, or at least generated code that compiled.
We'll fix this one by translating the `KFunction1` to a `(Int) -> String` by hand and hold just a little grudge for this second failed refactor in a row:

// begin-insert: tags/table-reader.18:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
----
// end-insert

On the plus side, because the `headerProvider` parameter has a default value, our tests are unchanged and continue to pass.

Now we're in a position to convert the first line in `readTableWithHeader` to the `headerProvider` needed by the `readTable`.
This means splitting the lines into the header (`first()`) and the rest (`drop(1)`).
This will fail if there are no lines, so we make a note to add a test for this case.
As for converting the header line into a `headerProvider`, we'll pretend that we have a function to do that called `headerProviderFrom(String)`:

// begin-insert: tags/table-reader.19:src/main/java/travelator/tablereader/table-reading.kt#readTableWithHeader
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(
        lines.drop(1),
        headerProviderFrom(lines.first())
    )
}
----
// end-insert

Alt-Enter to create it gives us:

// begin-insert: tags/table-reader.19:src/main/java/travelator/tablereader/table-reading.kt#headerProviderFrom
[source,kotlin]
----
fun headerProviderFrom(header: String): (Int) -> String {
    TODO("Not yet implemented")
}
----
// end-insert

This is a function that needs to return a function.
We can implement it with our `splitFields` again, now inside a lambda:

// begin-insert: tags/table-reader.20:src/main/java/travelator/tablereader/table-reading.kt#headerProviderFrom
[source,kotlin]
----
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers = header.splitFields(",")
    return { index -> headers[index] }
}
----
// end-insert

Note that provided we split the `header` outside the lambda, it will be parsed only once per table.
Our tests still pass, and if we're right, so will the test for `readTableWithHeader` that we disabled previously.
Let's un-`@Disabled` it:

// begin-insert: tags/table-reader.23:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `takes headers from header line`() {
    assertEquals(
        listOf(
            mapOf("H0" to "field0", "H1" to "field1")
        ),
        readTableWithHeader(
            listOf(
                "H0,H1",
                "field0,field1"
            )
        )
    )
}
----
// end-insert

This passes, and we're about to celebrate until we look down at our TODO list and remember that we wanted to check this API with an empty input.

// begin-insert: tags/table-reader.23:src/test/java/travelator/tablereader/TableReaderTests.kt#empty
[source,kotlin]
----
@Test
fun `readTableWithHeader on empty list returns empty list`() {
    assertEquals(
        emptyList<String>(),
        readTableWithHeader(
            emptyList()
        )
    )
}
----
// end-insert

This fails with `java.util.NoSuchElementException: List is empty.`, because `readTableWithHeader` is trying to call `lines.first()` on a empty `List`:

// begin-insert: tags/table-reader.20:src/main/java/travelator/tablereader/table-reading.kt#readTableWithHeader
[source,kotlin]
----
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(
        lines.drop(1),
        headerProviderFrom(lines.first())
    )
}
----
// end-insert

Our irritation at not being finished is offset by being right about having to add a test!
The simplest fix is to split our function into two definitions, with a `when` to choose between them:
This passes all the tests, and our TODO list is empty for now.
Here then is our public API:

// begin-insert: tags/table-reader.23:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first())
        )
    }

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map { parseLine(it, headerProvider) }
----
// end-insert

This is nice - our clients now can read with or without a header row.
But wait!
Looking at the code we realise that, if they want to specify their own field names for `readTable`, they can do this by overriding the default `headerProvider` in `readTable` - we have a feature for free!
Let's write a test to demonstrate it:

// begin-insert: tags/table-reader.24:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `can specify header names when there is no header row`() {
    val headers = listOf("apple", "banana")
    assertEquals(
        listOf(
            mapOf(
                "apple" to "field0",
                "banana" to "field1",
            )
        ),
        readTable(
            listOf("field0,field1"),
            headers::get
        )
    )
}
----
// end-insert

Its worth noting how easy it is to convert from a `Map<Int, String>` to our header provider function `(Int) -> String` - with the method reference `headers::getValue`.
There is also a pleasing symmetry between this map and the maps in the output.
Such symmetry doesn't guarantee that our design is on the right tracks, but it is a good sign.

Also a good sign is that we are now in a position to try running our acceptance test.
This was:

// begin-insert: tags/table-reader.23:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt#excerpt
[source,kotlin]
----
@Disabled
@Test
fun `acceptance test`() {
    val input = listOf(
        "time,x,y",
        "0.0,  1,  1",
        "0.1,1.1,1.2",
        "0.2,1.2,1.4",
    )
    val expected = listOf(
        Measurement(0.0, 1.0, 1.0),
        Measurement(0.1, 1.1, 1.2),
        Measurement(0.2, 1.2, 1.4)
    )
    assertEquals(
        expected,
        readTable(input).map { record ->
            Measurement(
                t = record["time"]?.toDoubleOrNull() ?: error("in time"),
                x = record["x"]?.toDoubleOrNull() ?: error("in x"),
                y = record["y"]?.toDoubleOrNull() ?: error("in y"),
            )
        }
    )
}
----
// end-insert

We now know that we have called the function `readTableWithHeader` in this case, so we make the change and run the test:

// begin-insert: tags/table-reader.24:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt#excerpt
[source,kotlin]
----
assertEquals(
    expected,
    readTableWithHeader(input).map { record ->
        Measurement(
            t = record["time"]?.toDoubleOrNull() ?: error("in time"),
            x = record["x"]?.toDoubleOrNull() ?: error("in x"),
            y = record["y"]?.toDoubleOrNull() ?: error("in y"),
        )
    }
----
// end-insert

It passes!
We'll check in the code with a little smug satisfaction before the next feature.

=== Different Field Separators

At the moment we are able to read tables with fields, but only when delimited by commas, and with no quoting or escaping rules.
It would be nice to be more flexible.
In order to add flexibility we need to identify an abstraction - as we did with the `headerProvider` previously.
What is the abstraction here?

Looking at the code we see that the header and body parsing both call `splitFields`:

// begin-insert: tags/table-reader.25:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers = header.splitFields(",")
    return { index -> headers[index] }
}

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}

private fun String.splitFields(separators: String): List<String> =
    if (isEmpty()) emptyList() else split(separators)
----
// end-insert

Neither the header parsing nor the body parsing really wants to know the details of how the splitting should happen, so let's abstract that behind a function `(String) -> List<String>`.
Why that signature rather than just parameterizing the character?
Well we'd like to be able to cope with quoting fields and escaping etc, and they can all be hidden behind that function signature.
To extract the current implementation from `parseLine` we can select `line.splitFields(",")` and "Introduce Functional Parameter", choosing the parameter name `splitter`:

// begin-insert: tags/table-reader.26:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider) { line -> // <1>
            line.splitFields(",")
        }
    }

...

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String,
    splitter: (String) -> List<String>, // <2>
): Map<String, String> {
    val values = splitter(line)
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

<1> This lambda ...
<2> ... implements the splitter

We want to be able to reuse the lambda, which represents our current strategy, so select it and "Introduce Variable" named `splitter`:

// begin-insert: tags/table-reader.27:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        val splitter: (String) -> List<String> = { line ->
            line.splitFields(",")
        }
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

We'd like to have a function reference for that `splitter` that we can pass around, so select the lambda, Alt-Enter and "Convert to anonymous function":

// begin-insert: tags/table-reader.28:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        val splitter: (String) -> List<String> = fun(line: String): List<String> {
            return line.splitFields(",")
        }
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

A little manual editing will convert this to a local function:

// begin-insert: tags/table-reader.29:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        fun splitOnComma(line: String): List<String> {
            return line.splitFields(",")
        }
        parseLine(it, headerProvider, ::splitOnComma)
    }
----
// end-insert

We can then pull this to the top level:

// begin-insert: tags/table-reader.30:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, ::splitOnComma)
    }

fun splitOnComma(line: String): List<String> = line.splitFields(",")
----
// end-insert

Now "Introduce Parameter" on the function reference `::splitOnComma`, selecting "Introduce default value" to give a `splitter` parameter for `readTable`:

// begin-insert: tags/table-reader.31:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

Because we used `::splitOnComma` as the default for the new `splitter` parameter, we haven't had to change our tests, which gratifyingly continue to pass.

As it stands, `readTable` is now using the supplied `splitter`, but `readTableWithHeader` is not.
Let's go to `headerProviderFrom` and "Introduce Functional Parameter" on the expression `header.splitFields(",")`
This was:

// begin-insert: tags/table-reader.31:src/main/java/travelator/tablereader/table-reading.kt#headerProviderFrom
[source,kotlin]
----
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers = header.splitFields(",")
    return { index -> headers[index] }
}
----
// end-insert

After the refactor it is called from `readTableWithHeader` passing a lambda:

// begin-insert: tags/table-reader.32:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first()) { header ->
                header.splitFields(",")
            }
        )
    }

...

private fun headerProviderFrom(
    header: String,
    splitter: (String) -> List<String>
): (Int) -> String {
    val headers = splitter(header)
    return { index -> headers[index] }
}
----
// end-insert

Full disclosure: when we wrote this we had the `KFunction1` nonsense again and had to fix it manually.

Now that lambda is the same code as `splitOnComma`, so we use that instead:

// begin-insert: tags/table-reader.33:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), ::splitOnComma)
        )
    }
----
// end-insert

Making `::splitOnComma` a parameter `named splitter` (again, manual editing was required to fix `KFunction1` irritations) gives:

// begin-insert: tags/table-reader.34:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter)
        )
    }
----
// end-insert

Finally, the header and body should be using the same splitter, so we pass it from `readTableWithHeader` to the inner `readTable`:

// begin-insert: tags/table-reader.35:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

We should probably write a test to show the use of the `splitter`, but before we do, let's make it more convenient to make one.
Here is `splitOnComma`:

// begin-insert: tags/table-reader.35:src/main/java/travelator/tablereader/table-reading.kt#splitOnComma
[source,kotlin]
----
fun splitOnComma(line: String): List<String> = line.splitFields(",")
----
// end-insert

It would be nice to be able to create splitters without having to define a function every time, so that, for example, our French clients could call `readTable` with `splitter = splitOn(";")`.
That `splitOn` function would take the separators and return a value of function type `(String) -> List<String>`.
We could try to extract this function from our current `splitOnComma`, but the refactoring is tedious, so instead let's just define the function:

// begin-insert: tags/table-reader.36:src/main/java/travelator/tablereader/table-reading.kt#splitOn
[source,kotlin]
----
fun splitOn(
    separators: String
): (String) -> List<String> = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

We can now use in from `splitOnComma`:

// begin-insert: tags/table-reader.36:src/main/java/travelator/tablereader/table-reading.kt#splitOnComma
[source,kotlin]
----
fun splitOnComma(line: String): List<String> {
    val splitOnComma: (String) -> List<String> = splitOn(",")
    return splitOnComma(line)
}
----
// end-insert

Then pull the variable to the top level:

// begin-insert: tags/table-reader.37:src/main/java/travelator/tablereader/table-reading.kt#splitOnComma
[source,kotlin]
----
val splitOnComma: (String) -> List<String> = splitOn(",")

fun splitOnComma(line: String): List<String> =
    splitOnComma.invoke(line) // <1>
----
// end-insert

<1> Unless we use `invoke`, the compiler sees this as the function `splitOnComma` and we get a stack overflow.

Now we can replace the function reference `::splitOnComma` with the value `splitOnComma`.
We can either just search and replace, or, if we're feeling particularly fastidious, inline the function version and remove the resulting lamba expansions.

When we're done we can create a `splitOnTab` too:

// begin-insert: tags/table-reader.38:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

Now we have a `splitOnTab`, we can write a new test to show that it all works:

// begin-insert: tags/table-reader.38:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `can specify splitter`() {
    assertEquals(
        listOf(
            mapOf(
                "header1" to "field0",
                "header2" to "field1",
            )
        ),
        readTableWithHeader(
            listOf(
                "header1\theader2",
                "field0\tfield1"
            ),
            splitOnTab
        )
    )
}
----
// end-insert

This passes, hooray!
We check it in and relax for a few minutes, before coming back to take stock.

We now have the basics of a CSV or TSV parser, with no new types introduced.
This is often the way with a more functional approach.
The grain of Kotlin is to leverage the rich abstractions provided by the standard library, where Java programs are more likely to define new types.
One reason for the difference is that Kotlin's support for value-types (<<beans-to-values>>), is so much better, and these are more predictably composed that Java's mutable objects.

=== Sequences

Value types may make for APIs composed of predictable calculations (<<calculations>>), but they can bring their own problems.
Our API design as it is suffers from one major issue - it works on a `List<String>` loaded into memory, and produces a `List<Map<String, String>>`.
Roughly speaking, the memory footprint of `readTable` is twice the number of bytes of the input, which is probably twice the size of a UTF-8 encoded file containing the data.
In order to process large files it would be nice to work in terms of ++Sequence++s rather than ++List++s, as if necessary these can keep only one item in a pipeline in memory at a time.

As we saw in <<streams-to-sequences>>, we can convert a `Sequence` to a `List` and back (with some caveats) very easily.
We could implement `Sequence` functions by delegating to our existing `List` API, but as our aim is to reduce our memory footprint, we will write the `Sequence` versions and delegate the `List` versions to them.
If we're clever we can test through the convenient `List` API, thus getting two sets of tests for the price of one.

`readTable` currently looks like this:

// begin-insert: tags/table-reader.39:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

We can try out our plan by converting to and from `Sequence` in the middle of the pipeline:

// begin-insert: tags/table-reader.40:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines
        .asSequence()
        .map {
            parseLine(it, headerProvider, splitter)
        }
        .toList()
----
// end-insert

That passes the tests, and they all funnel through this function, so that's reassuring.
Now we can extract the inner workings into a function taking and returning a `Sequence` - this is extracting part of a chain as described in <<functions-to-extension-functions>>.

// begin-insert: tags/table-reader.41:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTable(
        lines.asSequence(),
        headerProvider,
        splitter
    ).toList()

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
) = lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

This gives us a `Sequence` version of `readTable` which the `List` version calls, and the `List` version is well tested.
Now for the outer `readTableWithHeader` - it looks like this:

// begin-insert: tags/table-reader.42:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
----
// end-insert

We want to produce a `Sequence` version of this.
We can try the same transformation - to and from `Sequence`, but first inlining the `readTable` call there:

// begin-insert: tags/table-reader.43:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1).asSequence(),
            headerProviderFrom(lines.first(), splitter),
            splitter
        ).toList()
    }
----
// end-insert

Now, by hand, create a `linesAsSequence` as a variable and use it in place of `lines`.
This nearly works:

// begin-insert: tags/table-reader.44:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> {
    val linesAsSequence = lines.asSequence()
    return when {
        linesAsSequence.isEmpty() -> emptySequence() // <1>
        else -> {
            readTable(
                linesAsSequence.drop(1),
                headerProviderFrom(linesAsSequence.first(), splitter),
                splitter
            )
        }
    }.toList()
}
----
// end-insert

<1> Doesn't compile, as there is no `Sequence<T>.isEmpty()`.

In retrospect, there not being a `Sequence<T>.isEmpty()` function is a warning, but we can fudge it for now by substituting `linesAsSequence.firstOrNull() == null`:

// begin-insert: tags/table-reader.45:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> {
    val linesAsSequence = lines.asSequence()
    return when {
        linesAsSequence.firstOrNull() == null -> emptySequence()
        else -> {
            readTable(
                linesAsSequence.drop(1),
                headerProviderFrom(linesAsSequence.first(), splitter),
                splitter
            )
        }
    }.toList()
}
----
// end-insert

This passes the tests, so we can again extract the expression between the `return` and `.toList()` as the function we are looking for.
Extracting it and tidying up we have the `Sequence` version of `readTableWithHeader`:

// begin-insert: tags/table-reader.46:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTableWithHeader(
        lines.asSequence(),
        splitter
    ).toList()

fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
) = when {
    lines.firstOrNull() == null -> emptySequence()
    else -> {
        readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
}
----
// end-insert

At this point, we have two versions of `readTable` and `readTableWithHeader`, a `List` and a `Sequence` version of each.
Given how easy it is to convert a `List` argument to a `Sequence`, and a `Sequence` result to a `List`, maybe the `List` variants aren't paying their way?
Let's just move their definitions into the tests while we don't have any production uses - that way the tests can use them to stay simple, and the production code is kept minimal.

Here then is the entire public interface to our table parser:

// begin-insert: tags/table-reader.47:src/main/java/travelator/tablereader/table-reading.kt#public
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    when {
        lines.firstOrNull() == null -> emptySequence()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

This is supported by three utility functions:

// begin-insert: tags/table-reader.47:src/main/java/travelator/tablereader/table-reading.kt#private
[source,kotlin]
----
private fun headerProviderFrom(
    header: String,
    splitter: (String) -> List<String>
): (Int) -> String {
    val headers = splitter(header)
    return { index -> headers[index] }
}

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String,
    splitter: (String) -> List<String>,
): Map<String, String> {
    val values = splitter(line)
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}

// Necessary because String.split returns a list of an empty string
// when called on an empty string.
private fun String.splitFields(separators: String): List<String> =
    if (isEmpty()) emptyList() else split(separators)
----
// end-insert

Looking back at the code we realised that it wasn't clear _why_ we needed `splitFields`, so we added a comment.
It's often easier to do this in retrospect, when we are trying to understand code we are returning to, rather than code we have just written.
Apart from that we think that the code is pretty self-explanatory.
Sometimes we're wrong about that.
If it takes us more than a glance to work out what is going on next time we read this code, then we'll take the opportunity then to add more comments, or better, refactor to be more expressive.

=== Reading from a File

This seems a fine interface in the abstract, but the first time we come to use it in anger, we hit on a snag.
Let's illustrate the problem with a test.
This calls the `Sequence` version of `readTableWithHeader`:

// begin-insert: tags/table-reader.48:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `read from reader`() {
    val fileContents = """
        H0,H1
        row0field0,row0field1
        row1field0,row1field1
    """.trimIndent()
    StringReader(fileContents).useLines { lines ->
        val result = readTableWithHeader(lines).toList()
        assertEquals(
            listOf(
                mapOf("H0" to "row0field0", "H1" to "row0field1"),
                mapOf("H0" to "row1field0", "H1" to "row1field1")
            ),
            result
        )
    }
}
----
// end-insert

Can you see why this fails?
What if we say that it fails with `java.lang.IllegalStateException: This sequence can be consumed only once.`?

As we saw in <<streams-to-sequences>>, sequences cannot in general be consumed more than once.

// begin-insert: tags/table-reader.47:src/main/java/travelator/tablereader/table-reading.kt#readTableWithHeader
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    when {
        lines.firstOrNull() == null -> emptySequence()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
----
// end-insert

`lines.firstOrNull()` consumes the sequence, and when reading from a `Reader` we can't just go back and start again in order to evaluate `lines.drop(1)` and `lines.first()`.
Our unit tests were all starting from a `List` of all the file lines - those sequences can  _can_ be consumed again, as they are held in memory.

In order to use our `Sequence` interface on data in files we are either going to have to load it all into memory, or find a way to fetch the first and rest of a `Sequence` without trying to read it twice.
Given that we introduced the `Sequence` specifically in order to avoid loading all the data into memory at once, let's go with the latter.

What we need to do is to check whether the `Sequence` has any items, and if so split it into the head and tail, all without consuming it more than once.
The secret is to destructure the `Sequence` with a function like this:

// begin-insert: tags/table-reader.49:src/main/java/travelator/tablereader/table-reading.kt#destruct
[source,kotlin]
----
fun <T> Sequence<T>.destruct()
    : Pair<T, Sequence<T>>? {
    val iterator = this.iterator()
    return when {
        iterator.hasNext() ->
            iterator.next() to iterator.asSequence()
        else -> null
    }
}
----
// end-insert

This returns `null` if `this` is empty, otherwise it returns a `Pair` of the head and the tail, creating a new `Sequence` from any remains. It consumes the original (by calling `iterator()`), but provides a fresh `Sequence` to continue processing.
We can use it to refactor `readTableWithHeader` from this:

// begin-insert: tags/table-reader.48:src/main/java/travelator/tablereader/table-reading.kt#readTableWithHeader
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    when {
        lines.firstOrNull() == null -> emptySequence()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
----
// end-insert

to this:

// begin-insert: tags/table-reader.49:src/main/java/travelator/tablereader/table-reading.kt#readTableWithHeader
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> {
    val firstAndRest = lines.destruct()
    return when {
        firstAndRest == null -> emptySequence()
        else -> readTable(
            firstAndRest.second,
            headerProviderFrom(firstAndRest.first, splitter),
            splitter
        )
    }
}
----
// end-insert

The new form passes all the tests, because it doesn't consume `lines` more than once:
We can simplify it, although you have to be pretty familiar with the Kotlin we write to consider it simpler!
The result is this public API:

// begin-insert: tags/table-reader.50:src/main/java/travelator/tablereader/table-reading.kt#public
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.destruct()?.let { (first, rest) ->
        readTable(
            rest,
            headerProviderFrom(first, splitter),
            splitter
        )
    } ?: emptySequence()

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

We are almost done, we promise.
Now that the API has crystallised around two functions, we can also take the opportunity to make the tests more expressive.
This is an important step - finding the patterns in our tests and expressing them in functions like the `checkReadTable` that follows, both help readers of the tests to see what the code is doing, and can help us find gaps in our test coverage.
For example, what is the behaviour of our parser when there are more fields than headers, or vice-versa.

// begin-insert: tags/table-reader.52:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
class TableReaderTests {
    @Test
    fun `empty input returns empty`() {
        checkReadTable(
            lines = emptyList(),
            shouldReturn = emptyList()
        )
    }

    @Test
    fun `one line of input with default field names`() {
        checkReadTable(
            lines = listOf("field0,field1"),
            shouldReturn = listOf(
                mapOf("0" to "field0", "1" to "field1")
            )
        )
    }

    ...
    @Test
    fun `can specify header names when there is no header row`() {
        val headers = listOf("apple", "banana")
        checkReadTable(
            lines = listOf("field0,field1"),
            withHeaderProvider = headers::get,
            shouldReturn = listOf(
                mapOf(
                    "apple" to "field0",
                    "banana" to "field1",
                )
            )
        )
    }

    @Test
    fun `readTableWithHeader takes headers from header line`() {
        checkReadTableWithHeader(
            lines = listOf(
                "H0,H1",
                "field0,field1"
            ),
            shouldReturn = listOf(
                mapOf("H0" to "field0", "H1" to "field1")
            )
        )
    }

    ...
}

private fun checkReadTable(
    lines: List<String>,
    withHeaderProvider: (Int) -> String = Integer::toString,
    shouldReturn: List<Map<String, String>>,
) {
    assertEquals(
        shouldReturn,
        readTable(
            lines.asSequence().constrainOnce(),
            headerProvider = withHeaderProvider,
            splitter = splitOnComma
        ).toList()
    )
}

private fun checkReadTableWithHeader(
    lines: List<String>,
    withSplitter: (String) -> List<String> = splitOnComma,
    shouldReturn: List<Map<String, String>>,
) {
    assertEquals(
        shouldReturn,
        readTableWithHeader(
            lines.asSequence().constrainOnce(),
            splitter = withSplitter
        ).toList()
    )
}
----
// end-insert

=== Comparison with Commons CSV

We started this chapter by saying that in most real-world situations, we would reach for Apache Commons CSV rather than rolling our own parser.
Before we finish the chapter, let's compare our API with that of the Commons equivalent.

The most common use case for a table parser is to read a file with known columns, translating each row into some data class.
Here is how we do that with our parser:

// begin-insert: tags/table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt#ours
[source,kotlin]
----
@Test
fun example() {
    reader.useLines { lines ->
        val measurements: Sequence<Measurement> =
            readTableWithHeader(lines, splitOnComma)
                .map { record ->
                    Measurement(
                        t = record["time"]?.toDoubleOrNull()
                            ?: error("in time"),
                        x = record["x"]?.toDoubleOrNull()
                            ?: error("in x"),
                        y = record["y"]?.toDoubleOrNull()
                            ?: error("in y"),
                    )
                }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
----
// end-insert

Real-world code would probably need more error handling (we see how in <<bonus-error-handling>>), but this shows the basic use case.
We use the Kotlin `Reader.useLines` extension function to produce a `Sequence<String>`, which our parser transforms into a `Sequence<Map<String, String>>`.
We can `map` over the ++Map++s, indexing by field name to extract the data we need and transform it to the type (`Measurement`) that we actually want.
This design didn't happen by accident - it was the decision that we made at the very start, albeit with `List` rather than `Sequence` at the time.

Here is the Commons CSV version:

// begin-insert: tags/table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt#commons
[source,kotlin]
----
@Test
fun `commons csv`() {
    reader.use { reader ->
        val parser = CSVParser.parse(
            reader,
            CSVFormat.DEFAULT.withFirstRecordAsHeader()
        )
        val measurements: Sequence<Measurement> = parser
            .asSequence()
            .map { record ->
                Measurement(
                    t = record["time"]?.toDoubleOrNull()
                        ?: error("in time"),
                    x = record["x"]?.toDoubleOrNull()
                        ?: error("in x"),
                    y = record["y"]?.toDoubleOrNull()
                        ?: error("in y"),
                )
            }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
----
// end-insert

It too has a static function entry point, `CSVParser.parse`, which also takes configuration about the table format (in this case `CSVFormat.DEFAULT.withFirstRecordAsHeader()`; in ours `splitOnComma`).
We have two functions to differentiate between files with or without headers; the Apache API rolls this into the `CSVFormat`.

The Commons `parse` takes a `Reader` though, rather than our `Sequence<String>`.
This allows it to handle record separators other than newLine, and newlines in the middle of fields, but leads to a proliferation of `parse` methods - there are variants taking `Path`, `File`, `InputStream`, `String` and `URL`.
We suspect that the developers felt these were necessary because Java provides little support for converting between these types of sources and disposing of them safely.
The `CSVParser` returned by the `parse` static method has a lot of code to manage resources that our API delegates to the workings of `Sequence` and Kotlin lifecycle functions like `use` and `useLines`.

On the subject of lines, you have to read between them in the code example to see it, but `CSVParser` implements `<Iterable<CSVRecord>>`.
This is a clever design choice, as it allows Java developers to use a `for` statement to loop over the records, and Kotlin developers to convert to a `Sequence` with `.asSequence`.
Actually the Kotlin usability is due to the design of the Kotlin standard library building on the same `Iterable` abstraction that the Apache developers also leverage.

Moving on, the code to create an individual `Measurement` looks identical in both examples:
// begin-insert: tags/table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt#map
[source,kotlin]
----
.map { record ->
    Measurement(
        t = record["time"]?.toDoubleOrNull()
            ?: error("in time"),
        x = record["x"]?.toDoubleOrNull()
            ?: error("in x"),
        y = record["y"]?.toDoubleOrNull()
            ?: error("in y"),
    )
}
----
// end-insert

While with our parser the type of `record` is `<Map<String, String>>`, in the Commons case it is `CSVRecord`.
`CSVRecord` has a `get(String)` method, which is how `record["time"]` etc are resolved.
It also has methods: `get(int)` to retrieve a field by index, where we could use `Map.values[Int]`;
`size()` rather than `Map.size()`; and `isSet(String)` to substitute for `Map.hasKey(String)`.
Basically `CSVRecord` is having to reproduce the `Map` interface by hand, rather than just _being_ a `Map`.
Why?
Because, as we discussed in <<java-to-kotlin-collections>>, the Java `Map` interface is mutable, and mutation makes no sense in the context of reading fields from a file - mutations certainly aren't going to be written back to the file.
When programming in Java we find ourselves having to create new types to solve problems, where in Kotlin we can express operations in standard types and enjoy the richness of the Kotlin API on those types.

One area in which the Commons CSV library Excels is its provision of ready-made parser defaults.
These are expressed as constants in the `CSVFormat` class - we've seen `CSVFormat.DEFAULT`, but there are many others, including `CSVFormat.EXCEL`.
Armed with a `CSVFormat` you can pass it to the `CSVParser.parse` method as we saw, or use it directly, for example `CSVFormat.EXCEL.parse(reader)`.
Can we provide this facility without defining new types in our API?
How about:

// begin-insert: tags/table-reader.54:src/test/java/travelator/tablereader/CsvExampleTests.kt#extension
[source,kotlin]
----
@Test
fun `configuration example`() {
    reader.use { reader ->
        val measurements = splitOnComma.readTableWithHeader(reader)
            .map { record ->
                Measurement(
                    t = record["time"]?.toDoubleOrNull()
                        ?: error("in time"),
                    x = record["x"]?.toDoubleOrNull()
                        ?: error("in x"),
                    y = record["y"]?.toDoubleOrNull()
                        ?: error("in y"),
                )
            }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
----
// end-insert

Here `splitOnComma.readTableWithHeader(reader)` is an extension function on the function type:

// begin-insert: tags/table-reader.54:src/main/java/travelator/tablereader/table-reading.kt#extension
[source,kotlin]
----
fun ((String) -> List<String>).readTableWithHeader(
    reader: StringReader
): Sequence<Map<String, String>> =
    readTableWithHeader(reader.buffered().lineSequence(), this)
----
// end-insert

In reality, `CSVFormat` represents a whole package of strategies for escaping rules, what to do with blank lines etc, not just how to split a line.
When our parser grows these facilities, then we will probably want to create a data class to collect them.
Until that point, it is interesting how much progress we have been able to make using just the built-in types and Kotlin language features.

There is, though, another useful feature that the Commons interface provides that ours doesn't, and that we will need to create a type to implement.
Commons CSV has `CSVParser.getHeaderNames` to provide access to the header information.
Can we add this facility without modifying our current API, or at least requiring changes to our client code?

For many inputs we could just call `Map.keys` on the first of the output `Sequence`, but this won't work if the table has no data rows, only a header.
In order to return header information _and_ the parsed records we could return a `Pair<List<String>, Sequence<Map<String, String>>`, but this will force our current clients to discard the first of the pair.
Instead, we can return a type `Table` that implements `Sequence<Map<String, String>>`, but also has a header property.
This way all our current callers remain unchanged, but we can access `headers` when required:

// begin-insert: tags/table-reader.55:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `Table contains headers`() {
    val result: Table = readTableWithHeader(
        listOf(
            "H0,H1",
            "field0,field1"
        ).asSequence()
    )
    assertEquals(
        listOf("H0", "H1"),
        result.headers
    )
}

@Test
fun `Table contains empty headers for empty input`() {
    assertEquals(
        emptyList<String>(),
        readTableWithHeader(emptySequence()).headers
    )
}
----
// end-insert

We'll spare you the refactoring steps, but here is the implementation:

// begin-insert: tags/table-reader.55:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
class Table(
    val headers: List<String>,
    val records: Sequence<Map<String, String>>
) : Sequence<Map<String, String>> by records

fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Table =
    lines.destruct()?.let { (first, rest) ->
        tableOf(splitter, first, rest)
    } ?: Table(emptyList(), emptySequence())

private fun tableOf(
    splitter: (String) -> List<String>,
    first: String,
    rest: Sequence<String>
): Table {
    val headers = splitter(first)
    val sequence = readTable(
        lines = rest,
        headerProvider = headers::get,
        splitter = splitter
    )
    return Table(headers, sequence)
}
----
// end-insert

=== Conclusion

To cover - types, the problem with sequences, customisation with functions, where errors can occur, actual CSV parsing.