[[kotlin-from-scratch]]
== Kotlin From Scratch

In this book we've largely concentrated on converting our Java code to Kotlin.
Often the conversion has led to some rethinking of the interfaces to our code, and simplifying its implementation.
In this chapter we'll apply the lessons we've learned to write some Kotlin from scratch.

=== Our Mission

As we've seen in other chapters, Travelator has to import data from a lot of sources, much of it tabular, which is to say, in regular rows of columns.
Often, but not always, these tables will have a header row naming the columns for the remaining rows.
In <<bonus-refactoring>> we saw that one team had created their own parser, in other places we use the tried-and-trusted http://commons.apache.org/proper/commons-csv/[Apache Commons CSV library].
Honestly, for most uses we would still use Commons CSV, because it works out of the box, is nicely configurable for special cases, and plays really nicely with Kotlin.
Today though we're going to see what a clean-room Kotlin parser would look like.
On the way, we'll compare what we come up with to the Commons CSV functionality.

=== Lists and Maps

We're going to write the code test-first, so the first thing we need is somewhere to put the tests.
We're working on a table reader, we create a `TableReaderTests` with a stub method and check that it runs:

// begin-insert: tags/table-reader.0:src/test/java/travelator/tablereader/TableReaderTests.kt
[source,kotlin]
----
class TableReaderTests {
    @Test
    fun test() {

    }
}
----
// end-insert

What should our interface look like?
We know that our files are going to be lists of lines, so let's try making the input a `List<String>`.

// begin-insert: tags/table-reader.1.0:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun test() {
    val input: List<String> = emptyList()
}
----
// end-insert

What do we want the result to look like?
Each line is composed of fields, and each field can have a name from the header.
Fields may represent some other type, but they are basically ++String++s, so we can represent each output row as a `List<Pair<String, String>>`.
We can, but perhaps a more useful representation is `Map<String, String>`, as in the common case where we know the names of the fields we expect and want to extract named data for each row, the `Map` allows the lookup.
So we're going to choose the `Map`, but note that this will prevent us working with data where multiple fields have the same name.

// begin-insert: tags/table-reader.1.1:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun test() {
    val input: List<String> = emptyList()
    val expectedResult: List<Map<String, String>> = emptyList()
}
----
// end-insert

The simplest route from an input to an output is a single function, let's call it `readTable`:

// begin-insert: tags/table-reader.1.2:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun test() {
    val input: List<String> = emptyList()
    val expectedResult: List<Map<String, String>> = emptyList()
    val actualResult: List<Map<String, String>> = readTable(input)
}
----
// end-insert

This doesn't compile, as `readTable` doesn't exist yet, so Alt-Enter on the error and "Create function readTable"

// begin-insert: tags/table-reader.1.3:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
class TableReaderTests {
    @Test
    fun test() {
        val input: List<String> = emptyList()
        val expectedResult: List<Map<String, String>> = emptyList()
        val actualResult: List<Map<String, String>> = readTable(input)
    }

    private fun readTable(input: List<String>): List<Map<String, String>> {
        TODO("Not yet implemented")
    }
}
----
// end-insert

We didn't really want that there, so we'll move `readTable` out of the test.
So far our test has allowed us to sketch the interface - what about the implementation?
Well, (when we don't have a header), the `expectedResult` `emptyList()` here is correct for the `input` `emptyList()`, so we can add an assertion and rename the test.

// begin-insert: tags/table-reader.1.4:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `empty list returns empty list`() {
    val input: List<String> = emptyList()
    val expectedResult: List<Map<String, String>> = emptyList()
    val actualResult: List<Map<String, String>> = readTable(input)
    assertEquals(
        expectedResult,
        actualResult
    )
}
----
// end-insert

The simplest way to get this to pass is to hard-code the result in `readTable`:

// begin-insert: tags/table-reader.1.5:src/main/java/travelator/tablereader/table-reading.kt
[source,kotlin]
----
fun readTable(input: List<String>): List<Map<String, String>> {
    return emptyList()
}
----
// end-insert

The pedantic types in the test helped us to generate the function, but now they are just noise, so we can simplify the test to:

// begin-insert: tags/table-reader.1.5:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `empty list returns empty list`() {
    assertEquals(
        emptyList<Map<String, String>>(),
        readTable(emptyList<String>())
    )
}
----
// end-insert

Before we go on, let's just reflect on the fact that we have managed to define the interface to our parser without defining any new types.
Not only that, but by using standard types, we know that we have rich Kotlin APIs to supply the `List` that are reading from, and to interpret the ++List++s and ++Map++s that we are returning.

=== The Non-Trivial Case

It's always a good idea to have a test for empty input - the more complicated our algorithm the more it is likely to fail in this case.
But it's also a poor parser that always returns an empty result, so let's crack on.
Your authors are still Extreme Programmers at heart, so let's add a failing test first to give us a reason to change the implementation:

// begin-insert: tags/table-reader.3:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `empty list returns empty list`() {
    assertEquals(
        emptyList<Map<String, String>>(),
        readTable(emptyList())
    )
}

@Test
fun `one line of input with default field names`() {
    assertEquals(
        listOf(
            mapOf("0" to "field0", "1" to "field1")
        ),
        readTable(listOf(
            "field0,field1"
        ))
    )
}
----
// end-insert

We've made the design decision to name the fields with the +String+ representation of their index when we don't have a header row.
Why?
Well we know that their names should be a `String`, so that we can populate them from a header if we have one.
When we don't have a header, all we have is the index, so stringifying that is the simplest thing we can do.
We don't have much information to make a better choice at the moment, so _the simplest thing that could possibly work_ it is.

On the subject of which, we have a failing test, and we can be clever, or we can be quick.
We choose to get the test passing straight away by hard-coding the result again:

// begin-insert: tags/table-reader.3:src/main/java/travelator/tablereader/table-reading.kt
[source,kotlin]
----
fun readTable(lines: List<String>): List<Map<String, String>> {
    return if (lines.isEmpty())
        emptyList()
    else listOf(
        mapOf("0" to "field0", "1" to "field1")
    )
}
----
// end-insert

Now we can refactor with our tests passing to remove the duplication between the test and the code.
We could do this straight away, but we can simplify what we have and prepare the ground by noticing that we want a line in the output for every line in the input (excluding header).
This would happen naturally if we used `map`, so we can remove the `if` and `emptyList()`:

// begin-insert: tags/table-reader.4:src/main/java/travelator/tablereader/table-reading.kt
[source,kotlin]
----
fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine)
}

private fun parseLine(line: String) = mapOf("0" to "field0", "1" to "field1")
----
// end-insert

That's nicer, and gives us the place to build the map, this time by splitting the pairs:

// begin-insert: tags/table-reader.5:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = listOf("field0", "field1")
    val keys = listOf("0", "1")
    return keys.zip(values).toMap()
}
----
// end-insert

We're still resolutely cheating, but we can now see the pattern in the keys and generate these:

// begin-insert: tags/table-reader.6:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = listOf("field0", "field1")
    val keys = (0 .. values.size).map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

Now we split the line around the comma to extract the values, removing the duplication:

// begin-insert: tags/table-reader.7:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.split(",")
    val keys = (0 .. values.size).map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert


We haven't talked about how fields are separated yet.
Obviously this is something we'd like to parameterise, but that doesn't feel like much of a risk, so we'll leave it for now.
Running the tests all is fine, so some of our credibility is restored.

Maybe not all though.
Nat and Duncan are both old, although not equally old.
Duncan is old enough to have spidey-senses for code, and they are tingling when he looks at that `split`.
Splitting is odd if there is nothing to split around, so let's write a test to see what happens with an empty line:

// begin-insert: tags/table-reader.8:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `empty line returns empty map`() {
    assertEquals(
        listOf(
            emptyMap<String, String>()
        ),
        readTable(listOf(
            ""
        ))
    )
}
----
// end-insert

Aha!

----
org.opentest4j.AssertionFailedError:
Expected :[{}]
Actual   :[{0=}]
----

Digging a little, it seems that `split` on an empty `String` returns a `List` with one empty `String` in it.
That doesn't seem all that sensible, but we have to work around it:

// begin-insert: tags/table-reader.8:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.split(",")
    if (values.size == 1 && values.first().isEmpty())
        return emptyMap()
    val keys = (0 .. values.size).map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

That gets the tests passing, but muddies the waters of the function.
Let's pull out a variable:

// begin-insert: tags/table-reader.9:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val sussValues = line.split(",")
    val values = if (sussValues.size == 1 && sussValues.first().isEmpty())
        emptyList<String>() else sussValues
    val keys = (0 .. values.size).map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

Extract the muddy lines to a function:

// begin-insert: tags/table-reader.10:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = splitFields(line)
    val keys = (0 .. values.size).map(Integer::toString)
    return keys.zip(values).toMap()
}

private fun splitFields(line: String): List<String> {
    val sussValues = line.split(",")
    val values = if (sussValues.size == 1 && sussValues.first().isEmpty())
        emptyList<String>() else sussValues
    return values
}
----
// end-insert

Now we're just three wafer-thin refactorings from making `splitFields` the single-expression-extension-function it was born to be - here's the result:

// begin-insert: tags/table-reader.11:src/main/java/travelator/tablereader/table-reading.kt#splitFields
[source,kotlin]
----
private fun String.splitFields(separators: String): List<String> =
    split(separators).let { fields ->
        if (fields.size == 1 && fields.first().isEmpty())
            emptyList()
        else
            fields
    }
----
// end-insert

So far we started from an empty input, and then implemented the ability to handle one line.
Had we written an imperative solution we might have to add a loop to handle more input, but `map` has our back.
Trust but verify they say though, so we add a test:

// begin-insert: tags/table-reader.12:src/test/java/travelator/tablereader/TableReaderTests.kt#twoLines
[source,kotlin]
----
@Test
fun `two lines of input with default field names`() {
    assertEquals(
        listOf(
            mapOf("0" to "row0field0", "1" to "row0field1"),
            mapOf("0" to "row1field0", "1" to "row1field1")
        ),
        readTable(listOf(
            "row0field0,row0field1",
            "row1field0,row1field1"
        ))
    )
}
----
// end-insert

It passes - we always said it would!
This seems like a good places to check-in, make a fresh coffee and dispose of the last one before getting back to work.

=== Headers

Ready to go again?
OK, what about a header line?
First of all, how should our API change to account for one?
We could add a flag to `readTable` to tell it that our data has a header, or we can add another function.
Generally we prefer a different function for different functionality, so let's add a function named `readTableWithHeader`, taking the header as a separate parameter.
Given the extra parameter we might not usually give it a different name, but it will help us to differentiate between them in the book text.
Taking the header as a different parameter rather than the first in the `List<String>` is a bit arbitrary (and we'll see later that it turns out to be a bad call), but we need to do something, and this is a thing, and a simple one at that.

As before, we can add a test that calls the function that we wish we had:

// begin-insert: tags/table-reader.13:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `takes headers from header line`() {
    assertEquals(
        listOf(
            mapOf("H0" to "field0", "H1" to "field1")
        ),
        readTableWithHeader(
            "H0,H1",
            listOf("field0,field1")
        )
    )
}
----
// end-insert

Alt-Enter on `readTableWithHeader` and IntelliJ will then create it for us.
This time we haven't given it enough clues for it to know the return type, but we can specify that by hand as we implement the function by delegating to `readTable` for now:

// begin-insert: tags/table-reader.13:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine)
}
----
// end-insert

This compiles, but fails the tests, as we expect.
To get them to pass, we could hard-code the result as before, but this time we're going to modify the code to support this feature.
In retrospect (writing this episode up afterwards) this will leave this test failing for quite a long time, maybe we should backed it out having decided on the interface so that all tests pass while we refactor to make room for the functionality.

When we say _make room_, what we are aiming for is code that does the current thing (using `Integer::toString` field names), and which can support the new functionality as an addition rather than a modification.
In order to do that we need to get header information to `parseLine`, which is currently:

// begin-insert: tags/table-reader.13:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val keys = (0..values.size).map(Integer::toString)
    return keys.zip(values).toMap()
}
----
// end-insert

`Integer::toString` is our current mapping from index to key.
Let's prepare to make this configurable by introducing a variable named `headerProvider`:

// begin-insert: tags/table-reader.14:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val headerProvider: (Int) -> String = Integer::toString
    val keys = (0..values.size).map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

"Extracting Parameter" on the `headerProvider` line and naming it `headerProvider` will allow us to inject a different behaviour:

// begin-insert: tags/table-reader.15:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = (0..values.size).map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

Unfortunately IntelliJ currently fails to make this refactor work, breaking `readTable`:

// begin-insert: tags/table-reader.15:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine) // <1>
}
----
// end-insert

<1> We could use the function reference when `parseLine` only had one parameter. Now it needs two arguments, but `map` can only supply one.

"Replace function reference with lamba" before the refactor would have made everything OK, but we'll fail forward by doing it now and adding `Integer::toString` as the `headerProvider` to get things compiling again:

// begin-insert: tags/table-reader.16:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map { parseLine(it, Integer::toString) }
}
----
// end-insert

All our original tests still pass, so we probably haven't broken anything, although the new test is still failing, so we have been refactoring with a failing test which makes everything a lot more stressful.

Where are we going with this?
We want our new `readTableWithHeader` to call the old `readTable` with a `headerProvider` derived from the header line.
So we need to pull the `headerProvider` out as a parameter to the old `readTable`, as we did with `parseLine`.
So its "Extract Parameter" (with "Introduce Default Value") again:

// begin-insert: tags/table-reader.17:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(
    lines: List<String>,
    headerProvider: KFunction1<Int, String> = Integer::toString // <1>
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
----
// end-insert

<1> Doesn't compile: `Unresolved reference: KFunction1`

It's hard to say why IntelliJ (at the time of writing) sometimes uses function types and sometimes `KFunctionN` types when refactoring.
It would be nice if it was consistent, or at least generated code that compiled..
We'll fix this one by translating the `KFunction1` to a `(Int) -> String` by hand and hold just a little grudge for this second failed refactor in a row:

// begin-insert: tags/table-reader.18:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
----
// end-insert

Because the `headerProvider` parameter has a default, our tests are unchanged and continue to pass (except, sigh, for the one we still haven't implemented).

Now we're in a position to convert the `header` in `readTableWithHeader` to the `headerProvider` needed by the `readTable`.
A nested function will do for now:

// begin-insert: tags/table-reader.19:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    fun headerProvider(index: Int): String {
        val headers: List<String> = header.splitFields(",")
        return headers[index]
    }
    return readTable(lines, ::headerProvider)
}

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
----
// end-insert

Run the tests and, oh, the new test still fails.
Its in a different way though, now it says `java.lang.IndexOutOfBoundsException: Index 2 out of bounds for length 2`.
We're evidently reading outside our `headers` `List`, but why now?

// begin-insert: tags/table-reader.19:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = (0..values.size).map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

Scouring the code, `values.size` is suspicious - it looks like we were always trying to get one header too many!
We can fix that:

// begin-insert: tags/table-reader.20:src/main/java/travelator/tablereader/table-reading.kt#parseLine
[source,kotlin]
----
private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = (values.indices).map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

Now the tests all pass, and about time too.

`readTableWithHeader` is still a bit untidy though:

// begin-insert: tags/table-reader.20:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    fun headerProvider(index: Int): String {
        val headers: List<String> = header.splitFields(",")
        return headers[index]
    }
    return readTable(lines, ::headerProvider)
}
----
// end-insert

We'd like to move the `headerProvider()` function into the top level, but IntelliJ can't do that without a bit of persuasion.
If we select `::headerProvider` and "Introduce Variable" we get:

// begin-insert: tags/table-reader.21:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    fun headerProvider(index: Int): String {
        val headers: List<String> = header.splitFields(",")
        return headers[index]
    }
    val headerProvider = ::headerProvider
    return readTable(lines, headerProvider)
}
----
// end-insert

Now "Extract Function", calling it `headerProviderFrom`:

// begin-insert: tags/table-reader.22:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(header: String, lines: List<String>): List<Map<String, String>> {
    val headerProvider = headerProviderFrom(header)
    return readTable(lines, headerProvider)
}

private fun headerProviderFrom(header: String): KFunction1<Int, String> {
    fun headerProvider(index: Int): String {
        val headers: List<String> = header.splitFields(",")
        return headers[index]
    }

    val headerProvider = ::headerProvider
    return headerProvider
}
----
// end-insert

This is a function that will take a header line and return a function that will provide the column header given an index.
There's lots of unnecessary lines there though, and at the moment the nested `headerProvider` function will reparse the header line every time it is invoked.
We can fix that by moving the parsing out of the function definition, and refactor our way to:

// begin-insert: tags/table-reader.23:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>
): List<Map<String, String>> =
    readTable(lines, headerProviderFrom(header))

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map { parseLine(it, headerProvider) }

private fun headerProviderFrom(header: String): (Int) -> String {
    val headers: List<String> = header.splitFields(",")
    return fun (index: Int) = headers[index]
}
----
// end-insert

This is a nice API - our clients can read with or without a header row, and if they want to specify their own field names they can override the default `headerProvider`.
Let's write a test to demonstrate that last feature:

// begin-insert: tags/table-reader.24:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `can specify header names`() {
    val headers = mapOf(0 to "apple", 1 to "banana")
    assertEquals(
        listOf(
            mapOf(
                "apple" to "field0",
                "banana" to "field1",
            )
        ),
        readTable(
            listOf("field0,field1"),
            headers::getValue
        )
    )
}
----
// end-insert

Its worth noting how easy it is to convert from a `Map<Int, String>` to our header provider function (Int) -> String - with the method reference `headers::getValue`.
There is also a pleasing symmetry between this map and the maps in the output.
Such symmetry doesn't guarantee that our design is on the right tracks, but it is a good sign.
We'll check in the code with a little smug satisfaction before the next feature.

=== Different Field Separators

At the moment our format is fixed as comma-separated, and with no quoting or escaping rules.
It would be nice to be more flexible.
In order to add flexibility we need to identify an abstraction - as we did with the `headerProvider` previously.
What is the abstraction here?
Looking at the code we see that the header and body parsing both call `splitFields`

// begin-insert: tags/table-reader.25:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers: List<String> = header.splitFields(",")
    return fun (index: Int) = headers[index]
}

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = (values.indices).map(headerProvider)
    return keys.zip(values).toMap()
}

private fun String.splitFields(separators: String): List<String> =
    split(separators).let { fields ->
        if (fields.size == 1 && fields.first().isEmpty())
            emptyList()
        else
            fields
    }
----
// end-insert

Neither the header parsing nor the body parsing really wants to know the details of how the splitting should happen, so let's abstract that behind a function `(String) -> List<String>`.
Why that signature rather than just parameterizing the character?
Well we'd like to be able to cope with quoting fields and escaping etc, and they can all be hidden behind that function.
To extract the current implementation from `parseLine` we can select `line.splitFields(",")` and "Introduce Functional Parameter", choosing the parameter name `splitter`:

// begin-insert: tags/table-reader.26:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider) { line -> // <1>
            line.splitFields(",")
        }
    }

...

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String,
    splitter: (String) -> List<String>, // <2>
): Map<String, String> {
    val values = splitter(line)
    val keys = (values.indices).map(headerProvider)
    return keys.zip(values).toMap()
}
----
// end-insert

<1> This lambda ...
<2> ... implements the splitter

We want to be able to reuse that lambda, so select it and "Introduce Variable" named `splitter`:

// begin-insert: tags/table-reader.27:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        val splitter: (String) -> List<String> = { line ->
            line.splitFields(",")
        }
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

We'd like to have a function reference for that `splitter` that we can pass around, so select the lambda, Alt-Enter and "Convert to anonymous function":

// begin-insert: tags/table-reader.28:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        val splitter: (String) -> List<String> = fun(line: String): List<String> {
            return line.splitFields(",")
        }
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

A little manual editing will convert this to a local function:

// begin-insert: tags/table-reader.29:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        fun splitOnComma(line: String): List<String> {
            return line.splitFields(",")
        }
        parseLine(it, headerProvider, ::splitOnComma)
    }
----
// end-insert

We can then pull this to the top level:

// begin-insert: tags/table-reader.30:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, ::splitOnComma)
    }

fun splitOnComma(line: String): List<String> = line.splitFields(",")
----
// end-insert

Now "Introduce Parameter" on the function reference `::splitOnComma`, selecting "Introduce default value" to give a `splitter` parameter:

// begin-insert: tags/table-reader.31:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

Because we used `::splitOnComma` as the default for the new `splitter` parameter, we haven't had to change our tests, which gratifyingly continue to pass.

As it stands, `readTable` is now using the supplied `splitter`, but `readTableWithHeader` is not.
Let's go to `headerProviderFrom` and "Introduce Functional Parameter" on the expression `header.splitFields(",")`
This was:

// begin-insert: tags/table-reader.31:src/main/java/travelator/tablereader/table-reading.kt#headerProviderFrom
[source,kotlin]
----
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers: List<String> = header.splitFields(",")
    return fun (index: Int) = headers[index]
}
----
// end-insert

Now it is called from `readTableWithHeader` passing a lambda:

// begin-insert: tags/table-reader.32:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>
): List<Map<String, String>> =
    readTable(
        lines,
        headerProviderFrom(header) { header ->
            header.splitFields(",")
        }
    )

...

private fun headerProviderFrom(
    header: String,
    splitter: (String) -> List<String>
): (Int) -> String {
    val headers: List<String> = splitter(header)
    return fun (index: Int) = headers[index]
}
----
// end-insert

Full disclosure, when we wrote this we had the `KFunction1` nonsense again and had to fix it manually.

Now that lambda is the same code as `splitOnComma`, so we use that instead:

// begin-insert: tags/table-reader.33:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>
): List<Map<String, String>> =
    readTable(
        lines,
        headerProviderFrom(header, ::splitOnComma)
    )
----
// end-insert

Make it a parameter (again, manual editing was required to fix `KFunction1` irritations):

// begin-insert: tags/table-reader.34:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    readTable(
        lines,
        headerProviderFrom(header, splitter)
    )
----
// end-insert

Finally, the header and body should be using the same splitter, so we pass it from `reatTableWithHeader` to the inner `readTable`:

// begin-insert: tags/table-reader.35:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    readTable(
        lines,
        headerProviderFrom(header, splitter),
        splitter
    )

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = ::splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

We should probably write a test to show the use of the `splitter`, but before we do, let's make it more convenient to make one.
Here is `splitOnComma`:

// begin-insert: tags/table-reader.35:src/main/java/travelator/tablereader/table-reading.kt#splitOnComma
[source,kotlin]
----
fun splitOnComma(line: String): List<String> = line.splitFields(",")
----
// end-insert

Can we make a more generic `splitOn`?

We can if we call a function to initialise a value of function type.
Let's write that:

// begin-insert: tags/table-reader.36:src/main/java/travelator/tablereader/table-reading.kt#splitOn1
[source,kotlin]
----
val splitOnComma: (String) -> List<String> = splitOn(",")
----
// end-insert

Alt-Enter on `splitOn` creates the function for us:

// begin-insert: tags/table-reader.36:src/main/java/travelator/tablereader/table-reading.kt#splitOn2
[source,kotlin]
----
fun splitOn(separators: String): (String) -> List<String> {
    TODO("Not yet implemented")
}
----
// end-insert

Now we can implement it:

// begin-insert: tags/table-reader.37:src/main/java/travelator/tablereader/table-reading.kt#splitOn2
[source,kotlin]
----
fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

Now we can replace the function reference `::splitOnComma` with the value `splitOnComma`.
While we're there we can create a `splitOnTab` too:

// begin-insert: tags/table-reader.38:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTable(
        lines,
        headerProviderFrom(header, splitter),
        splitter
    )

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

Now we have a `splitOnTab` we can write a new test to show that it all works:

// begin-insert: tags/table-reader.38:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `can specify splitter`() {
    assertEquals(
        listOf(
            mapOf(
                "header1" to "field0",
                "header2" to "field1",
            )
        ),
        readTableWithHeader(
            "header1\theader2",
            listOf("field0\tfield1"),
            splitOnTab
        )
    )
}
----
// end-insert

This passes, hooray!
We check it in and relax for a few minutes, before coming back to take stock.

We now have the basics of a CSV or TSV parser, with no new types introduced.
This is often the way with a more functional approach.
The grain of Kotlin is to leverage the rich abstractions provided by the standard library, where Java programs are more likely to define new types.
Your authors think that one reason for the difference is that Kotlin's support for value-types is so much better, and these are more predictably composed that Java's mutable objects.
Nevertheless, values like Kotlin's `List<String>` are not without their problems.

=== Sequences

The design as it is suffers from one major issue - it works on a `List<String>` loaded into memory, and produces a `List<Map<String, String>>`
Roughly speaking, the memory footprint of `readTable` is twice the number of bytes of the input, which is probably twice the size of a UTF-8 encoded file containing the data.
In order to process large files it would be nice to work in terms of ++Sequence++s rather than ++List++s, as these can keep only one item a pipeline in memory at a time.

As we saw in <<streams-to-sequences>>, we can convert a `Sequence` to a `List` and back (with some caveats) very easily.
If our aim is to reduce our memory footprint, there is little point in implementing a `Sequence` API in terms of a `List` API, so we will write the `Sequence` versions and delegate the `List` versions to them.
If we're clever we can test through the convenient `List` API thus getting two sets of tests for the price of one.

`readTable` currently looks like this:

// begin-insert: tags/table-reader.39:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

We can try out our plan by converting to and from `Sequence` in the middle:

// begin-insert: tags/table-reader.40:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines
        .asSequence()
        .map {
            parseLine(it, headerProvider, splitter)
        }
        .toList()
----
// end-insert

That passes the tests, and they all funnel through this function, so that's reassuring.
Now we can extract the inner workings into a function taking and returning a `Sequence` - this is extracting part of a chain as described in <<functions-to-extension-functions>>.

// begin-insert: tags/table-reader.41:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTable(
        lines.asSequence(),
        headerProvider,
        splitter
    ).toList()

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
) = lines.map {
        parseLine(it, headerProvider, splitter)
    }
----
// end-insert

This still passing, excellent.
Now for the outer `readTableWithHeader` - it looks like this:

// begin-insert: tags/table-reader.42:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTable(
        lines,
        headerProviderFrom(header, splitter),
        splitter
    )
----
// end-insert

We want to produce a `Sequence` version of this.
It's a little around-the-houses, but if we inline the `readTable` call there:

// begin-insert: tags/table-reader.43:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTable(
        lines.asSequence(),
        headerProviderFrom(header, splitter),
        splitter
    ).toList()
----
// end-insert

Now extract `lines.asSequence()` as a variable:

// begin-insert: tags/table-reader.44:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> {
    val lines1 = lines.asSequence()
    return readTable(
        lines1,
        headerProviderFrom(header, splitter),
        splitter
    ).toList()
}
----
// end-insert

That expression between `return` and `.toList()` is the function we want - we extract it to a new function also named `readTableWithHeader`:

// begin-insert: tags/table-reader.45:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> {
    val lines1 = lines.asSequence()
    return readTableWithHeader(lines1, header, splitter).toList()
}

fun readTableWithHeader(
    lines1: Sequence<String>,
    header: String,
    splitter: (String) -> List<String>
) = readTable(
    lines1,
    headerProviderFrom(header, splitter),
    splitter
)
----
// end-insert

This just leaves tidying up by inlining `lines1`, converting to a single expression, and changing the parameter ordering and defaults for the `Sequence` version of `readTableWithHeader`:

// begin-insert: tags/table-reader.46:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTableWithHeader(
        header,
        lines.asSequence(),
        splitter
    ).toList()

fun readTableWithHeader(
    header: String,
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
) = readTable(
    lines,
    headerProviderFrom(header, splitter),
    splitter
)
----
// end-insert

At this point, we have two versions of `readTable` and `readTableWithHeaders`, a `List` and a `Sequence` version of each.
Given how easy it is to convert to and from `List` and `Sequence`, maybe the `List` variants aren't paying their way?
While we don't have any production uses, let's just move their definitions into the tests - that way the tests can use them to stay simple, and the production code is kept minimal.

Here then is the entire public interface to our table parser:

// begin-insert: tags/table-reader.47:src/main/java/travelator/tablereader/table-reading.kt#public
[source,kotlin]
----
fun readTableWithHeader(
    header: String,
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
) = readTable(
    lines,
    headerProviderFrom(header, splitter),
    splitter
)

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
) = lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
----
// end-insert

This is supported by three utility functions:

// begin-insert: tags/table-reader.47:src/main/java/travelator/tablereader/table-reading.kt#private
[source,kotlin]
----
private fun headerProviderFrom(
    header: String,
    splitter: (String) -> List<String>
): (Int) -> String {
    val headers: List<String> = splitter(header)
    return fun(index: Int) = headers[index]
}

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String,
    splitter: (String) -> List<String>,
): Map<String, String> {
    val values = splitter(line)
    val keys = (values.indices).map(headerProvider)
    return keys.zip(values).toMap()
}

// Necessary because String.split returns a list of an empty string
// when called on an empty string.
private fun String.splitFields(separators: String): List<String> =
    split(separators).let { fields ->
        if (fields.size == 1 && fields.first().isEmpty())
            emptyList()
        else
            fields
    }
----
// end-insert

You can see that we took the liberty of writing a comment explaining why `splitFields` had to exist - apart from that we think that the code is pretty self-explanatory.
Sometimes we're wrong about that.
If it takes us more than a glance to work out what is going on next time we read this file, then we'll take the opportunity then to add comments, or better, refactor to be more expressive.

=== Reading from a File

This seems a fine interface in the abstract, but the first time we come to use it in anger, we hit on a snag.
Let's illustrate the problem with a test.
This calls the `Sequence` version of `readTableWithHeader`:

// begin-insert: tags/table-reader.48:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `read from reader`() {
    val fileContents = """
        H0,H1
        row0field0,row0field1
        row1field0,row1field1
    """.trimIndent()
    StringReader(fileContents).useLines { lines ->
        val result = readTableWithHeader(
            lines.first(),
            lines.drop(1)
        ).toList()
        assertEquals(
            listOf(
                mapOf("H0" to "row0field0", "H1" to "row0field1"),
                mapOf("H0" to "row1field0", "H1" to "row1field1")
            ),
            result
        )
    }
}
----
// end-insert

Can you see why this fails?
What if we say that it fails with `java.lang.IllegalStateException: This sequence can be consumed only once.`?

As we saw in <<streams-to-sequences>>, sequences cannot in general be consumed more than once.
`lines.first()` and `lines.drop(1)` are both terminal operations, and when reading from a `Reader` we can't just go back and start again.
We don't have an equivalent test that starts from a `List` of all the file lines, but if we did it would pass, because a `Sequence` from a `List` _can_ be consumed again.

In order to use our `Sequence` interface on data in files we are either going to have to load it all into memory, or find a way to fetch the first and rest of a `Sequence` without trying to read it twice.
Given that we introduced the `Sequence` specifically in order to avoid loading all the data into memory, let's go with the latter.

The secret is to destructure the `Sequence` with a function like this:

// begin-insert: tags/table-reader.49:src/main/java/travelator/tablereader/table-reading.kt#destruct
[source,kotlin]
----
fun <T> Sequence<T>.destruct()
    : Pair<T, Sequence<T>>? {
    val iterator = this.iterator()
    return when {
        iterator.hasNext() ->
            iterator.next() to iterator.asSequence()
        else -> null
    }
}
----
// end-insert

This consumes the `Sequence` receiver (by calling `iterator()`), but creates another `Sequence` from any remains that have not been consumed (`iterator.asSequence()`).
It returns `null` if `this` is empty, otherwise a `Pair` of the head and the tail.
We can use it to get our test to pass as follows:

// begin-insert: tags/table-reader.49:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `read from reader`() {
    val fileContents = """
        H0,H1
        row0field0,row0field1
        row1field0,row1field1
    """.trimIndent()
    StringReader(fileContents).useLines { lines ->
        val (first, rest) = lines.destruct()!!
        val result = readTableWithHeader(
            first,
            rest
        ).toList()
        assertEquals(
            listOf(
                mapOf("H0" to "row0field0", "H1" to "row0field1"),
                mapOf("H0" to "row1field0", "H1" to "row1field1")
            ),
            result
        )
    }
}
----
// end-insert

Knowing to destruct the `Sequence` in order to call `readTableWithHeader` is a high hoop to jump through to use the API in such a common case, so we'll move the logic into a public API function `readTableWithHeader` that takes the header and body in a single `Sequence`.

// begin-insert: tags/table-reader.50:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.destruct()?.let { (first, rest) ->
        readTableWithHeader(
            first,
            rest,
            splitter
        )
    } ?: emptySequence()

fun readTableWithHeader(
    header: String,
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> = readTable(
    lines,
    headerProviderFrom(header, splitter),
    splitter
)
----
// end-insert

We can call the new function from the tests to show that it works:

// begin-insert: tags/table-reader.50:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `read from reader`() {
    fun `read from reader`() {
        val fileContents = """
        H0,H1
        row0field0,row0field1
        row1field0,row1field1
    """.trimIndent()
        StringReader(fileContents).useLines { lines ->
            val result = readTableWithHeader(lines).toList()
            assertEquals(
                listOf(
                    mapOf("H0" to "row0field0", "H1" to "row0field1"),
                    mapOf("H0" to "row1field0", "H1" to "row1field1")
                ),
                result
            )
        }
    }
}
----
// end-insert

We are almost done, we promise.
We really need a test to show what happens when there is only a header row (the `?: emptySequence()` expression in `readTableWithHeader`) - you can trust us sort this out.
On the API front - we've now discovered that `readTableWithHeader` that supplies the header row separately is practically useless given ++Sequence++s, so we remove it in favour of the new `readTableWithHeader`.
This requires a bit of refactoring of the tests too, the details of which we'll elide.

The net result is a public API like this:

// begin-insert: tags/table-reader.52:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.destruct()?.let { (first, rest) ->
        readTable(
            rest,
            headerProviderFrom(first, splitter),
            splitter
        )
    } ?: emptySequence()

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Integer::toString,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> = lines.map {
    parseLine(it, headerProvider, splitter)
}
----
// end-insert

We've can also take the opportunity to make the tests more expressive now that we know what we are doing.
This is an important step - finding the patterns in our tests and expressing them in functions like the `checkReadTable` that follows both help readers of the tests to see what the code is doing, and can help us find gaps in our test coverage.
For example, what is the behaviour of our parser when there are more fields than headers, or vice-versa.

// begin-insert: tags/table-reader.52:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
class TableReaderTests {
    @Test
    fun `empty input returns empty`() {
        checkReadTable(
            lines = emptyList(),
            shouldReturn = emptyList()
        )
    }

    @Test
    fun `one line of input with default field names`() {
        checkReadTable(
            lines = listOf("field0,field1"),
            shouldReturn = listOf(
                mapOf("0" to "field0", "1" to "field1")
            )
        )
    }

    ...
    @Test
    fun `can specify header names`() {
        val headers = mapOf(0 to "apple", 1 to "banana")
        checkReadTable(
            lines = listOf("field0,field1"),
            withHeaderProvider = headers::getValue,
            shouldReturn = listOf(
                mapOf(
                    "apple" to "field0",
                    "banana" to "field1",
                )
            )
        )
    }

    @Test
    fun `readTableWithHeader takes headers from header line`() {
        checkReadTableWithHeader(
            lines = listOf(
                "H0,H1",
                "field0,field1"
            ),
            shouldReturn = listOf(
                mapOf("H0" to "field0", "H1" to "field1")
            )
        )
    }

    ...
}

private fun checkReadTable(
    lines: List<String>,
    withHeaderProvider: (Int) -> String = Integer::toString,
    shouldReturn: List<Map<String, String>>,
) {
    assertEquals(
        shouldReturn,
        readTable(
            lines.asSequence().constrainOnce(),
            headerProvider = withHeaderProvider,
            splitter = splitOnComma
        ).toList()
    )
}

private fun checkReadTableWithHeader(
    lines: List<String>,
    withSplitter: (String) -> List<String> = splitOnComma,
    shouldReturn: List<Map<String, String>>,
) {
    assertEquals(
        shouldReturn,
        readTableWithHeader(
            lines.asSequence().constrainOnce(),
            splitter = withSplitter
        ).toList()
    )
}
----
// end-insert

=== Comparison with Commons CSV

We started this chapter by saying that in most real-world situations, we would reach for Apache Commons CSV rather than rolling our own parser.
Before we finish the chapter, let's compare our API with that of the Commons equivalent.

The most common use case for a table parser is to read a file with known columns, translating each row into some data class that represents the data there.
Here is how we do that with our parser, expressed as a test that we probably should have written before now!

// begin-insert: tags/table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt#ours
[source,kotlin]
----
@Test
fun example() {
    reader.useLines { lines ->
        val measurements: Sequence<Measurement> =
            readTableWithHeader(lines, splitOnComma)
                .map { record ->
                    Measurement(
                        t = record["time"]!!.toDouble(),
                        x = record["x"]!!.toDouble(),
                        y = record["y"]!!.toDouble(),
                    )
                }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
----
// end-insert

Real-world code would probably need more error handling (we see how in <<bonus-error-handling>>), but this shows the basic use case.
We use the Kotlin `Reader.useLines` extension function to produce a `Sequence<String>`, which our parser transforms into a `Sequence<Map<String, String>>`.
We can `map` over the ++Map++s, indexing by field name to extract the data we need and transform it the type (`Measurement`) that we actually want.
This design didn't happen by accident - it was the decision that we made at the very start, albeit with `List` rather than `Sequence` for simplicity.

Here is the Commons CSV version:

// begin-insert: tags/table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt#commons
[source,kotlin]
----
@Test
fun `commons csv`() {
    reader.use { reader ->
        val parser = CSVParser.parse(
            reader,
            CSVFormat.DEFAULT.withFirstRecordAsHeader()
        )
        val measurements: Sequence<Measurement> = parser
            .asSequence()
            .map { record ->
                Measurement(
                    t = record["time"]!!.toDouble(),
                    x = record["x"]!!.toDouble(),
                    y = record["y"]!!.toDouble(),
                )
            }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
----
// end-insert

It too has a static function entry point, `CSVParser.parse`, which also takes configuration about the table format (in this case `CSVFormat.DEFAULT`, in ours `splitOnComma`).
The Commons `parse` takes a `Reader` though, rather than a `Sequence<String>`.
This allows it to handle newlines in the middle of fields, but leads to a proliferation of `parse` methods - there are variants taking `Path`, `File`, `InputStream`, `String` and `URL`.
We suspect that the developers felt these were necessary because Java provides little support for converting between these types of sources and disposing of them safely.
The `CSVParser` returned by the `parse` static method has a lot of code to manage resources that our API delegates to the workings of `Sequence` and Kotlin lifecycle functions like `use` and `useLines`.

On the subject of lines, you have to read between them in the code example to see it, but `CSVParser` implements `<Iterable<CSVRecord>>`.
This is a clever design choice, as it allows Java developers to use `for` to loop over the records, or Kotlin developers to convert to a `Sequence` with `.asSequence`.
Actually the Kotlin usability is due to the design of the Kotlin standard library building on the same `Iterable` abstraction that the Apache developers also alighted on.

Moving on, the code to create an individual `Measurement` looks identical in both examples:
// begin-insert: tags/table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt#map
[source,kotlin]
----
.map { record ->
    Measurement(
        t = record["time"]!!.toDouble(),
        x = record["x"]!!.toDouble(),
        y = record["y"]!!.toDouble(),
    )
}
----
// end-insert

While with our parser the type of `record` is <Map<String, String>>, in the Commons case it is `CSVRecord`.
`CSVRecord` has a `get(String)` method, which is how `record["time"]` etc are resolved.
It also has methods `get(int)` to retrieve a field by index, where we could use `Map.values[Int]`;
`size()` rather than `Map.size()`, and `isSet(String)` where `Map.hasKey(String)` would do.
Basically `CSVRecord` is having to reproduce the `Map` interface by hand, rather than just _being_ a `Map`.
Why?
Because, as we discussed in <<java-to-kotlin-collections>>, the Java `Map` interface is mutable, and mutation makes no sense in the context of reading fields from a file - mutations certainly aren't going to be written back to the file.
When programming in Java we find ourselves having to create new types to solve problems, where in Kotlin we can express operations in standard types and enjoy the richness of the Kotlin API on those types.

One area in which the Commons library Excels, is its provision of ready-made parser defaults.
These are expressed as constants in the `CSVFormat` class - we've seen `CSVFormat.DEFAULT`, but there are many others, including `CSVFormat.EXCEL`.
Armed with a `CSVFormat` you can pass it to the `CSVParser.parse` method as we saw, or use it directly, for example `CSVFormat.EXCEL.parse(reader)`.
Can we provide this facility without defining new types?
How about:

// begin-insert: tags/table-reader.54:src/test/java/travelator/tablereader/CsvExampleTests.kt#extension
[source,kotlin]
----
@Test
fun example2() {
    reader.use { reader ->
        val measurements = splitOnComma.readTableWithHeader(reader)
            .map { record ->
                Measurement(
                    t = record["time"]!!.toDouble(),
                    x = record["x"]!!.toDouble(),
                    y = record["y"]!!.toDouble(),
                )
            }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
----
// end-insert

Here `splitOnComma.readTableWithHeader(reader)` is invoking an extension function on the function type:

// begin-insert: tags/table-reader.54:src/main/java/travelator/tablereader/table-reading.kt#extension
[source,kotlin]
----
fun ((String) -> List<String>).readTableWithHeader(
    reader: StringReader
): Sequence<Map<String, String>> =
    readTableWithHeader(reader.buffered().lineSequence(), this)
----
// end-insert

In reality, `CSVFormat` represents a whole package of strategies for escaping rules, what to do with blank lines etc, not just how to split a line.
When our parser grows these facilities, then we will probably want to create a data class to collect them.
Until that point, it is truly impressive how much progress we have been able to make using just the built-in types.

There is one particular feature that the Commons interface provides that ours doesn't, and that we will want to add a type to implement.
Commons CSV has `CSVParser.getHeaderNames` to provide access to the header information.
Can we add this facility without modifying our current API?

For many inputs we could just call `Map.keys` on the first of the output `Sequence`, but this won't work if the table has no rows, only a header.
In order to return header information _and_ the parsed records we could return a `Pair<List<String>, Sequence<Map<String, String>>`, but this will force our current clients to discard the first of the pair.
Instead, we can return a type that implements `Sequence<Map<String, String>>`, but also has a header property.
We'll spare the reader the refactoring steps, but this way all our current callers remain unchanged, but we can access `headers` when required:

// begin-insert: tags/table-reader.55:src/test/java/travelator/tablereader/TableReaderTests.kt#excerpt
[source,kotlin]
----
@Test
fun `Table contains headers`() {
    val result: Table = readTableWithHeader(
        listOf(
            "H0,H1",
            "field0,field1"
        ).asSequence()
    )
    assertEquals(
        listOf("H0", "H1"),
        result.headers
    )
}

@Test
fun `Table contains empty headers for empty input`() {
    assertEquals(
        emptyList<String>(),
        readTableWithHeader(emptySequence()).headers
    )
}
----
// end-insert

Here is the implementation:

// begin-insert: tags/table-reader.55:src/main/java/travelator/tablereader/table-reading.kt#excerpt
[source,kotlin]
----
class Table(
    val headers: List<String>,
    val records: Sequence<Map<String, String>>
) : Sequence<Map<String, String>> by records

fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Table =
    lines.destruct()?.let { (first, rest) ->
        tableOf(splitter, first, rest)
    } ?: Table(emptyList(), emptySequence())

private fun tableOf(
    splitter: (String) -> List<String>,
    first: String,
    rest: Sequence<String>
): Table {
    val headers = splitter(first)
    val sequence = readTable(
        rest,
        headerProviderFrom(headers),
        splitter
    )
    return Table(headers, sequence)
}
----
// end-insert

=== Conclusion

TODO