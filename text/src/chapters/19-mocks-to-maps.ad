[[mocks-to-maps]]
== Mocks to Maps

Mocks are a common technique to decouple object-oriented code from its production dependencies. Are there better solutions available in Kotlin?

This is a short bonus chapter, following on from <<interfaces-to-functions>>.
In that chapter we saw that the tests used mocking because they had to implement two multi-method interfaces, even though most of those methods were not used.
We left the refactoring there having replaced dependencies on multi-method  interfaces with a dependency on just the two operations that were actually required to perform the task. The tests though, still mock the whole interface, and then pass a reference to the required methods to the subject under test (`Recommendations`).

// begin-insert: tags/interfaces-to-functions-2.11:src/test/java/travelator/recommendations/RecommendationsTests.java#setup
[source,java]
----
public class RecommendationsTests {

    private final DistanceCalculator distanceCalculator =
        mock(DistanceCalculator.class);
    private final FeaturedDestinations featuredDestinations =
        mock(FeaturedDestinations.class);
    private final Recommendations recommendations = new Recommendations(
        featuredDestinations::findCloseTo,
        distanceCalculator::distanceInMetersBetween
    );
    ...
}
----
// end-insert

The tests abstract the mocking behind methods `givenFeaturedDestinationsFor` and `givenADistanceBetween`:

// begin-insert: tags/interfaces-to-functions-2.11:src/test/java/travelator/recommendations/RecommendationsTests.java#returns_recommendations_for_single_location
[source,java]
----
@Test
public void returns_recommendations_for_single_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000)
        ),
        recommendations.recommendationsFor(Set.of(paris))
    );
}
----
// end-insert

Here is the implementation of `givenADistanceBetween`:

// begin-insert: tags/interfaces-to-functions-2.11:src/test/java/travelator/recommendations/RecommendationsTests.java#givenADistanceBetween
[source,java]
----
private void givenADistanceBetween(
    Location l1,
    FeaturedDestination l2,
    int result
) {
    when(distanceCalculator.distanceInMetersBetween(l1, l2.getLocation()))
        .thenReturn(result);
}
----
// end-insert

Nat is keen to point out that the mocks that he and Steve Freeman wrote about (<<FP_GOOSGBT_2009,_Growing Object-Oriented Software Guided By Tests_>>) were never supposed to be used to implement query functionality like `findCloseTo` and `distanceInMetersBetween`, but only to abstract methods that change state.
Duncan doesn't remember noticing that, and is personally not against using mocks in this way, as they are still a nice way to specify what we expect of collaborators when practicing outside-in TDD, whether reading-from or writing-to.
In the end, maybe it doesn't matter, because in both of our experiences, most Java codebases have mocks that are used in this way, and most Kotlin codebases would be better off without them.

For now though, we are still mocking, but our refactoring has resulted in our passing narrow interfaces (the function types) to the code under test.
Now that we don't need to implement uncalled methods, do we still need the mocks?
Let's see where that takes us.

=== Replacing Mocks With Maps

Before we go on, we'll convert the tests to Kotlin, as it has better support for function types.
We could stay in Java, but then we would have to work out which of the Java function types (`Function`, `BiFunction` etc) expresses the operations, and we'd still have Java.

The automated conversion is quite smooth, although for some reason the converter created lambdas rather than using method references in the `Recommendations` constructor call that we have to replace by hand, leaving the setup as:

// begin-insert: tags/interfaces-to-functions-2.12:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
[source,kotlin]
----
class RecommendationsTests {
    private val distanceCalculator = mock(DistanceCalculator::class.java)
    private val featuredDestinations = mock(FeaturedDestinations::class.java)

    private val recommendations = Recommendations(
        featuredDestinations::findCloseTo,
        distanceCalculator::distanceInMetersBetween
    )
    ...
----
// end-insert

We could use Kotlin reified types to avoid those `::class.java` arguments, but we're moving away from mocks, not towards them, so we resist.

`when` is a keyword in Kotlin, but the converter is smart enough to quote it where required:

// begin-insert: tags/interfaces-to-functions-2.12:src/test/java/travelator/recommendations/RecommendationsTests.kt#when
[source,kotlin]
----
private fun givenFeaturedDestinationsFor(
    location: Location,
    result: List<FeaturedDestination>
) {
    Mockito.`when`(featuredDestinations.findCloseTo(location))
        .thenReturn(result)
}
----
// end-insert

To see how to remove the mocking, it helps to view a function type as a mapping between its input parameters (as a tuple) and its result.
So `destinationFinder` is a mapping between a single `Location` and a `List<FeaturedDestination>.
`distanceInMetersBetween` is a mapping between `Pair<Location, Location>` and `Int`.
++Map++s are our way of expressing a set of mappings, the name isn't accidental after all.
So we can fake a function by populating a `Map` with parameter keys and result values and replacing the function call with a lookup of the supplied parameters.
You may have used this trick to cache the result of expensive calculations.
Here, we won't cache, but seed the `Map` with the parameters and result that we expect to see.

Taking the `destinationFinder` case first, we'll create a property to hold the `Map` - `featuredDestinations`:

// begin-insert: tags/interfaces-to-functions-2.14:src/test/java/travelator/recommendations/RecommendationsTests.kt#featuredDestinations
[source,kotlin]
----
private val featuredDestinations =
    mutableMapOf<Location, List<FeaturedDestination>>()
        .withDefault { emptyList() }
----
// end-insert

`givenFeaturedDestinationsFor` can populate the `destinationLookup` Map` rather than setting expectations on a mock:

// begin-insert: tags/interfaces-to-functions-2.14:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenFeaturedDestinationsFor
[source,kotlin]
----
private fun givenFeaturedDestinationsFor(
    location: Location,
    destinations: List<FeaturedDestination>
) {
    featuredDestinations[location] = destinations.toList()
}
----
// end-insert

If we make `Recommendations` read out of `featuredDestinations` we have passing tests:

// begin-insert: tags/interfaces-to-functions-2.14:src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations
[source,kotlin]
----
private val recommendations =
    Recommendations(
        featuredDestinations::getValue,
        distanceCalculator::distanceInMetersBetween
    )
----
// end-insert

`getValue` is an extension on `Map` that respects the defaults set up by the `Map.withDefault`, and hence does not return `null`.

It won't surprise you when we do the same for `distanceInMetersBetween`, removing all trace of the formal mocking:

// begin-insert: tags/interfaces-to-functions-2.15:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
[source,kotlin]
----
class RecommendationsTests {

    private val featuredDestinations =
        mutableMapOf<Location, List<FeaturedDestination>>()
            .withDefault { emptyList() }
    private val distanceInMetersBetween =
        mutableMapOf<Pair<Location, Location>, Int>()
            .withDefault { -1 }

    private val recommendations =
        Recommendations(
            featuredDestinations::getValue,
            { l1, l2 -> distanceInMetersBetween.getValue(l1 to l2) }
        )
    ...
}
----
// end-insert

// begin-insert: tags/interfaces-to-functions-2.15:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenADistanceFrom
[source,kotlin]
----
private fun givenADistanceFrom(
    location: Location,
    destination: FeaturedDestination,
    distanceInMeters: Int
) {
    distanceInMetersBetween[location to destination.location] =
        distanceInMeters
}
----
// end-insert

It might take a couple of passes to see how that works, or let it go for now and come back to it if you need it.

Having to use a lambda rather than a method reference in the `Recommendations` constructor invocation is a bit irritating.
We can tidy that up with a local `getValue` extension function.
Did we mention how much we like extension functions?

// begin-insert: tags/interfaces-to-functions-2.16:src/test/java/travelator/recommendations/RecommendationsTests.kt#getValue
[source,kotlin]
----
class RecommendationsTests {

    private val featuredDestinations =
        mutableMapOf<Location, List<FeaturedDestination>>()
            .withDefault { emptyList() }
    private val distanceInMetersBetween =
        mutableMapOf<Pair<Location, Location>, Int>()
            .withDefault { -1 }

    private val recommendations =
        Recommendations(
            featuredDestinations::getValue,
            distanceInMetersBetween::getValue
        )

    ...
}

private fun <K1, K2, V> Map<Pair<K1, K2>, V>.getValue(k1: K1, k2: K2) =
    getValue(k1 to k2)
----
// end-insert

Oh, and we can improve the readability of the test methods with some judicious parameter naming and helper methods.
Previously we had plain function calls:

// begin-insert: tags/interfaces-to-functions-2.16:src/test/java/travelator/recommendations/RecommendationsTests.kt#test2
[source,kotlin]
----
@Test
fun deduplicates_using_smallest_distance() {
    givenFeaturedDestinationsFor(
        alton,
        flowerFarm, watercressLine
    )
    givenFeaturedDestinationsFor(
        froyle,
        flowerFarm, watercressLine
    )
    givenADistanceFrom(alton, flowerFarm, 5300)
    givenADistanceFrom(alton, watercressLine, 320)
    givenADistanceFrom(froyle, flowerFarm, 0)
    givenADistanceFrom(froyle, watercressLine, 6300)
    assertEquals(
        listOf(
            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),
            FeaturedDestinationSuggestion(alton, watercressLine, 320)
        ),
        recommendations.recommendationsFor(setOf(alton, froyle))
    )
}
----
// end-insert

A little effort yields:

// begin-insert: tags/interfaces-to-functions-2.17:src/test/java/travelator/recommendations/RecommendationsTests.kt#sugar
[source,kotlin]
----
@Test
fun deduplicates_using_smallest_distance() {
    givenFeaturedDestinationsFor(alton, of(flowerFarm, watercressLine))
    givenADistanceFrom(alton, to = flowerFarm, of = 5300)
    givenADistanceFrom(alton, to = watercressLine, of = 320)

    givenFeaturedDestinationsFor(froyle, of(flowerFarm, watercressLine))
    givenADistanceFrom(froyle, to = flowerFarm, of = 0)
    givenADistanceFrom(froyle, to = watercressLine, of = 6300)

    assertEquals(
        listOf(
            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),
            FeaturedDestinationSuggestion(alton, watercressLine, 320)
        ),
        recommendations.recommendationsFor(setOf(alton, froyle))
    )
}
----
// end-insert

Sometimes a tiny method like `of` can go a long way to letting our brains just read code rather than spending effort interpreting it:

// begin-insert: tags/interfaces-to-functions-2.17:src/test/java/travelator/recommendations/RecommendationsTests.kt#of
[source,kotlin]
----
private fun of(vararg destination: FeaturedDestination)
    = destination.toList()
----
// end-insert

=== Have We Really Weaned Off Mocks Though?

Ah, now that is a good question!

In some ways we have just implemented a poor imitation of a mocking framework - we have no parameter matchers, no way of failing if a method isn't called, no way of expressing execution order.

Looked at another way though, we have implemented the recommendation engine's dependencies as two maps.
`Recommendations.recommendationsFor` is beginning to look like a simple calculation (<<calculations>>).
The result of that calculation depends on the `journey` parameter, and the contents of those maps that enable us to lookup featured destinations and distances.
We know that in reality _when_ we call `recommendationsFor` does matter - it is really an action (<<actions>>).
The distance between locations probably won't change over time, but which destinations we find around a location will, as we add or remove them from whatever database they are held in.
In our tests though, the distinction is moot, and we could treat `recommendationsFor` as a calculation, in much the same way as we saw with `InMemoryTrips` in <<actions-to-calculations>>.
Calculations are easier to test than actions - we just check that a given input returns a given output - so let's pull on this thread.

At the moment, _when_ we call `recommendationsFor` in the tests matters too, because the result will depend on the contents of the `featuredDestinations` and `distanceInMetersBetween` maps.
These are initially empty, and are populated by calls to `givenFeaturedDestinationsFor` and `givenADistanceFrom` - that's a time-sensitivity right there.
What we need is some way to convert an action to a calculation, and we can do that by manipulating scope.
At the beginning of this chapter, we saw that we can view methods as functions with some of their arguments partially applied by capturing them as fields.
In tests, we can reverse this process - we can write a function that creates the object from its dependencies, once for each invocation.
If we call the populated object the subject of the tests, we can create it from the test state like this:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#subjectFor
[source,kotlin]
----
private fun subjectFor(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>
): Recommendations {
    val destinationsLookup = featuredDestinations.withDefault { emptyList() }
    val distanceLookup = distances.withDefault { -1 }
    return Recommendations(destinationsLookup::getValue, distanceLookup::getValue)
}
----
// end-insert

Here we create a new instance of `Recommendations` every call, so that it can capture immutable maps representing the rest of the data.

Now we can write a `resultFor` function that uses `subjectFor`:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#resultFor
[source,kotlin]
----
private fun resultFor(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>,
    locations: Set<Location>
): List<FeaturedDestinationSuggestion> {
    val subject = subjectFor(featuredDestinations, distances)
    return subject.recommendationsFor(locations)
}
----
// end-insert

Outside of the scope of the `resultFor` function there is no time-sensitivity - so it is effectively a calculation.

Now that we have a simple mapping of input to output, we can write simple tests that call it.
Each test can just specify the input parameters and check the result is as expected, with no need for state in the test at all.

Every test can then be of the form:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#check
[source,kotlin]
----
private fun check(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>,
    recommendationsFor: Set<Location>,
    shouldReturn: List<FeaturedDestinationSuggestion>
) {
    assertEquals(
        shouldReturn,
        resultFor(featuredDestinations, distances, recommendationsFor)
    )
}
----
// end-insert

This gives a pleasing simplicity to the previously confusing tests:

// begin-insert: tags/interfaces-to-functions-2.18:src/test/java/travelator/recommendations/RecommendationsTests.kt#excerpt
[source,kotlin]
----
class RecommendationsTests {
    companion object {
        val distances = mapOf(
            (paris to eiffelTower.location) to 5000,
            (paris to louvre.location) to 1000,
            (alton to flowerFarm.location) to 5300,
            (alton to watercressLine.location) to 320,
            (froyle to flowerFarm.location) to 0,
            (froyle to watercressLine.location) to 6300
        )
    }

    ...

    @Test
    fun returns_no_recommendations_when_no_featured() {
        check(
            featuredDestinations = emptyMap(),
            distances = distances,
            recommendationsFor = setOf(paris),
            shouldReturn = emptyList()
        )
    }

    ...

    @Test
    fun returns_recommendations_for_multi_location() {
        check(
            featuredDestinations = mapOf(
                paris to listOf(eiffelTower, louvre),
                alton to listOf(flowerFarm, watercressLine),
            ),
            distances = distances,
            recommendationsFor = setOf(paris, alton),
            shouldReturn = listOf(
                FeaturedDestinationSuggestion(alton, watercressLine, 320),
                FeaturedDestinationSuggestion(paris, louvre, 1000),
                FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
                FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
            )
        )
    }
    ...
}
----
// end-insert

It's instructive to compare this with an original test:

// begin-insert: tags/interfaces-to-functions-2.1:src/test/java/travelator/recommendations/RecommendationsTests.java#test1
[source,java]
----
@Test
public void returns_recommendations_for_multi_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    givenFeaturedDestinationsFor(alton,
        List.of(
            flowerFarm,
            watercressLine
        ));
    givenADistanceBetween(alton, flowerFarm, 5300);
    givenADistanceBetween(alton, watercressLine, 320);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(alton, watercressLine, 320),
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
        ),
        recommendations.recommendationsFor(Set.of(paris, alton))
    );
}
----
// end-insert

Admittedly this is broken up a bit by the `givenADistanceBetween` calls, but you can see how this refactoring has migrated our tests from woolly functions that may or may not have a common structure, to a clear testing of inputs against outputs.

=== Conclusions

Mocks have their place in software, and outside-in TDD can certainly improve our designs by allowing us to prototype how to distribute functionality between collaborating objects without having to commit to complete implementations.
However, they have a habit of masking design problems by allowing us to test designs expressed as object interactions that would be better seen as data flows.

In this example we've seen how focusing on data can simplify our tests, especially where we are only reading values.
In <<performing-io-to-passing-data>> we explore how we can apply this technique to writing as well.
