== Classes to Closures

We can hide encapsulate information in both functional and object-oriented programming paradigms.
OO encapsulation is very much the grain of Java, but things are a lot more fluid in Kotlin.
What advantages does functional encapsulation have, and how can the two interoperate in and between Java and Kotlin?

Imagine, if you can, that you need to send email from some code that you are writing.
Just that - not receive mail, or list sent messages - just fire and forget.

As users of this facility, we would like to call a function, passing it the information in the email.
So given a representation of an email

// begin-insert: src/main/kotlin/encapsulation/Email.kt
[source,kotlin]
----
data class Email(
    val to: String,
    val subject: String,
    val body: String
)
----
// end-insert

then we would like to invoke a function like

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#send
[source,kotlin]
----
fun send(email: Email) {
    TODO()
}
----
// end-insert

Of course when we come to implement this function, we discover that we need all sorts of other information to _actually_ send email.
Not information about the email itself, but rather configuration about how to send it.
Things like the sending email server's IP address, login details, other security credentials, timeouts, senders email address - all the things that your elderly relative doesn't know, but you need to set up their new computer.
Given the multitude of different email systems, in the end API's like https://javamail.java.net/nonav/docs/api/[JavaMail] basically punt and pass a whole dictionary, but for now, let's let 3 parameters stand in for the lot.

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#sendEmail
[source,kotlin]
----
fun sendEmail(
    email: Email,
    serverAddress: InetAddress,
    username: String,
    password: String
) {
    TODO()
}
----
// end-insert

As a client things have just gotten a lot less convenient.
Everywhere we want to send email has to know about this petty configuration - we'll be passing it around from the top to the bottom of the codebase.
Solving that problem by hiding the details in global variables works fine until we discover that every run of the unit test suite now is sending 5 emails!
There must be a better way of hiding these petty details.

=== Object-Oriented Encapsulation

Object-oriented languages have a ready-made solution to this problem - objects can encapsulate the data.

// begin-insert: src/main/kotlin/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
}
----
// end-insert

Now when we want to send email we need access to an EmailSender (rather than a static function).
But once we have one, instead of calling a function, we invoke a method, and we don't need to tell the method all the petty details because it already knows them - they are the fields of the object.

// begin-insert: src/main/kotlin/encapsulation/OO-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration

val sender: EmailSender = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message

fun sendDistress(sender: EmailSender) {
    sender.send(
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert
As a bonus, if we extract an interface

// begin-insert: src/main/kotlin/encapsulation/ISendEmail.kt
[source,kotlin]
----
interface ISendEmail {
    fun send(email: Email)
}
----
// end-insert

// begin-insert: src/main/kotlin/encapsulation/EmailSender.kt#impl
[source,kotlin]
----
class EmailSender(
        ...
) : ISendEmail {
    override fun send(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
}
----
// end-insert

we can configure the tests to use a mock or some other stub and not actually send emails.

Note that this is not implementation hiding so much as information hiding.
The static function hides the details of how to connect to a server and send email - here we are just hiding configuration.
Granted we can see that the OO approach could lead to `SmtpEmailSender` and `X400EmailSender` implementations, but we aren't at that stage yet.

Before we leave the object-oriented realm, it's worth noting that we don't have to (explicitly) create a class to implement `ISendEmail`, we can do it anonymously.

// begin-insert: src/main/kotlin/encapsulation/anonymous-class.kt#anon
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): ISendEmail =
    object : ISendEmail {
        override fun send(email: Email) = sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
----
// end-insert

Why might we want to do this?
Well in situations where we don't control all the clients of our code (we are publishing a library external to our organisation for example), then this gives us flexibility to change our implementation, safe in the knowledge that clients cannot be dependant on a specific implementation class.

Finally, note that in Kotlin 1.4, we can declare our `ISendEmail` interface as a `fun` interface (one with only one abstract method), and implement it with a lambda

// begin-insert: src/main/kotlin/encapsulation/anonymous-class.kt#anon2
[source,kotlin]
----
fun interface ISendEmail {
    fun send(email: Email)
}

fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
) = ISendEmail { email ->
    sendEmail(
        email,
        serverAddress,
        username,
        password
    )
}
----
// end-insert

=== Functional Encapsulation

Having seen how an OO programmer solves the problem of encapsulating pesky details so clients don't have to remember them, how would a functional programmer approach the same problem?

Remember that we're trying to get to a function with this signature

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#send
[source,kotlin]
----
fun send(email: Email) {
    TODO()
}
----
// end-insert

given an implementation that looks like this

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#sendEmail
[source,kotlin]
----
fun sendEmail(
    email: Email,
    serverAddress: InetAddress,
    username: String,
    password: String
) {
    TODO()
}
----
// end-insert

In functional terms, this is https://en.wikipedia.org/wiki/Partial_application[partial application] - fixing a number of arguments to a function to give a function with fewer arguments.
While some languages provide built-in support for this sort of thing, in Kotlin the easiest approach is to write a function to partially apply our configuration.

What we want is a function that takes the configuration, and returns a function that knows how to send a message.

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#createEmailSender0
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit { // <1>
    TODO()
}
----
// end-insert

<1> The return type of our function is itself a function, that takes an `Email` and returns `Unit`.

This is the functional analog of the OO case, where the `EmailSender` constructor is a function that 'returns' an object that knows how to send a message.

We can write this function in longhand first, by defining an inner function that captures the arguments it requires from the parent

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#createEmailSender1
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit {

    fun result(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
    return ::result
}
----
// end-insert

We can then make the result a lamba expression

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#createEmailSender2
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit {

    val result: (Email) -> Unit = { email ->
        sendEmail(email, serverAddress, username, password)
    }
    return result
}
----
// end-insert

before inlining all the stuff to leave this functional definition

// begin-insert: src/main/kotlin/encapsulation/encapsulation.kt#createEmailSender3
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit =
    { email ->
        sendEmail(email, serverAddress, username, password)
    }
----
// end-insert

We can read this as `createEmailSender` is a function that returns a lambda that calls `sendEmail` combining the lambda's single message argument with the configuration from `createEmailSender`.
We call this lambda a _closure_, as it closes-over values that it requires from it's enclosing context, capturing them for use later.

To use this function, we can create it in one place and invoke it in another, very much as we did with the object solution.

// begin-insert: src/main/kotlin/encapsulation/FP-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration

val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message

fun sendDistress(sender: (Email) -> Unit) {
    sender.invoke( // <1>
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert

<1> We could of course elide the `invoke` here, but we're leaving it for comparison.

In the unlikely event that you're joining us from JavaScript, or Clojure, the functional form will be much more familiar.
But if you came to Kotlin from Java, this solution probably feels quite alien.

=== What About Java Then?

Both the object and functional forms have allowed us to encapsulate things (in this case configuration, but it could equally well have been collaborators)
to transport them from the place where they are known to the place where they are used.
Any data-structure could have done that, but because the object and the function both have an operation that can be run (`send` and `invoke` respectively), the client can remain oblivious to the details of the collaborators and just pass the information that it uniquely knows.

One way of unifying the functional and OO solutions is to view a function as a object with a single `invoke` method.
This is exactly what Java 8 did when it introduced lambdas.
Instead of creating a syntax for function types, Java uses interfaces with a _Single Abstract Method_ (SAM) with the desired signature.
Expressed in Java, our functional solution is

// begin-insert: src/main/kotlin/encapsulation/FPUsage.java#foo
[source,java]
----
// Where we know the configuration

Consumer<Email> sender = createEmailSender(
    inetAddress("example.com"),
    "username",
    "password"
);

// Where we send the message

public static void sendDistress(Consumer<Email> sender) {
    sender.accept( // <1>
        new Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    );
}
----
// end-insert

<1> Accept is the name of the single abstract method on the `Consumer` interface.

`createEmailSender` can be implemented with a lambda

// begin-insert: src/main/kotlin/encapsulation/FPUsage.java#FPUsageLambda
[source,java]
----
static Consumer<Email> createEmailSender(
    InetAddress serverAddress,
    String username,
    String password
) {
    return email -> sendEmail(email, serverAddress, username, password);
}
----
// end-insert

but this is equivalent to creating an anonymous implementation of the interface, a technique that will be very familiar to those of us who programmed in Java before Java 8.

// begin-insert: src/main/kotlin/encapsulation/FPUsage.java#FPUsageLongHand
[source,java]
----
static Consumer<Email> createEmailSender(
    InetAddress serverAddress,
    String username,
    String password
) {
    return new Consumer<Email>() {
        @Override
        public void accept(Email email) {
            sendEmail(email, serverAddress, username, password);
        }
    };
}
----
// end-insert

It's worth noting at this point we can't assign the result of the Kotlin `createEmailSender` function to a variable of type `Consumer<Email>`.
This is because the Kotlin runtime has its own function types that it uses, and the compiler compiles `(Email) -> Unit` into `Function1<Email, Unit>`.
There are a whole series of Kotlin ``Function``N interfaces for the different numbers of parameters.
To get us used to their existence, IntelliJ helpfully introduces this function form rather than the `(P) -> R` syntax as the result of some automated refactorings in Kotlin.
Instead of these very generic interfaces, Java defines `Consumer`, `Supplier`, `Function`, `BiFunction`, `Predicate`, `DoublePredicate` etc.
These communicate their role well, but are forced on the language because of issues defining the generic type of `void` and efficiency concerns over boxing primitives.

In order to mix Java and Kotlin at this functional level then we are going to have to thunk sometimes.

// begin-insert: src/main/kotlin/encapsulation/thunking-consumer.kt#foo
[source,kotlin]
----
// Kotlin function type
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)
val consumer: Consumer<Email> = sender // Doesn't compile <1>

val consumer: Consumer<Email> = Consumer<Email> { email -> // <2>
    sender(email)
}

// Java method taking Consumer
sendDistress(sender) // <3>
----
// end-insert

<1> `Type mismatch. Required: Consumer<Email> Found:(Email) -> Unit`.
<2> We can convert with a lambda.
<3> Kotlin will convert parameters automatically.

=== Implementors and Clients

There are two sides to an abstraction, the client code that uses it, and the implementing code.
So far, both client and implementor have either been object-oriented (where fields carry the information), or functional (where a function closes over the information).
In the former we give the client an object that it can invoke a known method on, in the latter, the client has a function that it can invoke to send.
Can we unify these approaches, giving an OO implementation to a function-expecting client or vice versa?
Or, in Kotlin terms, can we convert `ISendEmail` to `(Email) -> Unit`, and the inverse.
Why yes we can.

Remember that in Java and Kotlin, function types are just interfaces.
Because of this `EmailSender` can implement the type `Consumer<Email>` or  (Email) -> Unit` respectively, by defining a method with the signature of the function type.

Here it is in Java

// begin-insert: src/main/kotlin/encapsulation/MixedUsage.java#consumer
[source,java]
----
public class EmailSender
    implements ISendEmail,
        Consumer<Email> // <1>
{
        ...
    @Override
    public void accept(Email email) { // <2>
        send(email);
    }

    @Override
    public void send(Email email) {
        sendEmail(email, serverAddress, username, password);
    }
}
----
// end-insert

<1> Declare
<2> Implement

and this is the Kotlin equivalent

// begin-insert: src/main/kotlin/encapsulation/EmailSender.kt#invoke
[source,kotlin]
----
class EmailSender(
        ...
) : ISendEmail,
    (Email) -> Unit // <1>
{
    override operator fun invoke(email: Email) = send(email) // <2>

    override fun send(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
}
----
// end-insert

<1> Declare
<2> Implement

If we do this then we can use our class-based sender in place of our functional one.
We'll stick with Kotlin now.

// begin-insert: src/main/kotlin/encapsulation/FP-usage.kt#bar
[source,kotlin]
----
// Where we know the configuration

val sender: (Email) -> Unit = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message

fun sendDistress(sender: (Email) -> Unit) {
    sender.invoke( // <1>
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert

Now our OO solution has become quite a bit more complicated in order to fit in with the FP approach.
This calls into question the usefulness of our `ISendEmail` interface.
We can see that it is equivalent to the function type `(Email) -> Unit` - all it does is give the name `send` to what happens when you invoke it.
Maybe we could just use the type `(Email) -> Unit` everywhere in place of `ISendEmail`?

If you think that might not be expressive enough, then maybe you aren't a functional programmer.
Luckily there is a middle ground - we can use a typealias to give a name to the functional type, thus communicating our intent.

// begin-insert: src/main/kotlin/encapsulation/EmailSender.kt#typealias
[source,kotlin]
----
typealias ISendEmailToo = (Email) -> Unit

class EmailSender(
        ...
) : ISendEmailToo {
    override fun invoke(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
}
----
// end-insert

Note that as the typealias is just an alias - it doesn't define a new type - you can write `ISendEmailToo` and `(Email) -> Unit` interchangeably, so that we don't have to retrofit `sendDistress` with typealias in order to make this change.

.Expressive Function Types
****
Once we have our head in the functional mindset, `(Email) -> Unit` may be expressive enough to tell us the role of the function, especially combined with a variable name of `sender`.
What can you do with an email that doesn't return a result⸮
Well if it doesn't return a result it must be an action, but deleting an email would also have a similar signature.
Objects have the advantage over functions that they get to name their methods (`send(email)` compared to `delete(email)`), at the expense of also having to name the type of the object or interface.

Kotlin has a feature that can help make function types more expressive - we can name the parameters.
So if it helps, we could write `(toSend: Email) -> Unit`.
It doesn't make a great difference here, but can be very useful in situations with parameters of the same type, for example `(username: String, password: String) -> Authentication`.
If we use this form, IntelliJ will even helpfully name the parameters when we implement the function with a lambda or a class.
****

There is another way of bridging the OO FP gap that doesn't involve making our classes implement function types - create a function reference at the point of invocation.
Given our old class-based solution:

// begin-insert: src/main/kotlin/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
}
----
// end-insert

we can convert an instance to a function type with a lambda

// begin-insert: src/main/kotlin/encapsulation/mixed-usage.kt#foo
[source,kotlin]
----
val instance = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)
val sender: (Email) -> Unit = { instance.send(it) }
----
// end-insert

or just pass a method reference

// begin-insert: src/main/kotlin/encapsulation/mixed-usage.kt#bar
[source,kotlin]
----
val sender: (Email) -> Unit = instance::send
----
// end-insert

Whilst we've shown these conversions in Kotlin, they also work in Java with a slightly different syntax.

Can we do the opposite - pass our functional sender into something that expects an `ISendEmail`?
This requires more ceremony, as we have to create an anonymous object implementing `ISendEmail` to perform the thunk.

// begin-insert: src/main/kotlin/encapsulation/OO-usage.kt#bar
[source,kotlin]
----
val function: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

val sender: ISendEmail = object: ISendEmail {
    override fun send(email: Email) {
        function(email)
    }
}
----
// end-insert

In Kotlin 1.4, we can again use a `fun interface` to remove some boilerplate

// begin-insert: src/main/kotlin/encapsulation/OO-usage.kt#baz
[source,kotlin]
----
fun interface ISendEmail {
    fun send(email: Email)
}

val sender = ISendEmail { function(it) }
----
// end-insert

=== Comparing the Approaches

Let's remind ourselves of the OO approach

First we define a type

// begin-insert: src/main/kotlin/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(email, serverAddress, username, password)
    }
}
----
// end-insert

then we create instances and call methods

// begin-insert: src/main/kotlin/encapsulation/OO-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration

val sender: EmailSender = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message

fun sendDistress(sender: EmailSender) {
    sender.send(
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert

In functional land we don't have to define a type, because `(Email) -> Unit` 'exists', so we can just say

// begin-insert: src/main/kotlin/encapsulation/FP-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration

val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message

fun sendDistress(sender: (Email) -> Unit) {
    sender.invoke( // <1>
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert

<1> with or without the `invoke`.

Clients using the object have to know to call the `send` method to send email, in contrast, clients using the function just have to invoke it, but they only know that the function sends email because it has been assigned the name `sender`, if that name got lost in the call hierarchy all bets are off.

The flipside of the OO clients having to know to call the `send` method is that we could package up a number of email-related operations into an `EmailSystem`, with methods like `send`, `list`, and `delete`, and pass all this functionality to clients, for them to choose which they need in which context.

// begin-insert: src/main/kotlin/encapsulation/EmailSystem.kt
[source,kotlin]
----
class EmailSystem(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email): Unit = TODO()

    fun delete(email: Email): Unit = TODO()

    fun list(): List<Email> = TODO()
}
----
// end-insert

To achieve this in the functional context would require either passing individual functions around, or some sort of map of name to function, maybe a class itself

// begin-insert: src/main/kotlin/encapsulation/fp-email-system.kt#foo
[source,kotlin]
----
class EmailSystem(
    val send: (Email) -> Unit,
    val delete: (Email) -> Unit,
    val list: () -> List<Email>
)
----
// end-insert

Clients with such an object could treat it very much like the class-based object

// begin-insert: src/main/kotlin/encapsulation/fp-email-system.kt#bar
[source,kotlin]
----
fun sendDistress(sender: EmailSystem) {
    sender.send(
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert

but this is not the same - instead of invoking a `send` method what is actually happening is that we are calling the `invoke` method on the `send` property.

// begin-insert: src/main/kotlin/encapsulation/fp-email-system.kt#baz
[source,kotlin]
----
fun sendDistress(sender: EmailSystem) {
    sender.send.invoke(
        Email("support@internationalrescue.org", "Travelator Customer Incident", "...")
    )
}
----
// end-insert

Here we have an example of code that reads the same, but generates very different, and fundamentally incompatible, bytecode.

=== OO or Functional?

Both the OO and functional approaches can achieve the same goals, and with similar levels of expressiveness.
Which should we choose?

Let's consider this from the context of the client code first.
Traditionally in Java the client would have depended on `EmailSystem` (or maybe its interface `IManageEmail`).
But if the client only needs to send email then a dependency on a function `val sender: (Email) -> Message` makes its needs clear, and saves providers of the dependency having to implement methods that it doesn't need.
In production code that is unlikely to be a problem, but test code in particular can often forgo complicated mocking if only a single function needs to be implemented.
If the client needs to send and list email, then maybe a dependency on two functions rather than the interface is better; or perhaps not, depending on the size of the interface, whether the relationship between the functions is clear without it, and how many other dependencies the client has.
At the point where the client requires 3 related operations then it feels like an interface (or in exceptional circumstances class) should be the default.

Assuming that we go down the interface route, where we should we define that interface?
The client can't define it, because the implementor will depend on the interface, and the client on the implementation, so that would lead to a circular dependency.
So it has to be defined either with the implementor, or in a separate location (package, JAR file) depended on by both implementor and client.
The later (an application of the Dependency Inversion Principle) is in theory preferable but in practice more work and often neglected.
The result is the client and implementation being coupled by the interface in ways which can make systems hard to reason with and refactor.

In contrast, our runtime defines all the function types, so they don't introduce a compile-time dependency between the client and an implementation.
This is another good reason for preferring function types at the client end of the relationship.

So until it becomes hard work, we should default to expressing our client's needs as function types.
Our implementation then can either be in terms of a function type, or an object thunked to the function type through method references or lambdas.
Its unlikely that our existing Java code takes the functional approach, and the compiler will generate anonymous classes to capture the parameters even if we do write a function returning a function, so we err on the side of the class approach by default.
In a class its easy to extract private methods as algorithms get more complex, and its easy to add public methods as we discover more ways that the client may want to interact.
These things are certainly possible in a functional implementation, but OO was designed to express the commonality and differences between types in a way that is harder if functions are your only abstraction.

TLDR;

The functional approach is a little more flexible while the OO approach is more explicit.

TODO - refactoring from classes to closures





