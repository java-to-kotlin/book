[[exceptions-to-errors]]
== Exceptions to Errors

You don't have to have programmed computers for long to discover that things go wrong...

...in _so many_ different ways.
In this part we'll look at the ways that software can fail.
We'll see how to write code that is able to cope with failure, and when it can't cope, is able to communicate the ways in which it can go wrong.
In the worked example we'll refactor exception-based error handling in Java into a more functional Kotlin style.

Early in their careers your authors tended to gloss over errors.
We often still do, at least early in a project.
As the system grows though, we learn how failures affect the application and start to add code to cope - at first piecemeal, later with some strategy informed by experience.
In this respect our error handling evolves in the same way as other aspects of our software design.
Sometimes we design up-front, making use of our experience of similar systems; other times we allow the writing of the software to teach us what it needs.

In the absence of a more deliberate strategy, most systems default to raising exceptions when something goes wrong, and catching and logging those exceptions at some outer level.
Command-line utilities will just exit in this case, hopefully having provided enough information for the user to correct the problem and try again.
A server app, or a GUI with an event-loop, will usually abort only the current interaction and get on with the next.

Often this is just a poor experience for our users, but sometimes the error will have corrupted the persistent state of the system, so that correcting the initial problem and retrying does not work.
This is the source of the often good advice to "turn it off and on again" - our systems mainly start in a safe state - so that after a restart a retry should succeed.
If not; well you've probably been in a situation where the only solution has been to reinstall the operating system - the ultimate way of removing corrupted persistent state.

.Rebooting the Internet
****
Duncan had a problem where the integration between his Nest thermostat and IfThisThenThat was not working.
IFTTT was receiving notifications when the Nest entered home mode, but not away mode.
The great AWS outage of 28th February 2017 mysteriously fixed the problem - it turns out that all it required was a reboot of the Internet.
****

If errors are not well managed and the system becomes successful, diagnosing and fixing corruption due to errors can expand to fill all the team's time.
This is not a great place for a software project to be - ask us how we know!

So we don't want errors because they annoy our users and may result in corruption that takes a lot of effort to fix, if we can fix it at all.
What sort of errors do we see?

Programs can go wrong for many reasons.
When we say _program_ we also mean functions, methods, procedures - any code that we invoke.
And when we say _go wrong_, we mean fail to do the job that we expected them to do.

Reasons for this failure include

* Sometimes programs need to talk to other systems and that communication fails in some way.
* Often we don’t give software the correct input it needs to do its job.
* We have heard of programmers making errors.
Apparently they instruct their computers to dereference null pointers or read past the ends of collections!
* The environment that we are running in fails for some reason, for example it might run out of memory, or not be able to load a class.

There are failures that don’t fit into these categories, but they cover the most common cases.

That doesn't seem to be too long a list, and yet as an industry we don't have a great reputation for reliability.
Error handling just seems to be hard, why is that?

Well for a start we often don't know that an operation could fail, and in what ways.
If we do know whether and how, knowledge of what to do about it may be in code a long way from where we detect the error.
The code that detects an error, and the code that recovers from it, are hard to isolate from the happy path and so hard to test.
Combine these with the tendency for errors to leave our system in unrecoverable states, and we end up with a situation where most developers would rather hope for the best rather than take on the hard work and still get it wrong.

Hard work _and_ error-prone?
Weren't computers supposed to free us from tasks like these, taking on the drudge work, so that we can focus on the fun creative stuff?
Yes they were, so our focus on error handling will be through the lens of how our programming language can make things safer and easier for programmers.

=== Error Handling Before Exceptions

Most error handling these days is based on exceptions, but other techniques have been used, and are still applicable in some circumstances.
We'll look at the pros and cons of those techniques first.
The cons will show us why exceptions now dominate, the pros may give us options when exceptions aren't appropriate.

==== Ignoring Errors

We can ignore errors - either the failing routine does nothing to bring them to the attention of the caller, or the caller doesn't bother to check.

This may lead to corruption of persistent data and silent failure to do the job - in most cases we need to aim higher.

==== Just Crashing

Some programs just exit when an error is detected.

Combined with a supervisor to restart on error and careful coding to prevent corruption of persistent state, this is a battle-tested strategy that may be appropriate.
Throwing an exception and aborting an operation can be seen as the application of this technique to a procedure rather than a whole program.

==== Returning a Special Value

Returning a special value to signify an error can be a useful technique.
For example, returning `-1` instead of an index when an item is not found in a list.

This technique can only be used when not all of the range of return values are valid results for a function.
It can also be dangerous, because the caller has to know (and remember) the convention.
If we try to calculate the distance between two items in a list by subtracting their indices, when one of them is not found and returns -1, our calculation will be incorrect unless we explicitly handle the special case.
We are not able to lean on the type checker to help us avoid errors.

A special case of returning a special value is returning null on error.
This is quite dangerous in most languages, because if the caller doesn't explicitly check for null, then using the result will throw a `NullPointerException`, which may be worse than the initial problem.
In Kotlin though, the type-checker forces callers to deal with null - making this a safe and effective technique.

==== Setting a Global Flag

One problem with returning special values is that they make it hard to signal which of several possible errors occurred.
To solve this we can combine the special value with setting a global variable.
When the special value is detected the caller can read `errno` for example to establish what the problem was.

This technique was popular in C, but was largely superseded by exception-based error handling.

==== Returning a Status Code

Another technique from the days before exceptions is returning a status code.
This is possible when a function either returns no value (it is entirely side-effect), or returns a value in another way, often by mutating a parameter passed by reference.

==== Invoking a Special Function

Even when exceptions are available, invoking a special function when an error occurs is sometimes a good strategy.
Usually the function is passed as a parameter to the invoked function - if a problem is detected the error function is invoked with the issue as a parameter.
Sometimes the error function is able to signal by its return value if the failed operation should be retried or aborted.

This technique is an example of the strategy pattern applied to error handling.
Even when exceptions are available, it is a useful tool in niche situations.

ifdef::todos[]

==== Continuation Passing Style

Maybe mention this.
It bears comparison with folding over an error type.

endif::[]

=== Error Handling With Exceptions

All the above techniques suffer from the drawback that the calling code is able, to a greater or lesser extent, to ignore that an error occurred.

Exceptions solve this problem - the operation automatically aborts on error - and the caller explicitly handles the exception.
If the caller does not handle it, the exception propagates further up the call stack until someone does.
If no handler is found the application exits.

=== Java and Checked Exceptions

Exceptions were relatively new when Java was released, and the language designers decided to innovate in this area.
They included the exceptions that a function could throw as part of its signature.
This way callers could know that, for example, a method might fail because the network resource that it was reading was no longer available.
If a method declared that it could fail in this way, then every caller would either have to deal with the failure (by catching it) or declare that it, too, was liable to fail with the same exception.
This ensures that the programmer takes account of the possibility of these errors.
Such exceptions are called _checked exceptions_, because the compiler checks that they are handled (or redeclared to be thrown by the calling method).

Unavoidable problems like these are only some of the possible reasons for failure though.
The language designers identified two other types.

Errors::
Subclasses of java.lang.Error are reserved for failures so severe that the JVM can no longer guarantee the correct functioning of the runtime - maybe a class cannot be loaded or the system runs out of memory.
These conditions could happen at any point in the execution of a program, and so could cause any function to fail.
If any function could fail in this way there is little value in including such errors in the function signature, so `Errors` are exempted from this requirement.

RuntimeExceptions::
Subclasses of RuntimeException represent other errors.
The intention was that these would be reserved for problems caused by programmer mistakes, such as accessing a null reference, or trying to read outside the bounds of a collection.
In both these cases the programmer could have been more careful, but again this is potentially an issue for practically every piece of code, and so `RuntimeExceptions` are also exempted from having to be declared and handled.

Java's novel exception scheme forces developers to deal with operations that can fail due to IO or other things that are out of their control (the checked exceptions), allowing defensive programming where it is economical.
If an `Error` is thrown the best default approach is exit the process as quickly as possible, before any more damage can be done to persistent state.

`RuntimeExceptions` are a middle ground.
If they do represent a programmer error (as it appears was the original intention) then we should probably assume that we have just proved that we don't really know what is going on in our program and abort.
Otherwise we might try to recover, especially if our system has been designed to limit the damage that can be done to persistent state.

Your authors both really liked checked exceptions, but it seems we were in the minority, as they fell out of favour in Java over the years.
They were hampered from the start by the odd decision to make the unchecked `RuntimeException`
a subclass of the otherwise checked `Exception`, so that code that wanted to handle all checked exceptions found itself catching unchecked ones as well, hiding programming errors.
They were also not helped by the fact that the Java APIs used them inconsistently.
Take extracting data from a string for example - the `URL` constructor `URL(String)` throws the _checked_ `MalformedURLException`; while `Integer.parseInt(String)` throws the _unchecked_ `NumberFormatException`.

.How should `parseInt` fail?
****
This is an interesting case, and goes to the heart of why error handling is so hard.

Looking through our strategies,
`parseInt` can't return a special integer value, because all the ints are spoken for.
It could return null as a boxed `Integer`, but having to box and unbox for this, a really fundamental low-level operation that will be used in performance critical code, is undesirable, especially on the JVMs of the mid-1990s.

Invoking an error function would similarly involve inefficient ceremony, so we are left with throwing an exception.
Should that exception be checked or unchecked?

The language designers decided that
`parseInt` should throw `NumberFormatException`, and that `NumberFormatException`
should be an `IllegalArgumentException`, which is a `RuntimeException` and so unchecked.

Those are both reasonable decisions in isolation.
In combination though they lead to `parseInt` not forcing its callers to consider that it might fail by declaring a checked exception.

I suspect that the JVM programmers were very used to parsing ints from `char*` in C, where there were no exceptions, and `atoi` returned `0` if it didn't work.
They would have considered not planning for this failure to be a programmer error, rather than a failure of the function itself.

We will have more to say on the characterisation of errors later.
****

Confusion over what type of exception to use multiplied, and it wasn't long before the default was that the only checked exceptions that most Java libraries declared were `IOExceptions`.
Even then database libraries such as Hibernate, which were definitely talking over the network and definitely subject to `IOExceptions`, would throw only `RuntimeExceptions`.

Once a good proportion of the code that you call just uses unchecked exceptions the game is up.
You can't rely on checked exceptions to warn you about how a function might fail.
Instead you are reduced to some tactical defensive programming and the age-old technique of putting it into production, seeing what errors you log, and adding code to handle those you don't like the look of.

.What should Hibernate have thrown?
****
Where a programmer explicitly invoked a Hibernate method to load an object, that method should declare `IOException`.
If there are other ways that function could fail - maybe failure to parse a query - the method might also declare a checked exception to cover these.
So most Hibernate methods should declare both `IOException`
and a checked `HibernateException`, with the latter having different subclasses for different failure modes.

Hibernate is an interesting case though because of lazy loading.
If you load an object that contains a collection, Hibernate could be configured to load the contents of that collection only when it was accessed.
So calling `itinerary.getStops().size()` might go to the database.
But `Collection.size()` doesn't declare that it throws `IOException`, so what is Hibernate to do?

It must throw an unchecked exception, but should that be an `Error` or a `RuntimeException`?
Given that the JVM is almost certainly still perfectly serviceable, we are left with `RuntimeException`.
But in this case this is a `RuntimeException` that is not the result of programmer error, in as much as there is no defensive action that could have been taken to avoid it.

So perhaps Hibernate should have declared a checked `HibernateException`
and an unchecked `HibernateRuntimeException`?

ifdef::todos[]
Maybe an end-of-chapter piece with our discussion on this.
endif::[]
****

The final nail in the coffin of checked exceptions was the introduction of lambdas in Java 8. All the Function interfaces designed to work with streams did not declare an exception type, and so cannot propagate checked exceptions.
To be fair, your authors would probably have given up there too.

=== Kotlin and Exceptions

Kotlin has exceptions, because it runs on the JVM, and exceptions are built into that ecosystem.
It does not have checked exceptions, because Java had already lost that fight, and because they are hard to reconcile with the higher-order functions that are now common.
It is able to largely ignore checked exceptions because they are not a feature of the JVM, but rather of the Java compiler.
The compiler does record in the bytecode what checked exceptions a method declares (in order to be able to check them), but the JVM itself does not care.

The result is that Kotlin programs are by default no better or worse than most Java programs when it comes to error handling.

An exception (lower case `e`) to this is that, as we observed above, Kotlin can use null to indicate an error, safe in the knowledge that callers will have to write code to handle it.
An example of this is the provision of
`<T> Iterable<T>.firstOrNull(): T?` in the runtime.
Confusingly though the runtime also defines `first()`, which throws `NoSuchElementException` if the collection is empty.

=== Beyond Exceptions - Functional Error Handling

Statically-typed functional programming languages often reject exceptions in favour of another error handling technique based on sum-types - represented in Kotlin by sealed classes.
Why not just use exceptions?

Well a distinguishing feature of functional programming is _Referential Transparency_.
When this applies we can replace an expression with the result of its evaluation.
So if we write

[source,kotlin]
----
val secondsIn24hours = 60 * 60 * 24
----

then we can replace `60 * 60` with `3600` or `60 * 24` with `1440` without affecting the results.
In fact the compiler may decide to replace the whole expression with `86400` for us, and unless we examine the bytecode or use a debugger we will be none the wiser.

In contrast

[source,kotlin]
----
val dayLengthInHours = secondsIn(today()) / 60.0 / 60 / 24
----

is not referentially transparent, because `today()` will yield a different result than it did yesterday, and any day may have had a leap second applied.

Why should we care?
Because referential transparency makes it a lot easier to reason about the behaviour of a program, which in turn leads to fewer errors and more opportunities to refactor and optimise.
If we want these things (and at the very least we don't want more errors and fewer opportunities) then we should strive for referential transparency.

What does this have to with error handling?
Let's return to our `Integer.parseInt(String)` example and see.
For a given input, this will always return the same value, so it could be referentially transparent.
But, what for the cases where the `String` doesn't represent an integer?
We can't replace the result of the function invocation with an exception, because the type of the expression is `int`.
Exceptions break referential transparency.

If instead of using exceptions we returned to the old trick of using a special value to represent errors, then we would have referential transparency, because that error value can replace the expression.
In Kotlin,
`null` would be great here, but what if we needed to say which was the first character that wasn't a digit?
We can convey that information in an exception, but not in a return type of `Int?`.

Can we find a way for our function to return either the `Int`, or the way that it failed?

The answer, as they say, is in the question.
We define a type `Either`, which can hold one of two types, but only one at a time.

[source,kotlin]
----
sealed class Either<out L, out R>

data class Left<out L>(val l: L) : Either<L, Nothing>()

data class Right<out R>(val r: R) : Either<Nothing, R>()
----

When `Either` is used for error handling, the convention is that `Right` is used for a result,
`Left` for an error.

If we stick to this convention we could define

[source,kotlin]
----
fun parseInt(s: String): Either<String, Int> = try {
    Right(Integer.parseInt(s))
} catch (exception: Exception) {
    Left(exception.message ?: "No message")
}
----

How would we use this?
As it is a sealed class,
`when` expressions and smart casting work really nicely to let us write things like

[source,kotlin]
----
val result: Either<String, Int> = parseInt(readLine() ?: "")
when (result) {
    is Right -> println("Your number was ${result.r}")
    is Left -> println("I couldn't read your number because ${result.l}")
}
----

By returning an `Either` we force our clients to deal with the fact that we may have failed - in effect we have reproduced some of checked exceptions in a functional form.
To embrace this style you make all functions that might ordinarily throw an exception return `Either`, and when they in turn invoke something that could fail, pass on any failure or unwrap the success and act on it.

[source,kotlin]
----
fun doubleString(s: String): Either<String, Int> {
    val result: Either<String, Int> = parseInt(s)
    return when (result) {
        is Right -> Right(2 * result.r)
        is Left -> result
    }
}
----

Whilst using `when` to unwrap an `Either` is logical it is also verbose, and this particular pattern occurs so much that we define

[source,kotlin]
----
inline fun <L, R1, R2> Either<L, R1>.map(f: (R1) -> R2): Either<L, R2> =
    when (this) {
        is Right -> Right(f(this.r))
        is Left -> this
    }
----

which allows us to write the previous function as

[source,kotlin]
----
fun doubleString(s: String): Either<String, Int> = parseInt(s).map { 2 * it }
----

Why is that function called `map` and not `invokeUnlessLeft`?
Well if you squint you may be able to see that it is kind of the same thing as `List.map`.
Practice that squinting, because we are now going to define

[source,kotlin]
----
inline fun <L, R1, R2> Either<L, R1>.flatMap(f: (R1) -> Either<L, R2>): Either<L, R2> =
    when (this) {
        is Right -> f(this.r)
        is Left -> this
    }
----

This unpacks our value and uses it to invoke a function that in turn might fail (as it returns `Either`).
What can we do with that?
Well lets say we want to read from a `Reader`
and print double the result.

[source,kotlin]
----
fun BufferedReader.eitherReadLine(): Either<String, String> =
    try {
        val line = this.readLine()
        if (line == null)
            Left("No more lines")
        else
            Right(line)
    } catch (x: IOException) {
        Left(x.message ?: "No message")
    }


fun doubleNextLine(reader: BufferedReader): Either<String, Int> =
    reader.eitherReadLine().flatMap { doubleString(it) }
----

This code will return a `Left` with the failure if `eitherReadLine` fails, otherwise it will return the result of `doubleString`, which may itself be either a `Left` for failure, or a `Right` with the final `int` result.
In this way a chain of `map` and/or `flatMap` calls acts like a series of expressions which might throw an exception - the first failure aborts the rest of the computation.

If you come from an object oriented background this style does take some getting used to.
No amount of reading helps - you just have to knuckle down and start writing code this way until it becomes less strange.
Luckily we'll go through some of this pain together in the worked examples later.

=== Error Handling in Kotlin

Now that we know the error handling options open to us, which should we use in our Kotlin projects, and how do we migrate our Java code?

It depends of course.

Using nullable types to represent failure is very effective, provided that you don't need to convey any information about the reason for failure.

You won't be fired for using exceptions as your default strategy.
The lack of type-checking makes it hard to communicate what code is subject to what failure though, which in turn makes it hard to build reliable systems.
Adding insult to this injury, you will lose the benefits of referential transparency, making it harder to fix and refactor your unreliable system.

Our preference is to return an `Either` type from those operations that would have thrown a checked exception in Java, either because of IO problems, or because, like `parseInt`, they cannot give a result for all inputs.
`Errors` are still appropriate for unrecoverable program errors.
They should generally not be caught and the program should exit, with systems outside the JVM responsible for restarting it.
`RuntimeExceptions` are still good for signalling when we have made an error as programmers -
`IndexOutOfBounds` and the like.
If we have carefully designed our system it should be able to survive these issues and process other inputs that do not run into the same problem.

Which `Either` type should you choose?
The built-in Kotlin `Result` type is, at the time of writing, a frustrating placeholder which just teases and gets in the way.
It is designed just for coroutines implementation, is restricted to an `Exception` as its `Left` type, and IntelliJ moans if you use it as a return value or property type.
This would be reasonable if it wasn't published in the `Kotlin` package.
As it is, if you try to use a more useful type called `Result` you get strange error messages until you remember that, until you specifically import, the compiler is assuming you mean the one that you aren't supposed to use.

There are plenty of other `Result` types available, but for this book we will use Result4k, not coincidentally written by Nat.
Compared to the generic `Either` type we introduced earlier, Result4k defines `Result<SuccessType, FailureType>`, with subtypes `Success` and `Failure`
rather than the generic `Left` and `Right`.
As it is specialised for representing errors, Result4k can offer operations, such as `onFailure` and `recover`, that would not make sense on `Either`.
We'll see some more of its other operations in the next chapter.

=== Migrating Exceptions to Errors

Now that we know the error handling options available to us,
let's refactor some Java code to give us some practice.

There is an HTTP endpoint in Travelator that allows the client app to register a `Customer`.

// begin-insert: tags/errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java
[source,java]
----
public class CustomerRegistrationHandler {

    private final IRegisterCustomers registration;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomerRegistrationHandler(IRegisterCustomers registration) {
        this.registration = registration;
    }

    public Response handle(Request request) {
        try {
            RegistrationData data = objectMapper.readValue(
                request.getBody(),
                RegistrationData.class
            );
            Customer customer = registration.register(data);
            return new Response(HTTP_CREATED, objectMapper.writeValueAsString(customer));
        } catch (JsonProcessingException x) {
            return new Response(HTTP_BAD_REQUEST);
        } catch (ExcludedException x) {
            return new Response(HTTP_FORBIDDEN);
        } catch (DuplicateException x) {
            return new Response(HTTP_CONFLICT);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert


`CustomerRegistrationHandler`'s job is to extract data from the request body,
pass it to `registration` for processing,
and return a response with either a JSON representation of a `Customer`
or a suitable error status.

.HTTP
****
We'd rather not tie our example code to a particular Java HTTP framework,
so we have abstracted incoming calls behind a simple function that takes a `Request` and returns a `Response`.

ifdef::todos[]
Something about sending the correct status' being import in order to maintain correct HTTP systems
endif::[]
****

`CustomerRegistration` implements the business rules,
which is that potential customers should be vetted
against an `ExclusionList` of undesireables.

// begin-insert: tags/errors.0:src/main/java/travelator/CustomerRegistration.java
[source,java]
----
public class CustomerRegistration implements IRegisterCustomers {

    private final ExclusionList exclusionList;
    private final Customers customers;

    public CustomerRegistration(
        Customers customers,
        ExclusionList exclusionList
    ) {
        this.exclusionList = exclusionList;
        this.customers = customers;
    }

    public Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException {
        if (exclusionList.exclude(data)) {
            throw new ExcludedException();
        } else {
            return customers.add(data.name, data.email);
        }
    }
}
----
// end-insert

Note that as well as failing because of exclusion,
`register` can fail because `customers.add` can fail with a `DuplicateException`.
Here is the `Customers` interface.

// begin-insert: tags/errors.0:src/main/java/travelator/Customers.java
[source,java]
----
public interface Customers {

    Customer add(String name, String email) throws DuplicateException;

    Optional<Customer> find(String id);
}
----
// end-insert

Finally, `Customer` is another value type.
Here it is after conversion to Kotlin.

// begin-insert: tags/errors.1:src/main/java/travelator/Customer.kt
[source,kotlin]
----
data class Customer(
    val id: String,
    val name: String,
    val email: String
)
----
// end-insert

This is typical of the Java code that your authors would write.
It expresses the things that might reasonably go wrong as the checked
`ExcludedException` and `DuplicateException`,
and these are all caught at in the top-level `handle` where they are reported to the caller,
in this case as HTTP status codes.
Your style might be to use unchecked exceptions,
in which case this code would be similar
but without the exceptions
as part of the method signatures.

In addition to the checked exceptions,
every method can raise or pass on runtime exceptions.
In this case we might expect that failures to persist a `Customer`,
perhaps because of database communications issues,
would be raised as a runtime exception.

==== Our Conversion Strategy

If we were to just convert this code to Kotlin,
we would lose the advantages of checked exceptions to tell us
what could go wrong and show where we are handling those problems.
So as we convert we will replace exception-based
error handling with a functional alternative using Result4k.

In this example we'll start at the lowest level
and work our way up,
keeping higher levels working,
until the predictable error cases,
those that would have been expressed as checked exceptions,
no longer use exceptions.
At the same time we have to be mindful that pretty much any instruction in the JVM can fail,
so we need to defend against these cases.

==== Starting at the Bottom

If we convert `Customers` to Kotlin we get

// begin-insert: tags/errors.2:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {
    @Throws(DuplicateException::class) // <1>
    fun add(name: String?, email: String?): Customer?
    fun find(id: String?): Optional<Customer?>?
}
----
// end-insert

<1> Although Kotlin doesn't have checked exceptions, the `@Throws` annotation allows interoperation with Java code.
Without it, a Java implementation of `Customers` cannot override the method
(assuming that it does actually throw `DuplicateException`).
Worse, Java client code can't catch the exception
or declare that it is passed on,
as it is a compile error for Java code to handle a checked exception
that the compiler cannot see is possible.

Before we go further, conversion to Kotlin has failed to infer the nullability of the parameters and results in Customers,
lets fix that.

// begin-insert: tags/errors.3:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {
    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Customer /// |
    fun find(id: String): Optional<Customer>       /// |
}
----
// end-insert

What we're going to do for now is to add to our interface a version of `Customers.add` that instead of throwing an exception,
returns `Result<Customer, DuplicateException>`.

If we were starting from scratch we would probably not use an exception
the type of our error,
but here it lets us interoperate with Java easily.
We are going to keep the old throwy version around for now so that we don't break existing callers,
convert those callers to use the `Result` version,
then remove the old version when we can.

First we add Result4k to our build.

// begin-insert: tags/errors.4:build.gradle#result4k
[source,groovy]
----
dependencies {
     ...
    implementation "com.natpryce:result4k:2.0.0"
     ...
}
----
// end-insert

and then we can add a default method to thunk from the exception case to the result.
We can't call it `add` too, as both have the same parameters, so we call it `addToo` for now.

// begin-insert: tags/errors.5:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {
    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Customer

    @JvmDefault // <1>
    fun addToo(name:String, email:String)
        : Result<Customer, DuplicateException> =
        try {
            Success(add(name, email))
        } catch (x: DuplicateException) {
            Failure(x)
        }

    fun find(id: String): Optional<Customer>
}
----
// end-insert

<1> This annotation tells the compiler to generate Java-compatible default methods.
We wouldn't have had to do this had we left `Customers` in Java -
we live and learn.
You have to tell the compiler how to implement `@JVMDefault` with a compiler switch.

// begin-insert: tags/errors.5:build.gradle#foo
[source,groovy]
----
compileKotlin {
    kotlinOptions.jvmTarget = "1.8"
    kotlinOptions.freeCompilerArgs = ['-Xjvm-default=compatibility']
}
----
// end-insert

.Naming
****
It's a bit irritating that we can't name the new method `add` as well,
but the JVM won't allow methods that differ only on return type to have the same name.

If we can't think of a good name in these or other situations,
we err on the side of using a bad one.
In all likelihood we'll come up with a better name later,
and the bad name will reduce the risk that we settle for not-good-enough.

In this case it really shouldn't matter,
because we know that by the end of this refactor we will have deleted the original method,
and can steal its name once it is gone.
****

Now we have both exception and result versions of the method,
we can migrate the callers of the exception version.
While we can use Result4k from Java,
it's a lot more convenient from Kotlin.
So let's take `CustomerRegistration` (the caller of `add`)

// begin-insert: tags/errors.5:src/main/java/travelator/CustomerRegistration.java
[source,java]
----
public class CustomerRegistration implements IRegisterCustomers {

    private final ExclusionList exclusionList;
    private final Customers customers;

    public CustomerRegistration(
        Customers customers,
        ExclusionList exclusionList
    ) {
        this.exclusionList = exclusionList;
        this.customers = customers;
    }

    public Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException {
        if (exclusionList.exclude(data)) {
            throw new ExcludedException();
        } else {
            return customers.add(data.name, data.email);
        }
    }
}
----
// end-insert

and convert it to Kotlin

// begin-insert: tags/errors.6:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        return if (exclusionList.exclude(data)) {
            throw ExcludedException()
        } else {
            customers.add(data.name, data.email)
        }
    }

}
----
// end-insert

That `customers.add` expression is the one that can throw `DuplicateException`.
We're going to replace it with a call to `addToo`
but keeping the behaviour the same.
So we pull out `result` as a local

// begin-insert: tags/errors.7:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result = customers.add(data.name, data.email)
        result
    }
}
----
// end-insert

Now if we call `addToo` instead it will no longer throw,
but the exception will be returned in the Result.
This won't compile yet

// begin-insert: tags/errors.8:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> = customers.addToo(data.name, data.email)
        result // <1>
    }
}
----
// end-insert

<1> `Type mismatch. Required: Customer Found: Result<Customer, DuplicateException>`

Now in the case of failure,
we want to throw the `DuplicateException` in the `Result`
(in order to keep the current behaviour of `register`).
We can use `result.recover`,
which will give us the content of the `Failure` to throw

// begin-insert: tags/errors.9:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> = customers.addToo(data.name, data.email)
        result.recover { throw it }
    }
}
----
// end-insert

and now we can inline to get back to a shorter form

// begin-insert: tags/errors.10:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        customers.addToo(data.name, data.email).recover {
            throw it
        }
    }
}
----
// end-insert

Finally, that nesting looks a bit too confusing for comfort,
so lets simplify it with a guard clause,
even though it prevents our using the single-expression form.

// begin-insert: tags/errors.11:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    if (exclusionList.exclude(data))
        throw ExcludedException()
    return customers.addToo(data.name, data.email)
        .recover { throw it }
}
----
// end-insert

That is a good place for a rest,
having replaced one use of exceptions with a result type.

==== Broadening

OK, ready to go again? Good.

We now have to choose whether to proceed depth or breadth first.
Depth-first would address the caller of `CustomerRegistration.register`,
breadth-first would first fix up the other callers of `Customers.add`,
so that we can remove it.
As it happens our example code has no other callers of `add`,
so let's go that way.

While there is no other caller of `Customers.add`,
there are of course implementations.
Let's look at the (not thread-safe) test version.

// begin-insert: tags/errors.11:src/test/java/travelator/InMemoryCustomers.java
[source,java]
----
public class InMemoryCustomers implements Customers {

    private final List<Customer> list = new ArrayList<>();
    private int id = 0;

    @Override
    public Customer add(String name, String email) throws DuplicateException {
        if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
            throw new DuplicateException("customer with email " + email + " already exists");
        int newId = id++;
        Customer result = new Customer(Integer.toString(newId), name, email);
        list.add(result);
        return result;
    }

    @Override
    public Optional<Customer> find(String id) {
        return list.stream().filter(customer -> customer.getId().equals(id)).findFirst();
    }

    // for test
    public void add(Customer customer) {
        list.add(customer);
    }

    public int size() {
        return list.size();
    }
}
----
// end-insert

The easiest way to implement `addToo` here is probably just to duplicate `add`
and fix it up

// begin-insert: tags/errors.12:src/test/java/travelator/InMemoryCustomers.java#foo
[source,java]
----
@SuppressWarnings("unchecked")
@Override
public Result<Customer, DuplicateException> addToo(
    String name, String email
) {
    if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
        return new Failure<>(
            new DuplicateException("customer with email " + email + " already exists")
        );
    int newId = id++;
    Customer result = new Customer(Integer.toString(newId), name, email);
    list.add(result);
    return new Success<Customer>(result);
}
----
// end-insert

We can also use this strategy to add `addToo` to our production implementations of Customers.

If we still had any remaining callers of `add`
we could implement `add` by delegating to our new `addToo`,
but we don't.
So we can just remove it from here and the interface,
and then rename `addToo` to `add`,
leaving us with

// begin-insert: tags/errors.13:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
----
// end-insert

and

// begin-insert: tags/errors.13:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        if (exclusionList.exclude(data))
            throw ExcludedException()
        return customers.add(data.name, data.email)
            .recover { throw it }
    }
}
----
// end-insert

We left `InMemoryCustomers` as Java really just to demonstrate that we could return Result4k types from our old code,
but we can't resist the conversion,
as the code now has a number of warnings
of the type `Not annotated [X] overrides @NotNull [X]`.

After conversion we have

// begin-insert: tags/errors.14:src/test/java/travelator/InMemoryCustomers.kt
[source,kotlin]
----
class InMemoryCustomers : Customers {

    private val list: MutableList<Customer> = ArrayList()
    private var id = 0

    override fun add(name: String, email: String): Result<Customer, DuplicateException> =
        when {
            list.any { it.email == email } -> Failure(
                DuplicateException("customer with email $email already exists")
            )
            else -> {
                val result = Customer(id++.toString(), name, email)
                list.add(result)
                Success(result)
            }
        }

    override fun find(id: String): Optional<Customer> =
        list.firstOrNull { it.id == id }.toOptional()

    // for test
    fun add(customer: Customer) {
        list.add(customer)
    }

    fun size(): Int = list.size
}
----
// end-insert

Lets recap where we are now.
`Customers` is now Kotlin,
and `add` returns a `Result` instead of throwing `DuplicateException`.

// begin-insert: tags/errors.14:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
----
// end-insert

`IRegisterCustomers` is still Java, and still throws 2 types of exception.
// begin-insert: tags/errors.14:src/main/java/travelator/IRegisterCustomers.java
[source,java]
----
public interface IRegisterCustomers {
    Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException;
}
----
// end-insert

`CustomerRegistration` is now Kotlin, and is the place where we now thunk between
`Result.Error` and `DuplicateException`.

// begin-insert: tags/errors.14:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        if (exclusionList.exclude(data))
            throw ExcludedException()
        return customers.add(data.name, data.email)
            .recover { throw it }
    }
}
----
// end-insert

==== Stepping Out

Now we have converted a whole layer of our interaction to use a result type,
we move to the next.

If we are to follow the same pattern with `IRegisterCustomers` as we did with `Customers` -
provide a default implementation of an adapter between exception-throwing and error-returning -
we are going to have to address the issue of how to express
the result of a function that can fail because of one of two causes.
In code -
`Result<Customer, Either<ExcludedException, DuplicateException>>`.


We could reach for a generic `Either` type,
but that only gets us so far as a strategy.
For a start,
`Either<ExcludedException, DuplicateException>`
is not the same thing as `Either<DuplicateException, ExcludedException>`,
which is at best really confusing,
and will get even worse if we ever have to expand to `OneOf<ExcludedException, DuplicateException, SomeOtherProblem>`.
Instead,
our best bet here is not to try to express the error in terms of existing types,
but to map to a new type.

As _exception_ and _error_ are all overloaded terms,
we've chosen `RegistrationProblem`,
with subtypes of `Excluded`,
(which carries no additional information and so can be an object),
and `Duplicate`
(which carries any data from the original `DuplicateException`).
We use these when we add a default implementation of `registerToo` to the interface.

// begin-insert: tags/errors.15:src/main/java/travelator/IRegisterCustomers.kt
[source,kotlin]
----
interface IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    fun register(data: RegistrationData): Customer

    fun registerToo(data: RegistrationData): Result<Customer, RegistrationProblem> =
        try {
            Success(register(data))
        } catch (x: ExcludedException) {
            Failure(Excluded)
        } catch (x: DuplicateException) {
            Failure(Duplicate(x.message))
        }
}

sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
----
// end-insert

Now we can migrate callers of `register` to `registerToo`.
Starting with `CustomerRegistrationHandler`,
which we convert to Kotlin first.

// begin-insert: tags/errors.16:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt
[source,kotlin]
----
class CustomerRegistrationHandler(
    private val registration: IRegisterCustomers
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val customer = registration.register(data)
            Response(
                HTTP_CREATED,
                objectMapper.writeValueAsString(customer)
            )
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: ExcludedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}
----
// end-insert

Now call `registerToo` instead of `register` in the handler,
and interpret the return type with `when`

// begin-insert: tags/errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt
[source,kotlin]
----
class CustomerRegistrationHandler(
    private val registration: IRegisterCustomers
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val customerResult = registration.registerToo(data)
            when (customerResult) {
                is Success -> Response(
                    HTTP_CREATED,
                    objectMapper.writeValueAsString(customerResult)
                )
                is Failure -> customerResult.reason.toResponse()

            }
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: ExcludedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}

private fun RegistrationProblem.toResponse() = when (this) {
    is Duplicate -> Response(HTTP_CONFLICT)
    is Excluded -> Response(HTTP_FORBIDDEN)
}
----
// end-insert

before removing the unnecessary exception cases
and simplifying the error case
with `map` and `recover`.

// begin-insert: tags/errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt#foo
[source,kotlin]
----
fun handle(request: Request): Response =
    try {
        val data = objectMapper.readValue(
            request.body,
            RegistrationData::class.java
        )
        registration.registerToo(data)
            .map {
                Response(
                    HTTP_CREATED,
                    objectMapper.writeValueAsString(it)
                )
            }
            .recover { it.toResponse() }
    } catch (x: JsonProcessingException) {
        Response(HTTP_BAD_REQUEST)
    } catch (x: Exception) {
        Response(HTTP_INTERNAL_ERROR)
    }
----
// end-insert

Note that this code is not exception-free.
Firstly the `ObjectMapper` can still throw `JSONProcessingException`.
That is the reality of Java (and frankly most Kotlin) APIs,
but the code is safe and communicates well,
as the throwing and catching are in the same method.
Secondly we still have to consider other `RuntimeExceptions` that could be thrown from anywhere
(`NullPointerException` etc).
These could have crossed function boundaries and leaked up to here,
where the buck stops at the top-level catch-all.
The reality is that we can still have unexpected exceptions,
but the expected failure cases are now expressed by `Results`
and communicated in our code.

Now we can confess that the `RegistrationHandlerTests` got broken a few steps ago.
Ordinarily we would have fixed them straight away,
but that would have interrupted our explanation.

The problem is that the tests are mock tests which expect calls to `IRegister.register`,
but we are now calling `registerToo`. For example

// begin-insert: tags/errors.19:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java#foo
[source,java]
----
public class CustomerRegistrationHandlerTests {

    @RegisterExtension
    final Mockery mockery = new JUnit5ClassMockery();

    final IRegisterCustomers registration = mockery.mock(IRegisterCustomers.class);
    final CustomerRegistrationHandler handler = new CustomerRegistrationHandler(registration);

    final String fredBody = toJson("{ 'name' : 'fred', 'email' : 'fred@bedrock.com' }");
    final RegistrationData fredData = new RegistrationData("fred", "fred@bedrock.com");

    @Test
    public void returns_Created_with_body_on_success()
        throws DuplicateException, ExcludedException {

        mockery.checking(new Expectations() {{
            oneOf(registration).register(fredData);
            will(returnValue(new Customer("0", fredData.name, fredData.email)));
        }});

        String expectedBody = toJson(
            "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
        );
        assertEquals(
            new Response(HTTP_CREATED, expectedBody),
            handler.handle(new Request(fredBody))
        );
    }

    @Test
    public void returns_Conflict_for_duplicate()
        throws DuplicateException, ExcludedException {

        mockery.checking(new Expectations() {{
            oneOf(registration).register(fredData);
            will(throwException(new DuplicateException("deliberate")));
        }});

        assertEquals(
            new Response(HTTP_CONFLICT),
            handler.handle(new Request(fredBody))
        );
    }
    ...
    private String toJson(String jsonIsh) {
        return jsonIsh.replace('\'', '"');
    }
}
----
// end-insert

We can fix the wrong expectation,
and the return type,
in one edit.
Note that returning a error type has simplified our mock tests -
we can dispense with a special `throwException` action in favour of returning
`Success` or `Failure`.

// begin-insert: tags/errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java#foo
[source,java]
----
@Test
public void returns_Created_with_body_on_success() {
    mockery.checking(new Expectations() {{
        oneOf(registration).registerToo(fredData);
        will(returnValue(
            new Success<>(
                new Customer("0", fredData.name, fredData.email)))
        );
    }});

    String expectedBody = toJson(
        "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
    );
    assertEquals(
        new Response(HTTP_CREATED, expectedBody),
        handler.handle(new Request(fredBody))
    );
}

@Test
public void returns_Conflict_for_duplicate() {
    mockery.checking(new Expectations() {{
        oneOf(registration).registerToo(fredData);
        will(returnValue(
            new Failure<>(new Duplicate("deliberate")))
        );
    }});

    assertEquals(
        new Response(HTTP_CONFLICT),
        handler.handle(new Request(fredBody))
    );
}
----
// end-insert

At this point we can return to `CustomerRegistration`
and implement `registerToo` directly.
In lieu of any cleverer idea we do this by duplicating the `register` method
and fettling the error handling,
using `Result.mapFailure` to convert `DuplicateException` to `Duplicate`.

// begin-insert: tags/errors.21:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        if (exclusionList.exclude(data))
            throw ExcludedException()
        return customers.add(data.name, data.email)
            .recover { throw it }
    }

    override fun registerToo(data: RegistrationData): Result<Customer, RegistrationProblem> {
        if (exclusionList.exclude(data))
            return Failure(Excluded)
        return customers.add(data.name, data.email)
            .mapFailure { exception: DuplicateException -> // <1>
                Duplicate(exception.message)
            }
    }
}
----
// end-insert

<1> Note that we explicitly type the lambda parameter in `mapFailure`.
This way if we change the return type of `add` to have a different failure type
the compiler will force us to change how we handle it.

There are two problems with this.
Firstly, `registerToo` has no test code,
and secondly, we have the duplicate logic caused by our just copying the code.
We can fix both by implementing `register` in terms of `registerToo` -
the opposite of what we did in IRegister.

// begin-insert: tags/errors.22:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer =
        registerToo(data).recover { error ->
            when (error) {
                is Excluded -> throw ExcludedException()
                is Duplicate -> throw DuplicateException(error.message)
        }
    }

    override fun registerToo(data: RegistrationData): Result<Customer, RegistrationProblem> {
        if (exclusionList.exclude(data))
            return Failure(Excluded)
        return customers.add(data.name, data.email)
            .mapFailure { exception: DuplicateException -> // <1>
                Duplicate(exception.message)
            }
    }
}
----
// end-insert

Now our RegistrationTests, which work in terms of `register`, will be testing `registerToo` for us.

// begin-insert: tags/errors.22:src/test/java/travelator/CustomerRegistrationTests.java
[source,java]
----
public class CustomerRegistrationTests {

    InMemoryCustomers customers = new InMemoryCustomers();
    Set<String> excluded = Set.of(
        "cruella@hellhall.co.uk"
    );
    CustomerRegistration registration = new CustomerRegistration(customers,
        (registrationData) -> excluded.contains(registrationData.email)
    );

    @Test
    public void adds_a_customer_when_not_excluded()
        throws DuplicateException, ExcludedException {
        assertEquals(Optional.empty(), customers.find("0"));

        Customer added = registration.register(
            new RegistrationData("fred flintstone", "fred@bedrock.com")
        );
        assertEquals(
            new Customer("0", "fred flintstone", "fred@bedrock.com"),
            added
        );
        assertEquals(added, customers.find("0").orElseThrow());
    }

    @Test
    public void throws_DuplicateException_when_email_address_exists() {
        customers.add(new Customer("0", "fred flintstone", "fred@bedrock.com"));
        assertEquals(1, customers.size());

        assertThrows(DuplicateException.class,
            () -> registration.register(
                new RegistrationData("another name", "fred@bedrock.com")
            )
        );
        assertEquals(1, customers.size());
    }

    @Test
    public void throws_ExcludedException_when_excluded() {
        assertThrows(ExcludedException.class,
            () -> registration.register(
                new RegistrationData("cruella de vil", "cruella@hellhall.co.uk")
            )
        );
        assertEquals(0, customers.size());
    }
}
----
// end-insert

This would be a good way to keep both `register`
and `registerToo`
while we migrate away from Java and exceptions
to Kotlin and an error type.
In this case though the tests are actually the last callers of `register`,
so let's convert them to call `registerToo`.
We could take the time to show how to use Result4k in Java,
but your author for one is pretty tired of this refactoring now,
so we'll convert the tests to Kotlin and
then to call `register` with the immortal words,
"Here's one I made earlier".

// begin-insert: tags/errors.23:src/test/java/travelator/CustomerRegistrationTests.kt
[source,kotlin]
----
class CustomerRegistrationTests {

    private val customers = InMemoryCustomers()
    private val excluded = setOf("cruella@hellhall.co.uk")
    private val registration = CustomerRegistration(
        customers,
        ExclusionList { excluded.contains(it.email) }
    )

    @Test
    fun `adds a customer when not excluded`() {
        assertEquals(Optional.empty<Any>(), customers.find("0"))
        val added = registration.registerToo(
            RegistrationData("fred flintstone", "fred@bedrock.com")
        ).valueOrNull()
        assertEquals(
            Customer("0", "fred flintstone", "fred@bedrock.com"),
            added
        )
        assertEquals(added, customers.find("0").orElseThrow())
    }

    @Test
    fun `returns Duplicate when email address exists`() {
        customers.add(Customer("0", "fred flintstone", "fred@bedrock.com"))
        assertEquals(1, customers.size())
        val failure = registration.registerToo(
            RegistrationData("another name", "fred@bedrock.com")
        ).failureOrNull()
        assertEquals(
            Duplicate("customer with email fred@bedrock.com already exists"),
            failure
        )
        assertEquals(1, customers.size())
    }

    @Test
    fun `returns Excluded when excluded`() {
        val failure = registration.registerToo(
                RegistrationData("cruella de vil", "cruella@hellhall.co.uk")
        ).failureOrNull()
        assertEquals(
            Excluded,
            failure
        )
        assertEquals(0, customers.size())
    }
}
----
// end-insert

Now we have no callers of `register`,
we can finally remove it and rename `registerToo` to `register`,
ending up with exception-free Kotlin.

// begin-insert: tags/errors.24:src/main/java/travelator/IRegisterCustomers.kt
[source,kotlin]
----
interface IRegisterCustomers {
    fun register(data: RegistrationData): Result<Customer, RegistrationProblem>
}

sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
----
// end-insert

// begin-insert: tags/errors.24:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
----
// end-insert

Hmm, not quite exception-free because of that `DuplicateException`,
which is not thrown from anywhere anymore,
just created and
put into a `Failure`.
It's an easy fix to rename the class to `DuplicateCustomer`
and stop extending `Exception`,
or to reuse the existing `Duplicate` subclass of `RegistrationProblem`.
Which is better?
Well it is a little strange for `Customers.add`,
which is in our domain layer,
to use an error type from the business rules layer,
so we should probably keep them separate.
You can trust us to fix it without bothering you,
and we will have more to say about errors crossing contexts
in future chapters.

=== Conclusions

=== See Also










