[[mocks-to-maps]]
== Mocks to Maps

++++
<blockquote data-type="epigraph">
<p>Mocks are a common technique to decouple object-oriented code from its production dependencies.
Are better solutions available in Kotlin?</p>
</blockquote>
++++

This is a short bonus chapter, following on from <<interfaces-to-functions>>.
In that chapter, we saw that our tests used mocks because they had to implement two multimethod interfaces, even though most of those methods were not used.
We left the refactoring, having replaced dependencies on multimethod interfaces with a dependency on just the two operations that were actually required to perform the task.
The tests, though, still mock the whole interface, and then pass a reference to the required methods to the subject under test (`Recommendations`):

// begin-insert: interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java#setup
[source,java]
----
public class RecommendationsTests {

    private final DistanceCalculator distanceCalculator =
        mock(DistanceCalculator.class);
    private final FeaturedDestinations featuredDestinations =
        mock(FeaturedDestinations.class);
    private final Recommendations recommendations = new Recommendations(
        featuredDestinations::findCloseTo,
        distanceCalculator::distanceInMetersBetween
    );
    ...
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/interfaces-to-funs.7/src/test/java/travelator/recommendations/RecommendationsTests.java#setup">
        interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java#setup
    </a>
</div>
++++
// end-insert

The tests abstract the mocking behind methods `givenFeaturedDestinationsFor` and `givenADistanceBetween`:

// begin-insert: interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java#returns_recommendations_for_single_location
[source,java]
----
@Test
public void returns_recommendations_for_single_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000)
        ),
        recommendations.recommendationsFor(Set.of(paris))
    );
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/interfaces-to-funs.7/src/test/java/travelator/recommendations/RecommendationsTests.java#returns_recommendations_for_single_location">
        interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java#returns_recommendations_for_single_location
    </a>
</div>
++++
// end-insert

Here is the implementation of `givenADistanceBetween`:

// begin-insert: interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java#givenADistanceBetween
[source,java]
----
private void givenADistanceBetween(
    Location location,
    FeaturedDestination destination,
    int result
) {
    when(
        distanceCalculator.distanceInMetersBetween(
            location,
            destination.getLocation())
    ).thenReturn(result);
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/interfaces-to-funs.7/src/test/java/travelator/recommendations/RecommendationsTests.java#givenADistanceBetween">
        interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java#givenADistanceBetween
    </a>
</div>
++++
// end-insert

.Mock-Induced Test Damage
****
David Heinemeier Hansson coined the term https://oreil.ly/8vgJU[test-induced design damage] to refer to harm caused to systems in the name of testability.
In practice, your authors don't recognize this as much of a problem; we find that systems are usually _improved_ by the decoupling required to test them well.
We _do_ often see tests ruined by mocks though, so much so that mocking has fallen out of favour in our circles.

The problem is that, as well as implementing interfaces, mock frameworks allow us to specify the expected invocations of their methods and what should be returned in those cases.
Often, though, expected calls and their results don't make for a human-readable description, as we'll see if we look at the inlined version of the last expectations:

// begin-insert: interfaces-to-funs.1:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
when(featuredDestinations.findCloseTo(paris))
    .thenReturn(List.of(
        eiffelTower,
        louvre
    ));
when(distanceCalculator.distanceInMetersBetween(
    paris, eiffelTower.getLocation())
).thenReturn(5000);
when(distanceCalculator.distanceInMetersBetween(
    paris, louvre.getLocation())
).thenReturn(1000);

when(featuredDestinations.findCloseTo(alton))
    .thenReturn(List.of(
        flowerFarm,
        watercressLine
    ));
when(distanceCalculator.distanceInMetersBetween(
    alton, flowerFarm.getLocation())
).thenReturn(5300);
when(distanceCalculator.distanceInMetersBetween(
    alton, watercressLine.getLocation())
).thenReturn(320);
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/interfaces-to-funs.1/src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt">
        interfaces-to-funs.1:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
    </a>
</div>
++++
// end-insert

Defining methods like `givenADistanceBetween` allows us to express the relationship between the mock expectations and our test: they can hide the _how_ to expose the _why_.
In practice, though, very few developers take this step, leading to cryptic tests that are blamed on the use of mocking.
****

Nat is keen to point out that the mocks that he and Steve Freeman wrote about (<<FP_GOOSGBT_2009,_Growing Object-Oriented Software Guided by Tests_>>) were never supposed to be used to implement query functionality like `findCloseTo` and `distanceInMetersBetween`, but only methods that change state.
Duncan doesn't remember noticing that and is personally not against using mocks in this way, because they are still a nice way to specify what we expect of collaborators when practicing outside-in test-driven development, whether reading-from or writing-to.
In the end, maybe it doesn't matter, because in both of our experiences, most Java codebases have mocks that are used in this way, and most Kotlin codebases would be better off without them.

For now though, we are still mocking, but our previous refactoring has resulted in our passing narrow interfaces (the function types) to the code under test.
Now that we don't need to implement uncalled methods, do we still need the mocks?
Let's see where pulling that thread takes us.

=== Replacing Mocks with Maps

Before we go on, we'll convert the tests to Kotlin, because it has better support for function types.
We could stay in Java, but then we would have to work out which of the Java function types (`Function`, `BiFunction` etc) expresses the operations.
And we'd still have Java.

The automated conversion is quite smooth, although for some reason the converter created lambdas rather than using method references in the `Recommendations` constructor call that we have to replace by hand, leaving the setup as:

// begin-insert: mocks-to-maps.0:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
[source,kotlin]
----
class RecommendationsTests {
    private val distanceCalculator = mock(DistanceCalculator::class.java)
    private val featuredDestinations = mock(FeaturedDestinations::class.java)

    private val recommendations = Recommendations(
        featuredDestinations::findCloseTo,
        distanceCalculator::distanceInMetersBetween
    )
    ...
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.0/src/test/java/travelator/recommendations/RecommendationsTests.kt#setup">
        mocks-to-maps.0:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
    </a>
</div>
++++
// end-insert

We could use Kotlin reified types to avoid those `::class.java` arguments, but we're moving away from mocks, not toward them, so we resist.

The term `when` is a keyword in Kotlin, but the converter is smart enough to quote it where required:

// begin-insert: mocks-to-maps.0:src/test/java/travelator/recommendations/RecommendationsTests.kt#when
[source,kotlin]
----
private fun givenFeaturedDestinationsFor(
    location: Location,
    result: List<FeaturedDestination>
) {
    Mockito.`when`(featuredDestinations.findCloseTo(location))
        .thenReturn(result)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.0/src/test/java/travelator/recommendations/RecommendationsTests.kt#when">
        mocks-to-maps.0:src/test/java/travelator/recommendations/RecommendationsTests.kt#when
    </a>
</div>
++++
// end-insert

To see how to remove the mocking, it helps to view a function type as a mapping between its input parameters (as a tuple) and its result.
So `destinationFinder` is a mapping between a single `Location` and a `List<FeaturedDestination>`, and `distanceInMetersBetween` is a mapping between `Pair<Location, Location>` and `Int`.
The `Map` data structure is our way of expressing a set of mappingsâ€”the name isn't accidental.
So we can fake a function by populating a `Map` with parameter keys and result values, and replacing the function call with a lookup of the supplied parameters.
You may have used this trick to cache the result of expensive calculations.
Here, we won't cache, but seed the `Map` with the parameters and result that we expect to see.

Taking the `destinationFinder` case first, we'll create a property to hold the `Map`, `featuredDestinations`:

// begin-insert: mocks-to-maps.1:src/test/java/travelator/recommendations/RecommendationsTests.kt#featuredDestinations
[source,kotlin]
----
private val featuredDestinations =
    mutableMapOf<Location, List<FeaturedDestination>>()
        .withDefault { emptyList() }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.1/src/test/java/travelator/recommendations/RecommendationsTests.kt#featuredDestinations">
        mocks-to-maps.1:src/test/java/travelator/recommendations/RecommendationsTests.kt#featuredDestinations
    </a>
</div>
++++
// end-insert

`givenFeaturedDestinationsFor` can populate the `destinationLookup` `Map` rather than setting expectations on a mock:

// begin-insert: mocks-to-maps.1:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenFeaturedDestinationsFor
[source,kotlin]
----
private fun givenFeaturedDestinationsFor(
    location: Location,
    destinations: List<FeaturedDestination>
) {
    featuredDestinations[location] = destinations.toList()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.1/src/test/java/travelator/recommendations/RecommendationsTests.kt#givenFeaturedDestinationsFor">
        mocks-to-maps.1:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenFeaturedDestinationsFor
    </a>
</div>
++++
// end-insert

If we make `Recommendations` read out of the `featuredDestinations` `Map`, we have passing tests:

// begin-insert: mocks-to-maps.1:src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations
[source,kotlin]
----
private val recommendations =
    Recommendations(
        featuredDestinations::getValue,
        distanceCalculator::distanceInMetersBetween
    )
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.1/src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations">
        mocks-to-maps.1:src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations
    </a>
</div>
++++
// end-insert

`getValue` is an extension on `Map`.
It acts like `get` but respects the defaults set up by the `Map.withDefault` (in this case to return an `emptyList()`) and, hence, does not return a nullable result.

It won't surprise you when we do the same for `distanceInMetersBetween`, removing all our dependency on  Mockito:

// begin-insert: mocks-to-maps.2:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
[source,kotlin]
----
class RecommendationsTests {

    private val featuredDestinations =
        mutableMapOf<Location, List<FeaturedDestination>>()
            .withDefault { emptyList() }
    private val distanceInMetersBetween =
        mutableMapOf<Pair<Location, Location>, Int>()
            .withDefault { -1 }

    private val recommendations =
        Recommendations(
            featuredDestinations::getValue,
            { l1, l2 -> distanceInMetersBetween.getValue(l1 to l2) }
        )
    ...
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.2/src/test/java/travelator/recommendations/RecommendationsTests.kt#setup">
        mocks-to-maps.2:src/test/java/travelator/recommendations/RecommendationsTests.kt#setup
    </a>
</div>
++++
// end-insert

// begin-insert: mocks-to-maps.2:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenADistanceFrom
[source,kotlin]
----
private fun givenADistanceFrom(
    location: Location,
    destination: FeaturedDestination,
    distanceInMeters: Int
) {
    distanceInMetersBetween[location to destination.location] =
        distanceInMeters
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.2/src/test/java/travelator/recommendations/RecommendationsTests.kt#givenADistanceFrom">
        mocks-to-maps.2:src/test/java/travelator/recommendations/RecommendationsTests.kt#givenADistanceFrom
    </a>
</div>
++++
// end-insert

It might take a couple of passes to see how that works; these are the details that mocking frameworks hide for us.
You can safely ignore them and come back here if you ever execute this refactoring yourself.

Having to use a lambda rather than a method reference in the `Recommendations` constructor invocation is a bit irritating.
We can tidy that up with a local `getValue` extension function.
Did we mention how much we like extension functions?

// begin-insert: mocks-to-maps.3:src/test/java/travelator/recommendations/RecommendationsTests.kt#getValue
[source,kotlin]
----
private fun <K1, K2, V> Map<Pair<K1, K2>, V>.getValue(k1: K1, k2: K2) =
    getValue(k1 to k2)
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.3/src/test/java/travelator/recommendations/RecommendationsTests.kt#getValue">
        mocks-to-maps.3:src/test/java/travelator/recommendations/RecommendationsTests.kt#getValue
    </a>
</div>
++++
// end-insert

This lets us say:

// begin-insert: mocks-to-maps.3:src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations
[source,kotlin]
----
private val recommendations =
    Recommendations(
        featuredDestinations::getValue,
        distanceInMetersBetween::getValue
    )
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.3/src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations">
        mocks-to-maps.3:src/test/java/travelator/recommendations/RecommendationsTests.kt#recommendations
    </a>
</div>
++++
// end-insert

Oh, and we can improve the readability of the test methods with some judicious parameter naming and helper methods.
Previously, we had plain function calls:

// begin-insert: mocks-to-maps.3:src/test/java/travelator/recommendations/RecommendationsTests.kt#test2
[source,kotlin]
----
@Test
fun deduplicates_using_smallest_distance() {
    givenFeaturedDestinationsFor(
        alton,
        flowerFarm, watercressLine
    )
    givenFeaturedDestinationsFor(
        froyle,
        flowerFarm, watercressLine
    )
    givenADistanceFrom(alton, flowerFarm, 5300)
    givenADistanceFrom(alton, watercressLine, 320)
    givenADistanceFrom(froyle, flowerFarm, 0)
    givenADistanceFrom(froyle, watercressLine, 6300)
    assertEquals(
        listOf(
            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),
            FeaturedDestinationSuggestion(alton, watercressLine, 320)
        ),
        recommendations.recommendationsFor(setOf(alton, froyle))
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.3/src/test/java/travelator/recommendations/RecommendationsTests.kt#test2">
        mocks-to-maps.3:src/test/java/travelator/recommendations/RecommendationsTests.kt#test2
    </a>
</div>
++++
// end-insert

A little effort yields:

// begin-insert: mocks-to-maps.4:src/test/java/travelator/recommendations/RecommendationsTests.kt#sugar
[source,kotlin]
----
@Test
fun deduplicates_using_smallest_distance() {
    givenFeaturedDestinationsFor(alton, of(flowerFarm, watercressLine))
    givenADistanceFrom(alton, to = flowerFarm, of = 5300)
    givenADistanceFrom(alton, to = watercressLine, of = 320)

    givenFeaturedDestinationsFor(froyle, of(flowerFarm, watercressLine))
    givenADistanceFrom(froyle, to = flowerFarm, of = 0)
    givenADistanceFrom(froyle, to = watercressLine, of = 6300)

    assertEquals(
        listOf(
            FeaturedDestinationSuggestion(froyle, flowerFarm, 0),
            FeaturedDestinationSuggestion(alton, watercressLine, 320)
        ),
        recommendations.recommendationsFor(setOf(alton, froyle))
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.4/src/test/java/travelator/recommendations/RecommendationsTests.kt#sugar">
        mocks-to-maps.4:src/test/java/travelator/recommendations/RecommendationsTests.kt#sugar
    </a>
</div>
++++
// end-insert

Sometimes defining a tiny local function like `of` can go a long way to letting our brains just read code rather than spending effort interpreting it:

// begin-insert: mocks-to-maps.4:src/test/java/travelator/recommendations/RecommendationsTests.kt#of
[source,kotlin]
----
private fun of(vararg destination: FeaturedDestination)
    = destination.toList()
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.4/src/test/java/travelator/recommendations/RecommendationsTests.kt#of">
        mocks-to-maps.4:src/test/java/travelator/recommendations/RecommendationsTests.kt#of
    </a>
</div>
++++
// end-insert

[TIP]
.Faking in Kotlin
====
There will be times, even in Kotlin, when we want to implement just some of an interface's methods for testing.
On the JVM, we can combine dynamic proxies with anonymous objects, delegation, and selective overriding to write the following:

// begin-insert: src/main/java/encapsulation/faking.kt
[source,kotlin]
----
inline fun <reified T> fake(): T =
    Proxy.newProxyInstance(
        T::class.java.classLoader,
        arrayOf(T::class.java)
    ) { _, _, _ ->
        TODO("not implemented")
    } as T


val sentEmails = mutableListOf<Email>()
val testCollaborator: EmailSystem = object: EmailSystem by fake() {
    override fun send(email: Email) {
        sentEmails.add(email)
    }
}
----
// end-insert
====

=== Have We Really Weaned Off Mocks, Though?

Ah, now that is a good question!

In some ways, we have just implemented a poor imitation of a mocking framework: we have no parameter matchers, no way of failing if a method isn't called, and no way of expressing execution order.

Looked at another way though, we have implemented the recommendation engine's dependencies as two maps.
`Recommendations.recommendationsFor` is beginning to look like a simple calculation (<<calculations>>).
The result of that calculation depends on the `journey` parameter and on the contents of those maps that enable us to look up featured destinations and distances.
We know that in reality _when_ we call `recommendationsFor` does matter; it is really an action (<<actions>>).
The distance between locations probably won't change over time, but which destinations we find around a location will as we add or remove them from whatever database they are held in.
In our tests, though, the distinction is moot, and we could treat `recommendationsFor` as a calculation in much the same way as we saw with `InMemoryTrips` in <<actions-to-calculations>>.
Calculations are easier to test than actionsâ€”we just check that a given input returns a given outputâ€”so let's pull on this thread.

At the moment, _when_ we call `recommendationsFor` in the tests matters too, because the result will depend on the contents of the `featuredDestinations` and `distanceInMetersBetween` maps.
These are initially empty, and are populated by calls to `givenFeaturedDestinationsFor` and `givenADistanceFrom`. That's a time-sensitivity right there.
What we need is some way to convert an action to a calculation, and we can do that by manipulating scope.

In <<interfaces-to-functions>>, we saw that we can view methods as functions with some of their arguments partially applied by capturing them as fields.
In tests, we can reverse this process.
We can write a function that creates the object from its dependencies once for each invocation.
If we call the populated object the _subject_ of the tests, we can create it from the test state like this:

// begin-insert: mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#subjectFor
[source,kotlin]
----
private fun subjectFor(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>
): Recommendations {
    val destinationsLookup = featuredDestinations.withDefault { emptyList() }
    val distanceLookup = distances.withDefault { -1 }
    return Recommendations(destinationsLookup::getValue, distanceLookup::getValue)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.5/src/test/java/travelator/recommendations/RecommendationsTests.kt#subjectFor">
        mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#subjectFor
    </a>
</div>
++++
// end-insert

Here we create a new instance of `Recommendations` every call so that it can capture immutable maps representing the state of the system.

Now we can write a `resultFor` function that uses `subjectFor`:

// begin-insert: mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#resultFor
[source,kotlin]
----
private fun resultFor(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>,
    locations: Set<Location>
): List<FeaturedDestinationSuggestion> {
    val subject = subjectFor(featuredDestinations, distances)
    return subject.recommendationsFor(locations)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.5/src/test/java/travelator/recommendations/RecommendationsTests.kt#resultFor">
        mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#resultFor
    </a>
</div>
++++
// end-insert

Outside of the scope of the `resultFor` function, there is no time sensitivity, so it is effectively a calculation.

Now that we have a simple mapping of input to output (`resultFor`), we can write simple tests that call it.
Each test can just specify the input parameters and check that the result is as expected, with no need for state in the test at all.

Every test can then be of the form:

// begin-insert: mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#check
[source,kotlin]
----
private fun check(
    featuredDestinations: Map<Location, List<FeaturedDestination>>,
    distances: Map<Pair<Location, Location>, Int>,
    recommendations: Set<Location>,
    shouldReturn: List<FeaturedDestinationSuggestion>
) {
    assertEquals(
        shouldReturn,
        resultFor(featuredDestinations, distances, recommendations)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.5/src/test/java/travelator/recommendations/RecommendationsTests.kt#check">
        mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#check
    </a>
</div>
++++
// end-insert

This gives a pleasing simplicity to the previously confusing tests:

// begin-insert: mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#excerpt
[source,kotlin]
----
class RecommendationsTests {
    companion object {
        val distances = mapOf(
            (paris to eiffelTower.location) to 5000,
            (paris to louvre.location) to 1000,
            (alton to flowerFarm.location) to 5300,
            (alton to watercressLine.location) to 320,
            (froyle to flowerFarm.location) to 0,
            (froyle to watercressLine.location) to 6300
        )
    }

    ...

    @Test
    fun returns_no_recommendations_when_no_featured() {
        check(
            featuredDestinations = emptyMap(),
            distances = distances,
            recommendations = setOf(paris),
            shouldReturn = emptyList()
        )
    }

    ...

    @Test
    fun returns_recommendations_for_multi_location() {
        check(
            featuredDestinations = mapOf(
                paris to listOf(eiffelTower, louvre),
                alton to listOf(flowerFarm, watercressLine),
            ),
            distances = distances,
            recommendations = setOf(paris, alton),
            shouldReturn = listOf(
                FeaturedDestinationSuggestion(alton, watercressLine, 320),
                FeaturedDestinationSuggestion(paris, louvre, 1000),
                FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
                FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
            )
        )
    }
    ...
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/mocks-to-maps.5/src/test/java/travelator/recommendations/RecommendationsTests.kt#excerpt">
        mocks-to-maps.5:src/test/java/travelator/recommendations/RecommendationsTests.kt#excerpt
    </a>
</div>
++++
// end-insert

It's instructive to compare this with an original test:

// begin-insert: interfaces-to-funs.0:src/test/java/travelator/recommendations/RecommendationsTests.java#test1
[source,java]
----
@Test
public void returns_recommendations_for_multi_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    givenFeaturedDestinationsFor(alton,
        List.of(
            flowerFarm,
            watercressLine
        ));
    givenADistanceBetween(alton, flowerFarm, 5300);
    givenADistanceBetween(alton, watercressLine, 320);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(alton, watercressLine, 320),
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
        ),
        recommendations.recommendationsFor(Set.of(paris, alton))
    );
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/refactoring-to/kotlin-code/blob/interfaces-to-funs.0/src/test/java/travelator/recommendations/RecommendationsTests.java#test1">
        interfaces-to-funs.0:src/test/java/travelator/recommendations/RecommendationsTests.java#test1
    </a>
</div>
++++
// end-insert

Admittedly, this is Java, and broken up a bit by the `givenADistanceBetween` calls, but you can see how this refactoring has migrated our tests from woolly functions that may or may not have a common structure to a clear testing of inputs against outputs.

=== Moving On

Mocks have their place in software, and outside-in test-driven development (TDD) can certainly improve our designs by allowing us to prototype how to distribute functionality between collaborating objects without having to commit to complete implementations.
However, they have a habit of masking design problems by allowing us to test designs expressed as object interactions that would be better seen as data flows.

In this example, we've seen how focusing on data can simplify our tests, especially where we are only reading values.
In <<performing-io-to-passing-data>>, we explore how we can apply this technique to writing as well.
