== Continuing the Journey
//TODO finish the final chapter

Let's take a look back at what we've seen in the journey so far...
 - Compared to Java, Kotlin is more concise, more explicit and has a type system that is unobtrusive and helpful, and a rich standard library with many convenience functions.
   Like a waiter in a good restaurant, it quietly makes things easy for you, and doesn't interrupt you the moment a forkful of food enters your mouth to ask how your meal is going.
 - The grain of Kotlin prefers transformation of immutable data over mutation.

To make the most of Kotlin, we have to adapt our design to work with the grain of the language.
We've looked at transforming Java to Kotlin in the small: classes, collections, streams, functions, extensions.
- separating calculations and data from actions
- moving mutation outwards (towards where I/O happens) or inwards (to become the responsibility of the runtime)
- and moving I/O and other effects outwards.

We've seen how to change our design gradually and safely, using the refactoring capabilities of IntelliJ, as we introduce Kotlin to the codebase.

Doing so will effect how you do design at larger scales
Continuing the journey involves applying that gradual adaption to the new grain at larger and larger scales:

Constructing complex objects: Builders to Constants.

Abstracting over structure: Reflection to Reification.

Composing the application from parts: DI Containers to Compositionality.

But that'll have to wait for next time...
