== Continuing the Journey

Let's take a look back at what we've seen in the journey so far...

 - Compared to Java, Kotlin is more concise, more explicit and has a type system that is unobtrusive and helpful -- like a waiter in the restaurant of a luxury hotel, it quietly makes things easy for you, and doesn't interrupt you to ask how your meal is going the moment a forkful of food enters your mouth.
 - The grain of Kotlin prefers transformation of immutable data over mutation.
 - that means moving mutation outwards (towards where I/O happens) or inwards (to become the responsibility of the runtime)
 - and moving I/O and other effects outwards.

To make the most of Kotlin, we have to adapt our design to work with the grain of the language.

We can do that gradually and safely, using the refactoring capabilities of IntelliJ.

We've looked at going from Java to Kotlin in the small: classes, collections, streams, functions, extensions.
Continuing the journey involves applying that gradual adaption to the new grain at larger and larger scales:

Constructing complex objects: Builders to Constants.

Abstracting over structure: Reflection to Reification.

Composing the application from parts: DI Containers to Compositionality.

But that'll have to wait for next time...
