[[methods-to-properties]]
== Methods to Properties

Java does not distinguish between property access methods and other types.
Kotlin on the other hand, treats properties differently to member functions.
When should we prefer a computed property to a function returning a result?

=== Fields, Accessors and Properties

Most programming languages allow us to group data together in some way, giving names (and often types) to the properties of a composite.

Here, for example, is a _record_, composed of 3 _fields_, in ALGOL W, the first general purpose language to support record types:footnote:[COBOL introduced the concept of records in the 1950s, but it was another ten years before they appeared in languages designed by academics.]

[source,algol-w]
----
RECORD PERSON (
    STRING(20) NAME;
    INTEGER AGE;
    LOGICAL MALE;
);
----

Things were different then: real programmers only had CAPITAL LETTERS, and gender was a boolean.

In ALGOL W we can (well OK, could) update the age held in a `PERSON` record:

[source,algol-w]
----
AGE(WILMA) := AGE(WILMA) + 1;
----

In this case the compiler will emit the instructions to reach into the memory of the record, find the bytes representing Wilma's age, and increment it.
Records, also known as _structs_ (for structures) in other languages, are a convenience for grouping together related data.
There is no information hiding here; just composition.

Most early object-oriented systems (C++ in particular) were based on this record mechanism.
Instance variables were simply record fields, and methods (aka member functions) were fields holding pointers to functions.
Smalltalk was different.
Smalltalk objects can have instance variables, but access to this state is by sending a message to the object asking the age.
Messages not fields is the fundamental abstraction.

The Java implementors took a little of each approach.
Objects can have public fields, but clients can't just reach into their memory to retrieve them; they have to call bytecode instructions to access their values.
This allows us to treat classes as records, whilst allowing the runtime to enforce private field access.

While direct access to fields was _permitted_, from the outset it was discouraged.
We can't change the internal representation of data if clients access fields directly, at least not without changing those clients too.
We also cannot maintain any invariant relationships between fields if clients can mutate them directly, and as we've seen in <<beans-to-values>>, in those days objects were all about mutation.
Fields access is also not polymorphic, so subclasses cannot change their implementation.
In those days objects were all about the subclassing too.

So instead of direct field access in Java, we usually write _accessor_ methods - getters and (if need be) setters.
Getters usually do nothing except return the value of a field, but they may instead compute a value from other fields.
Setters may maintain invariants or fire events.

Sometimes though, data is just data.
When it is, then direct access to public fields may be fine, especially when we have immutable values (which is to say, final fields of immutable types).
For more complicated models, polymorphic behaviour or a uniform way of accessing values from either a field or a calculation are useful, and accessor methods come into their own.

The Kotlin designers choose to take the decision away from us, and only support accessor methods.
The language doesn't support giving direct access to fields.
Kotlin will generate code to access public fields of Java classes, but does not define public fields itself. (A special annotation, `@JvmField` provides a back door if you really need it.)
They did this to encourage us to use accessors so that we can change representations without affecting clients.

To further encourage accessors, it allows us to generate both a private member-variable and an accessor in a single _property_ declaration.

So in Java we can give access to a field directly:

// begin-insert: src/main/java/properties/PersonWithPublicFields.java#excerpt
[source,java]
----
public class PersonWithPublicFields {
    public final String givenName;
    public final String familyName;
    public final LocalDate dateOfBirth;

    public PersonWithPublicFields(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }
}
----
// end-insert

Or, we can write our own accessor:

// begin-insert: src/main/java/properties/PersonWithAccessors.java#excerpt
[source,java]
----
public class PersonWithAccessors {
    private final String givenName;
    private final String familyName;
    private final LocalDate dateOfBirth;

    public PersonWithAccessors(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }

    public String getGivenName() {
        return givenName;
    }

    ...
}
----
// end-insert

In Kotlin, we just have properties:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#excerpt
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
}
----
// end-insert

This declaration will emit a private field called `givenName`, an accessor method `getGivenName()`, and a constructor to initialise all the fields.

In Java, we can access (visible) fields directly, or call accessors:

// begin-insert: src/main/java/properties/Calling.java#excerpt
[source,java]
----
public static String accessField(PersonWithPublicFields person) {
    return person.givenName;
}

public static String callAccessor(PersonWithAccessors person) {
    return person.getGivenName();
}

public static String callKotlinAccessor(PersonWithProperties person) {
    return person.getGivenName();
}
----
// end-insert

In Kotlin, we can access visible fields  (from Java classes) directly, or call accessors as if they were fields:

// begin-insert: src/main/java/properties/calling.kt
[source,kotlin]
----
fun accessField(person: PersonWithPublicFields): String =
    person.givenName

fun callAccessor(person: PersonWithAccessors): String =
    person.givenName

fun callKotlinAccessor(person: PersonWithProperties): String =
    person.givenName
----
// end-insert

Properties are a convenience backed by some compiler magic.
They make it as simple to use fields and accessors in Kotlin as plain old fields in Java, so we will naturally write code that can take advantage of encapsulation.
For example, we might find that we want to define a property in an interface, or compute a property that we used to store.

_Computed_ properties are those not backed by a field.
If we have `givenName` and `familyName` backed by fields, there is no need to store `fullName`: we can compute it when we need it.

// begin-insert: src/main/java/properties/PersonWithPublicFields.java
[source,java]
----
public class PersonWithPublicFields {
    public final String givenName;
    public final String familyName;
    public final LocalDate dateOfBirth;

    public PersonWithPublicFields(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }

    public String getFullName() {
        return givenName + " " + familyName;
    }
}
----
// end-insert

If we use direct-field-access in Java, there is now a difference between the way that we access the stored and computed properties:

// begin-insert: src/main/java/properties/CallingComputed.java#excerpt
[source,java]
----
public static String fieldAndAccessor(PersonWithPublicFields person) {
    return
        person.givenName + " " +
        person.getFullName();
}
----
// end-insert

This isn't the case in Kotlin, even when accessing the Java fields and methods, which is nice:

// begin-insert: src/main/java/properties/calling-computed.kt
[source,kotlin]
----
fun fieldAndAccessor(person: PersonWithPublicFields) =
    person.givenName + " " +
    person.fullName
----
// end-insert

In Kotlin, we define computed properties outside the constructor:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#PwP
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val fullName get() = "$givenName $familyName"
}
----
// end-insert

So, in Java, we _can_ define classes that give direct access to fields, but _should_ generally write and call accessors, which are just methods named, by convention but not always, with a `get` and maybe `set` prefix.
In Kotlin, we cannot define fields and accessors separately.
When we define a property in Kotlin, the compiler generates a field and accessors that follow the Java naming convention.
When we refer to a property in Kotlin, the syntax is the same as Java's syntax for field access, but the compiler generates a call to the accessor.
This even applies across the interop boundary: when we refer to properties of Java objects, the compiler will generate a call to the accessor if one exists and follows the Java naming convention.

=== How to Choose

Returning to the question at the beginning of the chapter: Given that computed properties are just methods with sugar on top, when should we choose a computed property, and when should we choose a method?

A good rule of thumb is to use a property when it depends only on other properties on the type, and is cheap to compute.
This applies to `fullName`, so that is a good computed property.
What about age?

We can compute age easily (ignoring timezones) from the `dateOfBirth` property, so we might be tempted in Java to write `fred.getAge()`.
But this doesn't depend only on other properties, it also depends on when we call it.
Unlikely thought it is, `fred.age == fred.age` can return `false`.

Age is an action (<<actions>>) - its result depends on when it is called.
Properties should be calculations (<<calculations>>) - timeless and dependent only on their inputs - in this case the `dateOfBirth` property.
Hence `age()` should be a function, not a property:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#DoB
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    fun age() = Period.between(dateOfBirth, LocalDate.now()).years
}
----
// end-insert

What about a cryptographic hash of all the other properties of the object?
This is a calculation (for immutable objects), but if it is expensive to compute, it should be a method `hash()` not a property 'hash`.
We might even want to hint at the cost of the method in its name:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash0
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    fun computeHash(): ByteArray =
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
}
----
// end-insert

We could make a property by calculating it up-front and storing it in a field:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val hash: ByteArray =
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
}
----
// end-insert

This has the disadvantage of making every instance slow to create, whether or not its `hash` is ever accessed.
We might split the difference with a lazy property:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash2
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val hash: ByteArray by lazy {
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
    }
}
----
// end-insert

In a limited scope this would be fine, but if the class was more widely used, we should at least hint at the potential first-invocation performance issue by hiding the computed property behind a function.

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash3
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    private val hash: ByteArray by lazy {
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
    }
    fun hash() = hash
}
----
// end-insert

In this particular case, we might consider an extension property.
As we discuss in <<functions-to-extension-functions>> though, extension properties can only be computed rather than backed by a field, and so cannot be lazy.
(Apart from that, the guidance in this chapter for deciding whether functionality should be implemented as a method or a property, also applies to extension functions versus extension properties.)

=== Mutable Properties

So what of mutable properties?
Kotlin allows us to define properties as `var`, for variable.

If you've read this far you'll know that your authors like to keep their data (<<beans-to-values>>) and collections (<<java-to-kotlin-collections>>) immutable.
We can imagine using Kotlin to define a mutable property to integrate with some Java code that required it, but very, very rarely use mutable public properties in practice.
We might occasionally define a property that will change over time (to give access to a count for example), but almost never one that clients can set.
In practice, we find that data classes with copy methods work better in almost all situations that might have called for a setter - in fact we would go as far as to say that allowing `var` properties in data classes was a language design mistake.

=== Refactoring to Properties

IntelliJ provides excellent refactoring support for converting between Kotlin methods and properties.
This is on one hand simple, because both are simply method calls, and on the other complicated, because Java interop relies on naming conventions to identify accessors.
Let's look at an example from Travelator.

Some of our hardier clients like to camp, so we list camp sites in the application:

// begin-insert: methods-to-properties.0:src/main/java/travelator/CampSite.java#excerpt
[source,java]
----
public class CampSite {
    private final String id;
    private final String name;
    private final Address address;
    ...

    public CampSite(
        String id,
        String name,
        Address address
        ...
    ) {
        this.id = id;
        this.name = name;
        this.address = address;
        ...
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCountryCode() {
        return address.getCountryCode();
    }

    public String region() {
        return address.getRegion();
    }

    ...
}
----
// end-insert

This is typical of a domain class that has grown over the years.
It has lots of properties, some backed by fields like `id` and `name`, and some computed (for low values of compute) like `countryCode` and `region`.
Someone ignored bean conventions by an accessor `region` rather than `getRegion`, but it is clear to us what they meant.

Here's some code that uses the accessors:

// begin-insert: methods-to-properties.0:src/main/java/travelator/CampSites.java
[source,java]
----
public class CampSites {

    public static Set<CampSite> sitesInRegion(
        Set<CampSite> sites,
        String countryISO,
        String region
    ) {
        return sites.stream()
            .filter( campSite ->
                campSite.getCountryCode().equals(countryISO) &&
                    campSite.region().equalsIgnoreCase(region)
            )
            .collect(toUnmodifiableSet());
    }
}
----
// end-insert

Let's convert `Campsite` to Kotlin (and then make it a data class):

// begin-insert: methods-to-properties.1:src/main/java/travelator/CampSite.kt#excerpt
[source,kotlin]
----
data class CampSite(
    val id: String,
    val name: String,
    val address: Address,
    ...
) {
    val countryCode: String
        get() = address.countryCode

    fun region(): String {
        return address.region
    }

    ...
}
----
// end-insert

Our field-backed properties have become constructor properties, and the computed `countryCode` a computed property.
However IntelliJ has not realised that `region` is a property, because it didn't obey getter naming conventions, and has simply converted the method.
The net result is that client code doesn't need to change.
If we want to correct the oversight, we can Alt-Enter on `region` and "Convert function to property", yielding:

// begin-insert: methods-to-properties.2:src/main/java/travelator/CampSite.kt#excerpt
[source,kotlin]
----
val region: String
    get() {
        return address.region
    }
----
// end-insert

As with most computed properties, this is better as a single expression (see <<multi-to-single-expression-functions>>):

// begin-insert: methods-to-properties.3:src/main/java/travelator/CampSite.kt#excerpt
[source,kotlin]
----
val region: String get() = address.region
----
// end-insert

Changing the Kotlin `region` method to a property means that the accessor method will now be named `getRegion` - thankfully IntelliJ is smart enough to fix up our clients for us:

// begin-insert: methods-to-properties.3:src/main/java/travelator/CampSites.java#excerpt
[source,java]
----
public static Set<CampSite> sitesInRegion(
    Set<CampSite> sites,
    String countryISO,
    String region
) {
    return sites.stream()
        .filter( campSite ->
            campSite.getCountryCode().equals(countryISO) &&
                campSite.getRegion().equalsIgnoreCase(region) // <1>
        )
        .collect(toUnmodifiableSet());
}
----
// end-insert

<1> `campsite.region()` has been replaced by `campsite.getRegion()`.

If we now convert `sitesInRegion` to Kotlin, we get the following:

// begin-insert: methods-to-properties.3.5:src/main/java/travelator/CampSites.kt
[source,kotlin]
----
object CampSites {
    fun sitesInRegion(
        sites: Set<CampSite>,
        countryISO: String,
        region: String?
    ): Set<CampSite> {
        return sites.stream()
            .filter { campSite: CampSite ->
                campSite.countryCode == countryISO &&
                    campSite.region.equals(region, ignoreCase = true) // <1>
            }
            .collect(Collectors.toUnmodifiableSet())
    }
}
----
// end-insert

<1> `campsite.getRegion()` is now invoked by `campsite.region`.

We saw how to move `sitesInRegion` to the top level in <<static-methods-to-top-level-functions>>, and to an extension function in <<functions-to-extension-functions>>:

// begin-insert: methods-to-properties.3.6:src/main/java/travelator/CampSites.kt
[source,kotlin]
----
fun Set<CampSite>.sitesInRegion(
    countryISO: String,
    region: String
): Set<CampSite> {
    return stream()
        .filter { campSite: CampSite ->
            campSite.countryCode == countryISO &&
                campSite.region.equals(region, ignoreCase = true)
        }
        .collect(Collectors.toUnmodifiableSet())
}
----
// end-insert

Streams to Iterables to Sequences (<<streams-to-sequences>>) and Multi to Single-Expression Functions (<<multi-to-single-expression-functions>>) will show how to finish the job to:

// begin-insert: methods-to-properties.4:src/main/java/travelator/CampSites.kt
[source,kotlin]
----
fun Iterable<CampSite>.sitesInRegion(
    countryISO: String,
    region: String
): Set<CampSite> =
    filter { site ->
        site.countryCode == countryISO &&
            site.region.equals(region, ignoreCase = true)
    }.toSet()
----
// end-insert

Due to the excellent tooling and interop around methods, accessors and properties, this has been a mercifully short refactor. So we crave your indulgence while we add just one more tweak.

`sitesInRegion` is a bit of an odd method.
It is making up for a deficiency in our modelling, which is that regions are just strings not entities.
Without the country code, if we filter just on region name "Hampshire", we risk returning a set of sites some of which are in an English county and some on a Canadian island.
Until we can fix that, what if we pull the filter predicate out into its own method?

// begin-insert: methods-to-properties.5:src/main/java/travelator/CampSites.kt
[source,kotlin]
----
fun Iterable<CampSite>.sitesInRegion(
    countryISO: String,
    region: String
): Set<CampSite> =
    filter { site ->
        site.isIn(countryISO, region)
    }.toSet()

fun CampSite.isIn(countryISO: String, region: String) =
    countryCode == countryISO &&
        this.region.equals(region, ignoreCase = true)
----
// end-insert

Now we have `Campsite.isIn(...)`, maybe `sitesInRegion` could be inlined into the places that call it, as the code is now really quite self-explanatory.
We prefer to find and publish the fundamental operations that clients can build on, rather hiding them inside functions.
Pulling on this thread, we might expand the functionality of `isIn` by making `region` optional:

// begin-insert: methods-to-properties.6:src/main/java/travelator/CampSites.kt#excerpt
[source,kotlin]
----
fun CampSite.isIn(countryISO: String, region: String? = null) =
    when (region) {
        null -> countryCode == countryISO
        else -> countryCode == countryISO &&
            region.equals(this.region, ignoreCase = true)
    }
----
// end-insert

Nat prefers the same, but with an Elvis operator:

// begin-insert: methods-to-properties.7:src/main/java/travelator/CampSites.kt#excerpt
[source,kotlin]
----
fun CampSite.isIn(countryISO: String, region: String? = null) =
    countryCode == countryISO &&
        region?.equals(this.region, ignoreCase = true) ?: true
----
// end-insert

Duncan likes a good Elvis, but thinks the code a lot clearer his way.
Your team will probably have these little battles (choose Duncan's way).

A fundamental operation like `isIn` might now be promoted to a method (as opposed to an extension function) on `Campsite`, or, even better, `Address`.
This way the problem of regions not being entities is confined to the type closest to the problem, and fixing it there will have the least effect on the rest of the codebase.

=== Conclusion

Kotlin provides a convenient syntax for both field-backed and computed properties that allows us to express the difference between accessing a property and calling a function, even if they are the same message-passing mechanism under the hood.
We should prefer a property to a method when it applies to a value type, depends only on the value, and is not expensive to compute.
In these cases refactoring from a method to a property is simple and makes our code easier to understand.