[[methods-to-properties]]
== Methods to Properties

Java does not distinguish between property access methods and other types.
Kotlin on the other hand, treats properties differently to member functions.
When should we prefer a computed property to a function returning a result?

=== Fields, Accessors and Properties

Most programming languages allow us to group data together in some way, giving names (and often types) to the properties of an entity.

Here, for example, is a _record_, composed of 3 _fields_, in ALGOL W:

[source,algol-w]
----
RECORD PERSON (
    STRING(20) NAME;
    INTEGER AGE;
    LOGICAL MALE;
);
----

Things were different then, real programmers only had CAPITAL LETTERS, and gender was a boolean.

We can also see by the `STRING(20)` that this record really cares about its layout in memory.
That's because when we write an statement like

[source,algol-w]
----
AGE(WILMA) := AGE(WILMA) + 1;
----

the compiler is going to add the number of bytes taken by 20 characters to the place that it has stored `WILMA` in order to know where to find the bytes representing her age, and increment it.
Records, also known as _structs_ (for structures) in other languages, are a convenience for grouping together related data.
There is no information hiding here, just composition.

Most early object-oriented systems (C++ in particular) were based on this record mechanism.
Instance variables were simply record fields, and methods (aka member functions) were fields holding pointers to functions.
Smalltalk was different.
Smalltalk objects can have instance variables, but access to this state is by sending a message to the object asking it for the person.
Messages not fields is the fundamental abstraction.

The Java implementors took a little of each approach.
Objects can have public fields, but clients can't just reach into their memory to retrieve them; they have to call bytecode instructions to access their values.
This allows us to treat classes as records, whilst allowing the runtime to enforce `private` field access.

While direct access to fields was _permitted_, from the outset it was discouraged.
If its clients access fields directly, then an implementation cannot change its internal representation without recompiling those clients.
We also cannot maintain any invariant relationships between fields if clients can mutate them directly, and as we've seen in Beans to Values (<<beans-to-values>>), in those days objects were all about mutation.
Another reason for not accessing fields directly is that it is not polymorphic, so subclasses cannot change its implementation.
In those days objects were all about the subclassing too.

So instead of direct field access in Java, we usually write _accessor_ methods - getters and (historically) setters.
Getters usually do nothing except return the value of a field, but they may instead compute a value from other fields.
Setters may maintain invariants or fire events.
Sometimes data is just data.
When it is, then direct access to public fields, is perfectly acceptable, especially when we have immutable values (which is to say, `final` fields of immutable types).
As models get more complicated, we will prefer a uniform way of accessing values from either a field or a calculation, or polymorphically.
Then accessor methods come into their own.

The Kotlin designers choose to take the decision away from us and only support accessor methods.
The language doesn't support giving direct access to the fields of its classes. (A special annotation, `@JvmField` provides a back door if you really need it.)
Kotlin will generate code to access to public fields of Java classes, but does not define public fields itself.

Instead, it allows us to generate both a private member-variable and an accessor in a single _property_ declaration.

So in Java we can give access to a field directly:

// begin-insert: src/main/java/properties/PersonWithPublicFields.java#excerpt
[source,java]
----
public class PersonWithPublicFields {
    public final String givenName;
    public final String familyName;
    public final LocalDate dateOfBirth;

    public PersonWithPublicFields(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }
}
----
// end-insert

Alternatively, we can write our own accessor:

// begin-insert: src/main/java/properties/PersonWithAccessors.java#excerpt
[source,java]
----
public class PersonWithAccessors {
    private final String givenName;
    private final String familyName;
    private final LocalDate dateOfBirth;

    public PersonWithAccessors(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }

    public String getGivenName() {
        return givenName;
    }

    ...
}
----
// end-insert

In Kotlin, we don't give access to the field directly:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#excerpt
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
}
----
// end-insert

This declaration will emit a private field called `givenName`, an accessor method `getGivenName()`, and a constructor to initialise all the fields.

In Java, we can access (visible) fields directly, or call accessors:

// begin-insert: src/main/java/properties/Calling.java#excerpt
[source,java]
----
public static String accessField(PersonWithPublicFields person) {
    return person.givenName;
}

public static String callAccessor(PersonWithAccessors person) {
    return person.getGivenName();
}

public static String callKotlinAccessor(PersonWithProperties person) {
    return person.getGivenName();
}
----
// end-insert

In Kotlin, we can access visible fields directly, or call accessors as if they were fields:

// begin-insert: src/main/java/properties/calling.kt
[source,kotlin]
----
fun accessField(person: PersonWithPublicFields): String =
    person.givenName

fun callAccessor(person: PersonWithAccessors): String =
    person.givenName

fun callKotlinAccessor(person: PersonWithProperties): String =
    person.givenName
----
// end-insert

Properties are a convenience backed by some compiler magic in Kotlin.
They make it as simple to use fields and accessors as plain old fields in Java, and so we will naturally write code that can take advantage of the encapsulation provided by accessors.
For example, we might find that we want to define a property in an interface, or compute a property that we used to store.

Computed properties are those not backed by a field.
If we have `givenName` and `familyName` backed by fields, there is no need to store `fullName`, we can compute it when we need it.

// begin-insert: src/main/java/properties/PersonWithPublicFields.java
[source,java]
----
public class PersonWithPublicFields {
    public final String givenName;
    public final String familyName;
    public final LocalDate dateOfBirth;

    public PersonWithPublicFields(
        String givenName,
        String familyName,
        LocalDate dateOfBirth
    ) {
        this.givenName = givenName;
        this.familyName = familyName;
        this.dateOfBirth = dateOfBirth;
    }

    public String getFullName() {
        return givenName + " " + familyName;
    }
}
----
// end-insert

Where we use direct-field-access in Java, there is now a difference between the way that we access the stored and computed properties.

// begin-insert: src/main/java/properties/CallingComputed.java#excerpt
[source,java]
----
public static String fieldAndAccessor(PersonWithPublicFields person) {
    return
        person.givenName + " " +
        person.getFullName();
}
----
// end-insert

This isn't the case in Kotlin, even when accessing the Java fields and methods.
This uniformity is a goal of properties.

// begin-insert: src/main/java/properties/calling-computed.kt
[source,kotlin]
----
fun fieldAndAccessor(person: PersonWithPublicFields) =
    person.givenName + " " +
    person.fullName
----
// end-insert

In Kotlin, we define computed properties outside the constructor:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#PwP
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val fullName get() = "$givenName $familyName"
}
----
// end-insert

So, in Java, we _can_ access fields directly, but should generally write and call accessors, which are just methods, although often with a `get` (and maybe `set`) prefix.
In Kotlin, we cannot _publish_ direct field access, but we can auto-generate accessors, and call them as if they were field access if they match a naming convention.

=== How to Choose

Returning to the question at the beginning of the chapter, given that computed properties are just methods with sugar on top, when should we choose a computed property, and when should we choose a method?

The rule of thumb is to use a property when it depends only on other properties on the type, and is cheap to compute.
This applies to `fullName`, so that is a good computed property.
What about age?

We can compute age easily (ignoring timezones) from the `dateOfBirth` property, so we might be tempted in Java to write `fred.getAge()`.
But this doesn't depend only on other properties, it also depends on when we call it.
It may be very unlikely, but the fact that the expression `fred.age == fred.age` may return `false` is the clue.

Age is an action (<<actions>>) - its result depends on when it is called.
Properties should be calculations (<<calculations>>) - timeless and dependent only on their inputs - in this case the `dateOfBirth` property.
Hence `age()` should be a function, not a property:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#DoB
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    fun age() = Period.between(dateOfBirth, LocalDate.now()).years
}
----
// end-insert

What about a cryptographic hash of all the other properties of the object?
This is a calculation, but if it is expensive to compute, it should be a method not be a property.
We might even want to hint at the cost of the method in its name:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash0
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    fun computeHash(): ByteArray =
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
}
----
// end-insert

We could make a property by calculating it up-front and storing it in a field:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val hash: ByteArray =
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
}
----
// end-insert

This has the disadvantage of making every instance slow to create, whether or not its `hash` is ever accessed.
We might split the difference with a lazy property:

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash2
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    val hash: ByteArray by lazy {
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
    }
}
----
// end-insert

In a limited scope this would be fine, but if the class was more widely used, we should at least hint at the potential first-invocation performance issue by hiding the computed property behind a function.

// begin-insert: src/main/java/properties/PersonWithProperties.kt#hash3
[source,kotlin]
----
data class PersonWithProperties(
    val givenName: String,
    val familyName: String,
    val dateOfBirth: LocalDate
) {
    private val hash: ByteArray by lazy {
        someSlowHashOf(givenName, familyName, dateOfBirth.toString())
    }
    fun hash() = hash
}
----
// end-insert

In this particular case, perhaps an extension property would be as appropriate.
As we discuss in <<functions-to-extension-functions>>, extension properties can only be computed rather than backed by a field.
As a result, the guidance in this chapter for deciding whether functionality should be implemented as a method or a property, also applies to extension functions versus extension properties.

=== Refactoring to Properties

IntelliJ provides excellent refactoring support for converting between Kotlin methods and properties.
This is on one hand simple, because both are simply method calls, and on the other complicated, because Java interop relies on naming conventions to identify accessors.
Let's look at an example from Travelator.

Some of our hardier clients like to camp, so we list camp sites in the application:

// begin-insert: methods-to-properties.0:src/main/java/travelator/CampSite.java#excerpt
[source,java]
----
public class CampSite {
    private final String id;
    private final String name;
    private final Address address;
    ...

    public CampSite(
        String id,
        String name,
        Address address
        ...
    ) {
        this.id = id;
        this.name = name;
        this.address = address;
        ...
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCountryCode() {
        return address.getCountryCode();
    }

    public String region() {
        return address.getRegion();
    }

    ...
}
----
// end-insert

This is typical of a domain class that has grown over the years.
It has lots of properties, some backed by fields like `id` and `name`, and some computed (for low values of compute) like `countryCode` and `region`.
Someone eschewed bean conventions by naming the `region` accessor `region` rather than `getRegion`, but it is clear to us what they meant.

Here's some code that uses the accessors:

// begin-insert: methods-to-properties.0:src/main/java/travelator/CampSites.java#excerpt
[source,java]
----
public static Set<CampSite> sitesInRegion(
    Set<CampSite> sites,
    String countryISO,
    String region
) {
    return sites.stream()
        .filter( campSite ->
            campSite.getCountryCode().equals(countryISO) &&
                campSite.region().equalsIgnoreCase(region)
        )
        .collect(toUnmodifiableSet());
}
----
// end-insert

Let's convert `Campsite` to Kotlin (and then make it a data class):

// begin-insert: methods-to-properties.1:src/main/java/travelator/CampSite.kt#excerpt
[source,kotlin]
----
data class CampSite(
    val id: String,
    val name: String,
    val address: Address,
    ...
) {
    val countryCode: String
        get() = address.countryCode

    fun region(): String {
        return address.region
    }

    ...
}
----
// end-insert

Our field-backed properties have become constructor properties, and the computed `countryCode` a computed property.
Because it didn't obey getter naming conventions though, IntelliJ has not realised that `region` is a property, and has simply converted the method.
The net result is that client code doesn't need to change.
If we want to correct the oversight, we can Alt-Enter on `region` and "Convert function to property", yielding:

// begin-insert: methods-to-properties.2:src/main/java/travelator/CampSite.kt#excerpt
[source,kotlin]
----
val region: String
    get() {
        return address.region
    }
----
// end-insert

As with most computed properties, this is better as a single expression (see <<multi-to-single-expression-functions>>):

// begin-insert: methods-to-properties.3:src/main/java/travelator/CampSite.kt#excerpt
[source,kotlin]
----
val region: String get() = address.region
----
// end-insert

Changing the Kotlin `region` method to a property means that the accessor method will now be named `getRegion` - thankfully IntelliJ is smart enough to fix up our clients for us:

// begin-insert: methods-to-properties.3:src/main/java/travelator/CampSites.java#excerpt
[source,java]
----
public static Set<CampSite> sitesInRegion(
    Set<CampSite> sites,
    String countryISO,
    String region
) {
    return sites.stream()
        .filter( campSite ->
            campSite.getCountryCode().equals(countryISO) &&
                campSite.getRegion().equalsIgnoreCase(region) // <1>
        )
        .collect(toUnmodifiableSet());
}
----
// end-insert

<1> `campsite.region()` has been replaced by `campsite.getRegion()`.

If we now convert `sitesInRegion` to Kotlin, using the techniques from Static Methods to Top Level Functions (<<static-methods-to-top-level-functions>>),
Streams to Sequences (<<streams-to-sequences>>), Multi to Single-Expression Functions (<<multi-to-single-expression-functions>>) and Functions to Extension Functions (<<functions-to-extension-functions>>), we have:

// begin-insert: methods-to-properties.4:src/main/java/travelator/CampSites.kt
[source,kotlin]
----
fun Iterable<CampSite>.sitesInRegion(
    countryISO: String,
    region: String
): Set<CampSite> =
    filter { site ->
        site.countryCode == countryISO &&
            site.region.equals(region, ignoreCase = true)
    }.toSet()
----
// end-insert

The getters are now hidden behind the property access syntax, `campsite.countryCode` etc.

Before we finish, it's worth observing that `sitesInRegion` is a bit of an odd method.
It is making up for a deficiency in our modelling, which is that regions are just `Strings` not entities.
If we filter just on region name "Hampshire", we risk returning a set of sites some of which are in an English county and some on a Canadian island.
Until we can fix that, what if we pull the filter predicate out into its own method?

// begin-insert: methods-to-properties.5:src/main/java/travelator/CampSites.kt
[source,kotlin]
----
fun Iterable<CampSite>.sitesInRegion(
    countryISO: String,
    region: String
): Set<CampSite> =
    filter { site ->
        site.isIn(countryISO, region)
    }.toSet()

fun CampSite.isIn(countryISO: String, region: String) =
    countryCode == countryISO &&
        this.region.equals(region, ignoreCase = true)
----
// end-insert

Now we have `Campsite.isIn(...)`, maybe `sitesInRegion` could be inlined into the places that call it, as the code is now really quite self-explanatory.
We prefer to find and publish the fundamental operations that clients can build on, rather hiding them inside functions.
Pulling on this thread, we might expand the functionality of `isIn` by making `region` optional:

// begin-insert: methods-to-properties.6:src/main/java/travelator/CampSites.kt#excerpt
[source,kotlin]
----
fun CampSite.isIn(countryISO: String, region: String? = null) =
    if (region == null)
        countryCode == countryISO
    else
        countryCode == countryISO &&
            region.equals(this.region, ignoreCase = true)
----
// end-insert

Nat prefers the same, but with an elvis operator:

// begin-insert: methods-to-properties.7:src/main/java/travelator/CampSites.kt#excerpt
[source,kotlin]
----
fun CampSite.isIn(countryISO: String, region: String? = null) =
    countryCode == countryISO &&
        region?.equals(this.region, ignoreCase = true) ?: true
----
// end-insert

Such a fundamental operation might now be converted to a method on `Campsite`, or, even better, `Address`.
This way the fundamental problem of regions not being entities is confined to the type closest to the problem, and fixing it there will have the least effect on the rest of the codebase.

=== Conclusion

Kotlin provides a convenient syntax for both field-backed and computed properties that allows us to express the difference between accessing a property and calling a function, even if they are the same message-passing mechanism under the hood.
We should prefer a property to a method when it applies to a value type, depends only on the value, and is not expensive to compute.
In these cases refactoring from a method to a property is simple and makes our code easier to understand.