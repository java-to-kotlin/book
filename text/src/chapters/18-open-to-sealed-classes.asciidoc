[[open-to-sealed-classes]]
== Open to Sealed Classes

++++
<blockquote data-type="epigraph">
<p>Our systems are composed of types and operations, nouns and verbs.
In Java, nouns are expressed as classes and interfaces, verbs as methods; but Kotlin adds sealed class hierarchies and freestanding functions.
What do they bring to the party?</p>
</blockquote>
++++

Change((("open to sealed classes", "benefits of polymorphism", id="OSCpoly18")))((("sealed classes", "benefits of polymorphism", id="SCbene18"))) is a constant challenge in designing software.
The more people use our software, the more they think of things they want it to do.
To support new use cases, we need to add new functions that work with existing data types, and new data types that work with existing functions.
If our design is well aligned with the way the software has to evolve, we can add new features by adding new code and making few, localized changes to our existing code.
If it isn't well aligned, we will have to change many functions when we add a new data type, or change many data types when we need to add a function.

We feel this tension between the variability of data types and of functions most keenly in the core entities of our domain model.
For example, the traveler's itinerary is a core entity of our Travelator application.
Many features of the application present views of, alter the contents of, or calculate information about itineraries.
It's no surprise then that many of the feature requests from our users affect our `Itinerary` type.
Our travelers want to include more kinds of things in their itineraries: not just journeys and accommodation, as we saw in <<functions-to-extension-functions>>, but now restaurant bookings and attractions along the route.
They also want to do more things with their itineraries.
In <<accumulating-objects-to-transformations>>, we saw how we estimate their cost, but our customers also want to compare them by cost, time, or comfort, view them on a map, import them into their calendar, share them with their friends...their imagination is endless.

When we last looked at the `Itinerary` class in <<accumulating-objects-to-transformations>>, we were modeling an itinerary as a data class, with a property for the route and another for the accommodation required along the route:

// begin-insert: accumulator.17:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val route: Route,
    val accommodations: List<Accommodation> = emptyList()
) {
    ...
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.1&amp;show=file">Example 18.1 [accumulator.17:src/main/java/travelator/itinerary/Itinerary.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.1&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

Since then, we have added more features to the application and, hence, more types of items to the itinerary.
We found it increasingly cumbersome to hold each type of itinerary item in a separate collection, because too much of our code involved combining those collections or applying the same filters and transforms to separate collections.
So we decided that an `Itinerary` would maintain a single collection of `ItineraryItem` rather than keep each type of item in a separate collection:

// begin-insert: open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt#itinerary
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val items: List<ItineraryItem>
) : Iterable<ItineraryItem> by items
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.2&amp;show=file">Example 18.2 [open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.2&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

`ItineraryItem` is an interface, implemented by the concrete item types we saw before: `Journey` and  `Accommodation` and new types `RestaurantBooking` and `Attraction`:

// begin-insert: open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
interface ItineraryItem {
    val id: Id<ItineraryItem>
    val description: String
    val costs: List<Money>
    val mapOverlay: MapOverlay
    ... and other methods
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.3&amp;show=file">Example 18.3 [open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.3&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

Operations on `Itinerary` don't depend on the concrete type of its items.
For example, to display the itinerary on a map, we create a `MapOverlay` that will be rendered on top of map tiles on the frontend.
The overlay for an `Itinerary` is the group of the overlays for all the items it contains.
The `Itinerary` class and its clients don't know, or need to know, how each item represents itself as a map overlay.

// begin-insert: open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt#mapOverlay
[source,kotlin]
----
val Itinerary.mapOverlay
    get() = OverlayGroup(
        id = id,
        elements = items.map { it.mapOverlay })
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.4&amp;show=file">Example 18.4 [open-to-sealed.0:src/main/java/travelator/itinerary/Itinerary.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.4&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

This polymorphism makes it very easy to add new types of `ItineraryItem` to the system without having to change the parts of the application that use the `Itinerary` type.

For a while now, though, we haven't had to do that.
Recently, we find that most of the new functionality we add to Travelator involves adding new operations to `Itinerary` and `ItineraryItem` rather than new types of `ItineraryItem`.
Changes to the ++Itinerary&#x200b;I&#x2060;tem++ interface and its implementations are a common source of merge conflicts between team members who are working on different features.
With every new feature, the `ItineraryItem` gets larger.
It seems to attract behavior to support distantly related parts of the application, with properties to support rendering, cost estimation, ranking by comfort, maps drawing, and more hidden beyond that ++...and other [.keep-together]#methods#++.
Paradoxically,((("object-oriented polymorphism"))) in the core of our application, object-oriented polymorphism is _increasing_ coupling!

// Reference the collections to type aliases example where we discuss coupling?

// Open/closed adding rather than changing code.
// Change risks breaking existing functionality
// Not to be confused with refactoring - changing code to get it to the place where a feature can be implemented as an addition.

Object-oriented polymorphism enables variability of data types with an infrequently changing set of operations.
For a while, that was what our codebase needed, but now that it has stabilized, we need the opposite: variability of operations applied to an infrequently changing set of data types.

If we were writing in Java (at least up to Java 16), there is no language feature to help us cope with variability in this dimension.
Java's principal feature to support variability is object-oriented polymorphism, and that doesn't help when operations change more frequently than the set of data types.

We((("double dispatch pattern"))) could use the https://oreil.ly/8m2HL[double dispatch] pattern, but it involves a lot of boilerplate code and, because it does not play well with checked exceptions, is not widely used in Java.
Instead, Java((("instanceof operator")))((("downcast operator"))) programmers often resort to runtime type checks, using the `instanceof` and downcast operators to run different code for different classes of object:

// begin-insert: open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItems.java#type_switch
[source,java]
----
if (item instanceof Journey) {
    var journey = (Journey) item;
    return ...
} else if (item instanceof Accommodation) {
    var accommodation = (Accommodation) item;
    return ...
} else if (item instanceof RestaurantBooking) {
    var restaurant = (RestaurantBooking) item;
    return ...
} else {
    throw new IllegalStateException("should never happen");
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.5&amp;show=file">Example 18.5 [open-to-sealed.0:src/main/java/travelator/itinerary/ItineraryItems.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.5&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

That((("type checks"))) `IllegalStateException` shows that this approach is risky.
Whereas the compiler can type check our calls to polymorphic methods, our hand-coded runtime type checks and casts are explicitly circumventing compile-time checks.
The type checker cannot tell whether our casts are correct or our conditional statement is _exhaustive_: whether it applies to all possible subclasses.
If returning a value from the method, we have to write an `else` clause to return a dummy value or throw an exception, even if we have branches for every subclass of `ItineraryItem`, and the else clause "cannot possibly be executed™."

Even if we cover all the subtypes of `ItineraryItem` when we write the code, if we later add new types, we have to find all such code and update it.
It turns out that we didn't do that here, so if we add an `Attraction` to an `Itinerary`, this code will fail with an `IllegalArgumentException`.
OO solves this problem, but we circumvented the solution because we were tired of having to update lots of classes when we add an operation.

Type checking and downcasting are possible in Kotlin, too, and carry the same overheads and risks.
However, Kotlin has another mechanism for organizing classes and behavior that makes runtime type checks safe and convenient: _sealed classes_.
A sealed class is an abstract class with a fixed set of direct subclasses.
We must define the sealed class and its subclasses in the same compilation unit and package; the compiler prevents us from extending the sealed class elsewhere.
Thanks to this restriction, runtime type checks on sealed class hierarchies do not have the same problem as runtime type checks in Java.
The static type checker can guarantee that `when` expressions that perform runtime type checks for a subtype of a sealed class cover all possible cases and only the possible cases.

[WARNING]
.When Statements Are Not Checked for Exhaustiveness
====
The((("exhaustiveness")))((("statements", "checking for exhaustiveness"))) compiler checks `when` expressions for exhaustiveness but does not check `when` _statements_;
`when` becomes a statement if the value of the entire `when` expression is not used.
You can force the compiler to check for exhaustiveness by using the result of the `when`, even though it is of type `Unit`.

If the `when` is the only statement in the body of a function, you can refactor the function to single-expression form.
If `when` is the last statement in a multistatement function, you can explicitly use its value with the `return` keyword.
When the `when` is in the middle of the function body, extracting it to its own function might make sense.

When none of those options apply, you can use the following utility function to force an exhaustiveness check:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_definition
[source,kotlin]
----
val <T> T.exhaustive get() = this
----
// end-insert

When used like this, it will prevent compilation when `when` is not exhaustive:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_usage
[source,kotlin]
----
when (instanceOfSealedClass) {
    is SubclassA -> println("A")
    is SubclassB -> println("B")
}.exhaustive
----
// end-insert
====

Compared to polymorphic methods, sealed classes and `when` expressions make it easy to add new operations that apply to a fixed type hierarchy, although we still have to change all those operations if we add a new type to that hierarchy.
At this point the compiler will help us by checking that all those operations cover all possible types in the hierarchy.((("", startref="OSCpoly18")))((("", startref="SCbene18")))

=== Polymorphism or Sealed Classes?

Some((("open to sealed classes", "polymorphism versus sealed classes")))((("sealed classes", "polymorphism versus sealed classes"))) languages have mechanisms that let us vary types _and_ operations without modifying existing code.
Haskell has type classes, Scala has implicit parameters, Rust has traits, Swift has protocols, and Clojure and Common Lisp have polymorphic functions that dispatch on the classes of multiple arguments.

Kotlin((("object-oriented polymorphism"))) doesn't have any equivalent.
When we're designing in Kotlin, we have to choose between object-oriented polymorphism or sealed classes based on the dimension—types or operations—we expect to vary most frequently as the program evolves.
Object-oriented polymorphism is preferable when the set of data types varies more frequently than the set of operations on those data types, and sealed class hierarchies when the set of operations varies more frequently than the set of data types they apply to.

[TIP]
.Only Typecast Down a Sealed Class Hierarchy
====
Only((("typecasts"))) use typecasts to cast from the root of a sealed class hierarchy to one of the children in an exhaustive `when` expression.
Otherwise, it is risky to cast away from the static type.
The actual class used to implement a value may have operations that violate the constraints expressed by its static type.

For example, as we saw in <<java-to-kotlin-collections>>, the static type `List` prevents mutation, but Kotlin's higher-order functions return lists that can be mutated if you downcast from `List` to `MutableList`.
A function that downcasts a list argument from `List` to `MutableList` and mutates it is likely to introduce bugs in code, because it violates the expectations of its callers.
It could introduce aliasing errors that are very hard to find, because the possibility of spooky action at a distance is not explicit in the type declarations of the function's signature.
If a future version of the Kotlin standard library returned immutable lists from its higher-order functions, the function would continue to compile successfully but crash at runtime.

Just because you _can_ cast from a super type to a subtype doesn’t mean you are intended to. The possibility is likely to be a mere implementation detail.
A((("downcasting"))) sealed class hierarchy signals that downcasting is intended, supported, and made safe by the compiler's exhaustiveness checks.
====

=== Converting an Interface to a Sealed Class

We're((("open to sealed classes", "converting interfaces to sealed classes", id="OSCinter18")))((("sealed classes", "converting interfaces to sealed classes", id="SCinterf18")))((("refactoring", "interfaces to sealed classes", id="Ringerf18"))) about to add another feature that involves itineraries and itinerary items: making the `Itinerary` appear in the traveler's calendar app.
We don't want to add more methods to the already bloated `ItineraryItem` interface and couple the core classes of our application's domain to the needs of another peripheral module.
It's time to bite the bullet and convert `ItineraryItem` from an interface of polymorphic methods to a sealed class hierarchy and freestanding functions, and move those freestanding functions into the modules that use them.

Kotlin 1.4 was current when we wrote this, so we have to define a sealed class and its direct subclasses in the same file.
Our first step, then, is to use the IDE's "Move Class" refactoring to move the implementations of `ItineraryItem` into the same file as the interface.
Once we've done that, we can turn the interface and its implementations into a sealed class hierarchy.
IntelliJ does not have an automated refactoring for this, so we have to do it by manually editing the class definitions.
At least moving all the classes into the same file has made the task easier.

// begin-insert: open-to-sealed.2:src/main/java/travelator/itinerary/ItineraryItem.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem { // <1>
    abstract val id: Id<ItineraryItem> // <2>
    abstract val description: String
    abstract val costs: List<Money>
    abstract val mapOverlay: MapOverlay
    ... and other methods
}

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() { // <3>
    val nights = Period.between(
        checkInFrom.toLocalDate(),
        checkOutBefore.toLocalDate()
    ).days
    val totalPrice: Money = pricePerNight * nights

    override val description
        get() = "$nights nights at ${location.userReadableName}"
    override val costs
        get() = listOf(totalPrice)
    override val mapOverlay
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )

    ... and other methods
}

... and other subclasses
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.6&amp;show=file">Example 18.6 [open-to-sealed.2:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.6&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

<1> We declare `ItineraryItem` as a `sealed class` instead of an `interface`.

<2> Because it is now a class, we have to explicitly mark its methods as `abstract`.
If the interface had any methods with a default implementation, we would have had to declare them as `open` so that subclasses could still override them.

<3> We replace the declaration of the interface in the concrete item classes with a call to the superclass constructor.

NOTE: Kotlin 1.5 (released as we completed this book) supports sealed _interfaces_, which make this refactoring easier.
It's unnecessary to move the subclasses into the same file or to call the constructor.

[role="pagebreak-before"]
`ItineraryItem` is now a sealed class.
Its operations are still polymorphic methods, but we can add _new_ operations without changing the `ItineraryItem` classes, by writing extension functions that use a `when` expression to safely dispatch on the concrete item type.

First we'll write the extension functions that we need to translate an `Itinerary` to a calendar.
When we're done, we'll continue refactoring to make the other operations on `ItineraryItem` work the same way.

// begin-insert: open-to-sealed.3:src/main/java/travelator/calendar/ItineraryToCalendar.kt#toCalendarEvent
[source,kotlin]
----
fun ItineraryItem.toCalendarEvent(): CalendarEvent? = when (this) {
    is Accommodation -> CalendarEvent(
        start = checkInFrom,
        end = checkOutBefore,
        description = description,
        alarms = listOf(
            Alarm(checkInFrom, "Check in open"),
            Alarm(checkOutBefore.minusHours(1), "Check out")
        )
    )
    is Attraction -> null
    is Journey -> CalendarEvent(
        start = departureTime,
        end = arrivalTime,
        description = description,
        location = departsFrom,
        alarms = listOf(
            Alarm(departureTime.minusHours(1)))
    )
    is RestaurantBooking -> CalendarEvent(
        start = time,
        description= description,
        location = location,
        alarms = listOf(
            Alarm(time.minusHours(1)))
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.7&amp;show=file">Example 18.7 [open-to-sealed.3:src/main/java/travelator/calendar/ItineraryToCalendar.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.7&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

Now, let's refactor the rest of the `ItineraryItem` methods from being polymorphic methods defined on the (now sealed) class, to extension functions that use `when` expressions to switch on the type of item.
We'll walk through the process with the `mapOverlay` property.

When we Alt-Enter on the definition of `mapOverlay` in `ItineraryItem`, the context menu includes the action "Convert member to extension".
Can it really be that easy?
Unfortunately, no.
At the time of writing, the IDE action only gets us part of the way there and leaves us with code that does not compile.

// begin-insert: open-to-sealed.4:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
sealed class ItineraryItem {
    abstract val id: Id<ItineraryItem>
    abstract val description: String
    abstract val costs: List<Money> // <1>
    ... and other methods
}

val ItineraryItem.mapOverlay: MapOverlay // <2>
    get() = TODO("Not yet implemented")

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Period.between(
        checkInFrom.toLocalDate(),
        checkOutBefore.toLocalDate()
    ).days
    val totalPrice: Money = pricePerNight * nights

    override val description
        get() = "$nights nights at ${location.userReadableName}"
    override val costs
        get() = listOf(totalPrice)
    override val mapOverlay // <3>
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )

    ... and other methods
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.8&amp;show=file">Example 18.8 [open-to-sealed.4:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.8&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

<1> The IDE removed the `mapOverlay` method from the `ItineraryItem` class...
<2> ...and replaced it with an extension function. Unfortunately, the extension function only contains a `TODO` that throws `UnsupportedOperationException`.
<3> The IDE left `override` modifiers on the `mapOverlay` properties in the subclasses, which no longer have a method in the superclass to override.

We can get the code compiling again by removing the `override` modifiers in the subclasses.
Then we'll make the code actually work by implementing the body of an extension function as a `when` expression that switches on the type of `ItineraryItem` and calls the now monomorphic `mapOverlay` getter on each concrete class:

// begin-insert: open-to-sealed.5:src/main/java/travelator/itinerary/ItineraryItem.kt#mapOverlay
[source,kotlin]
----
val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> mapOverlay
    is Attraction -> mapOverlay
    is Journey -> mapOverlay
    is RestaurantBooking -> mapOverlay
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.9&amp;show=file">Example 18.9 [open-to-sealed.5:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.9&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

The `when` expression will not compile until we have covered all the subclasses of [.keep-together]#++ItineraryItem++#.
IntelliJ also highlights each read of the subclass `mapOverlay` properties to show that the compiler's flow-sensitive typing is smart casting the implicit `this` reference from `ItineraryItem` to the correct subclass.

Now the point of this refactor was to prevent every implementation of `ItineraryItem` from having to know about map overlays.
At present each still does, because each has its own `mapOverlay` property—the one that was originally overriding the property in the interface:

// begin-insert: open-to-sealed.5:src/main/java/travelator/itinerary/ItineraryItem.kt#accommodation
[source,kotlin]
----
data class Accommodation(
...
) : ItineraryItem() {
    ...
    val mapOverlay
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )
    ...
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.10&amp;show=file">Example 18.10 [open-to-sealed.5:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.10&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

We can solve this problem by converting the `mapOverlay` properties with "Convert member to extension":

// begin-insert: open-to-sealed.6:src/main/java/travelator/itinerary/ItineraryItem.kt#accommodation
[source,kotlin]
----
data class Accommodation(
...
) : ItineraryItem() {
    ...
}

val Accommodation.mapOverlay
    get() = PointOverlay(
        id = id,
        position = location.position,
        text = location.userReadableName,
        icon = StandardIcons.HOTEL
    )
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.11&amp;show=file">Example 18.11 [open-to-sealed.6:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.11&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

Now `ItineraryItem.mapOverlay` doesn't appear to have changed at all:

// begin-insert: open-to-sealed.6:src/main/java/travelator/itinerary/ItineraryItem.kt#mapOverlay
[source,kotlin]
----
val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> mapOverlay
    is Attraction -> mapOverlay
    is Journey -> mapOverlay
    is RestaurantBooking -> mapOverlay
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.12&amp;show=file">Example 18.12 [open-to-sealed.6:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.12&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

Look closer, though (well, hover in IntelliJ), and we can see that those property accesses are now extension properties, not method calls—`Accommodation` and so on no longer depend on `MapOverlay`.
And now that `ItineraryItem.mapOverlay` and all the subclass properties are extensions, they don't need to be defined in the same file as the sealed classes.
We can move them to the module or package where they are used, and they won't clutter our core domain abstraction:

// begin-insert: open-to-sealed.7:src/main/java/travelator/geo/ItineraryToMapOverlay.kt#mapOverlay
[source,kotlin]
----
package travelator.geo

import travelator.itinerary.*

val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> mapOverlay
    is Attraction -> mapOverlay
    is Journey -> mapOverlay
    is RestaurantBooking -> mapOverlay
}

private val Accommodation.mapOverlay
    get() = PointOverlay(
        id = id,
        position = location.position,
        text = location.userReadableName,
        icon = StandardIcons.HOTEL
    )

 ... Attraction.mapOverlay etc
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.13&amp;show=file">Example 18.13 [open-to-sealed.7:src/main/java/travelator/geo/ItineraryToMapOverlay.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.13&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

We can do the same with the other members of `ItineraryItem`, until the sealed class declares only the fundamental properties of the type.
For `ItineraryItem` at the moment, only the `id` property is truly fundamental: declaring `id` as an abstract property on the sealed class forces every subclass to have an identifier.

Of the other properties, some are clearly there just to support specific features of the application, like `mapOverlay` and `toCalendar`.
Others, like `description`, are in a gray area: they support many features of the application, but are not a fundamental property of an `ItineraryItem`.
For example, each subtype derives its description from its fundamental properties.
Nat prefers to define properties like these as extensions, while Duncan prefers to define them as members of the class.
Nat is writing this example, so we'll make `description` an extension:

// begin-insert: open-to-sealed.8:src/main/java/travelator/itinerary/ItineraryDescription.kt
[source,kotlin]
----
val ItineraryItem.description: String
    get() = when (this) {
        is Accommodation ->
            "$nights nights at ${location.userReadableName}"
        is Attraction ->
            location.userReadableName
        is Journey ->
            "${departsFrom.userReadableName} " +
                "to ${arrivesAt.userReadableName} " +
                "by ${travelMethod.userReadableName}"
        is RestaurantBooking -> location.userReadableName
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.14&amp;show=file">Example 18.14 [open-to-sealed.8:src/main/java/travelator/itinerary/ItineraryDescription.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.14&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

You'll have to make your own judgment call in your own code.
That leaves the sealed `ItineraryItem` class declaring only the `id` property and its subclasses declaring their fundamental properties.
The whole hierarchy looks like this:

// begin-insert: open-to-sealed.8:src/main/java/travelator/itinerary/ItineraryItem.kt
[source,kotlin]
----
sealed class ItineraryItem {
    abstract val id: Id<ItineraryItem>
}

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Period.between(
        checkInFrom.toLocalDate(),
        checkOutBefore.toLocalDate()
    ).days
    val totalPrice: Money = pricePerNight * nights
}

data class Attraction(
    override val id: Id<Attraction>,
    val location: Location,
    val notes: String
) : ItineraryItem()

data class Journey(
    override val id: Id<Journey>,
    val travelMethod: TravelMethod,
    val departsFrom: Location,
    val departureTime: ZonedDateTime,
    val arrivesAt: Location,
    val arrivalTime: ZonedDateTime,
    val price: Money,
    val path: List<Position>,
    ... and other fields
) : ItineraryItem()

data class RestaurantBooking(
    override val id: Id<RestaurantBooking>,
    val location: Location,
    val time: ZonedDateTime
) : ItineraryItem()
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=18.15&amp;show=file">Example 18.15 [open-to-sealed.8:src/main/java/travelator/itinerary/ItineraryItem.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=18.15&amp;show=diff">(diff)</a> 
</div>
++++
// end-insert

Our `ItineraryItem` model is now a sealed class hierarchy of pure data classes.
The operations needed by the features of our application are all extension functions in the modules for those features.
Only the `id` property remains as a polymorphic `val`, because it is a fundamental property of the type that is not specific to any one feature of the application.((("", startref="OSCinter18")))((("", startref="SCinterf18")))((("", startref="Ringerf18")))

=== Moving On

As our software evolves, we have to add new data types and new operations to our system.
In Kotlin, as in Java, object-oriented polymorphism lets us easily add new data types without changing the code of existing functions.
We can also use sealed classes and safe runtime type checks to easily add new functions over existing data types without changing the code that defines those types.
Which we choose depends on what we expect to vary most frequently as the code evolves: data types or operations.
Managing variability in Kotlin involves mastering when to apply these two mechanisms to our domain models.

If our bet turns out to have been wrong, we must refactor from one to the other.
When all the code is in a single codebase, Kotlin and IntelliJ make refactoring between the two forms straightforward.
This chapter described going from the kind of object-oriented polymorphism we'd write in Java to Kotlin's sealed classes.
Going the other way involves refactoring steps described in Martin Fowler's <<F_RITDOEC_1999,_Refactoring: Improving the Design of Existing Code_>>, such as "Replace Conditional with Polymorphism," so we won't cover it in this book.
