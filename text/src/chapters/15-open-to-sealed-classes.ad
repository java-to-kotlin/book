[[open-to-sealed-classes]]
== Open to Sealed Classes

Our systems are composed of types and operations, nouns and verbs.
In Java, nouns are expressed as classes and interfaces, verbs as methods; but Kotlin adds sealed class hierarchies and free-standing functions.
What do they bring to the party?

=== Variability of Software

Change is a constant challenge in designing software.
The more people use our software, the more they think of things they want it to do.
To support new use cases we need to add new functions that work with existing data types, and new data types that work with existing functions.
If our design is well aligned with the way the software has to evolve, then we can add new features by adding new code and making few, localised changes to our existing code.
If it isn't well aligned, then we will have to change many functions when we add a new data type, or change many data types when we need to add a function.

We feel this tension between the variability of data types and of functions most keenly in the core entities of our domain model.
For example, the traveller's itinerary is a core entity of our Travelator application.
Many features of the application present views of, alter the contents of, or calculate information about, itineraries.
It's no surprise then that many of the feature requests from our users affect our `Itinerary` type.
Our travellers want to include more kinds of things in their itineraries: not just journeys and accommodation, as we saw in <<functions-to-extension-functions>>; but now restaurant bookings and attractions along the route.
They also want to do more things with their itineraries.
In <<accumulating-objects-to-transformations>> we saw how we estimate their cost, but our customers also want to compare them by cost, time or comfort, view them on a map, import them into their calendar, share them with their friends... their imagination is endless.

When we last looked at the `Itinerary` class, in <<accumulating-objects-to-transformations>>, we were modelling an itinerary as a data class, with a property for the route and another for the accommodation required along the route:

// begin-insert: tags/accumulator.12:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val route: Route,
    val accommodations: List<Accommodation> = emptyList()
) {
    ...
}
----
// end-insert

Since then, we have added more features to the application and hence more types of item to the itinerary.
We found it increasingly cumbersome to hold each type of itinerary item in a separate collection, because too much of our code involved combining those collections or applying the same filters and transforms to separate collections.
So we decided that an `Itinerary` would maintain a single collection of `ItineraryItem` rather than keep each type of item in a separate collection:

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/Itinerary.kt#itinerary
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val items: List<ItineraryItem>
) : Iterable<ItineraryItem> by items
----
// end-insert

`ItineraryItem` is an interface, implemented by the concrete item types we saw before: `Journey` and  `Accommodation`; and new types `RestaurantBooking` and `Attraction`:

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
interface ItineraryItem {
    val id: Id<ItineraryItem>
    val description: String
    val costs: List<Money>
    val mapOverlay: MapOverlay
    ... and other methods
}
----
// end-insert

Operations on `Itinerary` don't depend on the concrete type of its items.
For example, to display the itinerary on a map, we create a `MapOverlay` that will be rendered on top of map tiles in the front-end.
The overlay for an `Itinerary` is the group of the overlays for all the items it contains.
The `Itinerary` class and its clients don't know, or need to know, how each item represents itself as a map overlay.

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/Itinerary.kt#mapOverlay
[source,kotlin]
----
val Itinerary.mapOverlay
    get() = OverlayGroup(
        id = id,
        elements = items.map { it.mapOverlay })
----
// end-insert

This polymorphism makes it very easy to add new types of `ItineraryItem` to the system without having to change the parts of the application that use the `Itinerary` type.

For a while now though we haven't had to do that.
Recently we find that most of the new functionality we add to Travelator involves adding new operations to `Itinerary` and `ItineraryItem`, rather than new types of `ItineraryItem`.
Changes to the `ItineraryItem` interface and its implementations are a common source of merge conflicts between team members who are working on different features.
With every new feature, the `ItineraryItem` gets larger.
It seems to attract behaviour to support distantly related parts of the application, with properties to support rendering, cost estimation, ranking by comfort, drawing maps, and more hidden beyond that `... and other methods`.
Paradoxically, in the core of our application, object-oriented polymorphism is _increasing_ coupling!

// Reference the collections to type aliases example where we discuss coupling?

// Open/closed adding rather than changing code.
// Change risks breaking existing functionality
// Not to be confused with refactoring - changing code to get it to the place where a feature can be implemented as an addition.

Object-oriented polymorphism enables variability of data types with an infrequently changing set of operations.
For a while that was what our codebase needed, but now it has stabilised we need the opposite: variability of operations applied to an infrequently changing set of data types.

If we were writing in Java (at least up to Java 16), there is no language feature to help us cope with variability in this dimension.
Java's principal feature to support variability is object-oriented polymorphism, and that doesn't help when operations change more frequently than the set of data types.

We could use the https://wiki.c2.com/?DoubleDispatch[Double Dispatch] pattern, but it involves a lot of boilerplate code and, because it does not play well with checked exceptions, is not widely used in Java.
Instead, Java programmers often resort to runtime type checks, using the `instanceof` and downcast operators to run different code for different classes of object:

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/ItineraryItems.java#type_switch
[source,java]
----
if (item instanceof Journey) {
    var journey = (Journey) item;
    return ...
} else if (item instanceof Accommodation) {
    var accommodation = (Accommodation) item;
    return ...
} else if (item instanceof RestaurantBooking) {
    var restaurant = (RestaurantBooking) item;
    return ...
} else {
    throw new IllegalStateException("should never happen");
}
----
// end-insert

That `IllegalStateException` shows that this approach is risky.
While the compiler can type check our calls to polymorphic methods, our hand-coded runtime type checks and casts are explicitly circumventing compile-time checks.
The type checker cannot tell if our casts are correct or if our conditional statement is _exhaustive_ -- whether it applies to all possible subclasses.
If returning a value from the method, we have to write an `else` clause to return a dummy value or throw an exception, even if we have branches for every subclass of `ItineraryItem`, and the else clause "cannot possibly be executedâ„¢".

Even if we cover all the subtypes of `ItineraryItem` when we write the code, if we later add new types, we have to find all such code and update it.
It turns out that we didn't do that here -- so if we add an `Attraction` to an `Itinerary`, this code will fail with an `IllegalArgumentException`.
OO solves this problem, but we circumvented the solution because we were tired having to update lots of classes when we add an operation.

Type checking and downcasting are possible in Kotlin too, and carry the same overheads and risks.
However, Kotlin has another mechanism for organising classes and behaviour that makes runtime type checks safe and convenient: _sealed classes_.
A sealed class is an abstract class with a fixed set of direct subclasses.
We must define the sealed class and its subclasses in the same compilation unit and package; the compiler prevents us from extending the sealed class elsewhere.
Thanks to this restriction, runtime type checks on sealed class hierarchies do not have the same problem as runtime type checks in Java.
The static type checker can guarantee that `when` expressions that perform runtime type checks for a subtype of a sealed class cover all possible cases and only the possible cases.

// TODO insert example of safe kotlin when expression here?

Compared to polymorphic methods, sealed classes and `when` expressions make it easy to add new operations that apply to a fixed type hierarchy, although we still have to change all those operations if we add a new type to that hierarchy.
At this point the compiler will help us by checking that all those operations cover all possible types in the hierarchy.

=== Polymorphism or Sealed Classes?

Some languages have mechanisms that let us vary types _and_ operations without modifying existing code.
Haskell has type classes, Scala has implicit parameters, Rust has traits, Swift has protocols, and Clojure and Common Lisp have polymorphic functions that dispatch on the classes of multiple arguments.

Kotlin doesn't have any equivalent.
When we're designing in Kotlin, we have to choose between object-oriented polymorphism or sealed classes based on the dimension -- types or operations -- we expect to vary most frequently as the program evolves.
Object-oriented polymorphism is preferable when the set of data types varies more frequently than the set of operations on those data types; sealed class hierarchies when the set of operations varies more frequently than the set of data types they apply to.

=== Converting An Interface to a Sealed Class

We're about to add another feature that involves itineraries and itinerary items -- making the `Itinerary` appear in the traveller's calendar app.
We don't want to add more methods to the already bloated `ItineraryItem` interface and couple the core classes of our application's domain to the needs of another peripheral module.
It's time to bite the bullet and convert `ItineraryItem` from an interface of polymorphic methods to a sealed class hierarchy and free-standing functions, and move those free-standing functions into the modules that use them.

In the version of Kotlin we're using, a sealed class and all its direct subclasses must be defined in the same file.
Therefore, we must first use the IDE's Move Class refactoring to move the implementations of `ItineraryItem` into the same file as the interface.
Once we've done that, we can turn the interface and its implementations into a sealed class hieararchy.
IntelliJ does not have an automated refactoring for this, so we have to do it by manually editing the class definitions.
At least moving all the classes into the same file has made the task easier.

// begin-insert: tags/open-to-sealed-2.2:src/main/java/travelator/itinerary/ItineraryItem.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem { // <1>
    abstract val id: Id<ItineraryItem> // <2>
    abstract val description: String
    abstract val costs: List<Money>
    abstract val mapOverlay: MapOverlay
    ... and other methods
}

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() { // <3>
    val nights = Period.between(checkInFrom.toLocalDate(), checkOutBefore.toLocalDate()).days
    val totalPrice: Money = pricePerNight * nights

    override val description
        get() = "$nights nights at ${location.userReadableName}"
    override val costs
        get() = listOf(totalPrice)
    override val mapOverlay
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )

    ... and other methods
}

... and other subclasses
----
// end-insert

<1> We declare `ItineraryItem` as a `sealed class` instead of an `interface`.

<2> Because it is now a class, we have to explicitly mark its methods as `abstract`.  If the interface had any methods with a default implementation, we'd have had to declare them as `open` so that subclasses could still override them.

<3> We change the declaration of the interface in the concrete item classes with a call to the superclass constructor.

NOTE: Kotlin 1.5 will support sealed _interfaces_, which will make this refactoring easier -- these manual editing steps will not be necessary.

`ItineraryItem` is now a sealed class.
Its operations are still polymorphic methods, but we can write _new_ operations  without changing the `ItineraryItem` classes, by writing extension functions that use a `when` expression to safely dispatch on the concrete item type`.

We'll write the function we need to translate an itinerary to calendar events.
When we're done, we'll continue refactoring to make the other operations on `ItineraryItem` work the same way.

// begin-insert: tags/open-to-sealed-2.3:src/main/java/travelator/calendar/ItineraryToCalendar.kt
[source,kotlin]
----
fun Itinerary.toCalendar() = Calendar(
    id = Id.derivedFrom(this.id),
    events = mapNotNull { it.toCalendarEvent() }
)

private fun ItineraryItem.toCalendarEvent(): CalendarEvent? = when (this) {
    is Accommodation -> CalendarEvent(
        start = checkInFrom,
        end = checkOutBefore,
        description = description,
        alarms = listOf(
            Alarm(checkInFrom, "Check in open"),
            Alarm(checkOutBefore.minusHours(1), "Check out")
        )
    )
    is Attraction -> null
    is Journey -> CalendarEvent(
        start = departureTime,
        end = arrivalTime,
        description = description,
        location = departsFrom,
        alarms = listOf(
            Alarm(departureTime.minusHours(1)))
    )
    is RestaurantBooking -> CalendarEvent(
        start = time,
        description= description,
        location = location,
        alarms = listOf(
            Alarm(time.minusHours(1)))
    )
}
----
// end-insert

[TIP]
.Only typecast down a sealed class hierarchy
====
Only use typecasts to cast from the root of a sealed class hierarchy to one of the children in an exhaustive `when` expression.
Otherwise, it is risky to cast away from the static type.
The actual class used to implement a value may have operations that violate the constraints expressed by the static type.
For example, as we saw in <<java-to-kotlin-collections>>, the static type `List` prevents mutation, but Kotlin's higher-order functions return an object of a class that can be mutated if you downcast from `List` to `MutableList`.
Doing so will likely introduce bugs in code that does not expect a value of type `List` returned from a higher-order function to ever change.
====

Now, let's refactor the rest of the `ItineraryItem` methods from being polymorphic methods defined on the sealed class to extension functions that use `when` expressions to switch on the type of item.
We'll walk through the process with the `mapOverlay` property getter, which returns a representation of the Itinerary item to be drawn onto a map.

When we Alt-Enter on the definition of `mapOverlay` in `ItineraryItem`, the context menu includes the action "Convert member to extension".
Can it really be that easy?
Unfortunately, no.
At the time of writing, the IDE action only gets us part of the way there and leaves us with code that does not compile.

// begin-insert: tags/open-to-sealed-2.4:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
sealed class ItineraryItem {
    abstract val id: Id<ItineraryItem>
    abstract val description: String
    abstract val costs: List<Money> // <1>
    ... and other methods
}

val ItineraryItem.mapOverlay: MapOverlay // <2>
    get() = TODO("Not yet implemented")

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Period.between(checkInFrom.toLocalDate(), checkOutBefore.toLocalDate()).days
    val totalPrice: Money = pricePerNight * nights

    override val description
        get() = "$nights nights at ${location.userReadableName}"
    override val costs
        get() = listOf(totalPrice)
    override val mapOverlay // <3>
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )

    ... and other methods
}
----
// end-insert

<1> The IDE removed the mapOverlay method from the `ItineraryItem` class ...
<2> ... and replaced it with an extension function. Unfortunately the extension function only contains a `TODO` that throws `UnsupportedOperationException`.
<3> The IDE left `override` modifiers on the `mapOverlay` properties in the subclasses, which no longer have a method in the superclass to override.

We can get the code compiling again by removing the `override` modifiers in the subclasses.
Then we'll make the code actually work by implementing the body of an extension function as a `when` expression that switches on the type of `ItineraryItem` and calls the now monomorphic `mapOverlay` getter on each concrete class.

// begin-insert: tags/open-to-sealed-2.5:src/main/java/travelator/itinerary/ItineraryItem.kt#mapOverlay
[source,kotlin]
----
val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> mapOverlay
    is Attraction -> mapOverlay
    is Journey -> mapOverlay
    is RestaurantBooking -> mapOverlay
}
----
// end-insert

While we are writing the `when` expression, IntelliJ marks it as a type error until it covers all subclasses of `ItineraryItem`.
IntelliJ also highlights each monomorphic call to `mapOverlay` to show that the compiler's flow-sensitive typing is "smart casting" the `this` reference from `ItineraryItem` to the correct subclass.

[WARNING]
.When statements are not checked for exhaustiveness
====
The compiler checks `when` expressions for exhaustiveness but does not check `when` _statements_.
It considers a `when` to be a statement if the value of the entire `when` expression is never used.

You can force the compiler to check for exhaustiveness by using the value of the when statement, even though it is of type `Unit`.
If the `when` is the only statement in the body of a function, you can refactor the function to single-expression form.
If the body of the function has multiple statements and the `when` is the last statement, you can explicitly use its value with the `return` keyword.
If the `when` statement is in the middle of the function body you can extract it to its own function if that makes sense.
When none of those options apply, you can use the following utility function to use value of the `when` statement and force an exhaustiveness check:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_definition
[source,kotlin]
----
val <T> T.exhaustive get() = this
----
// end-insert

It can be used like this to make the compiler check a `when` statement for exhaustiveness:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_usage
[source,kotlin]
----
when (instanceOfSealedClass) {
    is SubclassA -> println("A")
    is SubclassB -> println("B")
}.exhaustive
----
// end-insert
====


We can inline those `mapOverlay` methods into the extension function, removing them from the concrete classes.

// begin-insert: tags/open-to-sealed-2.6:src/main/java/travelator/itinerary/ItineraryItem.kt#mapOverlay
[source,kotlin]
----
val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> PointOverlay(
        id = id,
        position = location.position,
        text = location.userReadableName,
        icon = StandardIcons.HOTEL
    )
    is Attraction -> PointOverlay(
        position = location.position,
        text = description,
        icon = StandardIcons.ATTRACTION,
        id = id
    )
    is Journey -> OverlayGroup(
        id = id,
        elements = listOf(
            PathOverlay(path, travelMethod.userReadableName),
            PointOverlay(departsFrom.position, departsFrom.userReadableName, StandardIcons.START),
            PointOverlay(arrivesAt.position, arrivesAt.userReadableName, StandardIcons.END)
        )
    )
    is RestaurantBooking -> PointOverlay(
        id = id,
        position = location.position,
        text = location.userReadableName,
        icon = StandardIcons.RESTAURANT
    )
}
----
// end-insert

Now that it is an extension property, `ItineraryItem.mapOverlay` does not need to be defined in the same file as the ItineraryItem class hierarchy.
We can move it and the `Itinerary.mapOverlay` properties to the module or package where we use it.

We can do the same with the other members of `ItineraryItem`, until the sealed class declares only the fundamental properties of the type.
For `ItineraryItem`, only the `id` property is truly fundamental.
It's useful to declare the `id` property as an abstract property on the sealed class to force every subclass to have an identifier.

Of the other properties, some are clearly there just to support specific features of the application, like `mapOverlay` and `toCalendar`.
Others, like `description`, are in a grey area: they support many features of the application, but are not a fundamental property of an `ItineraryItem`.
For example, each subclass derives its description from its fundamental properties.
Nat prefers to define properties like these as extensions, while Duncan prefers to define them as members of the class.
Nat is writing this example, so we'll make `description` an extension.
You'll have to make your own judgement call in your own code.
That leaves the sealed `ItineraryItem` class declaring only the `id` property, and its subclasses declaring their fundamental properties.
The whole hierarchy looks like this:

// begin-insert: tags/open-to-sealed-2.8:src/main/java/travelator/itinerary/ItineraryItem.kt
[source,kotlin]
----
sealed class ItineraryItem {
    abstract val id: Id<ItineraryItem>
}

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Period.between(checkInFrom.toLocalDate(), checkOutBefore.toLocalDate()).days
    val totalPrice: Money = pricePerNight * nights
}

data class Attraction(
    override val id: Id<Attraction>,
    val location: Location,
    val notes: String
) : ItineraryItem()

data class Journey(
    override val id: Id<Journey>,
    val travelMethod: TravelMethod,
    val departsFrom: Location,
    val departureTime: ZonedDateTime,
    val arrivesAt: Location,
    val arrivalTime: ZonedDateTime,
    val price: Money,
    val path: List<Position>,
    ... and other fields
) : ItineraryItem()

data class RestaurantBooking(
    override val id: Id<RestaurantBooking>,
    val location: Location,
    val time: ZonedDateTime
) : ItineraryItem()
----
// end-insert

Our `ItineraryItem` model is now a sealed class hierarchy of pure data classes.
We have implemented the operations needed by the features of our application as extension functions in the modules for those features.
Only the `id` property remains as a polymorphic `val`, because it is a fundamental property of the type that is not specific to any one feature of the application.

=== Conclusion

As our software evolves we have to add new data types and new operations to our system.
In Kotlin, as in Java, object-oriented polymorphism lets us easily add new data types without changing the code of existing functions.
We can also use sealed classes and safe runtime type checks to easily add new functions over existing data types without changing the code that defines those types.
Which we choose depends on what we expect to vary most frequently as the code evolves: data types or operations.
Managing variability in Kotlin involves mastering when to apply these two mechanisms to our domain models.

If our bet turns out to have been wrong, we must refactor from one to the other.
When all the code is in a single codebase, Kotlin and IntelliJ make refactoring between the two forms straightforward.
This chapter described going from the kind of object-oriented polymorphism we'd write in Java to Kotlin;s sealed classes.
Going the other way involves refactoring steps described in <<F_RITDOEC_1999,_Refactoring: Improving the Design of Existing Code_>>, such as _Replace Conditional with Polymorphism_, so we won't cover it in this book.
