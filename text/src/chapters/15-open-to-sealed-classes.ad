[[open-to-sealed-classes]]
== Open to Sealed Classes

Our systems are composed of types and operations, nouns and verbs.
In Java, nouns are expressed as classes and interfaces, verbs as methods.
Kotlin gives us other ways to combine these parts: free-standing functions, and sealed class hierarchies.
How do we choose between them?

=== Variability of Software

A constant challenge in designing software is _variability_.
The more people use our software, the more they think of things they want it to do.
To support new use cases we need to add new functions to our software that work with to its existing data types, or add new data types that work with its existing functions.
If our design is aligned well with the way the software has to evolve, then we can add a new features by adding new code and making very few, localised changes to our existing code.
If not, then we will have to change many functions when we add a new data type, or change many data types when we need to add a function.

We feel this tension between the variability of data types and of functions most keenly in the core entities of our application domain model.
For example, the traveller's itinerary is a core entity of our "Travelator" application.
Many features of the application present views of, alter the contents of, or calculate information about itineraries.
It's no surprise that many of the feature requests from our users affect the `Itinerary` type.
Our travellers want to include more kinds of things in their itineraries -- not just journeys and accommodation, as we saw in <<refactoring-to-extension-functions>>, but restaurant bookings and attractions along the route.
They also want to do lots of things with their itineraries -- estimate how much they will cost, as we saw in <<accumulating-objects-to-transformations>>, compare them by cost, time or comfort, view them on a map, import them into their calendar, share them with their friends, ... their imagination is endless.

When we last looked at the `Itinerary` class, in <<accumulating-objects-to-transformations>>, we were modelling an itinerary as a data class with a property for the route and another for the accommodation required along the route.
Since then, we have added more features to the application and added more types of item to the itinerary.
As the system evolved, we found it increasingly cumbersome to hold each type of itinerary item in a separate collection.
Too much of our code involved combining those collections or applying the same filters and transforms to separate collections.
Therefore, we decided that an `Itinerary` would maintain a single collection of `ItineraryItems` rather than keep each type of item in a separate collection:

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/Itinerary.kt#itinerary
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val items: List<ItineraryItem>
) : Iterable<ItineraryItem> by items
----
// end-insert

`ItineraryItem` is an interface, implemented by the concrete item types: `Journey`, `Accommodation`, `RestaurantBooking` and `Attraction`.

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
interface ItineraryItem {
    val id: Id<ItineraryItem>
    val description: String
    val costs: List<Money>
    val mapOverlay: MapOverlay
    ... and other methods
}
----
// end-insert

Operations on `Itinerary` do not depend on the concrete type of its items.
For example, to display the itinerary on a map, we create a map overlay that will be rendered on top of map tiles in the front-end.
The overlay for the itinerary is a group of the overlays for all the items it contains.
The `Itinerary` class and its clients don't know, or need to know, how each item represents itself as a map overlay.

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/Itinerary.kt#mapOverlay
[source,kotlin]
----
fun Itinerary.mapOverlay() = OverlayGroup(
    id = id,
    elements = items.map { it.mapOverlay })
----
// end-insert

This polymorphism makes it very easy to add new types of `ItineraryItem` to the system without having to change the parts of the application that use the `Itinerary` type.

However, we find that most of the new functionality we add to Travelator involves adding new operations to `Itinerary` and `ItineraryItem` rather than new types of `ItineraryItem`.
As a result, we change the `ItineraryItem` interface and its subtypes very often and they are a common source of merge conflicts between team members who are working on different features.
With every new feature, the `ItineraryItem` get larger.
The interface seems to "attract" behaviour to support distantly related parts of the application.
The interface has properties to support rendering, cost estimation, ranking by comfort, drawing maps, and more hidden beyond those elipsis.
Paradoxically, in the core of our application, object-oriented polymorphism is _increasing_ coupling!

// Reference the collections to type aliases example where we discuss coupling?

// Open/closed adding rather than changing code.
// Change risks breaking existing functionality
// Not to be confused with refactoring - changing code to get it to the place where a feature can be implemented as an addition.

Object-oriented polymorphism enables variability of data types with an infrequently changing set of operations.
In this case, we need variability of operations that can apply to an infrequently changing set of data types.

If we were writing in Java, we'd have exhausted the available language features to help us cope with variability.
Java's principal feature to support variability is object-oriented polymorphism.
It has no mechanism to support variability when the set of operations changes more frequently than the set of data types.

To ensure type safety we could consider https://wiki.c2.com/?DoubleDispatch[Double Dispatch], but this pattern involves a lot of boilerplate code and, because it does not play well with checked exceptions, is not widely used in Java.

As a result, Java programmers often resort to runtime type checks, using the `instanceof` and downcast operators, to run different code for different classes of object:

// begin-insert: tags/open-to-sealed-2.0:src/main/java/travelator/itinerary/ItineraryItems.java#type_switch
[source,java]
----
if (item instanceof Journey) {
    var journey = (Journey) item;
    return ...
} else if (item instanceof Accommodation) {
    var accommodation = (Accommodation) item;
    return ...
} else if (item instanceof RestaurantBooking) {
    var restaurant = (RestaurantBooking) item;
    return ...
} else {
    throw new IllegalStateException("should never happen");
}
----
// end-insert

This approach is risky.
While the compiler can type check our calls to polymorphic methods, our hand-coded runtime type checks and casts are explicitly circumventing compile-time type checks.
The type checker cannot tell if our casts are correct or if our conditional statement is _exhaustive_ -- has tested for all possible subclasses.
If returning a value from the method, we have to write an else clause to return a dummy value or throw an exception, even if we have branches for every subclass of `ItineraryItem` and the else clause cannot possibly be executed.
We might miss an existing subclass, or add a new case sometime later and not realise that we have to also update conditional statements in other classes.
In this example, we _have_ missed a subclass: our application will throw an exception when an Itinerary contains an `Attraction`: if we add an `Attraction` to an `Itinerary`, this code will fail with an `IllegalArgumentException`.
As a result, even if we get the code right when we write it, as we change our code it is easy to introduce bugs or leave dead code in the codebase that is hard to recognise and remove.

Those options are available in Kotlin too, and carry the same overheads and risks.
However, Kotlin has another mechanism for organising classes and behaviour that makes runtime type checks safe and convenient: _sealed classes_.
A sealed class is an abstract class with a fixed set of direct subclasses.
You must define the sealed class and its subclasses in the same source file, the compiler prevents you from extending the sealed class elsewhere footnote:[As an experimental feature, Kotlin 1.4 relaxes this restriction and allows sealed classes to be in different files in the same module and package.].
Thanks to this restriction, runtime type checks on sealed class hierarchies do not have the same problem as runtime type checks in Java.
The static type checker can guarantee that `when` expressions that perform runtime type checks for a subtype of a sealed class cover all possible cases and only the possible cases.

// TODO insert example of safe kotlin when expression here

Compared to polymorphic methods, sealed classes and when expressions make it easy to add new operations that apply to a fixed type hierarchy, but you will have to change all those operations if you add a new type to that hierarchy.
However, the compiler will help you by checking that all those operations cover all possible types in the hierarchy.

// TODO should this move to the conclusion?
Some languages have mechanisms that let us vary types _and_ operations without modifying existing code.
Haskell has type classes, Scala has implicit parameters, Rust has traits, Swift has protocols, and Clojure and Common Lisp have polymorphic functions that dispatch on the classes of multiple arguments.
Kotlin doesn't have any equivalent.
When we're designing in Kotlin, we have to choose between object-oriented polymorphism or sealed classes based on the dimension -- types or operations -- we expect to vary most frequently as the program evolves:
object-oriented polymorphism when the set of data types varies more frequently than the set of operations on those data types;
runtime type checks of sealed class hierarchies when the set of operations varies more frequently than the set of data types they apply to.

=== Converting the Interface to a Sealed Class

// TODO expand motivation here...
Want to export an Itinerary into the traveller's calendar app.
Don't want to add yet another methods to the `ItineraryItem` interface and couple the core classes of our application's domain to the needs of yet another of its peripheral modules.

Let's convert `ItineraryItem` from an interface with polymorphic methods into a sealed class hierarchy and free-standing functions, and move those free-standing functions into the modules that need them.

In the version of Kotlin we're using, a sealed class and all its direct subclasses must be defined in the same file.
So we must first use the IDE's Move Class refactoring to move the implementations of `ItineraryItem` into the same file as the interface.

Now we can turn the interface and its implementations into a sealed class hieararchy.
IntelliJ does not have an automated refactoring for this, so we have to do it by manually editing the code.
At least this is made easier by now having all the classes in the same file.

// begin-insert: tags/open-to-sealed-2.2:src/main/java/travelator/itinerary/ItineraryItem.kt#sealed
[source,kotlin]
----
sealed class ItineraryItem { // <1>
    abstract val id: Id<ItineraryItem> // <2>
    abstract val description: String
    abstract val costs: List<Money>
    abstract val mapOverlay: MapOverlay
    abstract val sufferScore: Int
    ... and other methods
}

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() { // <3>
    val nights = Period.between(checkInFrom.toLocalDate(), checkOutBefore.toLocalDate()).days
    val totalPrice: Money = pricePerNight * nights

    override val description
        get() = "$nights nights at ${location.userReadableName}"
    override val costs
        get() = listOf(totalPrice)
    override val mapOverlay
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )
    override val sufferScore
        get() = 0

    ... and other methods
}

... and other subclasses
----
// end-insert

<1> We declare `ItineraryItem` as a `sealed class` instead of an `interface`.

<2> Because it is now a class, we have to explicitly mark its methods as `abstract`.  If the interface had had any methods with a default implementation, we'd have had to declare them as `open` so that subclasses could still override them.

<3> We change the declaration of the interface in the concrete item classes with a call to the superclass constructor.

NOTE: Kotlin 1.5 will support sealed _interfaces_, which will make this refactoring easier -- these manual editing steps will not be necessary.

That's enough for us write a function to create calendar events from itinerary items without changing the `ItineraryItem` classes.
We'll do that now to get some immediate value, and continue refactoring to make the other operations on `ItineraryItem` work the same way.

// begin-insert: tags/open-to-sealed-2.3:src/main/java/travelator/calendar/ItineraryToCalendar.kt
[source,kotlin]
----
fun Itinerary.toCalendar() = Calendar(
    id = Id.derivedFrom(id),
    events = mapNotNull { it.toCalendarEvent() }
)

private fun ItineraryItem.toCalendarEvent(): CalendarEvent? = when (this) {
    is Accommodation -> CalendarEvent(
        start = checkInFrom,
        end = checkOutBefore,
        description = description,
        icon = StandardIcons.HOTEL,
        alarms = listOf(
            Alarm(checkInFrom, "Check in open"),
            Alarm(checkOutBefore.minusHours(1), "Check out")
        )
    )
    is Attraction -> null
    is Journey -> CalendarEvent(
        start = departureTime,
        end = arrivalTime,
        description = description,
        icon = StandardIcons.iconFor(travelMethod),
        location = departsFrom,
        alarms = listOf(
            Alarm(departureTime.minusHours(1)))
    )
    is RestaurantBooking -> CalendarEvent(
        start = time,
        end = time + Duration.ofHours(2),
        description= description,
        icon = StandardIcons.RESTAURANT,
        location = location,
        alarms = listOf(
            Alarm(time.minusHours(1)))
    )
}
----
// end-insert

Let's refactor the rest of the `ItineraryItem` methods from being polymorphic methods defined on the sealed class to extension functions that use `when` expressions to switch on the type of item.
We'll walk through the process with the `mapOverlay` property getter, which returns a representation of the Itinerary item to be drawn onto a map.

When we Alt-Enter on the definition of `mapOverlay` in `ItineraryItem`, the context menu includes the action "Convert member to extension".
Can it really be that easy?
Unfortunately, no.
At the time of writing, the IDE action only gets us part of the way there and leaves us with code that does not compile.

// TODO reproduce these steps on the new branch

// begin-insert: tags/open-to-sealed-2.4:src/main/java/travelator/itinerary/ItineraryItem.kt#item
[source,kotlin]
----
sealed class ItineraryItem {
    abstract val id: Id<ItineraryItem>
    abstract val description: String
    abstract val costs: List<Money> // <1>
    ... and other methods
}

val ItineraryItem.mapOverlay: MapOverlay // <2>
    get() = TODO("Not yet implemented")

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Period.between(checkInFrom.toLocalDate(), checkOutBefore.toLocalDate()).days
    val totalPrice: Money = pricePerNight * nights

    override val description
        get() = "$nights nights at ${location.userReadableName}"
    override val costs
        get() = listOf(totalPrice)
    override val mapOverlay // <3>
        get() = PointOverlay(
            id = id,
            position = location.position,
            text = location.userReadableName,
            icon = StandardIcons.HOTEL
        )

    ... and other methods
}
----
// end-insert

<1> The IDE removed the mapOverlay method from the `ItineraryItem` class ...
<2> ... and replaced it with an extension function. Unfortunately the extension function only contains a `TODO` that throws `UnsupportedOperationException`.
<3> The IDE left `override` modifiers on the `mapOverlay` properties in the subclasses, which no longer have a method in the superclass to override.

We can get the code compiling again by removing the `override` modifiers in the subclasses.
Then we'll make the code actually work by implementing the body of an extension function as a `when` expression that switches on the type of `ItineraryItem` and calls the now monomorphic `mapOverlay` getter on each concrete class.

// begin-insert: tags/open-to-sealed-2.5:src/main/java/travelator/itinerary/ItineraryItem.kt#mapOverlay
[source,kotlin]
----
val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> mapOverlay
    is Attraction -> mapOverlay
    is Journey -> mapOverlay
    is RestaurantBooking -> mapOverlay
}
----
// end-insert

While we are writing the `when` expression, Intellij marks it as a type error until it covers all subclasses of `ItineraryItem`.
Intellij also highlights each monomorphic call to `mapOverlay` to show that the compiler's flow-sensitive typing is "smart casting" the `this` reference from `ItineraryItem` to the correct subclass.

[WARNING]
.When statements are not checked for exhaustiveness
====
The compiler checks `when` expressions for exhaustiveness but does not check `when` _statements_.
It considers a `when` to be a statement if the value of the entire `when` expression is never used.

You can force the compiler to check for exhaustiveness by using the value of the when statement, even though it is of type `Unit`.
If the `when` is the only statement in the body of a function, you can refactor the function to single-expression form.
If the body of the function has multiple statements and the `when` is the last statement, you can explicitly use its value with the `return` keyword.
If the `when` statement is in the middle of the function body you can extract it to its own function if that makes sense.
When none of those options apply, you can use the following utility function to use value of the `when` statement and force an exhaustiveness check:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_definition
[source,kotlin]
----
val <T> T.exhaustive get() = this
----
// end-insert

It can be used like this to make the compiler check a `when` statement for exhaustiveness:

// begin-insert: src/main/java/exhaustive_when/ExhaustiveWhen.kt#exhaustive_val_usage
[source,kotlin]
----
when (instanceOfSealedClass) {
    is SubclassA -> println("A")
    is SubclassB -> println("B")
}.exhaustive
----
// end-insert
====


We can inline those `mapOverlay` methods into the extension function, removing them from the concrete classes.

// begin-insert: tags/open-to-sealed-2.6:src/main/java/travelator/itinerary/ItineraryItem.kt#mapOverlay
[source,kotlin]
----
val ItineraryItem.mapOverlay: MapOverlay get() = when (this) {
    is Accommodation -> PointOverlay(
        id = id,
        position = location.position,
        text = location.userReadableName,
        icon = StandardIcons.HOTEL
    )
    is Attraction -> PointOverlay(
        position = location.position,
        text = description,
        icon = StandardIcons.ATTRACTION,
        id = id
    )
    is Journey -> OverlayGroup(
        id = id,
        elements = listOf(
            PathOverlay(path, travelMethod.userReadableName),
            PointOverlay(departsFrom.position, departsFrom.userReadableName, StandardIcons.START),
            PointOverlay(arrivesAt.position, arrivesAt.userReadableName, StandardIcons.END)
        )
    )
    is RestaurantBooking -> PointOverlay(
        id = id,
        position = location.position,
        text = location.userReadableName,
        icon = StandardIcons.RESTAURANT
    )
}
----
// end-insert

Now that it is an extension property, `ItineraryItem.mapOverlay` does not need to be defined in the same file as the ItineraryItem class hierarchy.
We can move it and the `Itinerary.mapOverlay` properties to the module or package where we use it.

We can do the same with the other members of `ItineraryItem`, until the sealed class declares only the fundamental properties of the type.
For `ItineraryItem`, only the `id` property is truly fundamental.
It's useful to declare the `id` property as an abstract property on the sealed class to force every subclass to have an identifier.
Of the other properties, some are clearly there just to support specific features of the application, like `mapOverlay` and `toCalendar`.
Others, like `description`, are in a grey area: they support many features of the application, but are not a fundamental property of an `ItineraryItem`.
For example, each subclass derives its description from its fundamental properties.
Nat prefers to define properties like these as extensions, while Duncan prefers to define them as members of the class.
You'll have to make your own judgement call.

When we have converted all polymorphic members of the sealed class hierarchy to extensions, the `ItineraryItem` hiearchy looks like this:

// begin-insert: tags/open-to-sealed-2.8:src/main/java/travelator/itinerary/ItineraryItem.kt
[source,kotlin]
----
sealed class ItineraryItem {
    abstract val id: Id<ItineraryItem>
}

data class Accommodation(
    override val id: Id<Accommodation>,
    val location: Location,
    val checkInFrom: ZonedDateTime,
    val checkOutBefore: ZonedDateTime,
    val pricePerNight: Money
) : ItineraryItem() {
    val nights = Period.between(checkInFrom.toLocalDate(), checkOutBefore.toLocalDate()).days
    val totalPrice: Money = pricePerNight * nights
}

data class Attraction(
    override val id: Id<Attraction>,
    val location: Location,
    val notes: String
) : ItineraryItem()

data class Journey(
    override val id: Id<Journey>,
    val travelMethod: TravelMethod,
    val departsFrom: Location,
    val departureTime: ZonedDateTime,
    val arrivesAt: Location,
    val arrivalTime: ZonedDateTime,
    val price: Money,
    val path: List<Position>,
    ... and other fields
) : ItineraryItem()

data class RestaurantBooking(
    override val id: Id<RestaurantBooking>,
    val location: Location,
    val time: ZonedDateTime
) : ItineraryItem()
----
// end-insert

[TIP]
.Only typecast down a sealed class hierarchy
====
Only use typecasts to cast from the root of a sealed class hierarchy to one of the children in an exhaustive when expression.
Otherwise, it is risky to cast away from the static type.
The actual class used to implement a value may have operations that violate the constraints expressed by the static type.
For example, as we saw in <<java-to-kotlin-collections>>, the static type `List` prevents mutation, but Kotlin's higher-order functions return an object of a class that can be mutated if you downcast from `List` to `MutableList`.
Doing so will likely introduce bugs in code that does not expect a value of type `List` returned from a higher-order function to ever change.
====


=== Conclusion

As our software evolves we have to add new data types and new operations to our system.
In Kotlin, as in Java, object-oriented polymorphism lets us easily add new data types without changing the code of existing functions.
We can also used sealed classes and safe runtime type checks to easily add new functions over existing data types without changing the code that defines those types.
Managing variability in Kotlin means mastering when to apply these two mechanisms to our domain models.

Which to choose depends on what we expect to vary most frequently as the code evolves: data types or operations.

When modelling our domain we have to make a choice whether operations will be dispatched by object-oriented polymorphism or by testing for subtypes of a sealed class.
If our bet turns out to have been wrong, we have to refactor from one form to the other.

