[[performing-io-to-passing-data]]
== Performing I/O to Passing Data

++++
<blockquote data-type="epigraph">
<p>Input and output are problematic in code.
Our program is subject to errors talking to the outside world when files disappear or network sockets fail.
I/O is also an action and so limits our ability to reason with and refactor our code.
How can we limit the scope of the problems that I/O causes?</p>
</blockquote>
++++

Now that earlier chapters have built some foundations, we're going to up the pace here, going straight into refactoring and learning lessons as we go.

=== Listening to Tests

In((("performing I/O to passing data", "listening to tests"))) <<functions-to-extension-functions>>, we looked at some Java code that produced a report for marketing.
When we left the code, we had introduced extension functions to the ++HighValue&#x200b;Custo&#x2060;mersReport++, giving us:

// begin-insert: io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#all
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.0/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Here are the tests after conversion to Kotlin:

// begin-insert: io-to-data.1:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#all
[source,kotlin]
----
class HighValueCustomersReportTests {

    @Test
    fun test() {
        check(
            inputLines = listOf(
                "ID\tFirstName\tLastName\tScore\tSpend",
                "1\tFred\tFlintstone\t11\t1000.00",
                "4\tBetty\tRubble\t10\t2000.00",
                "2\tBarney\tRubble\t0\t20.00",
                "3\tWilma\tFlintstone\t9\t0.00"
            ),
            expectedLines = listOf(
                "ID\tName\tSpend",
                "4\tRUBBLE, Betty\t2000.00",
                "1\tFLINTSTONE, Fred\t1000.00",
                "\tTOTAL\t3000.00"
            )
        )
    }

    ...
    private fun check(
        inputLines: List<String>,
        expectedLines: List<String>
    ) {
        val output = StringWriter()
        generate(
            StringReader(inputLines.joinToString("\n")),
            output
        )
        assertEquals(expectedLines.joinToString("\n"), output.toString())
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.1/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.1:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

We didn't really look at the tests in <<functions-to-extension-functions>>, but if we do now, what stands out in the light of your authors' obsession with actions and calculations (<<actions-to-calculations>>)?
In particular, look at that((("check function"))) `check` function.

`check` is evidently not a calculation (<<calculations>>), because it works entirely by throwing an exception instead of returning a value.
What if we look at it this way though?

// begin-insert: io-to-data.2:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    val reader = StringReader(inputLines.joinToString("\n"))
    generate(reader, output)
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.2/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.2:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

This is for all intents and purposes the same code, but now we can see that we have a calculation, taking `inputLines` and yielding `outputLines`, before we go on to the assertion.
Even though `generate` is an action, relying on the side effects of reading and writing to and from its parameters, we can convert it to a calculation by limiting the scope of its side effects to local variables.

If we stop for a moment and listen, we can hear the tests talking to us.
They are saying, "Look, that report generation is fundamentally a calculation: it converts a `List<String>` to a `List<String>`.
We know it does, because that's what we are checking."

So the tests are telling us that the fundamental signature of `generate` is [.keep-together]#++generate(lines: List<String>): List<String>++#.
If _this_ was the signature, then it would not have to declare that it throws `IOException` either, because all the I/O would happen outside the function.
I/O has to happen somewhere, but, in common with other actions, the closer to the entry points of our system we can move it, the more we can deal in nice easy calculations.

Shall we refactor toward this goal?
You're right, that was a rhetorical question.

=== I/O to Data

As((("performing I/O to passing data", "I/O to data", id="PIOiotodata20")))((("refactoring", "I/O to data", id="Rio20"))) the first stage in our refactor, let's try to wean `generate` off its `reader` parameter.
The code is currently:

// begin-insert: io-to-data.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.3/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

We can convert `generate` to read from a `List` by invoking "Introduce parameter" on the `reader.readLines()` expression, naming the parameter `lines`.
Because the expression is the only use of the existing `reader` parameter, IntelliJ removes `reader` for us:

// begin-insert: io-to-data.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.4/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

The refactoring has moved the `readLines()` out into the callers; here is the result in test:

// begin-insert: io-to-data.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    val reader = StringReader(inputLines.joinToString("\n"))
    generate(output, reader.readLines())
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.4/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

This now shouts what the test was whispering all along.
We were having to create a `StringReader` from a list of lines just to parse the lines back out in `generate`.
Now that the steps are in the same place in the test, we can elide them to remove the `Reader`:

// begin-insert: io-to-data.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    generate(output, inputLines)
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.5/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

We are now reading from a `List`.
Let's go back and look at how to return a `List` too, rather than modifying the `Writer`.
Here is the code:

// begin-insert: io-to-data.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#writer
[source,kotlin]
----
writer.appendLine("ID\tName\tSpend")
for (customerData in valuableCustomers) {
    writer.appendLine(customerData.outputLine)
}
writer.append(valuableCustomers.summarised())
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.5/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Instead of thinking imperatively about the ways that we want to mutate the writer, let's think in terms of the data that we want written and create that:

// begin-insert: io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#resultLines
[source,kotlin]
----
val resultLines = listOf("ID\tName\tSpend") +
    valuableCustomers.map(CustomerData::outputLine) +
    valuableCustomers.summarised()
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.6/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Then we can write it in one lump to `writer`:

// begin-insert: io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    val resultLines = listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
    writer.append(resultLines.joinToString("\n"))
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.6/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

This function is now two statements that make up a calculation, and a final action taking the result of the calculation.
If we now "Extract function" with the calculation lines, making it public and calling it `generate` too, we get the following:

// begin-insert: io-to-data.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val resultLines = generate(lines)
    writer.append(resultLines.joinToString("\n"))
}

fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    val resultLines = listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
    return resultLines
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.7/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Inlining both vestigial `resultLines` gives:

// begin-insert: io-to-data.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    writer.append(generate(lines).joinToString("\n"))
}

fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.8/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

One more inline then, this time of the old `generate` function.
That replaces its invocation in client code, leaving this in the test:

// begin-insert: io-to-data.9:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter()
    output.append(generate(inputLines).joinToString("\n"))
    val outputLines = output.toString().lines()

    assertEquals(expectedLines, outputLines)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.9/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.9:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

This refactor has moved the action part of `generate` out a level, leaving the nice pure calculation bits in its place.
Another way of looking at this is that our original `Writer` was an accumulating object, which we have replaced with a transformation, as we saw in <<accumulating-objects-to-transformations>>.
Our tests didn't really want to be testing an action anyway, so they again have redundant I/O, which we can simplify to the form we were aiming for:

// begin-insert: io-to-data.10:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(expectedLines, generate(inputLines))
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.10/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.10:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

Let's take stock of our new `generate`:

// begin-insert: io-to-data.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.11/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Now that `generate` is doing so much less, it isn't clear that the function `toValuableCustomers()` is worthwhile.
Looking at it afresh, we see that it is working at mixed levels, converting and filtering.
Let's try inlining it:

// begin-insert: io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.12/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

That's better.
The local variable `valuableCustomers` does a good job of telling us what the expression means, and the list operations spell out the implementation in place.
This function is a case where a single-expression function (<<multi-to-single-expression-functions>>) would probably make things worse, so we'll leave it in two parts.
We'll also continue to resist the temptation to make it an extension function, `List<String>.toReport()`, at least for now.((("", startref="PIOiotodata20")))((("", startref="Rio20")))

.Refactoring for Readability
****
Refactoring((("refactoring", "for readability", secondary-sortas="readability")))((("performing I/O to passing data", "refactoring for readability"))) for readability is often this way.
We might extract a function to make something more readable in context, but when the context changes, the function we extracted makes things worse.
Time is also a context.
Sometimes something that we felt was quite expressive when we wrote it turns out to be less so when we read it back later, or could now be improved because we have internalized new idioms.
****

=== Efficient Writing

We're((("performing I/O to passing data", "efficient writing", id="PIOwrit20"))) quite pleased with this refactor.
It has simplified our tests and the production code, and we have moved from mixing I/O and logic to a simpler calculation with no side effects.

For((("OutOfMemoryError")))((("error handling", "OutOfMemoryError"))) a while, all is fine in production too, but with the easing of COVID-19 travel restrictions, Travelator becomes the roaring success that we all knew it would be.
Eventually, though, the lovely people in marketing start complaining that the report generation is failing with an `OutOfMemoryError`.
Could we look into it?

(Apart from running out of memory, we have had two other issues with errors in this code in living memory.
Both these times, the input file turned out to have been malformed, but marketing sit next door and just call us over to help if these occur.
They feed us cake in these cases, so we're hardly incentivized to do a better job of error handling for now (but see <<exceptions-to-values>>).
If we can fix the `OutOfMemoryError` quickly, we think we saw some crumpets...)

We haven't bothered you with the details so far, but there is a `main` method that invokes our report.
It is designed to be invoked with shell redirection, reading from a file piped as the standard input and writing to a file collected from the standard output.
This way, our process doesn't have to read filenames from the command line:

// begin-insert: io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    InputStreamReader(System.`in`).use { reader ->
        OutputStreamWriter(System.out).use { writer ->
            generate(reader, writer)
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.0/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.0:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

When we refactored `generate` to work with ++List++s rather than a `Reader` and `Writer`, IntelliJ automatically updated `main` to yield:

// begin-insert: io-to-data.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.append(
                generate(
                    reader.readLines()
                ).joinToString("\n")
            )
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.9/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

Ah, there's our problem.
We're reading the whole of the input into memory (`readLines()`), processing it, and then creating the entire output in memory (`joinToString()`) before writing it back out.

We sometimes run into problems like these with((("functional decomposition"))) functional decomposition.
In this case the original `Reader` and `Writer` code did not have this issue, so we have brought it on ourselves in the name of good style.
We could quickly revert our changes and go and see whether there are any crumpets left, or we could find a more functional solution.

Let's go back to `generate` and see what leeway we have:

// begin-insert: io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.12/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Concentrating on the output for now, we can see that we are building a `List` of the lines of the output;
`main` then takes each `String` in the result and creates one giant one with `joinToString()`.
At this point both the individual output lines and their conglomerate will be taking up memory.
To avoid running out of memory, we'll need to defer the creation of the intermediate collections, and, as we saw in <<streams-to-sequences>>, ++Sequence++s are designed for just that.

We can convert `generate` to return a `Sequence` methodically or quickly.
For once, we'll choose quickly and just replace `listOf` with `sequenceOf` in our `return` expression:

// begin-insert: io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.13/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

Now we will only be creating the output lines one at a time when the `Sequence` is iterated; each line can be disposed of quickly rather than hanging around until we have written the whole file.

The tests have to change to convert the returned `Sequence` to a `List`:

// begin-insert: io-to-data.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(
        expectedLines,
        generate(inputLines).toList()
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.13/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

Interestingly, though, `main` does not:

// begin-insert: io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.append(
                generate(
                    reader.readLines()
                ).joinToString("\n")
            )
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.13/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

`main` needs((("recompilation"))) to be _recompiled_ now that `generate` returns a `Sequence` rather than a `List`, but its _source_ doesn't need to be changed.
This is because there are extension functions `joinToString()` defined on both `Iterable` and `Sequence`, both returning `String`.

It might not _need_ to change, but unless `main` _does_ change, we are still creating one large string of all the output before writing it in one operation.
To avoid that, we need to get imperative again and write each output line individually, as our original `generate` had done:

// begin-insert: io-to-data.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            generate(
                reader.readLines()
            ).forEach { line ->
                writer.appendLine(line)
            }
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.14/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

The pedantic reader (don't worry, you're among friends) will have spotted that this behavior is subtly different from the `joinToString("\n")` version.
We're quietly confident that a trailing newline won't break anything, so we press on.

We can always pretend we aren't looping by hiding the iteration inside a `Writer::appendLines` extension function that we assumed the Kotlin standard library would define, but doesn't seem to:

// begin-insert: io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(reader.readLines())
            )
        }
    }
}

fun Writer.appendLines(lines: Sequence<CharSequence>): Writer {
    return this.also {
        lines.forEach(this::appendLine)
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.15/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

Note that although the definition of `Writer::appendLines` is a single expression, we agreed in <<multi-to-single-expression-functions>> to use the long form where functions are actions, and `appendLines` is definitely that.

Now that we are here, we realize that we could have postponed our memory crisis by just iterating over the original result `List` in `main`, writing each line individually, as we are doing now with the `Sequence`.
This solution will use even less memory, though, so we'll commit it, having bought ourselves lots of headroom with few changes and earned our crumpets.
Is there any butter?((("", startref="PIOwrit20")))

=== Efficient Reading

We((("performing I/O to passing data", "efficient reading", id="PIOread20"))) would be remiss if we didn't finish the job and pretend that we also need to save memory on reading too.
Let's look at `generate` again:

// begin-insert: io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.15/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

The pipeline of operations that builds `valuableCustomers` will build intermediate ++List++s: one for each stage, and each taking up memory.
Every line in the input is going to be in memory at once, along with a `CustomerData` object for every line.

We can avoid the intermediate collections by reading from a `Sequence`, although that will bring a few problems of its own.
We can see this if we change the code in `generate` to convert the `lines` to a `Sequence` and fix up the methods that did take `List`:

// begin-insert: io-to-data.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers: Sequence<CustomerData> = lines
        .asSequence()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun Sequence<String>.withoutHeader() = drop(1)

private fun Sequence<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.16/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

This passes the unit tests.
Are we done?
Is this another rhetorical question?

We'll cut to the chase and say that the issue is that we end up iterating over `valuableCustomers` twice, once _before_ we return from `generate` in that `sumByDouble`, and again _after_ we return, when our callers iterate over the returned `Sequence` to print the report.
If we iterate over a `Sequence` twice, we do all the work of creating the `Sequence` twice, in this case: removing the header and mapping and filtering and sorting twice.
Worse, when we try to use the code in production, passing a `Sequence` reading standard input, we won't be able to iterate over that twice, giving an `IllegalStateException`.
As we saw in <<streams-to-sequences>>, instances of `Sequence` differ in ways that aren't expressed in the type system, and they also carry hidden state.
Iterating over a `Sequence` looks like iterating over a `List` but will change the `Sequence` itself by consuming its contents.

We can show that we are abusing this `Sequence` by adding a `.constrainOnce()` call:

// begin-insert: io-to-data.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
    val valuableCustomers: Sequence<CustomerData> = lines
        .asSequence()
        .constrainOnce()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.17/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

This will cause our tests to fail with an `IllegalStateException`.
The simplest fix is to resolve the `Sequence` with a `.toList()` call:

// begin-insert: io-to-data.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
    val valuableCustomers: List<CustomerData> = lines
        .asSequence()
        .constrainOnce()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.18/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

This terminates the sequence (and hence ultimately reads the whole file) in that statement, but at least we run the pipeline only once, and the memory for each line can be discarded as soon as it is parsed `toCustomerData`.
We will in fact have to read through the whole input in this function anyway, because `Sequence.sortedBy` needs to read every item to perform the sort—it may return a `Sequence`, but it isn't lazy.

Now we can replay the "Introduce parameter" refactoring we used at the beginning of this chapter.
There we converted a `Reader` parameter into a `List`; now we convert the `List` to a `Sequence`.
The parameter we introduce is the expression `lines.asSequence().constrainOnce()`:

// begin-insert: io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: Sequence<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.19/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

The refactoring pulls the conversion of the `List` to the `Sequence` up into the tests:

// begin-insert: io-to-data.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(
        expectedLines,
        generate(
            inputLines.asSequence().constrainOnce()
        ).toList()
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.19/src/test/java/travelator/marketing/HighValueCustomersReportTests.kt">
        io-to-data.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt
    </a>
</div>
++++
// end-insert

It also pulls it up into `main`:

// begin-insert: io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(
                    reader.readLines().asSequence().constrainOnce()
                )
            )
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.19/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

This is where we are really able to save memory.
Instead of reading all the lines at once and converting to a `Sequence`, we can get a `Sequence` from the `Reader` with `buffered().lineSequence()`:

// begin-insert: io-to-data.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(
                    reader.buffered().lineSequence()
                )
            )
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.20/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

Now `generate` will be pulling the lines into memory one by one as it executes its pipeline.
We're now really quite efficient in our use of memory and run pleasingly quickly.
Can we resist one last tinker?
How much nicer would `main` read with more extension functions?

// begin-insert: io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            reader
                .asLineSequence()
                .toHighValueCustomerReport()
                .writeTo(writer)
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.21/src/main/java/travelator/marketing/HighValueCustomersMain.kt">
        io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersMain.kt
    </a>
</div>
++++
// end-insert

Which finally answers the question we posed back at the end of <<functions-to-extension-functions>>: yes, we do end up with report generation as an extension function.
We love it when a plan comes together:

// begin-insert: io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://github.com/java-to-kotlin/code/blob/io-to-data.21/src/main/java/travelator/marketing/HighValueCustomersReport.kt">
        io-to-data.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt
    </a>
</div>
++++
// end-insert

=== Moving On

This((("", startref="PIOread20"))) refactoring was motivated by a desire to simplify our code.
By moving I/O to the entry point of our program, the inner workings can be calculations rather than actions.
They can also abdicate responsibility for I/O errors.
That was all well and good, but calculations take and return values, and forming a value of the entire contents of large files is sometimes too much for even today's computers.

To solve this problem, we resorted to converting our ++List++s to ++Sequence++s.
Sequences have state and are not values, but with a little care we can treat them like lazy values—lazy in that they don't require or return all their contents up front, but can read or supply them on demand.
They aren't as simple as lists, but their compatible Kotlin API allows something of the best of both worlds.

Our original `Reader` to `Writer` version of `generate` had to worry about I/O errors, whereas the `List` to `List` version moved all I/O to its callers.
The `Sequence` version is in a middle ground.
It doesn't worry about I/O errors because they are hidden from it by the `Sequence` abstractions wrapping the `Reader` and `Writer`.
That doesn't mean that they can't happen, just that `generate` isn't responsible for them.
We'll take a break to see whether our colleagues in marketing have any more batter-based rewards before addressing that topic in pass:[<a data-type="xref" data-xrefstyle="chap-num-title" href="#exceptions-to-values">#exceptions-to-values</a>].
