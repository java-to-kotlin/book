[[java-to-kotlin-collections]]
== Java To Kotlin Collections

On the face of it, Java and Kotlin have very similar collections libraries: they certainly interoperate suspiciously seamlessly.
What are the differences, what motivates them, and where do we have to take care as we move from Java to Kotlin collections?

In the last chapter <<beans-to-values>>, we discussed how Java grew up in the days when we saw objects as fundamentally stateful and mutable.
This was particularly true for collections - I mean, what is the point of a list if you can't add to it?
We built collections by creating an empty object and adding to it.
Need to remove an item from a shopping cart? - mutate the list.
Shuffle a pack of cards? - obviously that changes the order of the deck.
We wouldn't create a new paper list of TODOs every time we remembered we need milk or took the cat to the vet -
mutable collections mirror our real world experience.

=== Java 1.0 Collections

On its release, the quality of its built-in collections was a major reason to adopt Java.
In those days many languages had no resizable collections, and even C++ had no standard Map class.
Object encapsulation was the technology that allowed us to build mutable collections safely.
It was only natural to make use of this superpower now it had been given to us, so we went ahead and used `Vector` and `HashTable` as Sun intended.

Java 1.0 had no generics, so collections just held ++Object++s which had to be downcast to be useful.
So we learned to wrap the standard collections in a class that would perform the cast for us:

// begin-insert: tags/java-to-kotlin-collections.0:src/main/java/travelator/Route.java
[source,java]
----
public class Route {
    private final Vector journeys = new Vector();

    public int size() {
        return journeys.size();
    }

    public Journey elementAt(int index) {
        return (Journey) journeys.elementAt(index);
    }

    public void addJourney(Journey journey) {
        journeys.add(journey);
    }

    public Location getDepartsFrom() {
        return elementAt(0).getDepartsFrom();
    }
}
----
// end-insert

As well as providing the downcast, this wrapper class was helpful in two other ways.
Firstly, it allowed us to restrict the mutability of the collection.
In the Route example, a raw `Vector` would have exposed operations like `insertElementAt` and `removeElement` which might not be appropriate to our abstraction.
In the case where we wanted an immutable `Route`, we could supply all its ++Journey++s to the constructor and not provide any mutators at all.
Secondly, the wrapper is a convenient place to define operations like `getDepartsFrom`.
This isn't applicable to a `Vector` of any ++Object++s, just ++Journey++s.
Armed with a variable of type `Route`, even the early Java IDEs were smart enough to pop up the messages that could be sent, so clients could see the operations applicable to their collection rather than hunting around a namespace looking for suitable functions.
This is a major selling point of statically-typed object orientation - the code practically writes itself.

=== Java 2 Collections

Java 2 footnote:[which was known as 1.2 until Java had to compete with C# version numbers] introduced generics, and with them a revised collections library.
Generics removed the need to downcast objects retrieved from a collection.

// begin-insert: tags/java-to-kotlin-collections.1:src/main/java/travelator/Route.java
[source,java]
----
public class Route {
    private final List<Journey> journeys = new ArrayList<>(); // <1>

    public int size() {
        return journeys.size();
    }

    public Journey elementAt(int index) {
        return journeys.get(index); // <2>
    }

    public void addJourney(Journey journey) {
        journeys.add(journey);
    }

    public Location getDepartsFrom() {
        return elementAt(0).getDepartsFrom();
    }
}
----
// end-insert

<1> The diamond `<>` was only added by Java 7
<2> Generics mean that we don't have to cast the result of `get`

Generics might allow us to use the unwrapped `List<Journey>` in place of a wrapper class, except that we still need a place to add operations like `getDepartsFrom`, and a way to restrict the mutability to the single `addJourney` method.

.Collections and Variance
****
If we have subclasses of Journey, using `List<Journey>` rather than a wrapper becomes complicated because of issues of co- and contra-variance.

We'll skip over the details here, but the net result of the design of Java generics is that users of a collection have to decide whether to treat it as read-only or write-only.
In the read-only case we can pass a `List<TrainJourney>` to a function expecting a `List<? extends Journey>`, but inside the function the list can only ever be read from.
In the write-only case we can pass a `List<Journey>` to a function expecting `List<? super TrainJourney>`, which can only ever write to the list.
The problem is that `List` has both read and write operations, the compiler error messages are cryptic, and the poor user of the collections API is left to decide rather than the author of the API.
****

These issues with using an unwrapped collection: where to define specific operations; how to restrict mutability; and banging one's head against the variance wall in a vain attempt to get something, anything, to compile; led to it being the exception rather than the rule for Java developers to write functions that used unwrapped collections rather than classes like `Route`.
Which is a shame, because it turns out that treating `Route` as `List<Journey`> would be very nice for clients who wanted to print its contents, or find the longest train `Journey`, or any operation that the writers of `Route` didn't anticipate or feel was fundamental to the abstraction that they were creating.

We could allow clients to define their own operations based on the underlying collection, _and_ have a place to host specific methods, if we defined a wrapper class `Route` that implemented `List<Journey>`.
If we try to do this, we find that `List`, even for Java 2, is quite a broad interface - we end up writing a lot of methods that just delegate to the underlying `journey` field.
Making `Route` extend `ArrayList<Journey>` simplifies things, and your authors have certainly written classes like this in their careers.

// begin-insert: tags/java-to-kotlin-collections.2:src/main/java/travelator/Route.java
[source,java]
----
public class Route extends ArrayList<Journey> {

    public Location getDepartsFrom() {
        return get(0).getDepartsFrom();
    }
}
----
// end-insert

The problem with this implementation is that `Route` is now mutable: really mutable.
Pass a reference to a `Route` to your rendering code, and it can come back empty.
Actually empty is unlikely - only a determined developer would clear a `Route` as part of rendering it, but sorting by length of `Journey` or filtering to contain just the refundable portions is exactly the sort of thing that rendering code would do.
Who can blame the developer who was given a reference and called methods on its interface to do their job?

You only have to spend several hundred hours debugging the problems caused by issues like this to come to the conclusion that maybe immutable collections (actually immutable objects full stop) might be a better default.
In Java this point evidently came after the introduction of Java 2, and so we have forever been stuck with mutable collections interfaces.

=== Immutable Collections

It is of course possible to define your own immutable collections interfaces to solve this problem; what you can't do is to ask the JDK collections to implement them.
Java developers who wanted immutable collections compatible with the JDK would have to to compromise.
The lowest end is to implement `Iterable`.

// begin-insert: tags/java-to-kotlin-collections.3:src/main/java/travelator/Route.java
[source,java]
----
public class Route implements Iterable<Journey> {

    private final List<Journey> journeys;

    public Route(Collection<Journey> journeys) {
        this.journeys = List.copyOf(journeys);
    }

    public int size() {
        return journeys.size();
    }

    @Override
    public Iterator<Journey> iterator() {
        return journeys.iterator();
    }

    public Location getDepartsFrom() {
        return journeys.get(0).getDepartsFrom();
    }

    // <1>
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Route journeys1 = (Route) o;
        return journeys.equals(journeys1.journeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(journeys);
    }
}
----
// end-insert

<1> Because `Route` is now an immutable value type, as we discussed in <<beans-to-values>>, equality has a simple semantic, and so we can now implement `equals` and `hashCode`.

Here `Route` has to be completely initialised in its constructor, in this case from any other `Collection` of ++Journey++s.
Unfortunately, because that `Collection` may be mutable, we have to take a defensive copy of its items if `Journey` is to be truly immutable.
In fact, even as defined here `Route` is not entirely immutable in the typesystem, as the `Iterator` it yields has a mutator method - `remove`.
So we have a class whose interface is almost immutable, except for one second-order operation.
Luckily for us, the `List` returned by `List.copyOf` is 'safe' and will throw an `UnsupportedOperationException` at runtime if we attempt to call `remove` on its iterator.

It all goes to show that you have to be very careful if you want to make sure that your Java objects are not subject to subtle mutation.
In fact, that `List.copyOf` method only appeared in Java 10 - prior to that the path of least resistance would have been to write `this.journeys = new ArrayList<>(journeys);` safe in the knowledge that no operations in `Route` mutated the list; but unsafe in the reality that anyone with the `Iterator` could.

In this definition we have taken the pragmatic approach of exposing `size` as a `Route` property, but not allowing random access to elements with `get(int)`.
The size of a collection is often really useful when we're rendering and the like, and isn't available through the `Iterator.
The `Iterator` is enough though to allow common operations like `map` or `filter` through https://github.com/google/guava[Guava] Iterables, or Java Streams.
If we made a great deal of use of the latter we might expose the `Stream` directly:

// begin-insert: tags/java-to-kotlin-collections.4:src/main/java/travelator/Route.java#foo
[source,java]
----
public Stream<Journey> stream() {
    return journeys.stream();
}
----
// end-insert

which suggests that `Stream` is actually the de-facto immutable collection interface for Java.
Maybe it's a pity that the JVM authors didn't define `Streamable` to go with `Iterable`.

Another low-ceremony way of allowing clients to treat `Route` as a collection of ++Journey++s is to expose the backing field via a property.

// begin-insert: tags/java-to-kotlin-collections.5:src/main/java/travelator/Route.java
[source,java]
----
public class Route {

    private final List<Journey> journeys;

    public Route(Collection<Journey> journeys) {
        this.journeys = List.copyOf(journeys);
    }

    public List<Journey> getJourneys() {
        return journeys;
    }

    public Location getDepartsFrom() {
        return journeys.get(0).getDepartsFrom();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Route journeys1 = (Route) o;
        return journeys.equals(journeys1.journeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(journeys);
    }
}
----
// end-insert

Now the route isn't a collection per se, but you can ask it for one.
The `List` returned from `getJourneys` lies to you at compile time by exposing all those mutation methods, but none of them will work at runtime, and in practice you get used to this way of working pretty quickly.

At the other end of the pragmatism spectrum, we can go the whole hog and implement `List<Journey>` in `Route`.

// begin-insert: tags/java-to-kotlin-collections.6:src/main/java/travelator/Route.java#foo
[source,java]
----
public class Route implements List<Journey>{

    private final List<Journey> journeys;

    public Route(Collection<Journey> journeys) {
        this.journeys = List.copyOf(journeys);
    }

    public Location getDepartsFrom() {
        return journeys.get(0).getDepartsFrom();
    }

    @Override
    public int size() {
        return journeys.size();
    }

    @Override
    public boolean isEmpty() {
        return journeys.isEmpty();
    }

    // ... and 26 other List methods ...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Route journeys1 = (Route) o;
        return journeys.equals(journeys1.journeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(journeys);
    }
}
----
// end-insert

Finally our `Route` is directly usable everywhere that takes `List<Journey>`.
Well, except for usages that call any mutating methods, where the `AbstractImmutableList` that is the actual type of `journeys` will rebut attempts, but only at runtime.
Again, project teams can get used to these conventions and produce reliable software because of and in spite of them.
On the whole the benefits of actually immutable collections outweigh the problems of a typesystem that is lying to you, because, to butcher a phrase, values are just so valuable.
The JVM's libraries may hark back to the days when mutability was the norm, but this is a case where going against the grain of Java is better than going with it.

[quote,Alan Perlis,Epigrams in Programming]
It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.

Now we are here, we can demonstrate why we want to have domain values like `Route` implement a fundamental collection interface.
As we intimated before, the reason is that it allows us to bring the full power of the collections libraries to bear on solving problems, but from outside the class rather than only by adding methods.
Given a `Route`, clients can now find the duration of the longest `Journey` themselves.

// begin-insert: tags/java-to-kotlin-collections.6:src/main/java/travelator/Routes.java
[source,java]
----
public class Routes {
    public static Duration durationOfLongestJourney(List<Journey> route) {
        if (route.isEmpty())
            return Duration.ZERO;
        else
            return route
                .stream()
                .map(Journey::getDuration)
                .max(Duration::compareTo)
                .orElseThrow();
    }
}
----
// end-insert

Shouldn't this be a method on `Route`?
Early in our careers we might have said yes, but we've seen too many classes bloated by trying to support every operation that any client required.
Better to find the key abstractions that allows clients to help themselves, and very often a standard collection is one of those abstractions.
This just leaves the problem that in Java it is much harder to find static functions like `durationOfLongestJourney` compared to methods, and the calling convention for such utility functions is different.
The discoverability of such functions is a lot worse than typing `route.` and waiting for suggestions to appear.

=== Kotlin Collections

In contrast to Java, Kotlin and its standard library were designed in an age when mutability was falling out of fashion.
At the same time though, smooth interoperation with Java was a key goal, and Java has mutable collections.
Scala had tried introducing its own sophisticated persistent (immutable but data-sharing) collections, but this forced developers to copy information between collections on the interop boundary.
How to square this circle?

The Kotlin developers took a different tack.
They took the Java collections interfaces, removed the mutation methods, and published them in the `kotlin.collections` package as `Collection<E>`, 'List<E>` etc.
These were then extended by `MutableCollection<E>`, `MutableList<E>` etc, which add back in the mutation methods.
So in `kotlin.collections`, `MutableList<String>` is a subtype of `List<String>` which is a subtype of `Collection<String>`.
`MutableList<String>` also implements `MutableCollection<String>`.

On the face of it this is a simple scheme.
Mutable collections have the same operations as immutable collections, plus the mutation methods.
It is safe to pass a `MutableList` as an argument to code that expects a `List`, because all the `List` methods will be present and can be invoked.
In terms of the Liskov Substitution Principle, we can substitute a `MutableList` where a `List` is expected, without affecting our program correctness.

A little bit of compiler magic makes it so that Kotlin code can accept a `java.util.List` as either a `kotlin.collections.List`:

// begin-insert: src/test/java/collections/ListInteropTest.kt#immutable
[source,kotlin]
----
val aList: List<String> = SomeJavaCode.mutableListOfStrings("0", "1")
aList.removeAt(1) // doesn't compile
----
// end-insert

or a `kotlin.collections.MutableList`:

// begin-insert: src/test/java/collections/ListInteropTest.kt#mutable
[source,kotlin]
----
val aMutableList: MutableList<String> = SomeJavaCode.mutableListOfStrings("0", "1")
aMutableList.removeAt(1)
assertEquals(listOf("0"), aMutableList)
----
// end-insert

In fact, because the Java `List` is actually mutable here, we can downcast to Kotlin's `MutableList` and mutate:

// begin-insert: src/test/java/collections/ListInteropTest.kt#cast
[source,kotlin]
----
val aList: List<String> = SomeJavaCode.mutableListOfStrings("0", "1")
val aMutableList: MutableList<String> = aList as MutableList<String>
aMutableList.removeAt(1)
assertEquals(listOf("0"), aMutableList)
----
// end-insert

In the other direction, the compiler will allow both a `kotlin.collections.MutableList` and a `kotlin.collections.List` where a `java.util.List` is needed.

// begin-insert: src/test/java/collections/ListInteropTest.kt#javaAcceptMutableList
[source,kotlin]
----
val aMutableList: MutableList<String> = mutableListOf("0", "1")
SomeJavaCode.needsAList(aMutableList)
----
// end-insert

// begin-insert: src/test/java/collections/ListInteropTest.kt#javaAcceptList
[source,kotlin]
----
val aList: List<String> = listOf("0", "1")
SomeJavaCode.needsAList(aList)
----
// end-insert

At face-value, so far everything has been very plausible.
We can differentiate between immutable ++List++s and ++MutableList++s in Kotlin, and easily interoperate with Java.
And because there is an immutable `List` interface, we can implement that rather than the mutable Java version when we want to write nice value types.
Let's convert our `Route` to Kotlin

// begin-insert: tags/java-to-kotlin-collections.7:src/main/java/travelator/Route.kt
[source,kotlin]
----
data class Route(
    private val journeys: List<Journey>
) : List<Journey> by journeys {
    val departsFrom: Location = journeys[0].departsFrom
}
----
// end-insert

Note how easy it is to delegate our implementation of `List<Journey>` to a field, compared to the Java version.
Also compared to Java, extension functions (or in this case an extension property) give a very natural way for clients to write their specific operations against this interface:

// begin-insert: tags/java-to-kotlin-collections.7:src/main/java/travelator/Routes.kt
[source,kotlin]
----
val List<Journey>.durationOfLongestJourney: Duration
    get() = when {
        isEmpty() -> Duration.ZERO
        else -> map { it.duration }.max() ?: error("unexpected null")
    }
----
// end-insert

Unfortunately, when it comes to mutability, there is more to substitutability that the Liskov Substitution Principle.
Let's go back to our route and populate it from Java.

// begin-insert: tags/java-to-kotlin-collections.7:src/main/java/travelator/SomeJava.java#someJava
[source,java]
----
List<Journey> journeys = loadJourneys();
Route route = new Route(journeys);

Journey shortestJourney = shortestJourneyIn(journeys);
Location start = route.getDepartsFrom();
----
// end-insert

All seems fine, but we keep getting bug reports that suggest that all is not well, even though our tests pass.
Drilling down we find:

// begin-insert: tags/java-to-kotlin-collections.7:src/main/java/travelator/SomeJava.java#shortestJourneyIn
[source,java]
----
private static Journey shortestJourneyIn(List<Journey> journeys) {
    journeys.sort(Comparator.comparing(Journey::getDuration));
    return journeys.get(0);
}
----
// end-insert

After a frustrating afternoon in the debugger we realise that, whilst our `Route` thought that it was being populated with an immutable list, no one told the Java code that supplied that list that it couldn't mutate it.
`Route` turns out to be a mutable after all!
Because of this, `departsFrom`, which is initialised in on construction, can get out of date.

The official line is that the non-mutable Kotlin collections are not _immutable_, but rather a _read-only view_ of a collection.
This is the unfortunate consequence of having your mutable collections extend your otherwise non-mutable collections - the recipient of a non-mutable collection cannot modify it, but cannot know that it won't change.
Even in Kotlin we could have created `MutableList`, passed it to `Journey` and then sorted it in place.

The rigorous solution to this problem is to separate mutable from immutable collections by not having a subtype relationship.
In this scheme if we have a mutable list and want an immutable copy of it, we have to copy the data.
A good analogy is a `StringBuilder`.
This is effectively a mutable `String`, but is not a subtype of `String` - once we are ready we need to call `.toString()`,
and subsequent modifications to the `StringBuilder` will not affect previous results.
Both Clojure and Scala adopt this approach for their collections libraries,
why didn't Kotlin?

We suspect that the answer is, because the Kotlin designers, like your authors, had adopted a Java style where any collection passed from one place to another was treated as immutable, even if it had started life as mutable, and despite the mutation operations present in the Java interfaces.
Sometimes we might enforce this immutability by wrapping with `Collections.unmodifiableList(...)` etc, but in an aligned development team this was unnecessary because no-one would think to modify a collection just because the Java interface said that they could.
Passing your collection to a library written by another team or organisation was risky, as was receiving a collection that a source might retain a reference to and mutate later, but in practice we didn't suffer from many bugs from these causes.

In return for accepting a largely theoretical risk, we, and Kotlin, reaped the rewards of very simple and efficient interoperation with Java.
And by extracting the 'immutable' interfaces it becomes very much simpler to define value types and to differentiate them from those collections that we do need to mutate for some reason.
This pragmatism is typical of the grain of Kotlin - in this case it might be expressed as "be as safe as is sensible, but no safer."

=== Migrating From Java to Kotlin Collections

TODO

* Beware that Java can mutate a collection that it has passed to Kotlin
* Beware that Java can (at least try to) mutate a collection that is has received from Kotlin.
* If you haven't already, remove mutation from your use of Java collections.
* Where you can't take defensive copies
* Then it will be safe to use Kotlin collections as if they are immutable, rather than just read only
* As more and more of your code is Kotlin you can begin to forget the distinction between read-only and immutable - just always pass immutable and never retain mutable.
* Stay in Kotlin immutable land whenever you can, but if you need efficiency, don't be afraid to create a mutable collection and return it as immutable.

Gotchas

* Java collections say they are mutable, but are often immutable, Kotlin vv
* Kotlin exposing its mutability to Java

=== Conclusions

Java at one time favoured programming with mutability.
That has fallen out of favour, but more by convention than enforcement.
Kotlin has taken a very pragmatic approach to mutability in its collections, giving smooth operation and an simple programming model, but only where your Java conventions align with its approach.

