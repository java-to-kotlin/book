[[java-to-kotlin-collections]]
== Java To Kotlin Collections

On the face of it, Java and Kotlin have very similar collections libraries, they certainly interoperate suspiciously seamlessly.
What are the differences, what motivates them, and where do we have to take care as we move from Java to Kotlin collections?

In the last chapter <<beans-to-values>>, we discussed how Java grew up in the days when we saw objects as fundamentally stateful and mutable.
This was particularly true for collections - I mean, what is the point of a list of things if you can't add to it?
We built collections by creating an empty one and adding to it.
Need to remove an item from a shopping cart? - mutate the list.
Mutable collections mirror our real world experience - we wouldn't create a new paper list of TODOs every time we remembered we need milk or took the cat to the vets.

=== Java 1.0 Collections

On its release, the quality of its built-in collections was a major reason to adopt Java.
In those days many languages had no resizable collections, and even C++ had no standard Map class.
Object encapsulation was the technology that allowed us to build mutable collections safely.
It was only natural to make use of this superpower now it had been given to us, and we went ahead and used `Vector` and `HashTable` as Sun intended.

Java 1.0 had no generics, a `Vector` was a collection of ++Object++s which had to be downcast to be useful.
So we learned to wrap this in a class that would downcast for us:

// begin-insert: tags/java-to-kotlin-collections.0:src/main/java/travelator/Route.java
[source,java]
----
public class Route {
    private final Vector journeys = new Vector();

    public int size() {
        return journeys.size();
    }

    public Journey elementAt(int index) {
        return (Journey) journeys.elementAt(index);
    }

    public void addJourney(Journey journey) {
        journeys.add(journey);
    }

    public Location getDepartsFrom() {
        return elementAt(0).getDepartsFrom();
    }
}
----
// end-insert

As well as providing the downcast, this wrapper class was helpful in two other ways.
Firstly, it allowed us to restrict the mutability of the collection.
In the Route example, a raw `Vector` would have exposed operations like `insertElementAt` and `removeElement` which might not be appropriate to our abstraction.
If a `Route` should be immutable, we could supply all its ++Journey++s to the constructor and not provide any mutators.
Secondly, the wrapper is a convenient place to define operations like `getDepartsFrom`.
This isn't applicable to a `Vector` of any ++Object++s, just ++Journey++s.
Armed with a variable of type `Route`, even the early Java IDEs were smart enough to pop up the messages that could be sent.
This is a major selling point of statically-typed object orientation - the code practically writes itself.

=== Java 2 Collections

Java 2 footnote:[which was known as 1.2 until Java had to compete with C# version numbers] introduced generics, and with them a revised collections library.
Generics removed the need to downcast objects retrieved from a collection.

// begin-insert: tags/java-to-kotlin-collections.1:src/main/java/travelator/Route.java
[source,java]
----
public class Route {
    private final List<Journey> journeys = new ArrayList<>(); // <1>

    public int size() {
        return journeys.size();
    }

    public Journey elementAt(int index) {
        return journeys.get(index); // <2>
    }

    public void addJourney(Journey journey) {
        journeys.add(journey);
    }

    public Location getDepartsFrom() {
        return elementAt(0).getDepartsFrom();
    }
}
----
// end-insert

<1> The diamond `<>` was only added by Java 7
<2> We don't have to cast the result of `get`

This might have removed the need for a wrapper class, except that we still needed a place to add operations like `getDepartsFrom`, and a way to restrict the mutability to `addJourney`.
In fact, if we have subclasses of Journey, using `List<Journey>` becomes worse in many ways because of issues of co- and contra-variance.
We'll skip over the details here, but the net result of the design of Java generics is that users of a collection have to decide whether to treat it as read-only or write-only.
In the read-only case we can pass a `List<TrainJourney>` to a function expecting a `List<? extends Journey>`, but inside the function the list can only ever be read from.
In the write-only case we can pass a `List<Journey>` to a function expecting `List<? super TrainJourney>`, which can only ever write to the list.
The problem is that `List` has both read and write operations, the compiler error messages are cryptic, and the poor user of the collections API is left to decide rather than the author of the API.

These issues: where to define specific operations; how to restrict mutability; and banging one's head against the variance wall in a vain attempt to get something, anything, to compile; led to it being the exception rather than the rule for Java developers to write functions that used unwrapped collections rather than classes like `Route`.
Which is a shame, because it turns out that treating `Route` as `List<Journey`> would be very nice for clients who wanted to print its contents, or find the longest train `Journey`, or any operation that the writers of `Route` didn't anticipate or feel was fundamental to the abstraction that they were creating.
This goal, and that of hosting specific methods, would be met if `Route` implemented `List<Journey>`.
If we try to do this, we find that `List`, even for Java 2, is quite a broad interface - we end up writing a lot of methods that just delegate to the underlying `journey` field.
Making `Route` extend `ArrayList<Journey>` simplifies things, and your authors have certainly written classes like this in their careers.

// begin-insert: tags/java-to-kotlin-collections.2:src/main/java/travelator/Route.java
[source,java]
----
public class Route extends ArrayList<Journey> {

    public Location getDepartsFrom() {
        return get(0).getDepartsFrom();
    }
}
----
// end-insert

The problem with this implementation is that `Route` is now mutable: really mutable.
Pass a reference to a `Route` to your rendering code, and it can come back empty.
Actually empty is unlikely - only a determined developer would clear a `Route` as part of rendering it, but
sorting by length of `Journey` or filtering to display just the refundable portions is exactly the sort of thing that rendering code would do.
Who can blame the developer who was given a reference and called methods on its interface to do their job?
You only have to spend several hundred hours debugging the problems caused by issues like this to come to the conclusion that maybe immutable collections (actually immutable objects full stop) might be a better default.
As an industry this point evidently came after the introduction of Java 2, at least in JVM Land, and so we have forever been stuck with mutable collections interfaces.

=== Immutable Collections

It is of course possible to define your own immutable collections interfaces to solve this problem; what you can't do is to ask the JDK collections to implement them.
Java developers who wanted immutable collections compatible with the JDK would have to to compromise.
The lowest end is to implement `Iterable`.

// begin-insert: tags/java-to-kotlin-collections.3:src/main/java/travelator/Route.java
[source,java]
----
public class Route implements Iterable<Journey> {

    private final List<Journey> journeys;

    public Route(Collection<Journey> journeys) {
        this.journeys = List.copyOf(journeys);
    }

    public int size() {
        return journeys.size();
    }

    @Override
    public Iterator<Journey> iterator() {
        return journeys.iterator();
    }

    public Location getDepartsFrom() {
        return journeys.get(0).getDepartsFrom();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Route journeys1 = (Route) o;
        return journeys.equals(journeys1.journeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(journeys);
    }
}
----
// end-insert

Here `Route` has to be completely initialised in its constructor, in this case from any other `Collection` of ++Journey++s.
Unfortunately, because that `Collection` may be mutable, we have to take a defensive copy of its items if `Journey` is to be truly immutable.
Even as defined here `Route` is not fundamentally immutable, as the `Iterator` it yields has a mutatator method - `remove`.
So we have a class whose interface is almost immutable, except for one second-order operation.
Luckily for us, the `List` returned by `List.copyOf` is 'safe' and will throw an `UnsupportedOperationException` at runtime if we attempt to call `remove` on its iterator.
It all goes to show that you have to be very careful if you want to make sure that your Java objects are not subject to subtle mutation.
In fact that `List.copyOf` method was only added in Java 10 - prior to that the path of least resistance would have been to write `this.journeys = new ArrayList<>(journeys);` safe in the knowledge that no operations in `Route` mutated the list but unsafe in the reality that anyone with the `Iterator` could.

Note that because `Route` is now an immutable value type, as we discussed in <<beans-to-values>>, equality has a simple semantic, and so we can now implement `equals` and `hashCode`

We have taken the pragmatic approach in this definition of exposing `size` as a `Route` property, but not allowing random access to elements with `get(int)`.
The size of a collection is often really useful when we're rendering and the like, and isn't available through the `Iterator.
The `Iterator` is enough though to allow common operations like `map` or `filter` through https://github.com/google/guava[Guava] Iterables, or Java Streams.
If we made a great deal of use of the latter we might expose the `Stream` directly:

// begin-insert: tags/java-to-kotlin-collections.4:src/main/java/travelator/Route.java#foo
[source,java]
----
public Stream<Journey> stream() {
    return journeys.stream();
}
----
// end-insert

which suggests that `Stream` is actually the de-facto immutable collection interface for Java.
Maybe it's a pity that the JVM authors didn't define `Streamable` to go with `Iterable`.

Another low-ceremony way of allowing clients to treat `Route` as a collection of ++Journey++s is to expose the backing field via a property.

// begin-insert: tags/java-to-kotlin-collections.5:src/main/java/travelator/Route.java
[source,java]
----
public class Route {

    private final List<Journey> journeys;

    public Route(Collection<Journey> journeys) {
        this.journeys = List.copyOf(journeys);
    }

    public List<Journey> getJourneys() {
        return journeys;
    }

    public Location getDepartsFrom() {
        return journeys.get(0).getDepartsFrom();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Route journeys1 = (Route) o;
        return journeys.equals(journeys1.journeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(journeys);
    }
}
----
// end-insert

Now the route isn't a collection per se, but you can ask it for one.
The `List` returned from `getJourneys` lies to you at compile time by exposing all those mutation methods, but none of them will work at runtime, and in practice you get used to this way of working pretty quickly.

At the other end of the pragmatism spectrum, we can go the whole hog and implement `List<Journey>` in `Route`.

// begin-insert: tags/java-to-kotlin-collections.6:src/main/java/travelator/Route.java#foo
[source,java]
----
public class Route implements List<Journey>{

    private final List<Journey> journeys;

    public Route(Collection<Journey> journeys) {
        this.journeys = List.copyOf(journeys);
    }

    public Location getDepartsFrom() {
        return journeys.get(0).getDepartsFrom();
    }

    @Override
    public int size() {
        return journeys.size();
    }

    @Override
    public boolean isEmpty() {
        return journeys.isEmpty();
    }

    // ... and 26 other List methods ...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Route journeys1 = (Route) o;
        return journeys.equals(journeys1.journeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(journeys);
    }
}
----
// end-insert

Now our `Route` is directly usable everywhere that takes `List<Journey>`.
Well, except for usages that call any mutating methods, where the `AbstractImmutableList` that is the actual type of `journeys` will rebutt attempts, but only at runtime.
Again, project teams can get used to these conventions and produce reliable software because of and in spite of them.
On the whole the benefits of actually immutable collections outweigh the problems of a typesystem that is lying to you, because, to butcher a phrase, values are just so valuable.

=== Kotlin Collections

=== Converting from Java to Kotlin Collections

=== Problems with Interop

* Java collections say they are mutable, but are often immutable, Kotlin vv
* Kotlin exposing its mutability to Java

=== Migrating Java Collections to Kotlin

=== Conclusions

=== See Also


