[[java-to-kotlin-collections]]
== Java To Kotlin Collections

On the face of it, Java and Kotlin have very similar collections libraries: they certainly interoperate suspiciously seamlessly.
What are the differences, what motivates them, and where do we have to take care as we move from Java to Kotlin collections?

In <<beans-to-values>>, we discussed how Java grew up in the days when we saw objects as fundamentally stateful and mutable.
This was particularly true for collections - I mean, what is the point of a list if you can't add to it?
We built collections by creating an empty one and adding to it.
Need to remove an item from a shopping cart? - mutate the list.
Shuffle a pack of cards? - obviously that changes the order of the deck.
We wouldn't create a new paper To-Do list every time we need milk or take the cat to the vet -
mutable collections mirror our real world experience.

[[java-collections]]
=== Java Collections

On its release, the quality of its built-in collections was a major reason to adopt Java.
In those days many languages had no resizable collections, and even C++ had no standard Map class.
Object encapsulation allowed us to build and use mutable collections safely.
It was only natural to make use of this superpower now it had been given to us, so we went ahead and used `Vector` and `HashTable` as Sun intended.
Which is to say, we created them and then mutated them.
There was no choice, as, none of the collections had a constructor that took the inital contents.

Java 2 (which was version 1.2 until Java had to compete with C# version numbers) introduced a revised collections library.
This tidied up the ad-hoc `Vector`, `Stack` and `Hashtable`, extracting a common `Collection` interface with more useful subclasses including `HashSet`.
Java 5 introduced generics, and cleverly retro-fitted them to the existing collections.

From the outset, developers were encouraged not to use raw collections, but rather to wrap the library objects in their own classes.
So instead of passing around a `List<Journey>`, we would create a `Route` wrapper class.

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/Route.java
[source,java]
----
public class Route {
    private final List<Journey> journeys = new ArrayList<>(); // <1>

    public int size() {
        return journeys.size();
    }

    public Journey getJourney(int index) {
        return journeys.get(index); // <2>
    }

    public void addJourney(Journey journey) {
        journeys.add(journey);
    }

    public Location getDepartsFrom() {
        return getJourney(0).getDepartsFrom();
    }
}
----
// end-insert

<1> The diamond `<>` was only added by Java 7.
<2> Generics mean that we don't have to cast the result of `get`.

Until Java 5 and the introduction of generics we needed this wrapper class to enforce type safety.
It prevented the adding of a `String`, for example, to a list that should only hold ++Journey++s, and down-cast the `Object` held in the collection on retrieval.
Generics make collections type-safe with no extra work, so it is now possible to use a plain `List<Journey>` rather than defining a wrapper `Route`.

In <<encapsulated-collections-to-typealiases>> we'll look at some other benefits of wrapper classes, but in this chapter we'll focus on one particular issue with unwrapped collections.
The problem is that they are mutable, very mutable.
`List<Journey> exposes operations like `remove` and `replaceAll`, where, in our example, we only want to support appending ++Journey++s.
Hiding the collection inside the wrapper means that we can add only the mutators we want, and if we want an immutable `Route`, we can populate all the ++Journey++s in the constructor and not add any mutators at all.

.Collections and Variance
****
If we have subclasses of Journey, using `List<Journey>` rather than a wrapper also becomes complicated because of issues of co- and contra-variance.

We'll skip over the details here, but the net result of the design of Java generics is that users of a collection have to decide whether to treat it as read-only or write-only.
In the read-only case we can pass a `List<TrainJourney>` to a function expecting a `List<? extends Journey>`, but inside the function the list can only ever be read from.
In the write-only case we can pass a `List<Journey>` to a function expecting `List<? super TrainJourney>`, which can only ever write to the list.
The problem is that the `List` interface has both read and write operations, the compiler error messages are cryptic, and the poor user of the collections API is left to decide rather than the author of the API.
****

As we will keep on saying, mutation is the source of many of our problems with keeping software simple, as it allows state in one place to get out of date with respect to state in another.
We might start with this:

// begin-insert: tags/java-to-kotlin-collections.0:src/main/java/travelator/Suffering.java#sufferScoreFor
[source,java]
----
public static int sufferScoreFor(List<Journey> route) {
    Location start = getDepartsFrom(route);
    var longestJourneys = longestJourneysIn(route, 3);
    return sufferScore(longestJourneys, start);
}
----
// end-insert

Let's inline `start`:

// begin-insert: tags/java-to-kotlin-collections.1:src/main/java/travelator/Suffering.java#sufferScoreFor
[source,java]
----
public static int sufferScoreFor(List<Journey> route) {
    List<Journey> longestJourneys = longestJourneysIn(route, 3);
    return sufferScore(longestJourneys, getDepartsFrom(route));
}
----
// end-insert

All seems fine, but we keep getting bug reports that suggest that all is not well, even though our tests pass.
Drilling down we find:

// begin-insert: tags/java-to-kotlin-collections.0:src/main/java/travelator/Routes.java#getDepartsFrom
[source,java]
----
public static Location getDepartsFrom(List<Journey> route) {
    return route.get(0).getDepartsFrom();
}
----
// end-insert

// begin-insert: tags/java-to-kotlin-collections.0:src/main/java/travelator/Suffering.java#longestJourneysIn
[source,java]
----
public static List<Journey> longestJourneysIn(List<Journey> journeys, int limit) {
    journeys.sort(comparing(Journey::getDuration).reversed());
    var actualLimit = Math.min(journeys.size(), limit);
    return journeys.subList(0, actualLimit);
}
----
// end-insert

Ah, a developer was given a reference and called methods on its interface to solve a problem, but that turned out to break code somewhere else in the system.
You only have to spend several hundred hours of your life debugging the problems caused by issues like this, to come to the conclusion that maybe immutable collections (actually immutable objects full stop) might be a better default.
For the JDK developers this point evidently came after the introduction of Java 2, and so we have forever been stuck with mutable collections interfaces.

To be fair, while Java's collections are in-theory mutable, they have, over the years, become less and less so in practice.
Since their introduction it had always been possible to wrap a collection with, for example, `Collections.unmodifiableList`.
The result is still a `List`: it still has all the mutation methods, but they all throw `UnsupportedOperationException`.
We could have found out about the problem of `shortestJourneyIn` mutating our list by wrapping the result from `loadJourneys` in an `UnmodifiableList`.
The tests of any code that combined the two would quickly fail, albeit only when run as opposed to when compiled.
It's a shame when we cannot depend on the type system to ensure correctness, but we can't go back in time, so this is a pragmatic patch.

Wrapping a list in an `UnmodifiableList` solves the problems of depended-on code mutating our collection.
If it's possible for the original list to be modified we can still have issues though, because `UnmodifiableList` reads through to its underlying collection.
It doesn't guarantee that it never changes, just that it cannot be modified through the wrapper.
In these cases we have to take a defensive copy of the original list if we are to be isolated from changes.
`List.copyOf(collection)` was finally provided in Java 10 to copy an underlying collection as an `AbstractImmutableList`, which is neither modifiable nor subject to changes in the original collection.

If you think that all this second-guessing when the source or destination of collections are likely to modify them, and taking appropriate action, sounds a bit tedious, then you aren't alone.
The problem applies to any mutable data, but mutating collections is particularly pernicious, because we often derive values (such as `departsFrom`) that can get out of date if we change the collection we extracted them from.
Rather than taking defensive copies at every function boundary, many teams, your authors' included, adopted a simpler and more efficient strategy.

[[dont-mutate-shared-collections]]
.Don't Mutate Shared Collections
****
Treat any collection shared between separate pieces of code as immutable.
Sharing includes references received as a parameter, returned as a result, or assigned to a shared variable.
This applies even if the collection started life as mutable, and despite the mutation operations present in the Java interfaces.

As we've seen, code that we don't own may not respect this convention.
In this case, we can use copies to insulate our code from these changes.
****

This strategy doesn't stop us from creating mutable collections and populating them within a function, but code should only change a collection that it has just created.
As soon as we return a reference as a result we should treat it as immutable - create, don't mutate.
We might occasionally enforce this immutability by wrapping with `Collections.unmodifiableList(...)` etc, but in an aligned development team this is unnecessary, because no code will treat the as mutable.

There will of course be exceptions to the rule - places where, usually for reasons of efficiency, we want to share a collection as a mutable collection.
In these cases we can get dispensation by naming (`accumulator` is a good start), and by limiting the scope of the sharing as much as possible.
Within a function is ideal, between private methods in a class acceptable, across module boundaries very rarely so.
<<accumulating-objects-to-transformations>> discusses ways to avoid (visibly) mutable collections in these situations.

Project teams that adopt this convention can produce simple and reliable software in spite of collections' mutability.
On the whole the benefits of actually immutable collections outweigh the problems of a type system that is lying to you, because, to butcher a phrase, values are just so valuable.
The JVM's libraries may hark back to the days when mutability was the norm, but this is a case where the grain of Java is shifting to the immutable, and it's better to be ahead of this change than behind it.

=== Kotlin Collections

In contrast to Java, Kotlin and its standard library were designed in an age when mutability had fallen out of fashion.
At the same time though, smooth interoperation with Java was a key goal, and Java has mutable collections.
Scala had tried introducing its own sophisticated persistent (immutable but data-sharing) collections, but this forced developers to copy information between collections on the interop boundary.
How to square this circle?

The Kotlin developers took a different tack.
They took the Java collections interfaces, removed the mutation methods, and published them in the `kotlin.collections` package as `Collection<E>`, `List<E>` etc.
These were then extended by `MutableCollection<E>`, `MutableList<E>` etc, which add back in the Java mutation methods.
So in `kotlin.collections`, `MutableList<String>` is a subtype of `List<String>` which is a subtype of `Collection<String>`.
`MutableList<String>` also implements `MutableCollection<String>`.

On the face of it this is a simple scheme.
Mutable collections have the same operations as non-mutable collections, plus the mutation methods.
It is safe to pass a `MutableList` as an argument to code that expects a `List`, because all the `List` methods will be present and can be invoked.
In terms of the https://en.wikipedia.org/wiki/Liskov_substitution_principle[Liskov Substitution Principle], we can substitute a `MutableList` for a `List`, without affecting our program correctness.

A little compiler magic makes it so that Kotlin code can accept a `java.util.List` as either a `kotlin.collections.List`:

// begin-insert: src/test/java/collections/ListInteropTest.kt#immutable
[source,kotlin]
----
val aList: List<String> = SomeJavaCode.mutableListOfStrings("0", "1")
aList.removeAt(1) // doesn't compile
----
// end-insert

or a `kotlin.collections.MutableList`:

// begin-insert: src/test/java/collections/ListInteropTest.kt#mutable
[source,kotlin]
----
val aMutableList: MutableList<String> = SomeJavaCode.mutableListOfStrings("0", "1")
aMutableList.removeAt(1)
assertEquals(listOf("0"), aMutableList)
----
// end-insert

In fact, because the Java `List` is actually mutable here, we can downcast to Kotlin's `MutableList` and mutate:

// begin-insert: src/test/java/collections/ListInteropTest.kt#cast
[source,kotlin]
----
val aList: List<String> = SomeJavaCode.mutableListOfStrings("0", "1")
val aMutableList: MutableList<String> = aList as MutableList<String>
aMutableList.removeAt(1)
assertEquals(listOf("0"), aMutableList)
----
// end-insert

In the other direction, the compiler will allow both a `kotlin.collections.MutableList` and a `kotlin.collections.List` where a `java.util.List` is needed.

// begin-insert: src/test/java/collections/ListInteropTest.kt#javaAcceptMutableList
[source,kotlin]
----
val aMutableList: MutableList<String> = mutableListOf("0", "1")
SomeJavaCode.needsAList(aMutableList)
----
// end-insert

// begin-insert: src/test/java/collections/ListInteropTest.kt#javaAcceptList
[source,kotlin]
----
val aList: List<String> = listOf("0", "1")
SomeJavaCode.needsAList(aList)
----
// end-insert

At face-value, so far everything has been very plausible.
Unfortunately, when it comes to mutability, there is more to substitutability than the Liskov Substitution Principle.
As we saw in <<java-collections>>, just because we can't see mutators on our reference of type `kotlin.collections.List`, doesn't mean that the contents cannot change.
The actual type could be a `java.util.List`, which _is_ mutable.
In some ways it's worse in Kotlin, because we can convert a `MutableList` to a `List` in passing:

// begin-insert: src/test/java/collections/ListInteropTest.kt#upCast
[source,kotlin]
----
val aMutableList = mutableListOf("0", "1")
val aList: List<String> = aMutableList
----
// end-insert

Now lets say that we accept a `List<String>` somewhere, and take its immutabilty at face value:

// begin-insert: src/test/java/collections/ListInteropTest.kt#aClass
[source,kotlin]
----
class AValueType(
    val strings: List<String>
) {
    val first: String? = strings.firstOrNull()
}
----
// end-insert

Everything seems fine:

// begin-insert: src/test/java/collections/ListInteropTest.kt#passAsList
[source,kotlin]
----
val holdsState = AValueType(aList)
assertEquals(holdsState.first, holdsState.strings.first())
----
// end-insert

But wait, don't we still have a reference to a `MutableList`?

// begin-insert: src/test/java/collections/ListInteropTest.kt#mutate
[source,kotlin]
----
aMutableList[0] = "banana"
assertEquals(holdsState.first, holdsState.strings.first()) // Expected "0", actual "banana"
----
// end-insert

`AValueType` turns out to be a mutable after all!
Because of this, `first`, which is initialised in on construction, can get out of date.
Having non-mutable collections interfaces has not resulted in immutable collections!

The official line is that the non-mutable Kotlin collections are not _immutable_, but rather a _read-only view_ of a collection.
This is the unfortunate consequence of having your mutable collections extend your otherwise non-mutable collections - the recipient of a non-mutable collection cannot modify it, but cannot know that it won't change.

The rigorous solution to this problem is to separate mutable from immutable collections by not having a subtype relationship.
In this scheme if we have a mutable list and want an immutable copy of it, we have to copy the data.
A good analogy is a `StringBuilder`.
This is effectively a mutable `String`, but is not a subtype of `String`.
Once we have a result we want to publish we need to call `.toString()`,
and subsequent modifications to the `StringBuilder` will not affect previous results.
Both Clojure and Scala adopt this builder approach for their mutable collections, why doesn't Kotlin?

We suspect that the answer is: because the Kotlin designers, like your authors, had adopted the convention described in <<dont-mutate-shared-collections>>.
If you treat any collection received as a parameter, returned as a result, or otherwise shared between code, as immutable, then having mutable collections extend non-mutable collections turns out to be quite safe.
Admittedly _quite_ in the sense of _mainly_, rather than _completely_, but still the benefits outweigh the costs.
The Kotlin collections make this scheme even more powerful.
In Java, we have the situation where we can in theory mutate any collections, so the type system doesn't tell us when this is safe or otherwise.
In Kotlin, if we declare all normal references as the non-mutable versions, we can use ++MutableCollection++s to document when we do, in fact, consider that the collection is subject to change.
In return for accepting a largely theoretical risk, we reap the rewards of very simple and efficient interoperation with Java.
Pragmatism is typical of the grain of Kotlin - in this case it might be expressed as "be as safe as is sensible, but no safer."

Recall that another way to express the convention is - our code should only mutate a collection that it has just created.
We see this in action if we look into the Kotlin standard library.
Here, for example, is (a streamlined version of) the definition of `map`:

// begin-insert: src/main/kotlin/collections/collections.kt
[source,kotlin]
----
inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    val result = ArrayList<R>()
    for (item in this)
        result.add(transform(item))
    return result
}
----
// end-insert

Here we are able to build a list in place by mutation, and then return it as read-only.
This is simple _and_ efficient.
Technically we _could_ downcast the result to `MutableList` and change the result, but we shouldn't.
Instead, we should take the result type at face value - that way any code sharing this collection will not have to consider the complications that would arise if it were to change.

=== Migrating From Java to Kotlin Collections

Because of the smooth interop between Java and Kotlin collections described above, converting code with collections is usually seamless, at least at the syntactic level.
If our Java code relies on mutating collections, though, we may have to take extra care in order to avoid ending up breaking invariants in Kotlin.

A good approach is to refactor your Java code to the <<dont-mutate-shared-collections>> convention before converting to Kotlin.

==== Fixup the Java

Let's have a look at the code from Travelator we saw earlier.

// begin-insert: tags/java-to-kotlin-collections.2:src/main/java/travelator/Suffering.java#foo
[source,java]
----
public static int sufferScoreFor(List<Journey> route) {
    Location start = getDepartsFrom(route);
    List<Journey> longestJourneys = longestJourneysIn(route, 3);
    return sufferScore(longestJourneys, start);
}

public static List<Journey> longestJourneysIn(List<Journey> journeys, int limit) {
    journeys.sort(comparing(Journey::getDuration).reversed());
    var actualLimit = Math.min(journeys.size(), limit);
    return journeys.subList(0, actualLimit);
}
----
// end-insert

`longestJourneysIn` breaks the rule by mutating its parameter.
This leads to our being unable to change the order that we evaluate `getDepartsFrom` and `longestJourneysIn`
Before we can fix this, we have to be sure that no other code depends on this mutation.
This can be hard, which is itself a good reason to not allow changing collections from the outset.
If we have confidence in our tests we can try making the edit and seeing if anything breaks - otherwise we may have to add tests and/or reason with our code and dependency analysis.
Let's decide that it's safe go ahead and make the change.

At the time of writing your authors couldn't find any standard Java function to take a collection and return a sorted `List` from it.
Curiously `List.sort(...)` actually creates a sorted version of itself and then mutates itself to match:

[source,java]
----
@SuppressWarnings({"unchecked", "rawtypes"})
default void sort(Comparator<? super E> c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator<E> i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
----

This just goes to show how mutable thinking was the grain of Java back in the Java 8 days when this was written.
There is now `Stream.sorted(...)` but in our experience streams are rarely performant for small collections.
Maybe we shouldn't care about performance, but we can't help ourselves.
We justify our indulgence by reasoning that we know of several places in the code that currently sort in place, and so will have to be changed in order to not mutate shared collections.
We and end up writing:

// begin-insert: tags/java-to-kotlin-collections.3:src/main/java/travelator/Collections.java#sorted
[source,java]
----
@SuppressWarnings("unchecked")
public static <E> List<E> sorted(Collection<E> collection, Comparator<? super E> by) {
    var result = (E[]) collection.toArray();
    Arrays.sort(result, by);
    return Arrays.asList(result);
}
----
// end-insert

Before we go on, it's worth considering how we can be confident that this code is correct.
Because of mutation it's really quite hard.
We have to be sure that `Arrays.sort` won't affect the input collection, which means checking the documentation for `Collection.toArray`.
When we do, we find the magic words "The caller is thus free to modify the returned array," so that's OK, we've decoupled the input from the output.
This function is a classic example of accepting mutation in the scope where we create a collection, but not outside - "create, don't mutate."

While we're pulling this thread - what are we returning, and is it mutable?
`Arrays.asList` returns an `ArrayList`, but not the standard one.
This one is `private` inside `Arrays` and writes through to our `result`.
Because it is backed by an array though, we cannot add or remove items - it isn't resizable.
It turns out that Java collections aren't just mutable, non-mutable, or immutable, they are sometimes mutable provided that we don't change their structure!
None of these distinctions are reflected in the type system, so it is possible to make type-preserving changes that break at runtime depending on which code path yields a collection that we subsequently try to modify.
This is yet another reason to side-step the issue altogether and just never modify a shared collection.

Anyhoo, returning to our refactoring, we can use our new `sorted` in `longestJourneysIn` in order (oops) to stop modifying the shared collection.

// begin-insert: tags/java-to-kotlin-collections.3:src/main/java/travelator/Suffering.java#longestJourneysIn
[source,java]
----
static List<Journey> longestJourneysIn(List<Journey> journeys, int limit) {
    var actualLimit = Math.min(journeys.size(), limit);
    return sorted(journeys, comparing(Journey::getDuration).reversed())
        .subList(0, actualLimit);
}
----
// end-insert

Now `sufferScoreFor` won't be subject to the side effect in `longestJourneysIn` we can inline the local variables.

// begin-insert: tags/java-to-kotlin-collections.4:src/main/java/travelator/Suffering.java#sufferScoreFor
[source,java]
----
public static int sufferScoreFor(List<Journey> route) {
    return sufferScore(
        longestJourneysIn(route, 3),
        getDepartsFrom(route));
}
----
// end-insert

Inlining the local variables might not seem much of a payoff, but it's a small example of a bigger theme.
In <<actions-to-calculations>> we'll look at how avoiding mutation allows us to safely refactor code in ways that just isn't possible otherwise.

Stepping out to look at the callers of `sufferScoreFor` we find:

// begin-insert: tags/java-to-kotlin-collections.4:src/main/java/travelator/Suffering.java#routesToShowFor
[source,java]
----
public static List<List<Journey>> routesToShowFor(String itineraryId) {
    var routes = loadRoutes(itineraryId);
    removeUnbearableRoutes(routes);
    return routes;
}

private static void removeUnbearableRoutes(List<List<Journey>> routes) {
    routes.removeIf(route -> sufferScoreFor(route) > 10);
}
----
// end-insert

Hmmm, that's so pathologically mutating that it might have been written as an example in a book!
At least `removeUnbearableRoutes` is signalling that it must mutate something by returning `void`.
We can take baby steps by changing that first and using the result - a case of making something worse before making it better:

// begin-insert: tags/java-to-kotlin-collections.5:src/main/java/travelator/Suffering.java#routesToShowFor
[source,java]
----
public static List<List<Journey>> routesToShowFor(String itineraryId) {
    var routes = loadRoutes(itineraryId);
    routes = removeUnbearableRoutes(routes);
    return routes;
}

private static List<List<Journey>> removeUnbearableRoutes(List<List<Journey>> routes) {
    routes.removeIf(route -> sufferScoreFor(route) > 10);
    return routes;
}
----
// end-insert

This time we will use streams and `filter` to replace the mutation:

// begin-insert: tags/java-to-kotlin-collections.6:src/main/java/travelator/Suffering.java#routesToShowFor
[source,java]
----
public static List<List<Journey>> routesToShowFor(String itineraryId) {
    var routes = loadRoutes(itineraryId);
    routes = bearable(routes);
    return routes;
}

private static List<List<Journey>> bearable(List<List<Journey>> routes) {
    return routes.stream()
        .filter(route -> sufferScoreFor(route) <= 10)
        .collect(toUnmodifiableList());
}
----
// end-insert

Note how it is now easier to find a nice short name for our function - `removeUnbearableRoutes` becomes `bearable`.
If you have functional leanings you might also be baulking at the reassignment to `routes` in `routesToShowFor`.
That's deliberate, but only to allow us to draw parallels with the refactor in <<beans-to-values>>.
There we changed mutating-some-data-in-place to replacing-the-reference-with-a-mutated-value, and that is what we have done here too.
Of course, we don't need the local at all really, so let's get rid of it, inline twice does it nicely:

// begin-insert: tags/java-to-kotlin-collections.7:src/main/java/travelator/Suffering.java#routesToShowFor
[source,java]
----
public static List<List<Journey>> routesToShowFor(String itineraryId) {
    return bearable(loadRoutes(itineraryId));
}

private static List<List<Journey>> bearable(List<List<Journey>> routes) {
    return routes.stream()
        .filter(route -> sufferScoreFor(route) <= 10)
        .collect(toUnmodifiableList());
}
----
// end-insert

==== Convert to Kotlin

Now we've removed all the mutation from our Java collections, it's time to convert to Kotlin.
Unfortunately, the converter can get confused when it tries to infer the nullability of collections, and their generic types.
In order to get the following we had to remove ++?++s from some hairy types like `List<List<Journey?>>?`

// begin-insert: tags/java-to-kotlin-collections.8:src/main/java/travelator/Suffering.kt#foo
[source,kotlin]
----
object Suffering {
    @JvmStatic
    fun sufferScoreFor(route: List<Journey>): Int {
        return sufferScore(
            longestJourneysIn(route, 3),
            Routes.getDepartsFrom(route)
        )
    }

    @JvmStatic
    fun longestJourneysIn(journeys: List<Journey>, limit: Int): List<Journey> {
        val actualLimit = Math.min(journeys.size, limit)
        return Collections.sorted(journeys, Comparator.comparing { obj: Journey -> obj.duration }
            .reversed())
            .subList(0, actualLimit)
    }

    @JvmStatic
    fun routesToShowFor(itineraryId: String): List<List<Journey>> {
        return bearable(loadRoutes(itineraryId))
    }

    private fun bearable(routes: List<List<Journey>>): List<List<Journey>> {
        return routes.stream()
            .filter { route: List<Journey> -> sufferScoreFor(route) <= 10 }
            .collect(Collectors.toUnmodifiableList())
    }

    ...
}
----
// end-insert

On the plus side, Java code calling our Kotlin hasn't had to change - here is a test passing a plain Java `List` to the Kotlin `longestJourneyIn`.

// begin-insert: tags/java-to-kotlin-collections.8:src/test/java/travelator/LongestJourneyInTests.java#foo
[source,java]
----
@Test public void returns_limit_results() {
    assertEquals(
        List.of(longJourney, mediumJourney),
        longestJourneysIn(List.of(shortJourney, mediumJourney, longJourney), 2)
    );
}
----
// end-insert

Returning to the Kotlin, we can tidy up quite a bit.
`sort...` and `take` extension functions on `Iterable` let us simplify `longestJourneysIn` dramatically.

// begin-insert: tags/java-to-kotlin-collections.9:src/main/java/travelator/Suffering.kt#longestJourneysIn
[source,kotlin]
----
@JvmStatic
fun longestJourneysIn(journeys: List<Journey>, limit: Int): List<Journey> =
    journeys.sortedByDescending { it.duration }.take(limit)
----
// end-insert

Now converting to an extension function <<functions-to-extension-functions>> allows us to simplify the name.
Java code is still able to call this as a static method.

// begin-insert: tags/java-to-kotlin-collections.10:src/main/java/travelator/Suffering.kt#longestJourneysIn
[source,kotlin]
----
@JvmStatic
fun List<Journey>.longestJourneys(limit: Int): List<Journey> =
    sortedByDescending { it.duration }.take(limit)
----
// end-insert

In `bearable` we can convert the `Stream` to Kotlin by removing the call to `.stream()` and the terminal operation - Kotlin `filter` returns a `List` directly.

// begin-insert: tags/java-to-kotlin-collections.11:src/main/java/travelator/Suffering.kt#bearable
[source,kotlin]
----
private fun bearable(routes: List<List<Journey>>): List<List<Journey>> = routes
    .filter { sufferScoreFor(it) <= 10 }
----
// end-insert

Interestingly this is a place where the result is potentially more mutable than our Java was.
In Java, we were collecting with `Collectors.toUnmodifiableList()`.
Kotlin `filter` declares its return type as `List`, but the actual type is the mutable `ArrayList`.
Provided we never down-cast this shouldn't be an issue, especially as we are now treating our shared collections as immutable even in Java.

Finally, we can make things read more nicely with a typealias to name `List<Journey>` as `Route`, and a cheek local extension property to allow us to write `route.departsFrom`.

// begin-insert: tags/java-to-kotlin-collections.12:src/main/java/travelator/Suffering.kt#foo
[source,kotlin]
----
typealias Route = List<Journey>

object Suffering {
    @JvmStatic
    fun sufferScoreFor(route: Route): Int =
        sufferScore(
            route.longestJourneys(3),
            route.departsFrom // <1>
        )

    @JvmStatic
    fun Route.longestJourneys(limit: Int): Route =
        sortedByDescending { it.duration }.take(limit)

    @JvmStatic
    fun routesToShowFor(itineraryId: String): List<Route> {
        return bearable(loadRoutes(itineraryId))
    }

    private fun bearable(routes: List<Route>): List<Route> =
        routes.filter { sufferScoreFor(it) <= 10 }

    private val Route.departsFrom: Location get() = Routes.getDepartsFrom(this) // <2>

    ...
}
----
// end-insert

<1> `List<Journey>` doesn't have `departsFrom`,
<2> but we can pretend with a local extension property.

=== Conclusions

Java at one time favoured programming with mutability.
That has fallen out of favour, but more by convention than enforcement.
Kotlin has taken a very pragmatic approach to mutability in its collections, giving smooth operation and a simple programming model, but only where your Java conventions align with its approach.

* Beware that Java can mutate a collection that it has passed to Kotlin
* Beware that Java can (at least try to) mutate a collection that is has received from Kotlin.
* If you haven't already, remove mutation from your use of Java collections.
* Where you can't take defensive copies
* Then it will be safe to use Kotlin collections as if they are immutable, rather than just read only
* As more and more of your code is Kotlin you can begin to forget the distinction between read-only and immutable - just always pass immutable and never retain mutable.
* Stay in Kotlin immutable land whenever you can, but if you need efficiency, don't be afraid to create a mutable collection and return it as immutable.


