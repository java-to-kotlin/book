[[java-to-kotlin-collections]]
== Java To Kotlin Collections

On the face of it, Java and Kotlin have very similar collections libraries: they certainly interoperate suspiciously seamlessly.
What are the differences, what motivates them, and where do we have to take care as we move from Java to Kotlin collections?

In <<beans-to-values>>, we discussed how Java grew up in the days when we saw objects as fundamentally stateful and mutable.
This was particularly true for collections - I mean, what is the point of a list if you can't add to it?
We built collections by creating an empty one and adding to it.
Need to remove an item from a shopping cart? - mutate the list.
Shuffle a pack of cards? - obviously that changes the order of the deck.
We wouldn't create a new paper To-Do list every time we remember we need milk or take the cat to the vet -
mutable collections mirror our real world experience.

=== Java Collections

On its release, the quality of its built-in collections was a major reason to adopt Java.
In those days many languages had no resizable collections, and even C++ had no standard Map class.
Object encapsulation allowed us to build and use mutable collections safely.
It was only natural to make use of this superpower now it had been given to us, so we went ahead and used `Vector` and `HashTable` as Sun intended.
Which is to say, we created them and then mutated them.
There was no choice, as, none of the collections had a constructor that took the inital contents.

Java 2 (which was version 1.2 until Java had to compete with C# version numbers) introduced a revised collections library.
This tidied up the ad-hoc `Vector`, `Stack` and `Hashtable`, extracting a common `Collection` interface with more useful subclasses including `HashSet`.
Java 5 introduced generics, and cleverly retro-fitted them to the existing collections.

From the outset, developers were encouraged not to use raw collections, but rather to wrap the library objects in their own classes.
So instead of passing around a `List<Journey>`, we would create a `Route` wrapper class.

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/Route.java
[source,java]
----
public class Route {
    private final List<Journey> journeys = new ArrayList<>(); // <1>

    public int size() {
        return journeys.size();
    }

    public Journey elementAt(int index) {
        return journeys.get(index); // <2>
    }

    public void addJourney(Journey journey) {
        journeys.add(journey);
    }

    public Location getDepartsFrom() {
        return elementAt(0).getDepartsFrom();
    }
}
----
// end-insert

<1> The diamond `<>` was only added by Java 7.
<2> Generics mean that we don't have to cast the result of `get`.

Until Java 5 and the introduction of generics we needed the wrapper class to enforce type safety.
It prevented the adding of a `String`, for example, to a list that should only hold ++Journey++s, and down-cast the `Object` held in the collection on retrieval.
Generics made collections type-safe.
So, if there were no additional properties, why wouldn't we use `List<Journey>` rather than defining a wrapper `Route`?

Firstly, the wrapper is a convenient place to define operations like `getDepartsFrom`.
We can't add operations to the standard `List`, so we would have to write a static function:

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/Routes.java
[source,java]
----
public class Routes {

    public static Location getDepartsFrom(List<Journey> journeys) {
        return journeys.get(0).getDepartsFrom();
    }

    // ... other utility functions
}
----
// end-insert

We then have to call this function statically:

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/UsingRoutes.java#function
[source,java]
----
List<Journey> route = loadJourneys();
Location start = Routes.getDepartsFrom(route);
----
// end-insert

This compares unfavourably with calling the method:

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/UsingRoutes.java#method
[source,java]
----
Route route = loadRoute();
Location start = route.getDepartsFrom();
----
// end-insert

Armed with a variable of type `Route`, even the early Java IDEs were smart enough to pop up the messages that could be sent, so clients could see the operations applicable to their type.
This is a major selling point of statically-typed object orientation - the code practically writes itself.
Without methods, you have to hunt around looking for suitable functions that take the type you have in hand.
<<encapsulated-collections-to-typealiases>> examines this aspect of wrapper classes in more detail.

The second major reason for having a wrapper class is that it allows us to restrict the mutability of the collection.
`List<Journey> exposes operations like `insertElementAt` and `removeElement`, where, in our example, we only want to support appending ++Journey++s.
The wrapper means that we can add only the mutators we want, and if we want an immutable `Route`, we can populate all the ++Journey++s in the constructor and not add any mutators at all.

.Collections and Variance
****
If we have subclasses of Journey, using `List<Journey>` rather than a wrapper also becomes complicated because of issues of co- and contra-variance.

We'll skip over the details here, but the net result of the design of Java generics is that users of a collection have to decide whether to treat it as read-only or write-only.
In the read-only case we can pass a `List<TrainJourney>` to a function expecting a `List<? extends Journey>`, but inside the function the list can only ever be read from.
In the write-only case we can pass a `List<Journey>` to a function expecting `List<? super TrainJourney>`, which can only ever write to the list.
The problem is that the `List` interface has both read and write operations, the compiler error messages are cryptic, and the poor user of the collections API is left to decide rather than the author of the API.
****

As we will keep on saying, mutation is the source of many of our problems keeping software simple, as it allows state in one place to get out of date with respect to state in another.
We might start with this:

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/UsingRoutes.java#before
[source,java]
----
List<Journey> route = loadJourneys();
Location start = Routes.getDepartsFrom(route);
Journey shortestJourney = shortestJourneyIn(route);
var score = someComplicatedCalculation(shortestJourney, start);
----
// end-insert

Let's inline `start`:

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/UsingRoutes.java#after
[source,java]
----
List<Journey> route = loadJourneys();
Journey shortestJourney = shortestJourneyIn(route);
var score = someComplicatedCalculation(shortestJourney, Routes.getDepartsFrom(route));
----
// end-insert

All seems fine, but we keep getting bug reports that suggest that all is not well, even though our tests pass.
Drilling down we find:

// begin-insert: tags/duncan-collections.1:src/main/java/travelator/UsingRoutes.java#shortestJourneyIn
[source,java]
----
public static Journey shortestJourneyIn(List<Journey> journeys) {
    journeys.sort(Comparator.comparing(Journey::getDuration));
    return journeys.get(0);
}
----
// end-insert

Who can blame the developer who was given a reference and called methods on its interface to do their job?
You only have to spend several hundred of the prime hours of your life debugging the problems caused by issues like this, to come to the conclusion that maybe immutable collections (actually immutable objects full stop) might be a better default.
In Java this point evidently came after the introduction of Java 2, and so we have forever been stuck with mutable collections interfaces.

While Java's collections are in-theory mutable, they have, over the years, become less and less so in practice.
Since their introduction it had always been possible to wrap a collection with, for example, `Collections.unmodifiableList`.
The result is still a `List`, it still has all the mutation methods, but they all throw `UnsupportedOperationException`.
We could have found out about the problem of `shortestJourneyIn` mutating our list by wrapping the result from `loadJourneys` in an `UnmodifiableList`.
The tests of any code that combined the two would quickly fail, albeit only when run as opposed to when compiled.

Wrapping a received list in an `UnmodifiableList` solves the problems of depended-on code mutating our collection.
If it's possible for the original list to be modified we can still have issues though, because `UnmodifiableList` reads through to its underlying collection.
It doesn't guarantee that it never changes, just that it cannot be modified through the wrapper.
In these cases we have to take a defensive copy of the original list if we are to be isolated from changes.
`List.copyOf(collection)` was finally provided in Java 10 to copy an underlying collection as an `AbstractImmutableList`, which is neither modifiable nor subject to changes in the original collection.

If you think that all this second-guessing when the source or destination of collections is likely to modify them, and taking appropriate action, sounds a bit tedious, then you aren't alone.
The problem applies to any mutable data, but mutating collections is particularly pernicious, because we often derive values (such as `departsFrom`) that can get out of date if we change the collection we extracted them from.
Rather than taking defensive copies at every function boundary, many teams, your author's included, adopted a simpler and more efficient policy.
This is to treat any collection shared between pieces of code that we own as immutable, even if it had started life as mutable, and despite the mutation operations present in the Java interfaces.
We might occasionally enforce this immutability by wrapping with `Collections.unmodifiableList(...)` etc, but in an aligned development team this is unnecessary because no-one would think to modify a collection just because the Java interface said that they could.
Passing your collection to a library written by another team or organisation may be risky, as is receiving a collection that a source might retain a reference to and mutate later, but in practice we don't find many problems from these causes.
When we do, we can wrap or copy on the boundary of our code as appropriate.

Another way to state this policy is that our code should only every mutate a collection that it has just created.
Never mutate a collection that you have received from another source.

=== Kotlin Collections

In contrast to Java, Kotlin and its standard library were designed in an age when mutability was falling out of fashion.
At the same time though, smooth interoperation with Java was a key goal, and Java has mutable collections.
Scala had tried introducing its own sophisticated persistent (immutable but data-sharing) collections, but this forced developers to copy information between collections on the interop boundary.
How to square this circle?

The Kotlin developers took a different tack.
They took the Java collections interfaces, removed the mutation methods, and published them in the `kotlin.collections` package as `Collection<E>`, 'List<E>` etc.
These were then extended by `MutableCollection<E>`, `MutableList<E>` etc, which add back in the mutation methods.
So in `kotlin.collections`, `MutableList<String>` is a subtype of `List<String>` which is a subtype of `Collection<String>`.
`MutableList<String>` also implements `MutableCollection<String>`.

On the face of it this is a simple scheme.
Mutable collections have the same operations as immutable collections, plus the mutation methods.
It is safe to pass a `MutableList` as an argument to code that expects a `List`, because all the `List` methods will be present and can be invoked.
In terms of the Liskov Substitution Principle, we can substitute a `MutableList` where a `List` is expected, without affecting our program correctness.

A little bit of compiler magic makes it so that Kotlin code can accept a `java.util.List` as either a `kotlin.collections.List`:

// begin-insert: src/test/java/collections/ListInteropTest.kt#immutable
[source,kotlin]
----
val aList: List<String> = SomeJavaCode.mutableListOfStrings("0", "1")
aList.removeAt(1) // doesn't compile
----
// end-insert

or a `kotlin.collections.MutableList`:

// begin-insert: src/test/java/collections/ListInteropTest.kt#mutable
[source,kotlin]
----
val aMutableList: MutableList<String> = SomeJavaCode.mutableListOfStrings("0", "1")
aMutableList.removeAt(1)
assertEquals(listOf("0"), aMutableList)
----
// end-insert

In fact, because the Java `List` is actually mutable here, we can downcast to Kotlin's `MutableList` and mutate:

// begin-insert: src/test/java/collections/ListInteropTest.kt#cast
[source,kotlin]
----
val aList: List<String> = SomeJavaCode.mutableListOfStrings("0", "1")
val aMutableList: MutableList<String> = aList as MutableList<String>
aMutableList.removeAt(1)
assertEquals(listOf("0"), aMutableList)
----
// end-insert

In the other direction, the compiler will allow both a `kotlin.collections.MutableList` and a `kotlin.collections.List` where a `java.util.List` is needed.

// begin-insert: src/test/java/collections/ListInteropTest.kt#javaAcceptMutableList
[source,kotlin]
----
val aMutableList: MutableList<String> = mutableListOf("0", "1")
SomeJavaCode.needsAList(aMutableList)
----
// end-insert

// begin-insert: src/test/java/collections/ListInteropTest.kt#javaAcceptList
[source,kotlin]
----
val aList: List<String> = listOf("0", "1")
SomeJavaCode.needsAList(aList)
----
// end-insert

At face-value, so far everything has been very plausible.
We can differentiate between immutable ++List++s and ++MutableList++s in Kotlin, and easily interoperate with Java.
And because there is an immutable `List` interface, we can implement that rather than the mutable Java version when we want to write nice value types.
Let's convert our `Route` to Kotlin

// begin-insert: tags/wrappers-to-collections.7:src/main/java/travelator/Route.kt
[source,kotlin]
----
data class Route(
    private val journeys: List<Journey>
) : List<Journey> by journeys {
    val departsFrom: Location = journeys[0].departsFrom
}
----
// end-insert

Note how easy it is to delegate our implementation of `List<Journey>` to a field, compared to the Java version.
Also compared to Java, extension functions (or in this case an extension property) give a very natural way for clients to write their specific operations against this interface:

// begin-insert: tags/wrappers-to-collections.7:src/main/java/travelator/Routes.kt#durationOfLongestJourney
[source,kotlin]
----
val List<Journey>.durationOfLongestJourney: Duration
    get() = when {
        isEmpty() -> Duration.ZERO
        else -> map { it.duration }.max() ?: error("unexpected null")
    }
----
// end-insert

Unfortunately, when it comes to mutability, there is more to substitutability than the Liskov Substitution Principle.
Let's go back to our route and populate it from Java.

// begin-insert: tags/wrappers-to-collections.7:src/main/java/travelator/SomeJava.java#someJava
[source,java]
----
List<Journey> journeys = loadJourneys();
Route route = new Route(journeys);

Journey shortestJourney = shortestJourneyIn(journeys);
Location start = route.getDepartsFrom();
----
// end-insert

All seems fine, but we keep getting bug reports that suggest that all is not well, even though our tests pass.
Drilling down we find:

// begin-insert: tags/wrappers-to-collections.7:src/main/java/travelator/SomeJava.java#shortestJourneyIn
[source,java]
----
private static Journey shortestJourneyIn(List<Journey> journeys) {
    journeys.sort(Comparator.comparing(Journey::getDuration));
    return journeys.get(0);
}
----
// end-insert

After a frustrating afternoon in the debugger we realise that, whilst our `Route` thought that it was being populated with an immutable list, no one told the Java code that supplied that list that it couldn't mutate it.
`Route` turns out to be a mutable after all!
Because of this, `departsFrom`, which is initialised in on construction, can get out of date.

The official line is that the non-mutable Kotlin collections are not _immutable_, but rather a _read-only view_ of a collection.
This is the unfortunate consequence of having your mutable collections extend your otherwise non-mutable collections - the recipient of a non-mutable collection cannot modify it, but cannot know that it won't change.
Even in Kotlin we could have created `MutableList`, passed it to `Journey` as a `List`, and then sorted it in place.

The rigorous solution to this problem is to separate mutable from immutable collections by not having a subtype relationship.
In this scheme if we have a mutable list and want an immutable copy of it, we have to copy the data.
A good analogy is a `StringBuilder`.
This is effectively a mutable `String`, but is not a subtype of `String`.
Once we have a result we want to publish we need to call `.toString()`,
and subsequent modifications to the `StringBuilder` will not affect previous results.
Both Clojure and Scala adopt this builder approach for their mutable collections,
why doesn't Kotlin?

We suspect that the answer is: because the Kotlin designers, like your authors, had adopted a Java style where any collection shared from one place to another was treated as immutable, even if it had started life as mutable, and despite the mutation operations present in the Java interfaces.
Sometimes we might enforce this immutability by wrapping with `Collections.unmodifiableList(...)` etc, but in an aligned development team this was unnecessary because no-one would think to modify a collection just because the Java interface said that they could.
Passing your collection to a library written by another team or organisation was risky, as was receiving a collection that a source might retain a reference to and mutate later, but in practice we didn't find many bugs from these causes.
In return for accepting a largely theoretical risk, we, and Kotlin, reaped the rewards of very simple and efficient interoperation with Java.
Pragmatism is typical of the grain of Kotlin - in this case it might be expressed as "be as safe as is sensible, but no safer."

This convention - that any collection received as a parameter, returned as a result, or otherwise shared between code, is considered immutable unless documented as a special case - is a powerful one in Java.
As discussed in <<beans-to-values>>, using values rather than mutable data allows our code to be less complex, with fewer places for bugs to hide.
Mutating collections is particularly pernicious, because we often derive values (such as `departsFrom`) that can get out of date if we change the collection we extracted them from.
In Kotlin, default-immutable collections power this convention.
That's because if we declare all normal references as the 'immutable' versions, we can use `MutableCollection` to document when we do, in fact, consider that the collection is subject to change.

We see this convention in action if we look into the Kotlin standard library.
Here, for example, is (a streamlined version of) the definition of `map`:

// begin-insert: src/main/kotlin/collections/collections.kt
[source,kotlin]
----
inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    val result = ArrayList<R>()
    for (item in this)
        result.add(transform(item))
    return result
}
----
// end-insert

Here we are able to build a list in place by mutation, and then return it as read-only.
This is simple and efficient.
Technically we _could_ downcast the result to `MutableList` and change the result, but we shouldn't.
Instead, we should take the result type at face value - that way


=== Migrating From Java to Kotlin Collections

Remove all visible mutation


TODO

* Beware that Java can mutate a collection that it has passed to Kotlin
* Beware that Java can (at least try to) mutate a collection that is has received from Kotlin.
* If you haven't already, remove mutation from your use of Java collections.
* Where you can't take defensive copies
* Then it will be safe to use Kotlin collections as if they are immutable, rather than just read only
* As more and more of your code is Kotlin you can begin to forget the distinction between read-only and immutable - just always pass immutable and never retain mutable.
* Stay in Kotlin immutable land whenever you can, but if you need efficiency, don't be afraid to create a mutable collection and return it as immutable.

Gotchas

* Java collections say they are mutable, but are often immutable, Kotlin vv
* Kotlin exposing its mutability to Java

=== Conclusions

Java at one time favoured programming with mutability.
That has fallen out of favour, but more by convention than enforcement.
Kotlin has taken a very pragmatic approach to mutability in its collections, giving smooth operation and an simple programming model, but only where your Java conventions align with its approach.

