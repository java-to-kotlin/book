[[methods-to-operators]]
== Methods to Operators

Most of the value types in our application domain model are _abstract data types_.
An abstract data type represents a concept in our application domain, but hides how it represents that concept behind an API.
The API defines the only operations that the rest of the program can use to work with values of the abstract data type, and guarantees that the hidden representation is always correct.

Kotlin's data classes greatly reduce the amount of boilerplate we need to write to implement value semantics.
However, a data class cannot be an abstract data type, because Kotlin generates a copy method that can bypass any other operations you might define for the data and break any correctness guarantees those operations provide.

In this chapter we translate a Java class that implements an abstract data type into Kotlin.
We will support idiomatic usage in both languages while our project is in transition from one to the other.


=== An Abstract Data Type with Value Semantics

One of the most fundamental value types in our Travelator application is `Money`.
Travellers need to budget for their trips.
They want to compare costs of different travel options, see those costs converted to the their preferred currency, and see a grand total of all the costs the trip will involve.

`Money` class is a value type, and an abstract data type:

// begin-insert: tags/value_types.4:src/main/java/travelator/money/Money.java#money
[source,java]
----
public class Money {
    private final BigDecimal amount;
    private final Currency currency;

    private Money(BigDecimal amount, Currency currency) { // <1>
        this.amount = amount;
        this.currency = currency;
    }

    public static Money of(BigDecimal amount, Currency currency) { // <1>
        return new Money(
            amount.setScale(currency.getDefaultFractionDigits()),
            currency);
    }

    // ... and convenience overloads

    public BigDecimal getAmount() { // <2>
        return amount;
    }

    public Currency getCurrency() { // <3>
        return currency;
    }

    @Override
    public boolean equals(Object o) { // <3>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amount.equals(money.amount) &&
            currency.equals(money.currency);
    }

    @Override
    public int hashCode() { // <3>
        return Objects.hash(amount, currency);
    }

    @Override
    public String toString() { // <4>
        return amount.toString() + " " + currency.getCurrencyCode();
    }

    public Money add(Money that) { // <5>
        if (!this.currency.equals(that.currency)) {
            throw new IllegalArgumentException(
                "cannot add Money values of different currencies");
        }

        return new Money(this.amount.add(that.amount), this.currency);
    }
}
----
// end-insert

<1> The constructor is private.
Other classes obtain Money values by calling the static `Money.of` method, which guarantees that the scale of the amount is consistent with the number of minor units of the currency.
Most currencies have 100 minor units (two digits), but some have fewer and some more: the Japanese Yen has no minor units, and the Jordanian Dinar has one thousand, for example.
+
The "of" method follows a coding convention of <<modern-java-style,Modern Java>> that draws a distinction in the source between objects with identity, which are constructed by the new operator, and values, which are obtained from static methods.
This convention is followed by the Java time API (for example `LocalDate.of(2020,8,17)`) and recent additions to the collections API (for example, `List.of(1,2,3)` creates an immutable list)
+
The class provides some convenient overloads of the `of` method for String or int amounts.
<2> A `Money` value exposes its amount and currency properties using Java Bean conventions, even though it is not actually a Java Bean.
<3> The equals and hashCode methods implement value semantics.
<4> The toString method returns a representation of its properties that can be shown to the user, not just for debugging.
<5> `Money` provides operations for calculating with money values.
For example, you can add monetary values together.
The `add` method constructs new Money values by calling the constructor directly, because the result of BigDecimal.add has the correct scale already and so we can avoid the overhead of setting the scale.

[NOTE]
====
.BigDecimal.setScale does not set the scale!

The method `BigDecimal.setScale` is confusing.
Although named like a Java Bean setter, it does not actually mutate the BigDecimal object.
Like our Money class, BigDecimal is an immutable value type, so `setScale` returns a BigDecimal value with the specified scale.

Sun added the BigDecimal class to the standard library in Java 1.1. This release also included the first version of the Java Beans API. The hype around the Beans API popularised the Java Beans coding conventions, and they were widely adopted, even for classes that, like BigDecimal, were not Java Beans (see <<bean-java-style>>).
There were no Java conventions for value types.

Today, we avoid the "set" prefix for methods that do not mutate their receiver and instead use names that emphasise when the method returns a transformation of the receiver.
One convention is to use the prefix "with" for transformations that affect a single property, which would make the code in our Money class read as:

[source,kotlin]
----
 amount.withScale(currency.getDefaultFractionDigits())
----

In Kotlin we can write extension methods to fix such historical accidents.
If we were writing a lot of code that calculated with BigDecimals, it might be worth doing so to improve the clarity of the code:

[source,kotlin]
----
inline fun BigDecimal.withScale(int scale, RoundingMode mode) =
    setScale(scale, mode)
----
====

Converting Money to Kotlin produces the following code:

// begin-insert: tags/value_types.5:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money
private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val money = o as Money
        return amount == money.amount && currency == money.currency
    }

    override fun hashCode(): Int {
        return Objects.hash(amount, currency)
    }

    override fun toString(): String {
        return amount.toString() + " " + currency.currencyCode
    }

    fun add(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    companion object {
        @JvmStatic
        fun of(amount: BigDecimal, currency: Currency): Money {
            return Money(
                amount.setScale(currency.defaultFractionDigits),
                currency
            )
        }

        // ... and convenience overloads
    }
}
----
// end-insert

The Kotlin class still has a primary constructor, but that constructor is now marked private.
The syntax for this is a little clunky.

The static "of" functions are now methods on a companion object.
IntelliJ noticed that they are called from our Java code, and annotated them as `@JvmStatic` to ensure they are compiled to static methods and the call sites in the Java code are unaffected.

****
TODO: sidebar to explain @Jvm... annotations.
Coordinate with what Duncan is writing.
****

Can we also reduce the size of the class even further by making it a data class?

When we change `class` to `data class`, IntelliJ highlights the `private` keyword of the primary constructor with a warning:

----
Private data class constructor is exposed via the generated 'copy' method."
----

What's that all aboutâ¸®

Kotlin generates a public `copy` method for data classes that creates a copy of an instance, replacing some of the field values.

The constructor of the Money class is private because the class maintains an invariant between its properties, ensuring that the scale of the amount field is equal to the default number of minor currency digits of the currency field.
The `Money.of(BigDecimal,Currency)` method ensures the invariant for new Money values.
The `add` method maintains the invariant because adding two BigDecimal values with the same scale produces a BigDecimal that also has the same scale.
The add method therefore can call the constructor directly because doesn't need to recalculate the scale.
The constructor need only assign fields, safe in the knowledge that it is only called with parameters that meet the class invariant. and it is private to prevent code outside the Money class from creating values that violate the invariant.

However, the public `copy` method of a data class _would_ allow client code to create Money values that violate the invariant.
Our Money class cannot be a data class.

[WARN]
====
Don't define a value type as a data class if it must maintain invariants between its properties.
====

We can still make the code more concise by applying other Kotlin features.
We can define all the methods in single-expression form, and lean on Kotlin's flow-sensitive type inference to greatly simplify the `equals` method:

// begin-insert: tags/value_types.7:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    override fun equals(other: Any?) =
        this === other ||
            other is Money &&
            amount == other.amount &&
            currency == other.currency

    override fun hashCode() =
        Objects.hash(amount, currency)

    override fun toString() =
        amount.toString() + " " + currency.currencyCode

    fun add(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    companion object {
        @JvmStatic
        fun of(amount: BigDecimal, currency: Currency) = Money(
            amount.setScale(currency.defaultFractionDigits),
            currency
        )

        // ... and convenience overloads
    }
}
----
// end-insert

=== Supporting Both Java and Kotlin Conventions

Our `Money` class still looks sort of "Java-ish".
It follows conventions for value types that are common in <<modern-java-style,Modern Java>>, but are not the way things are usually done in Kotlin:
it uses methods of a companion object to create values,
and it uses methods, rather than operators, for arithmetic.

In a monolingual codebase, it would be pretty straightforward to address those issues.
However, when adopting Kotlin in a project that has a significant amount of Java, it's unlikely that we will translate all the Java in one big bang.
That involves too much up-front cost and risk.
Instead, we'll continue to make changes to the Java and to the Kotlin, until Kotlin has edged Java out altogether.
In the meantime, when both Kotlin _and_ Java use a Kotlin class, we'll ensure that the call sites in either language are conventional enough not to frighten the horses.


=== Adding A User-Defined Operator

Kotlin code that adds Money values is still rather clumsy:

[source,kotlin]
----
val total = price.add(tax)
----

This is the best we can do in Java, but in Kotlin we can define arithmetic operators for our own classes, allowing us to write that code as:

[source,kotlin]
----
val total = price + tax
----

We give classes the `+` operator by writing an operator method or extension function called `plus`.
For our Money class we can rename the existing `add` method to `plus` and add the `operator` modifier:

// begin-insert: tags/value_types.9:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    ...

    operator fun plus(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    ...
}
----
// end-insert

With this change, our Kotlin code can add Money values with the + operator, while the Java code calls `plus` as a method.

The name "plus" isn't conventional Java.
Java classes in the standard library that have arithmetic operations, such as BigDecimal and BigInteger, use the name "add", not "plus".

We can make the method appear to have different names in Java and Kotlin by annotating it's definition with the `@JvmName` annotation.
Let's revert the change we just made and take another run at it, starting by annotating the method with `@JvmName("add")`.

// begin-insert: tags/value_types.10:src/main/java/travelator/money/Money.kt#add_method
[source,kotlin]
----
@JvmName("add")
fun add(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Now when we rename the method to "plus", our Java code is unchanged, and
marking it as an operator allows both Java and Kotlin code to call the method according to their respective language conventions:

// begin-insert: tags/value_types.11:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
@JvmName("add")
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Whether this is desirable is a matter of opinion.
It can be quite confusing to have the same method appear under different names in different parts of the same codebase,
but on the other hand, because it's an operator method, the name "plus" should only appear in the definition of the method, and all uses of the method be via the `+` operator. The phrase `operator fun plus` is more like a language keyword than a method name.
On balance, your authors think it's worth using the @JvmName annotation in this case,
but in general you will need to come to an agreement within your team about how you use the `@JvmName` annotation to adjust Kotlin classes to Java clients.


=== Calling Our Operator from Existing Kotlin Code

This still leaves us with a problem.
At the time of writing, IntelliJ does not have an automated refactoring to replace all direct calls to an operator method with use of the respective operator.
Any of our Kotlin code that had been calling the `Money.add` method before we turned it into an operator will be left calling `Money.plus` as a method instead of using the `+` operator.
Even if we only called `Money.add` from Java code, we still have a problem:
IntelliJ will convert Java that calls `Money.add` into Kotlin that calls 'Money.plus' as a method instead of using `+` operator.
IntelliJ can automatically refactor each of those call sites from a method call to an operator, but we would have to go through them one by one, refactoring each one individually.

To address these problems, we'll use a sequence of refactoring steps to switch all our Kotlin code over to use the `+` operator, and leave a hook in our code to let us easily do that in bulk as we convert more Java classes to Kotlin.

Let's revert our change again, and take yet another run at the conversion.

This time, we'll extract the entire body of the `add` method as a method called `plus` and make it a public, operator method:

// begin-insert: tags/value_types.13:src/main/java/travelator/money/Money.kt#extract_plus
[source,kotlin]
----
fun add(that: Money): Money {
    return plus(that)
}

operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

Using IntelliJ's automatic refactoring, we make `this` explicit in the call to `plus`:

// begin-insert: tags/value_types.14:src/main/java/travelator/money/Money.kt#add
[source,kotlin]
----
fun add(that: Money): Money {
    return this.plus(that)
}
----
// end-insert

From this form, IntelliJ's lets us automatically refactor from method call to operator:

// begin-insert: tags/value_types.15:src/main/java/travelator/money/Money.kt#add
[source,kotlin]
----
fun add(that: Money): Money {
    return this + that
}
----
// end-insert

Finally we can transform the `add` method to single-expression form.

// begin-insert: tags/value_types.16:src/main/java/travelator/money/Money.kt#extract_plus
[source,kotlin]
----
fun add(that: Money) = this + that

operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(amount.add(that.amount), currency)
}
----
// end-insert

We now have two methods for addition.
The `plus` operator method implements the addition logic and is what we'd like all our Kotlin code to use in the future, but nothing calls it directly yet.
The `add` method will remain for use by our Java code, while it exists, and its body contains the ideal syntax we would like to use in our Kotlin code.

We can make all our Kotlin code that adds Money values use that ideal syntax by inlining the `Money.add` method.
When we do so, IntelliJ reports that it was unable to inline all the uses of `add`.
That's just what we want!
We can't inline Kotlin code into Java, so IntelliJ has inlined the body of `add` method only into the Kotlin call sites, and has kept it's definition in the `Money` class because it is still called by Java.
All our Kotlin code is now using the `+` operator, and our Java code is unchanged.

In the future, when we translate more Java classes that add Money values to Kotlin, we can inline the `add` method again to make the converted Kotlin class use the `+` operator instead of method call syntax.
As long as there is Java code in our codebase that calls it, IntelliJ will preserve the `add` method.
After we've converted the last Java class that adds Money, IntelliJ will remove the now unused `add` method as part of the inline refactoring.
Our codebase will then only use the `+` operator.

// this refactoring combo is also used to introduce infix methods in the JSON DSL chapter -- ensure they are consistent and don't repeat themselves


=== Operators for Existing Java Classes

While we're working on the `plus` method, we can also take the opportunity to use the `+` operator inside the method to add the amount values.
The Money class represents its amount as a `BigDecimal`, a class from the Java standard library.
We can replace the call to the BigDecimal's `add` method with the + operator:

// begin-insert: tags/value_types.18:src/main/java/travelator/money/Money.kt#plus_method
[source,kotlin]
----
operator fun plus(that: Money): Money {
    require(currency == that.currency) {
        "cannot add Money values of different currencies"
    }

    return Money(this.amount + that.amount, currency)
}
----
// end-insert

Our code continues to compile.
How is that possible?

The Kotlin standard library includes extension functions that define operators for classes in the Java standard library: mathematical classes, such as `BigInteger` and `BigDecimal` and collections, such as `List<T>` or `Set<T>`.
Because these extension functions are defined in the `kotlin` package, they are available to any package automatically; we don't need to import them.


=== Conventions for Denoting Values

The static `of` functions on the companion object, used to denote Money values, also break Kotlin conventions.

Java syntax distinguishes between instantiating a class with the `new` operator and obtaining an object as the result of a method call.
A <<modern-java-style,Modern Java>> convention is that stateful objects, for which identity is significant, are constructed with the new operator, and values are denoted by calls to static factory functions.
For example, the expression `new ArrayList<>()` constructs a new mutable list distinct from any other mutable list, while the expression `List.of("a","b","c")` denotes an immutable list value.

Kotlin does not draw a distinction between constructing objects and calling functions: the syntax for instantiating a class is the same as that for calling a function.
Nor are there coding conventions to distinguish between constructing new a stateful object that has a distinct identity, and denoting values that do not.

NOTE: Although the Kotlin code for calling a function and instantiating a class look the same, they are implemented by different JVM bytecode.  A source-compatible change between a class and a function will not be binary-compatible.

Where a class needs multiple factory functions, as does our Money class, they are usually defined as top level functions, not on the companion object of the class.
IntelliJ does its bit to nudge one towards this style:
it is much better at autosuggesting top-level functions than methods on a companion object.

So, it would be more conventional if our Money class was created by expressions like `Money(...)` or, alternatively, like `moneyOf(...)`, than like `Money.of(...)`.

We've declared the Money constructor as private, so it looks like the easiest option would be to define top-level `moneyOf` functions in the same source file as the Money class.
However, those `moneyOf` functions would have to call the Money class' constructor, making it invisible outside the class.
We would have to declare it as `internal`, rather than `private`.

Internal visibility would make the constructor visible to any Kotlin code in the same compilation unit (equivalent to a Gradle subproject or IntelliJ module), but prevent it being called by Kotlin code in other compilation units.
The compilation unit, rather than the class, would be responsible for guaranteeing the invariants of the Money class by never calling its constructor inappropriately.
That would be safe enough, if it wasn't for those parts of our system that we will continue to maintain in Java during our system's transition to Kotlin.
Java and the JVM do not have the concept of internal visibility.
The Kotlin compiler translates internal features of a class to a public features in the JVM classfiles it generates, and records the internal visibility as additional metadata that is processed by the Kotlin compiler but ignored by the Java compiler.
As a result, Kotlin features declared as internal appear to be public to the Java compiler and JVM, allowing us to accidentally create invalid Money values when we're working in the Java code of our project.
That makes top-level `moneyOf` functions an unattractive option.

Instead, we can lean on Kotlin's operator overloading again.
If we define the function call operator for the Money class' companion object, Kotlin code can create money values using the same syntax as if they were directly calling the constructor.
We implement the function call operator by defining by an operator function called `invoke`:

Just as we found when renaming the `add` method to `plus`, merely renaming `of` to `invoke` will have a knock-on effect on our Java code.
Java code that creates Money values changes from reading as `Money.of(100, EUR)` to `Money.invoke(100, EUR)`.
The `of` methods had _two_ responsibilities: to enforce the class invariants when constructing money values, and to provide syntactic sugar in the caller that conforms to Modern Java conventions for denoting values.
Renaming from `of` to `invoke` doesn't affect the former, but messes up the latter.

We can use the same combo of extract method, refactor the call to the extracted method, and inline method to avoid any negative effects on our Java code as we refactor our Kotlin code to follow Kotlin conventions.

First, extract the `of` method's entire body as a method called `invoke`.

// begin-insert: tags/value_types.19:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    ...

    companion object {
        @JvmStatic
        fun of(amount: BigDecimal, currency: Currency) =
            invoke(amount, currency)

        private fun invoke(amount: BigDecimal, currency: Currency) =
            Money(
                amount.setScale(currency.defaultFractionDigits),
                currency
            )

        // ... and convenience overloads
    }
}
----
// end-insert

Then make `invoke` a public operator method:

// begin-insert: tags/value_types.20:src/main/java/travelator/money/Money.kt#delegation
[source,kotlin]
----
@JvmStatic
fun of(amount: BigDecimal, currency: Currency) =
    invoke(amount, currency)

operator fun invoke(amount: BigDecimal, currency: Currency) =
    Money(
        amount.setScale(currency.defaultFractionDigits),
        currency
    )
----
// end-insert:

This allows us to call the Money companion object as a function, so how come the call to `Money(...)` in the body of the `invoke` method does not overflow the call stack?
Inside the `invoke` method, the call to `Money(...)` is not a recursive call to `invoke` but actually calls the private `Money` constructor.
Outside the class, a call to `Money(...)` calls the companion object's `invoke` method, because the private constructor is not visible.
We have the best of both worlds: conventional syntax for instantiating the class, and an encapsulation boundary that guarantees the class invariants when required.

To make existing Kotlin code use  that conventional syntax, we need to first  make the companion object's `of` method call itself as a function:

// begin-insert: tags/value_types.21:src/main/java/travelator/money/Money.kt#call_this
[source,kotlin]
----
@JvmStatic
fun of(amount: BigDecimal, currency: Currency) =
    this(amount, currency)
----
// end-insert:

Then, we inline the `of` method into our Kotlin code.
Again, Java code will not be affected, and when there is no Java code calling the `of` method, the IDE will remove it for us.

Before the inline refactoring, Kotlin code that creates Money values looks like this:

// begin-insert: tags/value_types.23:src/main/java/travelator/money/ExchangeRates.kt
[source,kotlin]
----
interface ExchangeRates {
    fun rate(fromCurrency: Currency, toCurrency: Currency): BigDecimal

    @JvmDefault
    fun convert(fromMoney: Money, toCurrency: Currency): CurrencyConversion {
        val rate = rate(fromMoney.currency, toCurrency)
        val toAmount = fromMoney.amount * rate
        val toMoney = Money.of(toAmount, toCurrency)

        return CurrencyConversion(fromMoney, toMoney)
    }
}
----
// end-insert:

After the inline refactoring, it looks like this:

// begin-insert: tags/value_types.24:src/main/java/travelator/money/ExchangeRates.kt
[source,kotlin]
----
interface ExchangeRates {
    fun rate(fromCurrency: Currency, toCurrency: Currency): BigDecimal

    @JvmDefault
    fun convert(fromMoney: Money, toCurrency: Currency): CurrencyConversion {
        val rate = rate(fromMoney.currency, toCurrency)
        val toAmount = fromMoney.amount * rate
        val toMoney = Money(toAmount, toCurrency)

        return CurrencyConversion(fromMoney, toMoney)
    }
}
----
// end-insert:


=== Conclusions

Java and Kotlin have different conventions that work with the different grains of the two languages.

We don't want our use of Kotlin to have a negative effect on our Java, or leave our Kotlin code as mere Java in Kotlin syntax.

Using annotations and delegation we can ensure that both Kotlin and Java code remains conventional during the transition to Kotlin.
The "extract-and-inline" refactoring combo makes this cheap to introduce, and to eliminate when no longer needed.

Now let's take a look at how the grain of the two languages differs when working with optional data and collections.
