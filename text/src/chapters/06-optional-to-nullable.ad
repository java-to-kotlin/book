== Optional to Nullable

Null may have been a billion dollar mistake, but we still need to represent the absence of things in our software systems.
How can we use Kotlin's nullability support to embrace null while still having safe software?

Perhaps Kotlin's most attractive feature for Java programmers is its representation of nullability in the typesystem.
We won't start by rehashing the arguments around why this is such a good idea, but instead observe that this is another area where the grains of Java and Kotlin are different.

Prior to Java 8, Java relied on convention, documentation, and intuition to distinguish between references that could or could not be null.
We can deduce that methods that return an item from a collection must be able to return `null`, but can `addressLine3` be `null`, or do we use an empty string when there is no information?

Over the years, your authors and their Java colleagues settled into a convention where Java references are assumed non-null, unless otherwise flagged.
So we might name a field `addressLine3OrNull`, or a method `previousAddressOrNull`.
Within a codebase this worked well enough; even if it is a little verbose, and requires eternal vigilance to avoid the scourge of `NullPointerExceptions`.

Some codebases instead opted to use `@Nullable` and `@NotNullable` annotations, often supported by tools that would check for correctness.
Java 8, released in 2014, enhanced support for annotations to the extent that tools like the https://checkerframework.org[Checker Framework] could statically check much more than just null safety.
More crucially though, it introduced a standard `Optional` type.

By this time many JVM developers had dabbled in Scala and come to appreciate the advantages of using a _Maybe_ type (named `Option` in Scala's standard library) when absence was possible, and plain references when it was not.
Oracle muddied the waters by telling developers not to use their `Optional` for field values because it wasn't serializable (as if anyone had ever actually used Java serialisation in the preceding decade).
As with many features introduced in Java 8 though,
`Optional` was good enough and was adopted into the mainstream usage of Java.

Depending on its age, your Java code may use some or all of these strategies for dealing with absence.
It is certainly possible to have a codebase in which `NullPointerExceptions` are practically never seen, but the reality is that this is hard work.
Java is weighed down by null, and embarrassed by its half-hearted `Optional` type.

In contrast, Kotlin embraces null.
Making optionality a part of the typesystem, rather than the standard library, means that Kotlin codebases have refreshing uniformity in their treatment of missing values.
It isn't all perfect:
`Map<K, V>.get(key)` returns a nullable `V?`
if there is no value for `key`; but
`Array<T>.get(index)` throws `IndexOutOfBoundsException`
when there is no value at `index`.
Likewise `Iterable<T>.first()` throws `NoSuchElementException`
rather than returning `null`.
Largely though the imperfections were forced on the designers to give backwards compatibility with Java.

Where Kotlin has its own APIs they are generally good examples of how to safely use null to represent optional properties, parameters and return values.
Returning to languages without this support feels unsafe.
Like riding a bike on a cliff path with no fence, your speed is limited by the unmitigated risk.

Functional programmers may have advised you to use a Maybe type rather than nullablity in Kotlin.
We counsel against this, even though it will give you the option to use the same (monadic, there, we said it) tools to represent potential absence, errors, asynchrony, etc.
One reason not to use `Optional` in Kotlin is that you will lose access to the language features designed specifically to support nullablity - in this area the grain of Kotlin is different to the grain of, say, Scala.

Another reason not to use wrapper type to represent optionality is subtle but important.
In the Kotlin typesystem, `T` is a subtype of `T?`.
If we have a `T` that cannot be null, we can always use it where a nullable `T` is required.
In contrast, `T` is not a subtype of `Optional<T>`.
If we have a String and we want to assign it to an optional variable, we have first to wrap it in an `Optional`.
Worse, if we have a function that returns an `Optional<String>` and later discover a way to always return a result, changing the return type to `String` will break all our clients.
Had our return type been `T?`, then we could have strengthed it to `T` whilst maintaining compatibility.
The same applies to properties of data structures: we easily migrate from optional to non-optional with nullability, but not, ironically, with `Optional`.

It's safe to say then that your authors love Kotlin's support for nullablity, and have learned to lean on it to solve many problems.
It takes a while to wean yourself off of avoiding nulls, but once you have, there is literally a whole new dimension of expressiveness to explore and exploit.

It seems a shame not to have that facility in Travelator, so let's look at how to migrate from Java code using `Optional`
to Kotlin and nullable.

=== Migrating from Optional to Nullable

Travelator trips are divided into ++Leg++s, where each `Leg` is an unbroken journey.
Here is one of the utility functions we've found in the code, designed to find legs over a given duration.

// begin-insert: tags/nullability.0:src/main/java/travelator/Legs.java
[source,java]
----
public class Legs {

    public static Optional<Leg> findLongestLegOver(List<Leg> legs, Duration duration) {
        Leg result = null;
        for (Leg leg : legs) {
            if (isLongerThan(leg, duration))
                if (result == null || isLongerThan(leg, result.getPlannedDuration())) {
                    result = leg;
                }
        }
        return Optional.ofNullable(result);
    }

    private static boolean isLongerThan(Leg leg, Duration duration) {
        return leg.getPlannedDuration().compareTo(duration) > 0;
    }
}
----
// end-insert

The tests not only check the code works as intended, but allow us to see its behaviour at a glance:

// begin-insert: tags/nullability.0:src/test/java/travelator/LongestLegOverTests.java#foo
[source,java]
----
public class LongestLegOverTests {

    private List<Leg> legs = List.of(
        new Leg("one hour",
            ...
        ),
        new Leg("one day",
            ...
        ),
        new Leg("two hours",
            ...
        )
    );
    private final Duration oneDay = Duration.ofDays(1);

    @Test
    public void is_absent_when_no_legs() {
        assertEquals(
            Optional.empty(),
            findLongestLegOver(emptyList(), Duration.ZERO)
        );
    }

    @Test
    public void is_absent_when_no_legs_long_enough() {
        assertEquals(
            Optional.empty(),
            findLongestLegOver(legs, oneDay)
        );
    }

    @Test
    public void is_longest_leg_when_one_match() {
        assertEquals(
            "one day",
            findLongestLegOver(legs, oneDay.minusMillis(1)).orElseThrow().getDescription()
        );
    }

    @Test
    public void is_longest_leg_when_more_than_one_match() {
        assertEquals(
            "one day",
            findLongestLegOver(legs, Duration.ofMinutes(59)).orElseThrow().getDescription()
        );
    }
}
----
// end-insert

Let's see what we can do to make things better in Kotlin.
Converting `Legs.java` to Kotlin gives us this (after a little reformatting):

// begin-insert: tags/nullability.2:src/main/java/travelator/Legs.kt
[source,kotlin]
----
object Legs {
    @JvmStatic
    fun findLongestLegOver(legs: List<Leg>, duration: Duration): Optional<Leg> {
        var result: Leg? = null
        for (leg in legs) {
            if (isLongerThan(leg, duration))
                if (result == null || isLongerThan(leg, result.plannedDuration))
                    result = leg
        }
        return Optional.ofNullable(result)
    }

    private fun isLongerThan(leg: Leg, duration: Duration): Boolean {
        return leg.plannedDuration.compareTo(duration) > 0
    }
}
----
// end-insert

The method parameters are as we would expect, with Kotlin `List<Leg>` transparently accepting a `java.util.List`.
It's worth mentioning here that, when a Kotlin function declares a non-nullable parameter, the compiler inserts a null check before the function body.
That way, if Java callers sneak in a `null` we know straight away (the `legs` parameter is similarly checked).
Because of these defensive checks Kotlin detects unexpected nulls as close as possible to their source, in contrast to Java, where a reference can be set to `null` a long way in time and space from where it finally explodes.

Returning to the example, the Kotlin `for` loop is very similar to Java's, except for the use of the `in` keyword rather than `:`, and similarly applies to any type that extends `Iterable`.
Actually, you can use other types as well - the Kotlin `for` "iterates over anything that is iterable (anything that has an iterator() function that provides an Iterator object), or anything that is itself an iterator".
You can even define an (operator) extension function to make someone else's type `Iterable` - we hope to find a use for that one day.

The converted `findLongestLegOver` code is not very idiomatic Kotlin.
Arguably, since the introduction of streams, it wasn't very idiomatic Java either.
Instead of a for loop we should look for something more intention-revealing, but let's park that urge for now because our primary mission is to migrate from `Optional` to nullable.
We'll illustrate that by converting our tests one by one, so that we have a mix as we would in a codebase that we were migrating.
In order to make use of nullability in our clients they have to be Kotlin, so let's convert the tests.

// begin-insert: tags/nullability.3:src/test/java/travelator/LongestLegOverTests.kt#foo
[source,kotlin]
----
class LongestLegOverTests {
    ...
    @Test
    fun is_absent_when_no_legs() {
        Assertions.assertEquals(
            Optional.empty<Any>(),
            findLongestLegOver(emptyList(), Duration.ZERO)
        )
    }

    @Test
    fun is_absent_when_no_legs_long_enough() {
        Assertions.assertEquals(
            Optional.empty<Any>(),
            findLongestLegOver(legs, oneDay)
        )
    }

    @Test
    fun is_longest_leg_when_one_match() {
        Assertions.assertEquals(
            "one day",
            findLongestLegOver(legs, oneDay.minusMillis(1)).orElseThrow().description
        )
    }

    @Test
    fun is_longest_leg_when_more_than_one_match() {
        Assertions.assertEquals(
            "one day",
            findLongestLegOver(legs, Duration.ofMinutes(59)).orElseThrow().description
        )
    }
}
----
// end-insert

Actually (when we wrote this) the converted code didn't compile, but what's the odd import between friends? Alt-Enter does the needful.

Now to migrate gradually, we're going to need two versions of `findLongestLegOver`, the existing `Optional`-returning one, and a new one that returns `Leg?`.
We can do that by extracting the guts of the current implementation.
We can't give it the same name, so we use `longestLegOver`.

// begin-insert: tags/nullability.4:src/main/java/travelator/Legs.kt#foo
[source,kotlin]
----
@JvmStatic
fun findLongestLegOver(
    legs: List<Leg>,
    duration: Duration
): Optional<Leg> {
    return Optional.ofNullable(longestLegOver(legs, duration))
}

fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? {
    var result: Leg? = null
    for (leg in legs) {
        if (isLongerThan(leg, duration))
            if (result == null || isLongerThan(leg, result.plannedDuration))
                result = leg
    }
    return result
}
----
// end-insert

Now we can convert our Kotlin clients to call the nullable-returning `longestLegOver`, while leaving our Java clients (and as-yet-unconverted Kotlin) to consume the `Optional`.

We'll do the absent ones first.
Change `assertEquals(Optional.empty<Any>())`

// begin-insert: tags/nullability.4:src/test/java/travelator/LongestLegOverTests.kt#absent
[source,kotlin]
----
@Test
fun is_absent_when_no_legs() {
    assertEquals(
        Optional.empty<Any>(),
        findLongestLegOver(emptyList(), Duration.ZERO)
    )
}

@Test
fun is_absent_when_no_legs_long_enough() {
    assertEquals(
        Optional.empty<Any>(),
        findLongestLegOver(legs, oneDay)
    )
}
----
// end-insert

to `assertNull`

// begin-insert: tags/nullability.5:src/test/java/travelator/LongestLegOverTests.kt#absent
[source,kotlin]
----
@Test
fun `is absent when no legs`() {
    assertNull(longestLegOver(emptyList(), Duration.ZERO))
}

@Test
fun `is absent when no legs long enough`() {
    assertNull(longestLegOver(legs, oneDay))
}
----
// end-insert

Now for the calls returning non-absent.

// begin-insert: tags/nullability.4:src/test/java/travelator/LongestLegOverTests.kt#present
[source,kotlin]
----
@Test
fun is_longest_leg_when_one_match() {
    assertEquals(
        "one day",
        findLongestLegOver(legs, oneDay.minusMillis(1)).orElseThrow().description
    )
}

@Test
fun is_longest_leg_when_more_than_one_match() {
    assertEquals(
        "one day",
        findLongestLegOver(legs, Duration.ofMinutes(59)).orElseThrow().description
    )
}
----
// end-insert

The Kotlin equivalent of `Option.orElseThrow()`
(aka `get()`) is the `!!` operator.

// begin-insert: tags/nullability.6:src/test/java/travelator/LongestLegOverTests.kt#present
[source,kotlin]
----
@Test
fun `is longest leg when one match`() {
    assertEquals(
        "one day",
        longestLegOver(legs, oneDay.minusMillis(1))!!.description
    )
}

@Test
fun `is longest leg when more than one match`() {
    assertEquals(
        "one day",
        longestLegOver(legs, Duration.ofMinutes(59))?.description
    )
}
----
// end-insert

We've converted the first of the non-null-returning tests this way, but it suffers from failing the test with a thrown `NullPointerException` rather than a nice diagnostic.
In the second case we've solved that problem with `?.` - so that if the leg is `null` the error will be

----
Expected :one day
Actual   :null
----

which is much nicer.

We can work this refactoring through our clients, converting them to Kotlin and then to using `longestLegOver`.
Once we have converted all of them we delete the `Optional`-returning `findLongestLegOver`, and move its replacement `longestLegOver`
out of the `Legs` object scope into the top-level.
Unfortunately this refactoring is not automated - we describe the steps in detail in <<static-methods-to-free-standing-functions>>.

We now have just a top-level Kotlin function, plus a supporting function that we converted to an extension function because, well, it just reads better that way.

// begin-insert: tags/nullability.7:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? {
    var result: Leg? = null
    for (leg in legs) {
        if (leg.isLongerThan(duration))
            if (result == null || leg.isLongerThan(result.plannedDuration))
                result = leg
    }
    return result
}

private fun Leg.isLongerThan(duration: Duration) =
    plannedDuration.compareTo(duration) > 0
----
// end-insert

=== Refactoring to Idiomatic Kotlin

Now we're all-Kotlin, but the normal feeling of relaxation we get from finishing a refactor is spoiled by that implementation - it still looks like Java converted to Kotlin, largely on account of it being Java converted to Kotlin.
Can we find a nice way to refactor it?

The only suggestion IntelliJ gives is to replace `compareTo` with `>`, so let's do that first.
Once we have, `isLongerThan` isn't really pulling its weight, so we inline it.
At this point we run out of refactoring talent (you may be more inspired) and decide to rewrite the function from scratch.

In order to do so, we ask ourselves, "What is the code trying to do?"
The answer is helpfully in the name of the function - `longestLegOver`.
In order to implement this calculation, we can find the longest leg, and if it is longer than duration, return it, otherwise null.
Typing `legs.` at the beginning of the function we look at the suggestions and find `maxBy` - our longestLeg is going to be `legs.maxBy(Leg::plannedDuration)`.
This API helpfully returns `Leg?` to remind us that it can't give a result if `legs` is empty.
Converting our algorithm "find the longest leg, and if it is longer than duration, return it, otherwise null" to code directly we have:

// begin-insert: tags/nullability.8:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? {
    val longestLeg: Leg? = legs.maxBy(Leg::plannedDuration)
    if (longestLeg != null && longestLeg.plannedDuration > duration)
        return longestLeg
    else
        return null
}
----
// end-insert

That passes the tests, but those multiple returns are ugly.
IntelliJ will helpfully offer to lift the `return` out of the `if`.

// begin-insert: tags/nullability.9:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? {
    val longestLeg: Leg? = legs.maxBy(Leg::plannedDuration)
    return if (longestLeg != null && longestLeg.plannedDuration > duration)
        longestLeg
    else
        null
}
----
// end-insert

Now Kotlin's nullability support allows several ways to refactor this, depending on your tastes.

We can return early

// begin-insert: tags/nullability.10:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? {
    val longestLeg = legs.maxBy(Leg::plannedDuration) ?:
        return null
    return if (longestLeg.plannedDuration > duration)
        longestLeg
    else
        null
}
----
// end-insert

or we can go with a single `?.let` expression

// begin-insert: tags/nullability.11:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? =
    legs.maxBy(Leg::plannedDuration)?.let { longestLeg ->
        if (longestLeg.plannedDuration > duration)
            longestLeg
        else
            null
    }
----
// end-insert

That is succinct, and a pleasing single-expression, but maybe hard to comprehend in a single glance.
Spelling out the options with a `when` is clearer

// begin-insert: tags/nullability.13:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? {
    val longestLeg = legs.maxBy(Leg::plannedDuration)
    return when {
        longestLeg == null -> null
        longestLeg.plannedDuration > duration -> longestLeg
        else -> null
    }
}
----
// end-insert

In order to simplify further we need a trick that Duncan (who is writing this) has so far failed to internalise.
`takeIf` returns its receiver if a predicate is `true`, otherwise null, which is exactly the logic of our `let` block.
So we can write

// begin-insert: tags/nullability.12:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun longestLegOver(
    legs: List<Leg>,
    duration: Duration
): Leg? =
    legs.maxBy(Leg::plannedDuration)?.takeIf { longestLeg ->
        longestLeg.plannedDuration > duration
    }
----
// end-insert

Depending on the team's experience with Kotlin, that may be too subtle?
Nat thinks it's fine, but we're going to err on the side of explicit, so the `when` version gets to stay, at least until the next time someone refactors here.

Finally, let's make `legs` the receiver in an extension function, allowing us finally to get rid of our accidental double-entendre.

// begin-insert: tags/nullability.14:src/main/java/travelator/Legs.kt
[source,kotlin]
----
fun List<Leg>.longestOver(duration: Duration): Leg? {
    val longestLeg = maxBy(Leg::plannedDuration)
    return when {
        longestLeg == null -> null
        longestLeg.plannedDuration > duration -> longestLeg
        else -> null
    }
}
----
// end-insert

Just before we finish this chapter, take the time to compare this version with the original.
Are there any advantages to the old version?

// begin-insert: tags/nullability.0:src/main/java/travelator/Legs.java
[source,java]
----
public class Legs {

    public static Optional<Leg> findLongestLegOver(List<Leg> legs, Duration duration) {
        Leg result = null;
        for (Leg leg : legs) {
            if (isLongerThan(leg, duration))
                if (result == null || isLongerThan(leg, result.getPlannedDuration())) {
                    result = leg;
                }
        }
        return Optional.ofNullable(result);
    }

    private static boolean isLongerThan(Leg leg, Duration duration) {
        return leg.getPlannedDuration().compareTo(duration) > 0;
    }
}
----
// end-insert

Usually we would say "It depends," but in this case we think that the new version is better on pretty much every front.
It is shorter, simpler, easier to see how it works, and in most cases results in fewer calls to `getPlannedDuration()`, which is a relatively expensive operation.
What if we had taken the same approach in Java?

// begin-insert: tags/nullability.1:src/main/java/travelator/Legs.java
[source,java]
----
public class Legs {

    public static Optional<Leg> findLongestLegOver(List<Leg> legs, Duration duration) {
        var longestLeg = legs.stream().max(Comparator.comparing(Leg::getPlannedDuration));
        if (longestLeg.isEmpty()) {
            return Optional.empty();
        } else if (isLongerThan(longestLeg.get(), duration)) {
            return longestLeg;
        } else {
            return Optional.empty();
        }
    }

    private static boolean isLongerThan(Leg leg, Duration duration) {
        return leg.getPlannedDuration().compareTo(duration) > 0;
    }
}
----
// end-insert

Actually that isn't bad, but compared with the Kotlin version you can see how `Optional`
adds noise to pretty much every line of the method.

=== Conclusions

The absence or presence of information is inescapable in our code: by raising it to first-class status, Kotlin makes sure that we are take account of it when we have to, but are not overwhelmed by it when we don't. In comparison, Java's `Optional` type feels clumsy. Luckily we can easily migrate from `Optional` to nullable, and support both simultaneously when we are not ready to convert all our code to Kotlin.

=== See Also

<<functions-to-extension-functions>> discusses extension functions, which can usefully be defined on nullable type.