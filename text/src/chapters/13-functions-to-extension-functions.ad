[[functions-to-extension-functions]]
== Functions to Extension Functions

Kotlin has a special form of function called an extension function, which is called like a method but is in fact (usually) a free-standing function.
It's easy to convert from a normal function to an extension function, and back, but when should we prefer one to the other?

=== Functions and Methods

Object-oriented programming is the art of solving problems by sending messages to objects.
Want to know the length of `myString`?
Send it a message `myString.length()` asking it.
Want to print that string to the console?
Send it in a message to the `System.out` object: `System.out.println(myString)`.
In a class-based OO language, we define how an object reacts to a message by defining methods on a class.
Methods are bound to a class, and have access to the data (fields) associated with a particular instance.
When we invoke a method, the runtime arranges for the correct version of a method to be called (depending on the runtime type of the object), and for it to have access to instance state.

In functional programming we solve problems by calling functions with values.
We find the length of `myString` by passing it to a `length(myString)` function.
We print to the console with `println(myString)`, and if we wanted to print somewhere else we would pass that to the function: `println(myString, System.err)`.
Functions are not defined _on_ a type, although they may have an intimate relationship with it.

The paradigms have pros and cons, but for now let's just consider discoverability and extensibility.

Let's say that we have a `Customer` type:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#customer
[source,kotlin]
----
data class Customer(
    val givenName: String,
    val familyName: String
) {
        ...
}
----
// end-insert

This _is_ a class, so straight away we know that we can send messages to ask for the `givenName` and `familyName`.
What about other operations?
In a class-based system we only have to scroll down to see another message that we can send:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#customerFull
[source,kotlin]
----
data class Customer(
    val givenName: String,
    val familyName: String
) {
    val fullName get() = "$givenName $familyName"
}
----
// end-insert

Even without looking at the definition, if we have a variable `val customer: Customer`, we can type `customer.` and our IDE will eagerly tell us that we can call `givenName`, `familyName` or `fullName`.
In fact, this auto-complete is in many ways better than looking at the class definition, because if we look at source we have to remember to navigate up into all our supertypes to find other operations (`equals` etc) that might apply.

In a functional decomposition, `fullName` would be a function, and we would have to search our codebase for it.
In this case it will be a function where the only argument is of type `Customer`.
It's surprisingly hard to get IntelliJ to help us - "Find Usages" grouped by parameter type will do the job, but it's hardly convenient.
Maybe IDEs for functional languages do a better job, but given that there don't seem to be any IDEs for functional languages, it seems unlikely.
Of course in practice we will expect to find the definition of `Customer` and its fundamental operations close together in the source, perhaps in the same file or at least namespace.

Score one to OO for discoverability then.
What about extensibility?
What happens when we want to add an operation to `Customer`?
Marketing would like to render the name reversed with the `familyName` in upper case.
(You may notice that whenever we need a simple but arbitrary example we blame marketing.)

If we own the code then we can just add a method:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#postalName
[source,kotlin]
----
data class Customer(
    val givenName: String,
    val familyName: String
) {
    val fullName get() = "$givenName $familyName"
    fun nameForMarketing() = "${familyName.toUpperCase()}, $givenName}"
}
----
// end-insert

If we don't own the code then we can't add a method, and so we have to fall back on a function.
In Java we might have a collection of these static functions in a class called `Marketing`, or `CustomerUtils`.
In Kotlin we can make them top-level functions (see <<static-methods-to-top-level-functions>>), but the principle is the same.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketing
[source,kotlin]
----
fun nameForMarketing(customer: Customer) =
    "${customer.familyName.toUpperCase()}, $customer.givenName}"
----
// end-insert

What of the functional solution?
Well this is the functional solution too.
So the functional solution is better for extensibility, because extension operations are indistinguishable from those (like `fullName`) provided by the original authors, whereas the OO solution makes us look for two different types of implementation, methods and functions.

Even if we _do_ own the code for the `Customer` class, we should be wary of adding methods like `nameForMarketing`.
The class `Customer` is a fundamental domain class in our application: lots of other code will depend on it.
Adding a report for marketing shouldn't force us to recompile and retest everything, but it will if we add a method.
So for better or worse it's probably better that we keep `Customer` as small as possible and add functionality with external functions.

Those functions don't have to be as hard to find as we've made out though; they can be extension functions.

=== Extension Functions

Extension functions are functions that look like methods, but are in fact just functions.
(As we explore in <<static-methods-to-top-level-functions>>, technically they are _also_ methods on the JVM, because all code has to be.
And they can in fact be non-static methods of another class, we'll get to that later.)

If we define an extension function:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketingExt
[source,kotlin]
----
fun Customer.nameForMarketing() = "${familyName.toUpperCase()}, $givenName}"
----
// end-insert

then we can call it as if it is a method

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#callingExt
[source,kotlin]
----
val s = customer.nameForMarketing()
----
// end-insert

and IntelliJ will auto-suggest it along with the actual methods.

Java isn't quite so helpful - it just sees the extension function as a static function:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#callingExt
[source,java]
----
var s = Extension_functionsKt.nameForMarketing(customer); // <1>
----
// end-insert

<1> `Extension_functionsKt` is the name of the class containing our top-level declarations as static methods - see <<static-methods-to-top-level-functions>>.

Interestingly we can't call the function in the same way from Kotlin:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#error
[source,kotlin]
----
nameForMarketing(customer) // <1> doesn't compile
----
// end-insert

<1> `Unresolved reference. None of the following candidates is applicable because of receiver type mismatch:
public fun Customer.nameForMarketing(): String ...`.

[TIP]
.Function Types for Methods and Extension Functions
****
While we can't call extension methods as normal functions in Kotlin, we can assign them to normal function references. So the following compiles:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#references
[source,kotlin]
----
val methodReference: (Customer.() -> String) = Customer::fullName
val extensionFunctionReference: (Customer.() -> String) = Customer::nameForMarketing

val methodAsFunctionReference: (Customer) -> String = methodReference
val extensionAsFunctionReference: (Customer) -> String = extensionFunctionReference
----
// end-insert

We can invoke these as expected:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke1
[source,kotlin]
----
customer.methodReference()
customer.extensionFunctionReference()

methodAsFunctionReference(customer)
extensionAsFunctionReference(customer)
----
// end-insert

We can also use the _with-receiver_ references as if they took the receiver as the first argument:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke2
[source,kotlin]
----
methodReference(customer)
extensionFunctionReference(customer)
----
// end-insert

We cannot, however, call the plain references as if they had a receiver:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke3
[source,kotlin]
----
customer.methodAsFunctionReference() // <1> doesn't compile
customer.extensionAsFunctionReference() // doesn't compile
----
// end-insert

<1> `Unresolved reference: methodAsFunctionReference`
****

As their name implies, extension functions give us the ability to extend the operations available on a type.
They do this while supporting the intuitive, send-a-message calling convention of methods, which allows them to be discoverable in the same Ctrl-Space way.
It's important to note though that they are not, in fact, sending a message to an object.
It is the compile-time type of the reference that is used to select which extension function to call.
We'll look at this more in <<methods-to-extension-functions>> and <<open-to-sealed-classes>>.

ifdef::todos[]


----
Platform declaration clash: The following declarations have the same JVM signature (nameForMarketing(LextensionFunctions/Customer;)Ljava/lang/String;):
public final fun nameForMarketing(customer: Customer): String ...
public final fun Customer.nameForMarketing(): String ...
----



Content from Duncan's blog - to be repurposed.

I enjoyed [Extension functions are not utility functions](https://medium.com/@dimsuz/extension-functions-are-not-utility-functions-74a5f9b53892#.o57pbn5k2)

I thought that I disagreed, but on more careful reading maybe not. Instead I'll pull out some extension functions from my current codebase.

We're finding that extension functions are a simple way to make code more expressive.

Without an extension function:

```kotlin
private fun addressFrom(node: JsonNode): Address = ...

val addresses = nodes.map { addressFrom(it) }
```

With an extension function:

```kotlin
private fun JsonNode.toAddress(): Address = ...

val addresses = nodes.map { it.toAddress() }
```

You might the find first example more readable like this:

```kotlin
private fun toAddress(node: JsonNode): Address = ...

val addresses = nodes.map(::toAddress)
```

in which case fill yer boots, but my mind doesn't work that way.

Extension functions work well here, but the place where they really shine is method chaining.

Without them:

```kotlin
private fun addressFrom(node: JsonNode): Address = ...

private fun isInUK(address: Address): Boolean = ...

val isInUK = isInUK(addressFrom(node))
```

Extension functions don't make you turn your brain inside out:

```kotlin
private fun JsonNode.toAddress(): Address = ...

private fun Address.isInUK(): Boolean = ...

val isInUK = node.toAddress().isInUK()
```

You may have noticed the `private` in the examples above - most of the extension functions that we write this way are used  locally - just to make a few lines of code more intuitive. But that's by no means universally true - this is from some library code to extend Jackson in more general ways:

```kotlin
fun JsonNode.getExpected(name: String): JsonNode = get(name) ?: throw MissingPropertyException("property '$name' is missing")

fun JsonNode.getNonBlankText(name: String) = getExpected(name).asText().apply {
    if (isBlank()) throw JsonInterpretationException("property $name is blank")
}
```

I had wondered whether this style was best suited to operations on types that we don't own. But I find we have code that acts on our own types:

```kotlin
fun suggestionsTemplateDataFor(suggestions: List<JournalJson>) = mapOf(
    "results" to suggestions.withOAText()
)

private fun List<JournalJson>.withOAText(): List<Map<String, Any?>> = this.map { it.withOAText() }

private fun JournalJson.withOAText() = TreeMap(this.asPropertyMap().plus( "openAccessText" to this.accessType.toUIString()))

private fun AccessType.toUIString() = when (this) {
    AccessType.OPEN_ACCESS -> "Yes"
    AccessType.SUBSCRIPTION -> "No"
    AccessType.OPEN_CHOICE -> "Optional"
    else -> "Unknown"
}
```

Here `JournalJson` and `AccessType` are simple data classes, unencumbered by all the operations that the rest of the system would like them to have; because they can define operations like `withOAText()` as extension functions when they need them. And if defining an extension on `List<JournalJson>` isn't a utility function I don't know what is, but here it really helps us to at least get the gist of what is going on at the top level.

Hidden in there is a call to

```kotlin
fun Any.asPropertyMap(): Map<String, Any?> = SpaceBlanket(this)
```

which *is* the archetypal extension function definition - high-level and fundamental.


The article brought out 3 extension function use-cases.

1.  Adding a little local expressiveness with private methods like `JsonNode.toAddress()`
2.  Adding methods you wish were available on types that you don't own - `JsonNode.getNonBlankText(name: String)`
3.  Keeping your own classes small by defining operations as extension functions rather than actual methods - `AccessType.toUIString()`

On the Kotlin Slack Channel, Daniel Wellman asked

*"How do you decide when methods should be extension functions and when they should be members (functions) on classes/objects _that you own_?"*

Nathan Armstrong replied

*"I think it's usually when it encapsulates operations on a type in some context tangential to the one the type was made for.  For example, when writing code that intersects two domains or concerns, using extension methods can help you use your existing types more naturally alongside one another without leaking that local utility into other parts of the codebase"*

He's right. So right that I'm going to say that again with many more words and claim the credit.

Most of my Java projects have ended up with a package of domain objects - `Person`, `Address` etc. Kotlin makes these nice and simple with data classes, and when 1.1 allows inheritance these will become even more useful.

Over time these classes accrete operations that make sense to our application. Things like `Person.asJson()` and `Address.isCloseMyHouse()`. These operations dilute the essence of the class for our happy convenience, but after a while we can't see the platonic wood for expedient trees.

Extension functions let us express the PersonNess in the `Person` class, and the JSONness elsewhere. In this case maybe type-classes would be better, but for now, we can move our JSON writing and useful-to-us-but-not-really-essential operations off of the class and into extension functions.

A nice side-effect of this is that we can build our domain classes in a module that doesn't have dependencies on Jackson and some SQL library and the whole of the rest of our app. Maybe we'll finally get reuseable abstractions for those fundamental real-world things that every app has to implement from scratch because of all the special cases that define our Customer rather than yours.

A word of warning though. Extension functions are not polymorphic. If I have


```kotlin
class Person

class Customer: Person

fun Person.toJson() = ...

fun Customer.toJson() = ...
```

the bindings are as follows:

```kotlin
Person().toJson() // calls Person.toJson()

Customer().toJson() // calls Customer.toJson()

val person: Person = readCustomer(42)
person.toJson() // calls Person.toJson() no matter what the actual type of person
```

Cover: flow, nullability.

Also, which object should be the receiver?

And calling without a receiver (passing as first param)

Reference <<methods-to-extension-functions>>, <<methods-to-properties>>
endif::[]
