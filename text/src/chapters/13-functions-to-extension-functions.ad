[[functions-to-extension-functions]]
== Functions to Extension Functions

Kotlin has a special form of function called an extension function, which is called like a method but is in fact (usually) a free-standing function.
It's easy to convert from a normal function to an extension function, and back, but when should we prefer one to the other?

=== Functions and Methods

Object-oriented programming is the art of solving problems by sending messages to objects.
Want to know the length of `myString`?
Send it a message `myString.length()` asking it.
Want to print that string to the console?
Send it in a message to the `System.out` object: `System.out.println(myString)`.
In a class-based OO language, we define how an object reacts to a message by defining methods on a class.
Methods are bound to a class, and have access to the data (fields) associated with a particular instance.
When we invoke a method, the runtime arranges for the correct version of a method to be called (depending on the runtime type of the object), and for it to have access to instance state.

In functional programming we solve problems by calling functions with values.
We find the length of `myString` by passing it to a `length(myString)` function.
We print to the console with `println(myString)`, and if we wanted to print somewhere else we would pass that to the function: `println(myString, System.err)`.
Functions are not defined _on_ a type, although they may have an intimate relationship with it.

The paradigms have pros and cons, but for now let's just consider discoverability and extensibility.

Let's say that we have a `Customer` type:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#customer
[source,kotlin]
----
data class Customer(
    val id: String,
    val givenName: String,
    val familyName: String
) {
    ...
}
----
// end-insert

This _is_ a class, so straight away we know that we can send messages to ask for the `id`, `givenName` and `familyName`.
What about other operations?
In a class-based system we only have to scroll down to see another message that we can send:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#customerFull
[source,kotlin]
----
data class Customer(
    val id: String,
    val givenName: String,
    val familyName: String
) {
    val fullName get() = "$givenName $familyName"
}
----
// end-insert

Even without looking at the definition, if we have a variable `val customer: Customer`, we can type `customer.` and our IDE will eagerly tell us that we can call `givenName`, `familyName` or `fullName`.
In fact, this auto-complete is in many ways better than looking at the class definition, because if we look at source we have to remember to navigate up into all our supertypes to find other operations (`equals` etc) that might apply.

In a functional decomposition, `fullName` would be a function, and we would have to search our codebase for it.
In this case it will be a function where the only argument is of type `Customer`.
It's surprisingly hard to get IntelliJ to help us - "Find Usages" grouped by parameter type will do the job, but it's hardly convenient.
Maybe IDEs for functional languages do a better job, but given that there don't seem to be any IDEs for functional languages, it seems unlikely.
Of course in practice we will expect to find the definition of `Customer` and its fundamental operations close together in the source, perhaps in the same file or at least namespace.

Score one to OO for discoverability then.
What about extensibility?
What happens when we want to add an operation to `Customer`?
Marketing would like to render the name reversed with the `familyName` in upper case.
(You may notice that whenever we need a simple but arbitrary example we blame marketing.)

If we own the code then we can just add a method:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#postalName
[source,kotlin]
----
data class Customer(
    val id: String,
    val givenName: String,
    val familyName: String
) {
    val fullName get() = "$givenName $familyName"
    fun nameForMarketing() = "${familyName.toUpperCase()}, $givenName}"
}
----
// end-insert

If we don't own the code then we can't add a method, and so we have to fall back on a function.
In Java we might have a collection of these static functions in a class called `Marketing`, or `CustomerUtils`.
In Kotlin we can make them top-level functions (see <<static-methods-to-top-level-functions>>), but the principle is the same.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketing
[source,kotlin]
----
fun nameForMarketing(customer: Customer) =
    "${customer.familyName.toUpperCase()}, $customer.givenName}"
----
// end-insert

What of the functional solution?
Well this is the functional solution too.
So the functional solution is better for extensibility, because extension operations are indistinguishable from those (like `fullName`) provided by the original authors, whereas the OO solution makes us look for two different types of implementation, methods and functions.

Even if we _do_ own the code for the `Customer` class, we should be wary of adding methods like `nameForMarketing`.
The class `Customer` is a fundamental domain class in our application: lots of other code will depend on it.
Adding a report for marketing shouldn't force us to recompile and retest everything, but it will if we add a method.
So for better or worse it's probably better that we keep `Customer` as small as possible and add functionality with external functions.

Those functions don't have to be as hard to find as we've made out though; they can be extension functions.

=== Extension Functions

Extension functions are functions that look like methods, but are in fact just functions.
(As we explore in <<static-methods-to-top-level-functions>>, technically they are _also_ methods on the JVM, because all code has to be.
And they can in fact be non-static methods of another class, we'll get to that later.)

If we define an extension function:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketingExt
[source,kotlin]
----
fun Customer.nameForMarketing() = "${familyName.toUpperCase()}, $givenName}"
----
// end-insert

then we can call it as if it is a method

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#callingExt
[source,kotlin]
----
val s = customer.nameForMarketing()
----
// end-insert

and IntelliJ will auto-suggest it along with the actual methods.

Java isn't quite so helpful - it just sees the extension function as a static function:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#callingExt
[source,java]
----
var s = Extension_functionsKt.nameForMarketing(customer); // <1>
----
// end-insert

<1> `Extension_functionsKt` is the name of the class containing our top-level declarations as static methods - see <<static-methods-to-top-level-functions>>.

Interestingly we can't call the function in the same way from Kotlin:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#error
[source,kotlin]
----
nameForMarketing(customer) // <1> doesn't compile
----
// end-insert

<1> `Unresolved reference. None of the following candidates is applicable because of receiver type mismatch:
public fun Customer.nameForMarketing(): String ...`.

_Receiver_ by the way is the name that Kotlin gives to `this` in an extension function.

[TIP]
.Function Types for Methods and Extension Functions
****
While we can't call extension functions as normal functions in Kotlin, we can assign them to normal function references. So the following compiles:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#references
[source,kotlin]
----
val methodReference: (Customer.() -> String) =
    Customer::fullName
val extensionFunctionReference: (Customer.() -> String) =
    Customer::nameForMarketing

val methodAsFunctionReference: (Customer) -> String =
    methodReference
val extensionAsFunctionReference: (Customer) -> String =
    extensionFunctionReference
----
// end-insert

We can invoke these as expected:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke1
[source,kotlin]
----
customer.methodReference()
customer.extensionFunctionReference()

methodAsFunctionReference(customer)
extensionAsFunctionReference(customer)
----
// end-insert

We can also use the _with-receiver_ references as if they took the receiver as the first argument:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke2
[source,kotlin]
----
methodReference(customer)
extensionFunctionReference(customer)
----
// end-insert

We cannot, however, call the plain references as if they had a receiver:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke3
[source,kotlin]
----
customer.methodAsFunctionReference() // <1> doesn't compile
customer.extensionAsFunctionReference() // doesn't compile
----
// end-insert

<1> `Unresolved reference: methodAsFunctionReference`
****

As their name implies, extension functions give us the ability to extend the operations available on a type.
They do this while supporting the intuitive, send-a-message calling convention of methods, which allows them to be discoverable in the same Ctrl-Space way.

[WARN]
.Extension Functions are Not Polymorphic
****
It's important to note though that while invoking an extension function looks like a method call, it is not, in fact, sending a message to an object.
It is the compile-time type of the reference that is used to select which extension function to call, not the runtime type as with methods.

We'll look at this more in <<methods-to-extension-functions>> and <<open-to-sealed-classes>>.
****

=== Conversions

So far we have examined extension functions for adding operations to a type.
Conversions from one type to another are good application.
Travelator needs to convert customer details to and from JSON and XML.
Let's first consider converting from `JsonNode` to `Customer`.

We could add a constructor, `Customer(jsonNode)` (or a static `Customer` method) that knew how to extract the relevant data, but it really doesn't feel right to pollute our `Customer` class with dependencies on a specific JSON library, and then XML, and then what?
The same argument applies to JsonNode.
Even if we could change its code, pretty soon it would be unmanageable with all the jsonNode.toMyDomainType()` methods.

In Java then, we'd end up with a class of utility functions of the form:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#toCustomer
[source,java]
----
static Customer toCustomer(JsonNode node) {
        ...
}
----
// end-insert

or our preference:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#customerFrom
[source,java]
----
static Customer customerFrom(JsonNode node) {
        ...
}
----
// end-insert

Calling these individually isn't too horrible:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#calling
[source,java]
----
var customer = customerFrom(node);
var customer2 = toCustomer(node);
----
// end-insert

If we need to combine functions though, things start to go awry:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#chaining
[source,java]
----
var marketingLength = nameForMarketing(customerFrom(node)).length();
----
// end-insert

We're all developers here, and used to reading function invocations, so it's easy to underestimate the cognitive load of searching for the innermost call and working your way out through function and method calls to work out how an expression evaluates.
Compare this to the version using extension functions:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#chaining
[source,kotlin]
----
fun JsonNode.toCustomer(): Customer = SOME_CODE()

val marketingLength = jsonNode.toCustomer().nameForMarketing().length
----
// end-insert

Duncan can literally feel the difference in readability in the tension in his shoulders.

=== Nullability

One major difference between invoking a method and calling a function is in the treatment of `null` references.
If we have a reference that is `null`, we can't send a message to it, because there is nothing to send a message to.
Some runtimes will allow you to pretend by silently ignoring such calls, but not the JVM, which signals its disgust with `NullPointerExceptions`.
In contrast, `null` parameters are tractable.
We may not know what to do with them, but they don't prevent us from invoking the code, because we have an object to send the message to
In the case of static methods this is the Java class, or the Kotlin object.

It follows that whilst `thing.method()` and `thing.extensionFunction()` look to be equivalent calls, `method` can never be called if `thing` is `null`, whereas `extensionFunction` can.
In order to allow this we have to declare the receiver as nullable.
Here's an example from the code to convert an XML `Element` to a `Customer`.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#xml
[source,kotlin]
----
fun Element?.toCustomer(): Customer? = this?.let { element ->
    Customer(
        element.attribute("id"),
        element.attribute("first-name"),
        element.attribute("last-name")
    )
}
----
// end-insert

Inside a method, `this` can never be `null`, but here the receiver can be, so we use `this?.let` to separate the cases.

Extension functions on nullable types can significantly reduce the noise of properly handling `null` values in Kotlin, again reducing the cognitive load of understanding what our code is doing.

=== Generics

So far we looked at extension functions defined on concrete types.
Just as with normal functions, they can have generic parameters though, and this is most interesting when the receiver is generic.

Here's a really useful extension function that for some reason isn't part of the standard library.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed
[source,kotlin]
----
fun <T> T.printed(): T = this.also(::println)
----
// end-insert

We can use this when we want to debug the value of an expression in place.
For example, remember this:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed2
[source,kotlin]
----
val marketingLength = jsonNode.toCustomer().nameForMarketing().length
----
// end-insert

If we need to see the value of the customer we would normally pull out a variable:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed3
[source,kotlin]
----
val customer = jsonNode.toCustomer()
println(customer)
val marketingLength = customer.nameForMarketing().length
----
// end-insert

With `printed` we have a function that prints the value of the receiver and returns it unchanged, so that we can write:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed4
[source,kotlin]
----
val marketingLength = jsonNode.toCustomer().printed().nameForMarketing().length
----
// end-insert

which is much less disruption, and easy to search for before we check in.

We can also define extension functions for specialised generic types.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#familyNames
[source,kotlin]
----
fun Iterable<Customer>.familyNames(): Set<String> =
    this.map(Customer::familyName).toSet()
----
// end-insert

This extension function is applicable to any `Collection<Customer>`, but not to collections of other types.
We can use extension functions in this way to use collections to represent domain concepts rather than defining our own types - see <<encapsulated-collections-to-typealiases>>, and for extracting parts of collections pipelines into named sections - see <<TODO>>.

=== Use in the Standard Library

Note that the Kotlin library authors faced the same issue extending types that they don't own as we do - in their case those provided by the Java standard library.
While they resorted to compiler trickery in some cases, a lot of the Kotlin standard library is extension functions.
This includes fundamental functions like `map`, `filter` and `reduce` (defined as extensions on `Iterable`), and the scope functions `let`, `run`, `with`, `apply` and `also`. There is even an extension function `toString`.

[WARN]
.`toString` on Nullable Types
****
Where a method and extension function are both in scope and visible, the compiler will generate a call to the method, not the function.
As we've discussed, a method can never be safely called on a nullable type, but an extension function can.
So Kotlin defines an extension function:

[source,kotlin]
----
fun Any?.toString(): String
----

This is called if you invoke `toString` on a nullable type:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nullableToString
[source,kotlin]
----
val customer: Customer? = SOME_CODE()
val s: String = customer.toString()
----
// end-insert

Here `s` will be either the result of calling the `Customer.toString` method if customer is not `null`, or the `String` with value `"null"`.
That's a reference pointing to not to `null`, but to the characters "null".

This is a neat trick, but means that you can find variables that you thought would contain the string representation of an object actually set to the string "null".
This lead to hours of gentle debugging - ask us how we know!
****

=== Extension Functions as Methods

=== Migrating to Extension Functions

=== Conclusion

Use-cases.

1.  Adding a little local expressiveness with private methods like `JsonNode.toAddress()`
2.  Adding methods you wish were available on types that you don't own - `JsonNode.getNonBlankText(name: String)`
3.  Keeping your own classes small by defining operations as extension functions rather than actual methods - `AccessType.toUIString()`

Reference <<methods-to-extension-functions>>, <<methods-to-properties>>, <<encapsulated-collections-to-typealiases>>, <<explaining-variables-to-extension-functions>>,
