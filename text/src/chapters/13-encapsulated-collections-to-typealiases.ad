[[encapsulated-collections-to-typealiases]]
== Encapsulated Collections to Type Aliases

In Java, we encapsulate collections of objects in classes to control mutation and add operations.
Controlling mutation is less of a concern in Kotlin, and we can use extension functions to add operations.
How would our designs be better without the encapsulation, and how do we get there?

=== Encapsulated Collections

In <<java-to-kotlin-collections>> we looked at the differences between the grain of Java and Kotlin when it comes to collections.
Java's collection interfaces, in keeping with its object-oriented roots, are fundamentally mutable, whereas Kotlin treats collections as value types.
As we saw, if we mutate shared collections we can run into all sorts of trouble.
We _could_ avoid that trouble by not mutating shared collections (<<dont-mutate-shared-collections>>), but in Java that's hard to do when those `add` and `set` methods are just an auto-complete away.
Instead of convention and discipline, most Java code sensibly opts for the safer approach of simply not sharing raw collections.
Instead, collections are hidden inside another object.

Here, for example, is a `Route` in Travelator:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys; // <1>

    public Route(List<Journey> journeys) {
        this.journeys = journeys; // <2>
    }

    public int size() { // <3>
        return journeys.size();
    }

    public Journey get(int index) { // <3>
        return journeys.get(index);
    }

    public Location getDepartsFrom() { // <4>
        return get(0).getDepartsFrom();
    }

    public Location getArrivesAt() { // <4>
        return get(size() - 1).getArrivesAt();
    }

    public Duration getDuration() { // <4>
        return Duration.between(
            get(0).getDepartureTime(),
            get(size() - 1).getArrivalTime());
    }

    ...
}
----
// end-insert

<1> A `Route` encapsulates a `List` of `Journey`.
<2> The raw data is passed in the constructor.
<3> Access to the data, for example for displaying in the UI, is provided by `size` and `get` methods.
<4> The `Route` class implements application logic that uses the contents of the encapsulated list.

.Defensive Copies
****
To fully encapsulate the list, the `Route` constructor could take a defensive copy of the `journeys` parameter.
However, we "know" that our system only creates `Route` objects in the JSON deserialiser or in tests, neither of which holds onto the list of journeys after creating the `Route` that uses it.
There is, therefore, no risk of https://martinfowler.com/bliki/AliasingBug.html[aliasing errors], and we can save the cost of a copy whenever we create a `Route`.

If someone comes along and creates a `Route` with a collection that they later modify, we may come to regret this optimisation.
This is the problem with making use of conventions that are not underwritten by the type system.
****

Once we have a `Route` class, it is a convenient namespace to host operations on routes, like `getDepartsFrom` and `getDuration`.
In this case all the methods shown only use other public methods, and there is no polymorphic behaviour, so these operations _could_ be defined as static methods taking a `Route` parameter.
We can view `Route` as more of a namespace than a class: the operations don't _have_ to be methods, it's just more convenient that they are, at least in Java, where static functions are so much less discoverable than methods.
In Kotlin, as we saw in <<functions-to-extension-functions>>, making the operations into extension functions would let us find and call them as if they were methods.
`Route` as a class would then be adding no value to `List` of `Journey`, just preventing people from changing it.
And in an all Kotlin codebase, that `List` would be effectively immutable anyway.

In fact, `Route` is doing worse than adding no value to `List<Journey>`, it is removing value.
If we had a `List<Journey>`, our front end code could use its `Iterator` when rendering:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/UI.java#iterable
[source,java]
----
public void render(Iterable<Journey> route) {
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

With a `Route`, we're back to programming in the 1980s:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(Route route) {
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

If we encapsulate a collection, we _reduce_ the operations available for us to work with its contents to only those defined by the encapsulating class.
When we want to process that data in a new way, the path of least resistance is to add new methods to the class.
The more methods we add to the class, the more the class _increases_ the coupling between different parts of our application.
Before we know it, adding an operation to support a new UI function ends up recompiling our data-access layer.

=== Composing Domain Collections

If we don't encapsulate the collection -- if we make our domain model _be_ the appropriate data structure, rather than hiding it inside another class boundary -- we _extend_ the operations available for us to work with the data.
Then we have our application-specific operations _and_ all the operations defined for the collection.
Client code can define the operations it needs in terms of the rich collections API without having to add them to the class.

Rather than a `Route` class accreting all the route functionality, and in turn coupling all the parts of our application together, we can view functionality as operations to be composed by importing extension functions.
The UI can define functions that render `List<Journey>`, which in turn import functions that transform `Iterable<Journey>`.
The persistence layer can transform database responses into `List<Journey>` and have no particular concept of routyness at all.

We can program like this in Java, but the poor discoverability of static functions, combined with mutable collections, goes against the grain of the language.
Kotlin's extension functions address the first, and immutable collections the second, so that in Kotlin breaking our domain model into collection types and separate operations is the happy path.

If we don't need to control access to a collection to prevent embarrassing mutation, and we don't need to write a class to host operations on collections of a type, then is our `Route` class doing anything for us?
Well it is giving a name to `List<Journey>`, and it is also giving a type to this `List<Journey>` that might distinguish it from another `List<Journey>` -- those in reports about all the journeys our travellers have booked this week for example.
Apart from that though, in some ways it actually gets in our way - as we will see in <<substitute-type-alias>>.

Where differentiating between different types of lists of journeys is _not_ critical, Kotlin allows us to use type aliases to associate the name `Route` with `List<Journey>`, rather than having to use a class to do this:

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
----
// end-insert

In Kotlin then, the obstacles to using collections as domain types have been removed.
Encapsulating immutable collections should be the exception rather than the rule.

=== Collections with Other Properties

Of course, we can't always just substitute type aliases for classes.
Take our `Itinerary` class for example:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) {
    ...
}
----
// end-insert

In addition to the ++Journey++s currently hidden in its `route`, `Itinerary` has an `Id` that allows us to address it as an entity.
In these cases we can't just replace the class with its collection.

In these cases we can gain many of the advantages of unencapsulated collections by making `Itinerary` implement `List<Journey>`.
That's hard to do right now, because `Route` doesn't implement that interface itself, but this is a good strategy as more of our domain is expressed as complete collections.
We'll get to it in <<collections-with-properties>>.

=== Refactoring Encapsulated Collections

One of the core services of our Travelator application is route planning.

The `Route` that we saw earlier is a sequence of journeys that can take the traveller from one location to another.
We'd like to add some functionality that will allow us to sell accommodation where a `Route` is split over days, but, as a key domain abstraction, `Route` is collapsing under the weight of all the operations that we have already added to it, and coupling disparate parts of the codebase together.
Let's see if we can refactor `Route` to make some room before we start work on the new feature.

Here again is the Java Route class:

// begin-insert: tags/encapsulated-collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys;

    public Route(List<Journey> journeys) {
        this.journeys = journeys;
    }

    public int size() {
        return journeys.size();
    }

    public Journey get(int index) {
        return journeys.get(index);
    }

    public Location getDepartsFrom() {
        return get(0).getDepartsFrom();
    }

    ... many methods
}
----
// end-insert

==== Convert Operations to Extensions

We're going to make `Route` less unwieldy (maybe even more wieldy) by moving its operations from methods to functions.
Extension functions make this a reasonable strategy, but only from Kotlin, where they are much more discoverable.
So we're only going to attempt this stunt once the majority of our uses of `Route` are Kotlin.
Luckily, our team really likes converting Java to Kotlin and has been beavering away as they work through the chapters of this book, so we're ready to try this refactoring.

Ultimately we want to unencapsulate the collection, so that our clients work in terms of `List<Journey>` rather than `Route`, and operations are provided by extension functions on that `List<Journey>`.

We'll start by converting to `Route` to Kotlin - which after some tidying yields:

// begin-insert: tags/encapsulated-collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    private val journeys: List<Journey>
) {
    fun size(): Int = journeys.size

    operator fun get(index: Int) = journeys[index]

    val departsFrom: Location
        get() = get(0).departsFrom

    ... many methods
}
----
// end-insert

As usual, you should assume that we are running our tests between refactors to make sure that we haven't broken anything -- all is fine at the moment.

Once a class is in Kotlin, IntelliJ can convert methods into extension methods.
Let's try out this refactoring on the `departsFrom` property - select it, Alt-Enter and "Convert member to extension".
The method disappears, and reappears at the top-level of the file:

// begin-insert: tags/encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt#departsFrom
[source,kotlin]
----
val Route.departsFrom: Location
    get() = get(0).departsFrom
----
// end-insert

Kotlin code will continue to be able to access `route.departsFrom` as a property, but Java code can't.
IntelliJ has helpfully fixed up the one Java usage to see the property as a static method:

// begin-insert: tags/encapsulated-collections.3:src/main/java/travelator/UI.java#header
[source,java]
----
public void renderWithHeader(Route route) {
    renderHeader(
        RouteKt.getDepartsFrom(route), // <1>
        route.getArrivesAt(),
        route.getDuration()
    );
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

<1> Call of static method in `Route.kt`.

"Convert member to extension" works well for methods that only call `Route`'s public API.
It will fail if we try it on, for example, `withJourneyAt`:

// begin-insert: tags/encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun withJourneyAt(index: Int, replacedBy: Journey): Route {
    val newJourneys = ArrayList(journeys)
    newJourneys[index] = replacedBy
    return Route(newJourneys)
}
----
// end-insert

This references the `journeys` property, which is currently private and so not visible to an extension function.
At this point we can make the property public (provided that we don't abuse it by mutating the `List` from Java code).
This fixes the extension function:

// begin-insert: tags/encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun Route.withJourneyAt(index: Int, replacedBy: Journey): Route {
    val newJourneys = ArrayList(journeys)
    newJourneys[index] = replacedBy
    return Route(newJourneys)
}
----
// end-insert

We can continue the process of converting members to extensions until there are no members left - even `size` and `get` can be moved out
provided we are happy to use them statically in any remaining Java clients:

// begin-insert: tags/encapsulated-collections.5:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(Route route) {
    for (int i = 0; i < RouteKt.getSize(route); i++) {
        var journey = RouteKt.get(route, i);
        render(journey);
    }
}
----
// end-insert

(Note that as we have converted the `size` method to a `size` extension property, Java sees a `getSize` function.)

Here then is all that is left of the once-bloated `Route` class:

// begin-insert: tags/encapsulated-collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    val journeys: List<Journey>
)

val Route.size: Int
    get() = journeys.size

operator fun Route.get(index: Int) = journeys[index]

...
----
// end-insert

All its operations (bar accessing the `journeys`) are now extensions, albeit in the same file.
But now that they _are_ extensions, we can move them from this file to others, even in different modules, to better decouple our dependencies.

[[substitute-type-alias]]
==== Substitute a Type Alias

Now that we've achieved our goal of decoupling the `Route` functionality from the class, is that class superfluous?
Actually, wrapping the `List` is worse than superfluous: it prevents us easily using all the useful extension functions in Kotlin's standard library to construct, transform, and process routes.
To quote one of Alan Perlis' https://www.cs.yale.edu/homes/perlis-alan/quotes.html[Epigrams of Programming]: "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures."
We don't want a `Route` to _have_ a `List` of `Journey`, we want it to _be_ a `List` of `Journey`.
This is very easy to achieve in Kotlin with delegation:

// begin-insert: tags/encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    val journeys: List<Journey>
) : List<Journey> by journeys
----
// end-insert

In fact though, we may want more than for a `Route` to be a `List` of `Journey`; we may want a `List` of `Journey` to be a `Route`.
To see why, lets look at that `withJourneyAt` function that we glossed over earlier.

When a traveller decides that she would rather not travel by camel, we can't just replace a `Journey`, because `Route` is immutable.
Instead, we return a new `Route` where `journeys` is a copy with the relevant `Journey` replaced:

// begin-insert: tags/encapsulated-collections.5:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
@Test
fun replaceJourney() {
    val journey1 = Journey(waterloo, alton, someTime(), someTime(), RAIL)
    val journey2 = Journey(alton, alresford, someTime(), someTime(), CAMEL)
    val journey3 = Journey(alresford, winchester, someTime(), someTime(), BUS)
    val route = Route(listOf(journey1, journey2, journey3))

    val replacement = Journey(alton, alresford, someTime(), someTime(), RAIL)
    val replaced = route.withJourneyAt(1, replacement)

    assertEquals(journey1, replaced.get(0))
    assertEquals(replacement, replaced.get(1))
    assertEquals(journey3, replaced.get(2))
}
----
// end-insert

(In passing, note that this test was made more complicated by only having `get` to access the components of a `route`.
We can fix that now we can access the `journeys` property directly.)

Here's the implementation again:

// begin-insert: tags/encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun Route.withJourneyAt(index: Int, replacedBy: Journey): Route {
    val newJourneys = ArrayList(journeys)
    newJourneys[index] = replacedBy
    return Route(newJourneys)
}
----
// end-insert

Because `Route` wraps `journeys`, we can't just operate on `journeys`, we have to unwrap, operate and then wrap back up again.
If a `List<Journey>` was a `Route`, then we could use a nice generic function like:

// begin-insert: tags/encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt#withItemAt
[source,kotlin]
----
fun <T> Iterable<T>.withItemAt(index: Int, replacedBy: T): List<T> =
    this.toMutableList().apply {
        this[index] = replacedBy
    }
----
// end-insert

As it is, even using `withItemAt`, we still have to deal with the wrapper:

// begin-insert: tags/encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun Route.withJourneyAt(index: Int, replacedBy: Journey): Route =
    Route(journeys.withItemAt(index, replacedBy))
----
// end-insert

Any operation that transforms ++Route++s will have this problem: a problem that wouldn't exist if we just used a type alias to say that a `Route` and `List<Journey>` are the same type.

To get there, we are going to have to remove all the calls to the `Route` constructor, and also the accesses of the `journeys` property -- effectively unwrapping our carefully-crafted encapsulation.
There is a trick to do this automagically, but it relies on having converted all clients of `Route` to Kotlin.
So does using a type alias though, so if we have any remaining Java clients we are going to have to resign ourselves to some manual editing.

What we're going to do is to replace the class with a type alias, and at the same time add temporary definitions that emulate the API of the class:
That API is currently:

// begin-insert: tags/encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    val journeys: List<Journey>
) : List<Journey> by journeys
----
// end-insert

We emulate it with:

// begin-insert: tags/encapsulated-collections.8:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
typealias Route = List<Journey>

fun Route(journeys: List<Journey>) = journeys

val Route.journeys get() = this
----
// end-insert

Because there is no `new` keyword in Kotlin, we can emulate the constructor call `Route(...)` with a function of the same name.
Similarly, we replace the `journeys` property with an extension property that returns the receiver itself.
The net result is that our Kotlin clients continue to compile against this new API.

// begin-insert: tags/encapsulated-collections.8:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
val route = Route(listOf(journey1, journey2, journey3)) // <1>

val replacement = Journey(alton, alresford, someTime(), someTime(), RAIL)

assertEquals(
    listOf(journey1, replacement, journey3),
    route.withJourneyAt(1, replacement).journeys // <2>
)
----
// end-insert

<1> Our new function, not the constructor
<2> Extension property, not the class property

Inlining both function and property completes the refactor -- the encapsulated collection is now just a collection:

// begin-insert: tags/encapsulated-collections.9:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
val route = listOf(journey1, journey2, journey3) // <1>

val replacement = Journey(alton, alresford, someTime(), someTime(), RAIL)

assertEquals(
    listOf(journey1, replacement, journey3),
    route.withJourneyAt(1, replacement) // <2>
)
----
// end-insert

<1> `Route` was a no-op
<2> as was `journeys`.

Any remaining Java clients will have been broken when we replaced the `Route` class with a type alias, as Java doesn't understand type aliases.
We fixed those by hand, replacing `Route` with `List<Journey>`:

// begin-insert: tags/encapsulated-collections.8:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(List<Journey> route) {
    for (int i = 0; i < RouteKt.getSize(route); i++) {
        var journey = RouteKt.get(route, i);
        render(journey);
    }
}
----
// end-insert

Our transformation is almost complete.
We still have `size` and `get` functions:

// begin-insert: tags/encapsulated-collections.9:src/main/java/travelator/itinerary/Route.kt#excerpt
[source,kotlin]
----
val Route.size: Int
    get() = this.size

operator fun Route.get(index: Int) = this[index]
----
// end-insert

As these have the same signature as their method counterparts on `List`, the compiler warns us that they are shadowed -- our Kotlin will be calling the methods not the extensions.
That means that if we didn't have any Java client code invoking the extensions as statics, we could delete them.

We do have a Java client though -- that pesky rendering code, which is still calling the extensions as `getSize` and `get` in `RouteKt`.
Those extensions are calling the methods that we want to use, but we can't inline code from Kotlin to Java, so we'll just delete the extensions anyway.
Now the compiler will tell us where we need to fix the Java, and we can do that by hand:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(List<Journey> route) {
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

In reality of course, we would replace this with:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/UI.java#iterable
[source,java]
----
public void render(Iterable<Journey> route) {
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

The Kotlin clients are unphased by deleting the extensions, as they were always calling the methods on `List`, so the transformation is almost complete.
We can also now inline `withJourneyAt`, as it too is a no-op.
This leaves us with `Route` like this:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
typealias Route = List<Journey>

val Route.departsFrom: Location
    get() = first().departsFrom

val Route.arrivesAt: Location
    get() = last().arrivesAt

val Route.duration: Duration
    get() = Duration.between(
        first().departureTime,
        last().arrivalTime
    )
... other operations moved
----
// end-insert

Our Kotlin usages are just `List` operations:

// begin-insert: tags/encapsulated-collections.11:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
val route = listOf(journey1, journey2, journey3)
assertEquals(
    listOf(journey1, replacement, journey3),
    route.withItemAt(1, replacement)
)
----
// end-insert

Any residual Java is readable, if a little ugly:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/UI.java#header
[source,java]
----
public void renderWithHeader(List<Journey> route) {
    renderHeader(
        RouteKt.getDepartsFrom(route),
        RouteKt.getArrivesAt(route),
        RouteKt.getDuration(route)
    );
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

[[collections-with-properties]]
==== Refactoring Collections with Other Properties

As we saw previously, we can't use type aliases when our types have a collections with other attributes.
We looked at `Itinerary`, which combines an `id` with a `Route`:

// begin-insert: tags/encapsulated-collections.12:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) {

    fun hasJourneyLongerThan(duration: Duration) =
        route.any { it.duration > duration }

    ...
}
----
// end-insert

We can get the advantages of being able to query ++Journey++s directly by implementing `Route` with delegation:

// begin-insert: tags/encapsulated-collections.13:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) : Route by route { // <1>

    fun hasJourneyLongerThan(duration: Duration) =
        any { it.duration > duration }

    ...
}
----
// end-insert

<1> The `by route` clause declares that the an `Itinerary` object will delegate all methods of `Route` interface to the `route` parameter passed to its constructor.
    A class can override this behaviour by providing its own implementation of methods of the delegated interface, but we don't want to do this for `Itinerary`.

Now that we can treat `Itinerary` as a `Route`, we can move `hasJourneyLongerThan` out as an extension, and have it available to any `Route`, not just `Itinerary`:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/Itinerary.kt#hasJourneyLongerThan
[source,kotlin]
----
fun Route.hasJourneyLongerThan(duration: Duration) =
    any { it.duration > duration }
----
// end-insert

All those extensions to `Route` (aka `List<Journey>`) that we moved from methods to extensions are also now applicable to `Itinerary` as well:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt#shortest
[source,kotlin]
----
fun Iterable<Itinerary>.shortest() =
    minByOrNull {
        it.duration // <1>
    }
----
// end-insert

<1> This is `Route.duration` aka `List<Journey>.duration`

What we can't do as easily is to create a new `Itinerary` from an existing one.
This is now easy for `Route`, as standard API operations on `List<Journey>` (actually, usually `Iterable<Journey>` as we saw in <<java-to-kotlin-collections>>) return `List<Journey>`, which is the other name for `Route`:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt#withoutJourneysBy
[source,kotlin]
----
fun Route.withoutJourneysBy(travelMethod: TravelMethod) =
    this.filterNot { it.method == travelMethod }
----
// end-insert

For `Itinerary`, we have to create a new `Itinerary` to re-wrap the result:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt#withoutJourneysBy2
[source,kotlin]
----
fun Itinerary.withoutJourneysBy(travelMethod: TravelMethod) =
    Itinerary(
        id,
        this.filterNot { it.method == travelMethod }
    )
----
// end-insert

This is yet another place where data classes come to the rescue:

// begin-insert: tags/encapsulated-collections.15:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) : Route by route {

    ...
}
----
// end-insert

Making `Itinerary` a data class means that we can make a copy with just a revised route, no matter how many other properties it has:

// begin-insert: tags/encapsulated-collections.15:src/main/java/travelator/itinerary/itineraries.kt#withoutJourneysBy2
[source,kotlin]
----
fun Itinerary.withoutJourneysBy(travelMethod: TravelMethod) =
    copy(route = filterNot { it.method == travelMethod } )
----
// end-insert

Better still, we can add a method `withTransformedRoute`:

// begin-insert: tags/encapsulated-collections.16:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) : Route by route {

    fun withTransformedRoute(transform: (Route).() -> Route) =
        copy(route = transform(route))

    ...
}
----
// end-insert

This allows us to create a transformed `Itinerary` almost as easily as we could create a transformed `Route`:

// begin-insert: tags/encapsulated-collections.16:src/main/java/travelator/itinerary/itineraries.kt#excerpt
[source,kotlin]
----
fun Itinerary.withoutJourneysBy(travelMethod: TravelMethod) =
    withTransformedRoute {
        filterNot { it.method == travelMethod }
    }

fun Itinerary.withoutLastJourney() =
    withTransformedRoute { dropLast(1) }
----
// end-insert

=== Conclusion

We started this chapter with a Java class that encapsulated a mutable collection to guarantee value semantics.
As we translated more of our code to Kotlin, we could rely on Kotlin's type system to prevent the collection being modified, and no longer needed to encapsulate it within the class.
That allowed us to convert operations from methods to extensions, and move their definitions close to where they are used.
Because our class encapsulated a single collection, we were able to eliminate the class altogether, and replace it with a type alias.

Immutable collections and extensions allow us to organise our code in ways that are not available in Java.
We can group all the logic required by a particular feature of the application in the same module, regardless of the domain classes the logic applies to.
However, if we wanted methods of those domain classes to be polymorphic methods, we would have to define them on those classes and not in our feature module.
In <<open-to-sealed-classes>> we look at sealed classes, an alternative to object-oriented polymorphism that is more convenient when we define type hierarchies in one part of the code and operations on those types in another.

Finally, note that reusing built-in types like `List` rather than defining a specific type is not without cost.
We might be storing items in a `List` as an implementation detail rather than a modelling choice.
It's also a lot easier to "Find useages" of a specific wrapper class than a generic specialisation.
Nevertheless, the standard collection types are pervasive because they are such good abstractions -- so good that we generally shouldn't hide them.
<<creating-to-reusing-types>> looks at what happens if take this idea and run with it.

