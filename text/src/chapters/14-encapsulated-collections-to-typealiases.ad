[[encapsulated-collections-to-typealiases]]
== Encapsulated Collections to Type Aliases

In Java, we encapsulate collections of objects in classes to control mutation and add operations.
Controlling mutation is less of a concern in Kotlin, and we can use extension functions to add operations.
How would our designs be better without the encapsulation, and how do we get there?

In <<java-to-kotlin-collections>> we looked at the differences in the grain of Java and Kotlin when it comes to collections.
Java's collection interfaces, in keeping with its object-oriented roots, are fundamentally mutable, whereas Kotlin treats collections as value types.
As we saw, if we mutate shared collections we can run into all sorts of trouble.
We _could_ avoid that trouble by not mutating shared collections <<dont-mutate-shared-collections>>, but that's hard to do when those `add` and `set` methods are just an auto-complete away, and our runtime still doesn't give us a way to sort a collection that doesn't change it.
Instead of convention and discipline, most Java code sensibly opts for the safer approach of simply not sharing raw collections.
Instead, collections are hidden inside another object.

=== Encapsulated Collections

Here, for example, is a `Route` in Travelator:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys; // <1>

    public Route(List<Journey> journeys) {
        this.journeys = journeys; // <2>
    }

    public int size() { // <3>
        return journeys.size();
    }

    public Journey get(int index) { // <3>
        return journeys.get(index);
    }

    public Location getDepartsFrom() { // <4>
        return get(0).getDepartsFrom();
    }

    public Location getArrivesAt() { // <4>
        return get(size() - 1).getArrivesAt();
    }

    public Duration getDuration() { // <4>
        return Duration.between(
            get(0).getDepartureTime(),
            get(size() - 1).getArrivalTime());
    }

    ...
}
----
// end-insert

<1> A `Route` encapsulates a `List` of `Journey`.
<2> The raw data is passed in the constructor.
<3> Access to the data, for example for displaying in the UI, is provided by `size` and `get` methods.
<4> The `Route` class implements application logic that uses the contents of the encapsulated list.

.Defensive Copies
****
To fully encapsulate the list, the `Route` constructor could take a defensive copy of the `journeys` parameter.
However, we "know" that our system only creates `Route` objects in the JSON deserialiser or in tests, neither of which holds onto the list of journeys after creating the `Route` that uses it.
There is, therefore, no risk of https://martinfowler.com/bliki/AliasingBug.html[aliasing errors], and we can save the cost of a copy whenever we create a `Route`.

If someone comes along and creates a `Route` with a collection that they later modify, we may come to regret this optimisation.
This is the problem with making use of conventions that are not underwritten by the type system.
****

Once we have a `Route` class, it is a convenient namespace to host operations on routes, like `getDepartsFrom` and `getDuration`.
Interestingly, all those methods shown use other public methods - they don't need special access to the hidden list.
There is no polymorphic behaviour either, so these operations _could_ be defined as static methods (top-level functions in Kotlin) taking a `Route` parameter.
In Java we tend not to do this, as functions are so much less discoverable than methods.
As we saw in <<functions-to-extension-functions>>, extension functions in Kotlin would let us call these like methods.
That's why we look at the `Route` more as a namespace than a class - it doesn't add any value to `List` of `Journey`, just prevents people from changing it.

In fact though, it is _worse_ than an immutable `List` of `Journey`.
If we had a `List<Journey>`, our front end code could use its `Iterator` when rendering:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/UI.java#iterable
[source,java]
----
public void render(Iterable<Journey> route) {
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

With a `Route`, we're back to programming in the 1980s:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(Route route) {
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

We could solve this particular problem by having `Route` implement `Iterable<Journey>` (albeit with issues around `Iterator.remove()` -- Java really, really wants to be able to mutate collections).
In general though, when we encapsulate a collection, we _reduce_ the operations available for us to work with the contents to only those defined by the encapsulating class.
When we want to process that data in a new way, we will tend to add new operations to the class.
The more operations we add to the class, the more the class ends up _increasing_ the coupling between different parts of our application - so that adding an operation to support a UI function will end up recompiling our data-access layer.

=== Composing Domain Collections

If we don't encapsulate the collection - if we make our domain model _be_ the appropriate data structure, rather than hiding it behind a class boundary - we _extend_ the operations available for us to work with the data.
Then we have our application-specific operations _and_ all the operations defined for the collection.
Client code can define the operations it needs in terms of the rich collections API without having to add them to the class.

Rather than a `Route` class accreting all the route functionality, and in turn coupling all the parts of our application together, we can view functionality as operations to be composed.
The UI can define functions that render `List<Journey>`, which in turn import functions that transform `Iterable<Journey>`.
The persistence layer can render database responses as `List<Journey>` and have no particular concept of routyness at all.

We can program like this in Java, but as we saw in <<functions-to-extension-functions>>, it's much harder to find static functions that define operations on a type than it is to find methods.
This lack of discoverability, combined with mutable collections, makes the technique tedious and error-prone.
Kotlin's extension functions address the first, and immutable collections the second, so that in Kotlin breaking our domain model into collection types and separate operations is the happy path.

If we don't need to control access to a collection to prevent embarrassing mutation, and we don't need to write a class to host operations on collections of a type, then is our `Route` class doing anything for us?
Well it is giving a name to `List<Journey>`, and it is also giving a type to this `List<Journey>` that might distinguish it from another `List<Journey>` -- those in reports about all the journeys our travellers have paid for this week for example.
Apart from that though, in some ways it actually gets in our way - we'll see how later, in the refactoring section.

Where differentiating between different types of lists of journeys is not critical, Kotlin allows us to use type aliases to associate the name `Route` with `List<Journey>`, rather than having to use an actual type to do this.

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
----
// end-insert

In Kotlin then, the obstacles to using collections as domain types have been removed.
Encapsulating collections should be the exception rather than the rule.

=== Entities as Collections

Of course we can't always just substitute type aliases for classes.
Take our `Itinerary` class for example:

// begin-insert: tags/encapsulated-collections.0:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) {
    ...
}
----
// end-insert

In addition to the ++Journey++s currently hidden in its `route`, `Itinerary` has an `Id` that allows us to address it as an entity.
In these cases we can't just replace the class with its collection.
Here we can gain many of the advantages of unencapsulated collections by making `Itinerary` implement `List<Journey>`.
That's hard to do right now, because `Route` doesn't implement that interface itself, but this is a good strategy as more of our domain is expressed as complete collections.

=== Refactoring Encapsulated Collections

One of the core services of our Travelator application is route planning.

The `Route` that we saw earlier is a sequence of journeys that can take the traveller from one location to another.
Each journey in a route is a service provided by an operator, via some mode of transport -- ship, train, bus, camel, etc. -- departing from one location at a specific time and arriving at another location some time later.
Our routing service finds several possible routes, and our travellers can compare them by cost, duration, and so on, to choose the route they prefer.

The journeys along a route do not always have a convenient interchange between them.
Some services run only once a day, or once a week, so our travellers want to know when they will have to book accommodation between the end of one journey and the start of the next.
This will let us improve the cost estimate for a route, because we can suggest places to stay and include the cost in the overall cost of the route.
We can make the feature earn its keep by booking their preferred choices and earning a commission.

Fundamental to this feature is the ability to find every interchange in a `Route` where the traveller will need accommodation.
Currently, our `Route` class does not have that capability, and, as a key domain abstraction, it is collapsing under the weight of all the operations that we have already added to it.
Let's see if we can refactor `Route` to make some room before we start.

Here again is the Java Route class:

// begin-insert: tags/encapsulated-collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys;

    public Route(List<Journey> journeys) {
        this.journeys = journeys;
    }

    public int size() {
        return journeys.size();
    }

    public Journey get(int index) {
        return journeys.get(index);
    }

    public Location getDepartsFrom() {
        return get(0).getDepartsFrom();
    }

    ... many methods
}
----
// end-insert

==== Convert Operations to Extensions

We're going to make `Route` less unwieldy by moving its operations from methods to functions.
Extension functions make this a reasonable strategy, but only from Kotlin (as they just look like static methods in Java).
So we're only going to attempt this stunt once the majority of our uses of `Route` are Kotlin.
Luckily, our team really likes converting Java to Kotlin and has been beavering away as they work through the chapters of this book, so we're ready to try this refactoring.

Ultimately we want to unencapsulate the collection, so that our clients work in terms of `List<Journey>` rather than `Route`, and operations are provided by extension functions on that `List<Journey>`.

We'll start by converting to Kotlin - which after some tidying yields:

// begin-insert: tags/encapsulated-collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    private val journeys: List<Journey>
) {
    fun size(): Int = journeys.size

    operator fun get(index: Int) = journeys[index]

    val departsFrom: Location
        get() = get(0).departsFrom

    ... many methods
}
----
// end-insert

As usual, you should assume that we are running our tests between refactors to make sure that we haven't broken anything - all is fine at the moment.

Once a class is in Kotlin, IntelliJ can convert methods into extension methods.
Let's try out this refactoring on the `departsFrom` property - select it, Alt-Enter and "Convert member to extension".
The method disappears, and reappears at the top-level of the file:

// begin-insert: tags/encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt#departsFrom
[source,kotlin]
----
val Route.departsFrom: Location
    get() = get(0).departsFrom
----
// end-insert

Kotlin code will continue to be able to access `route.departsFrom` as a property, but Java code can't.
IntelliJ has helpfully fixed up the one Java usage to see the property as a static method:

// begin-insert: tags/encapsulated-collections.3:src/main/java/travelator/UI.java#header
[source,java]
----
public void renderWithHeader(Route route) {
    renderHeader(
        RouteKt.getDepartsFrom(route), // <1>
        route.getArrivesAt(),
        route.getDuration()
    );
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

<1> Call of static method in `Route.kt`.

"Convert member to extension" works well for methods that only call `Route`'s public API.
It will fail if we try it on, for example, `withJourneyAt`:

// begin-insert: tags/encapsulated-collections.3:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun withJourneyAt(index: Int, replacedBy: Journey): Route {
    val newJourneys = ArrayList(journeys)
    newJourneys[index] = replacedBy
    return Route(newJourneys)
}
----
// end-insert

This references the `journeys` property, which is currently private and so not visible to an extension function.
At this point we can make the property public, provided that we don't abuse it by mutating it from Java code.
This fixes the code:

// begin-insert: tags/encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun Route.withJourneyAt(index: Int, replacedBy: Journey): Route {
    val newJourneys = ArrayList(journeys)
    newJourneys[index] = replacedBy
    return Route(newJourneys)
}
----
// end-insert

We can continue the process of converting members to extensions until there are no members left - even `size` and `get` can be moved out
provided we are happy to use them statically in any remaining Java clients:

// begin-insert: tags/encapsulated-collections.5:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(Route route) {
    for (int i = 0; i < RouteKt.size(route); i++) {
        var journey = RouteKt.get(route, i);
        render(journey);
    }
}
----
// end-insert

(This could of course now be converted to iterate over the `journeys` property.)

Here then is all that is left of the once-bloated `Route` class:

// begin-insert: tags/encapsulated-collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    val journeys: List<Journey>
)

fun Route.size(): Int = journeys.size

operator fun Route.get(index: Int) = journeys[index]

...
----
// end-insert

All its operations (bar accessing the `journeys`) are now extensions, albeit in the same file.
But now that they _are_ extensions, we can move them from this file to others, even in different modules, to better manage our dependencies.

==== Substitute a Type Alias

Now that we've achieved our goal of decoupling the `Route` functionality from the class, is the class just superfluous?
Actually wrapping the list is worse than superfluous: it prevents us easily using all those useful extension functions in Kotlin's standard library to construct, transform, and process routes.
As Alan Perlis famously said: "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures."
We don't want a `Route` to _have_ a `List` of `Journey`, we want it to _be_ a `List` of `Journey`.
In type system terms, this is very easy to achieve in Kotlin:

// begin-insert: tags/encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    val journeys: List<Journey>
) : List<Journey> by journeys
----
// end-insert

In fact though, we may want more than for a `Route` to be a `List` of `Journey`; we may want a `List` of `Journey` to be a `Route`.
To see why, lets look at that `withJourneyAt` function that we glossed over earlier.

When a traveller decides that she'd rather not travel by camel, we can't just replace a `Journey`, because `Route` is immutable.
Instead, we return a new `Route` where `journeys` is a copy with the relevant `Journey` replaced:

// begin-insert: tags/encapsulated-collections.5:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
@Test
fun replaceJourney() {
    val journey1 = Journey(waterloo, alton, someTime(), someTime(), RAIL)
    val journey2 = Journey(alton, alresford, someTime(), someTime(), CAMEL)
    val journey3 = Journey(alresford, winchester, someTime(), someTime(), BUS)
    val route = Route(listOf(journey1, journey2, journey3))

    val replacement = Journey(alton, alresford, someTime(), someTime(), RAIL)
    val replaced = route.withJourneyAt(1, replacement)

    assertEquals(journey1, replaced.get(0))
    assertEquals(replacement, replaced.get(1))
    assertEquals(journey3, replaced.get(2))
}
----
// end-insert

(In passing, note that this test was made more complicated by only having and `get` to access the components of a `route`, we can fix that now we can access the `journeys`.)

Here's the implementation again:

// begin-insert: tags/encapsulated-collections.4:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun Route.withJourneyAt(index: Int, replacedBy: Journey): Route {
    val newJourneys = ArrayList(journeys)
    newJourneys[index] = replacedBy
    return Route(newJourneys)
}
----
// end-insert

Because `Route` wraps `journeys`, we can't just operate on `journeys`, we have to unwrap, operate and then wrap back up again.
If a `List<Journey>` was a route, then we could use a nice generic function like:

// begin-insert: tags/encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt#withItemAt
[source,kotlin]
----
fun <T> Iterable<T>.withItemAt(index: Int, replacedBy: T): List<T> =
    this.toMutableList().apply {
        this[index] = replacedBy
    }
----
// end-insert

As it is, even with this function, we still have to deal with the wrapper:

// begin-insert: tags/encapsulated-collections.7:src/main/java/travelator/itinerary/Route.kt#withJourneyAt
[source,kotlin]
----
fun Route.withJourneyAt(index: Int, replacedBy: Journey): Route =
    Route(journeys.withItemAt(index, replacedBy))
----
// end-insert

Any operation that transforms ++Route++s will have this problem, a problem that wouldn't exist if we just used a type alias to say that a `Route` and `List<Journey>` are the same type.

To get there, we are going to have to remove all the calls to the `Route` constructor, and also the accesses of the `journeys` property - effectively unwrapping all carefully-crafted encapsulation.
There is a trick to do this automagically, but it relies on having converted all clients of `Route` to Kotlin.
So does using a type alias though, so if we have any remaining Java clients we are going to have to resign ourselves to some manual editing.
What we're going to do is to replace the class with a typealias _and_ temporary definitions that emulate the API of the class:
This is currently:

// begin-insert: tags/encapsulated-collections.6:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(
    val journeys: List<Journey>
) : List<Journey> by journeys
----
// end-insert

We emulate it with:

// begin-insert: tags/encapsulated-collections.8:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
typealias Route = List<Journey>

fun Route(journeys: List<Journey>) = journeys

val Route.journeys get() = this
----
// end-insert

Because there is no `new` keyword in Kotlin, we can emulate the constructor call `Route` with a function with the same name.
Similarly, we replace the `journeys` property with an extension property that return the list itself.
The net result is that our Kotlin clients continue to compile against this new API.

// begin-insert: tags/encapsulated-collections.8:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
val route = Route(listOf(journey1, journey2, journey3)) // <1>

val replacement = Journey(alton, alresford, someTime(), someTime(), RAIL)

assertEquals(
    listOf(journey1, replacement, journey3),
    route.withJourneyAt(1, replacement).journeys // <2>
)
----
// end-insert

<1> Our new function, not constructor
<2> Extension property, not method

Inlining both function and property completes the refactor - the encapsulated collection is now just a collection:

// begin-insert: tags/encapsulated-collections.9:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
val route = listOf(journey1, journey2, journey3) // <1>

val replacement = Journey(alton, alresford, someTime(), someTime(), RAIL)

assertEquals(
    listOf(journey1, replacement, journey3),
    route.withJourneyAt(1, replacement) // <2>
)
----
// end-insert

<1> `Route` was a no-op
<2> as was `journeys`.

Our transformation is almost complete.
We still have `size` and `get` methods:

// begin-insert: tags/encapsulated-collections.9:src/main/java/travelator/itinerary/Route.kt#excerpt
[source,kotlin]
----
fun Route.size(): Int = this.size

operator fun Route.get(index: Int) = this[index]
----
// end-insert

`get` now shadows the `get` method on `List` and is only called from any Java clients.
We can't inline it automatically, but we can get substitute it as we'll see in a minute.
`size` is a bit odd as it is a method, not the property that Kotlin pretends exists as `List.size`.
If we convert it to a property (see <<methods-to-properties>>), it also will be shadowed, so we do that, then delete them both.
Kotlin clients are unphased, as they now compile against the methods on `List`, and we can fix up any residual Java to call those methods too:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(List<Journey> route) {
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

Although, remembering why we started this journey, this can now be :

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/UI.java#iterable
[source,java]
----
public void render(Iterable<Journey> route) {
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

We can also now inline `withJourneyAt`, as it too is a no-op.
This leaves us with `Route` like this:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
typealias Route = List<Journey>

val Route.departsFrom: Location
    get() = first().departsFrom

val Route.arrivesAt: Location
    get() = last().arrivesAt

val Route.duration: Duration
    get() = Duration.between(
        first().departureTime,
        last().arrivalTime
    )
... other operations moved
----
// end-insert

Our Kotlin usages are just `List` operations:

// begin-insert: tags/encapsulated-collections.11:src/test/java/travelator/itinerary/RouteTests.kt#replaceJourney
[source,kotlin]
----
val route = listOf(journey1, journey2, journey3)
assertEquals(
    listOf(journey1, replacement, journey3),
    route.withItemAt(1, replacement)
)
----
// end-insert

Residual Java is a little ugly, but plausible:

// begin-insert: tags/encapsulated-collections.11:src/main/java/travelator/UI.java#header
[source,java]
----
public void renderWithHeader(List<Journey> route) {
    renderHeader(
        RouteKt.getDepartsFrom(route),
        RouteKt.getArrivesAt(route),
        RouteKt.getDuration(route)
    );
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

==== Collections with Other Properties

As we observed previously, we can't use type aliases when our types have a collections with other attributes.
We looked at `Itinerary`, which combines an `id` with a `Route`:

// begin-insert: tags/encapsulated-collections.12:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) {

    fun hasJourneyLongerThan(duration: Duration) =
        route.any { it.duration > duration }

    ...
}
----
// end-insert

We can get the advantages of being able to query ++Journey++s directly by implementing `Route`.

// begin-insert: tags/encapsulated-collections.13:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) : Route by route { // <1>

    fun hasJourneyLongerThan(duration: Duration) =
        any { it.duration > duration }

    ...
}
----
// end-insert

<1> Delegation

Now we can treat `Itinerary` as a `Route`, we can move `hasJourneyLongerThat` out as an extension, and have it available to any `Route`, not just `Itinerary`:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/Itinerary.kt#hasJourneyLongerThan
[source,kotlin]
----
fun Route.hasJourneyLongerThan(duration: Duration) =
    any { it.duration > duration }
----
// end-insert

We can also use the extensions we defined previously on `Itinerary` as well as `Route`:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt#shortest
[source,kotlin]
----
fun Iterable<Itinerary>.shortest() =
    minByOrNull {
        it.duration // <1>
    }
----
// end-insert

<1> This is `Route.duration` aka `List<Journey>.duration`

What we can't do as easily is create a new `Itinerary` from an existing one.
This is now easy for `Route`:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt#withoutJourneysBy
[source,kotlin]
----
fun Route.withoutJourneysBy(travelMethod: TravelMethod) =
    this.filterNot { it.method == travelMethod }
----
// end-insert

For `Itinerary`, we have to create a new `Itinerary` to re-wrap the result:

// begin-insert: tags/encapsulated-collections.14:src/main/java/travelator/itinerary/itineraries.kt#withoutJourneysBy2
[source,kotlin]
----
fun Itinerary.withoutJourneysBy(travelMethod: TravelMethod) =
    Itinerary(
        id,
        this.filterNot { it.method == travelMethod }
    )
----
// end-insert

This is yet another place where data classes come to the rescue:

// begin-insert: tags/encapsulated-collections.15:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) : Route by route {

    ...
}
----
// end-insert

// begin-insert: tags/encapsulated-collections.15:src/main/java/travelator/itinerary/itineraries.kt#withoutJourneysBy2
[source,kotlin]
----
fun Itinerary.withoutJourneysBy(travelMethod: TravelMethod) =
    copy(route = filterNot { it.method == travelMethod } )
----
// end-insert

Better still, we can add a method `withTransformedRoute`:

// begin-insert: tags/encapsulated-collections.16:src/main/java/travelator/itinerary/Itinerary.kt#excerpt
[source,kotlin]
----
data class Itinerary(
    val id: Id<Itinerary>,
    val route: Route
) : Route by route {

    fun withTransformedRoute(transform: (Route).() -> Route) =
        copy(route = transform(route))

    ...
}
----
// end-insert

This allows us to create a transformed `Itinerary` almost as easily as we could create transformed ++Route++s:

// begin-insert: tags/encapsulated-collections.16:src/main/java/travelator/itinerary/itineraries.kt#excerpt
[source,kotlin]
----
fun Itinerary.withoutJourneysBy(travelMethod: TravelMethod) =
    withTransformedRoute {
        filterNot { it.method == travelMethod }
    }

fun Itinerary.withoutLastJourney() =
    withTransformedRoute { dropLast(1) }
----
// end-insert

=== Conclusion

We started this chapter with a Java class that encapsulated a mutable collection to guarantee value semantics.
As we translated more of our code to Kotlin, we could rely on Kotlin's type system to prevent the collection being modified, and no longer needed to encapsulate it within the class.
That allowed us to convert operations from methods to extensions, and move their definitions close to where they are used.
Because our class encapsulated a single collection, we were able to eliminate the class altogether, and replace it with a typealias.

Immutable collections and extensions allow us to organise our code in different ways.
We can group all the logic required by a particular feature of the application, or group logic that bridges between different domains.
We continue this train of thought in <<organising-code-by-domain>>.

This chapter looked at how we prevent unwanted mutation, and how Kotlin makes this unnecessary.
In <<accumulating-objects-to-transformations>>, we look at a class designed to be mutable and explore how we can refactor code that relies on its mutability to instead work by transforming immutable data.

Something about revisiting the issues of generic vs specific types and naming in <<interfaces-to-functions>>.