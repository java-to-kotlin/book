[[encapsulated-collections-to-typealiases]]
== Encapsulated Collections to Type Aliases

In Java, we encapsulate collections of objects in classes to control mutation and add operations.
Controlling mutation is less of a concern in Kotlin, and we can use extension functions to add operations.
How would our designs be better without the encapsulation, and how do we get there?

In <<java-to-kotlin-collections>> we looked at the differences in the grain of Java and Kotlin when it comes to collections.
Java's collection interfaces, in keeping with its object-oriented roots, are fundamentally mutable, whereas Kotlin treats collections as value types.
As we saw, if we mutate shared collections we can run into all sorts of trouble.
We _could_ avoid that trouble by not mutating shared collections <<dont-mutate-shared-collections>>, but that's hard to do when those `add` and `set` methods are just an auto-complete away, and our runtime still doesn't give us a way to sort a collection that doesn't change it.
Instead of convention and discipline, most Java code sensibly opts for the safer approach of simply not sharing raw collections.
Instead, collections are hidden inside another object.

=== Encapsulated Collections

Here, for example, is a `Route` in Travelator:

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys; // <1>

    public Route(List<Journey> journeys) {
        this.journeys = journeys; // <2>
    }

    public int size() { // <3>
        return journeys.size();
    }

    public Journey get(int index) { // <3>
        return journeys.get(index);
    }

    public Location getDepartsFrom() { // <4>
        return get(0).getDepartsFrom();
    }

    public Location getArrivesAt() { // <4>
        return get(size() - 1).getArrivesAt();
    }

    public Duration getDuration() { // <4>
        return Duration.between(
            get(0).getDepartureTime(),
            get(size() - 1).getArrivalTime());
    }

    ...
}
----
// end-insert

<1> A `Route` encapsulates a `List` of `Journey`.
<2> The raw data is passed in the constructor.
<3> Access to the data, for example for displaying in the UI, is provided by `size` and `get` methods.
<4> The `Route` class implements application logic that uses the contents of the encapsulated list.

.Defensive Copies
****
To fully encapsulate the list, the `Route` constructor could take a defensive copy of the `journeys` parameter.
However, we "know" that our system only creates `Route` objects in the JSON deserialiser or in tests, neither of which holds onto the list of journeys after creating the `Route` that uses it.
There is, therefore, no risk of https://martinfowler.com/bliki/AliasingBug.html[aliasing errors], and we can save the cost of a copy whenever we create a `Route`.

If someone comes along and creates a `Route` with a collection that they later modify, we may come to regret this optimisation.
This is the problem with making use of conventions that are not underwritten by the type system.
****

Once we have a `Route` class, it is a convenient namespace to host operations on routes, like `getDepartsFrom` and `getDuration`.
Interestingly, all those methods shown use other public methods - they don't need special access to the hidden list.
There is no polymorphic behaviour either, so these operations _could_ be defined as static methods (top-level functions in Kotlin) taking a `Route` parameter.
In Java we tend not to do this, as functions are so much less discoverable than methods.
As we saw in <<functions-to-extension-functions>>, extension functions in Kotlin would let us call these like methods.
That's why we look at the `Route` more as a namespace than a class - it doesn't add any value to `List` of `Journey`, just prevents people from changing it.

In fact though, it is _worse_ than an immutable `List` of `Journey`.
If we had a `List<Journey>`, our front end code could use its `Iterator` when rendering:

// begin-insert: tags/collections.1:src/main/java/travelator/UI.java#iterable
[source,java]
----
public void render(Iterable<Journey> route) {
    for (var journey : route) {
        render(journey);
    }
}
----
// end-insert

With a `Route`, we're back to programming in the 1980s:

// begin-insert: tags/collections.1:src/main/java/travelator/UI.java#route
[source,java]
----
public void render(Route route) {
    for (int i = 0; i < route.size(); i++) {
        var journey = route.get(i);
        render(journey);
    }
}
----
// end-insert

We could solve this particular problem by having `Route` implement `Iterable<Journey>` (albeit with issues around `Iterator.remove()` -- Java really, really wants to be able to mutate collections).
In general though, when we encapsulate a collection, we _reduce_ the operations available for us to work with the contents to only those defined by the encapsulating class.
When we want to process that data in a new way, we will tend to add new operations to the class.
The more operations we add to the class, the more the class ends up _increasing_ the coupling between different parts of our application - so that adding an operation to support a UI function will end up recompiling our data-access layer.

=== Composing Domain Collections

If we don't encapsulate the collection - if we make our domain model _be_ the appropriate data structure, rather than hiding it behind a class boundary - we _extend_ the operations available for us to work with the data.
Then we have our application-specific operations _and_ all the operations defined for the collection.
Client code can define the operations it needs in terms of the rich collections API without having to add them to the class.

Rather than a `Route` class accreting all the route functionality and coupling all the parts of our application together, we can view that functionality as parts to be composed.
The UI can define functions that render `List<Journey>`, which in turn import functions that transform `Iterable<Journey>`.
The persistence layer can render database responses as `List<Journey>` and have no particular concept of routyness at all.


We can program like this in Java, but the combination of the better-discoverability of methods compared to utility functions, and mutable collections, makes it tedious and error-prone.
Kotlin's extension functions address the first, and immutable collections the second, tipping the balance towards

If we don't need to control access to a collection to prevent embarrassing mutation, and we don't need to write a class to host operations on collections of a type, then is our `Route` class doing anything for us?
Well, it is giving a name to `List<Journey>`.
And it is also giving a type to this `List<Journey>` that might distinguish it from other `List<Journey>` -- those in reports about all the journeys our travellers have paid for this week for example.
Where differentiating between different types of lists of journeys is not critical, Kotlin allows us to use type aliases to associate the name `Route` with `List<Journey>`, rather than having to use an actual type to do this.

In Kotlin, encapsulating collections should be the exception rather than the rule.

===

=== Refactoring Encapsulated Collections

The `Route` that we saw earlier

=== A Class That Encapsulates a Collection

One of the core services of our Travelator application is route planning.

A route is a sequence of journeys that can take the traveller from one location to another.
Each journey in a route is a service provided by an operator, via some mode of transport -- ship, train, bus, camel, etc. -- departing from one location at a specific time and arriving at another location some time later.
Our routing service finds several possible routes, and our travellers can compare them by cost, duration, and so on, to choose the route they prefer.

The journeys along a route do not always have a convenient interchange between them.
Some services run only once a day, or once a week, so our travellers want to know when they will have to book accommodation between the end of one journey and the start of the next.
This will let us improve the cost estimate for a route, because we can suggest places to stay and include the cost in the overall cost of the route.
We can make the feature earn its keep by booking their preferred choices and earning a commission.

Fundamental to this feature is the ability to find every interchange in a Route where the traveller will need accommodation.
Currently, our Route class does not have that capability.
How best to add it?

Let's take a look at our Java Route class.

// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#route
[source,java]
----
public class Route {
    private final List<Journey> journeys; // <1>

    public Route(List<Journey> journeys) {
        this.journeys = journeys; // <2>
    }

    public int size() { // <3>
        return journeys.size();
    }

    public Journey get(int index) { // <3>
        return journeys.get(index);
    }

    public Location getDepartsFrom() { // <4>
        return get(0).getDepartsFrom();
    }

    public Location getArrivesAt() { // <4>
        return get(size() - 1).getArrivesAt();
    }

    public Duration getDuration() { // <4>
        return Duration.between(
            get(0).getDepartureTime(),
            get(size() - 1).getArrivalTime());
    }

    ...
}
----
// end-insert

<1> A Route encapsulates a List of Journeys.
<2> To fully encapsulate the list, the constructor should take a defensive copy of the `journeys` parameter.
    However, we know that our system only creates Route objects in the JSON deserialiser or in tests, neither of which holds onto the list of journeys after creating the Route that uses it.
     There is, therefore, no risk of https://martinfowler.com/bliki/AliasingBug.html[_aliasing errors_], and we can save the cost of a copy whenever we create a Route.
<3> Because Lists are mutable -- or, at least, the type system offers no guarantee that the List is _not_ mutable -- the `Route` class does not expose the `journeys` list to code using `Route` objects.
    Instead it provides accessors for getting the size and individual elements by index.
    This is used in the front-end code that displays the route to the user.
<4> The `Route` class implements application logic that uses the contents of the encapsulated list.
    We will add another operation to report any accommodation required along the route.

To calculate the interchanges that require accommodation, we will map every two contiguous Journeys in the Route to an Interchange between the end of the first journey and the start of the second, and filter the Interchanges to select only those that require one or more overnight stays.

In Java, neither the collection nor stream API provides an operation to return all the contiguous pairs of a collection.
If we wrote this logic in Java we would have to implement it imperatively, with a for loop and mutable list, like this:

[[required-stays-imperative]]
// begin-insert: tags/collections.1:src/main/java/travelator/itinerary/Route.java#imperative_algorithm
[source,java]
----
public List<Interchange> requiredAccommodation() {
    var results = new ArrayList<Interchange>();

    for (int i = 1; i < journeys.size(); i++) {
        var interchange =
            Interchange.between(journeys.get(i - 1), journeys.get(i));

        if (interchange.isAccommodationRequired()) {
            results.add(interchange);
        }
    }

    return results;
}
----
// end-insert

In Kotlin, the standard library provides operations on List that do exactly what we want.
We can write the logic as a concise pipeline of transformations where each phase in the pipeline corresponds to a step in our description of the logic, above.

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#declarative_algorithm
[source,kotlin]
----
fun requiredAccommodation() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isAccommodationRequired }
----
// end-insert

This lets us focus on our application's domain model and business rules, relying on the authors of the standard library functions to handle the edge cases and avoid fence-post errors.

First, we have to convert the Route class to Kotlin.
Here's the class after IntelliJ has worked its translation magic:

// begin-insert: tags/collections.2:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) {
    fun size(): Int {
        return journeys.size
    }

    operator fun get(index: Int): Journey {
        return journeys[index]
    }

    val departsFrom: Location
        get() = get(0).departsFrom

    val arrivesAt: Location
        get() = get(size() - 1).arrivesAt

    val duration: Duration
        get() = Duration.between(
            get(0).departureTime,
            get(size() - 1).arrivalTime
        )

    ...
}
----
// end-insert

Note that IntelliJ has helpfully translated the Java `get` method to an operator method, allowing Kotlin code to get elements with the more concise indexing syntax.
We can apply some automatic fixes to make the code even more concise and conventional Kotlin.

In Kotlin, collections usually report their size as a read-only property, not a method:

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#size_property
[source,kotlin]
----
val size
    get() = journeys.size
----
// end-insert

The get method with block syntax can be transformed to single-expression syntax.

// begin-insert: tags/collections.3:src/main/java/travelator/itinerary/Route.kt#get_single_expression
[source,kotlin]
----
operator fun get(index: Int) = journeys[index]
----
// end-insert

The `arrivesAt` and `duration` properties calculate the index of the last journey in the list.
The Kotlin standard library defines a `List.last()` extension function that expresses the intent of the code more clearly.
To make the code symmetrical, we'll also use the `List.first()` extension to get the first journey.

// begin-insert: tags/collections.4:src/main/java/travelator/itinerary/Route.kt#use_first_and_last
[source,kotlin]
----
val departsFrom
    get() = journeys.first().departsFrom

val arrivesAt
    get() = journeys.last().arrivesAt

val duration
    get() = Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime
    )
----
// end-insert

We are now ready to add the `requiredAccommodation` method to our Kotlin class.
That leaves the Route class as:

// begin-insert: tags/collections.5:src/main/java/travelator/itinerary/Route.kt#route
[source,kotlin]
----
class Route(private val journeys: List<Journey>) {
    val size
        get() = journeys.size

    operator fun get(index: Int) = journeys[index]

    val departsFrom
        get() = journeys.first().departsFrom

    val arrivesAt
        get() = journeys.last().arrivesAt

    val duration
        get() = Duration.between(
            journeys.first().departureTime,
            journeys.last().arrivalTime
        )

    fun requiredAccommodation() =
        journeys
            .windowed(2)
            .map { (j1, j2) -> Interchange.between(j1, j2) }
            .filter { it.isAccommodationRequired }

    ...
}
----
// end-insert


=== Do We Need to Encapsulate the Collection?

In Java, the Route class encapsulated a mutable list to ensure that it couldn't be mutated.
In Kotlin, the List type cannot be mutated, so there is nothing to encapsulate.
There is no compelling reason for the `journeys` field to be private.

The Route class also provides accessors -- properties and query methods -- that return useful information about the route.
Those accessors support different parts of the application, but were defined in the Route class because they used the private list of Journeys.
With the list of journeys public, we could define those as extension functions, and move them into the part of the application that uses them.
However, while we still have Java that uses Routes, those accessors have another responsibility: to provide a convenient API for use by our Java code.

As we translate the Java code using the Route class into Kotlin, we will get to the point where methods and properties are only called from Kotlin.
At that point we can convert the class features to extensions and, where it makes sense, move them into the module that uses them.
IntelliJ can do this automatically, leaving `Route` as:

// begin-insert: tags/collections.7:src/main/java/travelator/itinerary/Route.kt
[source,kotlin]
----
class Route(val journeys: List<Journey>)

val Route.size: Int
    get() = journeys.size

operator fun Route.get(index: Int) = journeys[index]

val Route.departsFrom
    get() = journeys.first().departsFrom

val Route.arrivesAt
    get() = journeys.last().arrivesAt

val Route.duration
    get() = Duration.between(
        journeys.first().departureTime,
        journeys.last().arrivalTime
    )
----
// end-insert

// begin-insert: tags/collections.7:src/main/java/travelator/rooms/Route_RequiredAccommodation.kt
[source,kotlin]
----
fun Route.requiredAccommodation() =
    journeys
        .windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isAccommodationRequired }
----
// end-insert

It is now glaringly obvious that a Route is nothing more than a list of Journeys.
The class wrapping the list is worse than superfluous: it prevents us easily using all those useful extension functions in Kotlin's standard library to construct, transform, and process Routes.
As Alan Perlis famously said: "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures."
We don't want a Route to _have_ a List of Journey's, we want it to _be_ a List of Journeys.
In Kotlin, we can express that with a `typealias`:

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
----
// end-insert

However, replacing the class definition with a typealias will break code that constructs Route objects or refers to the `journeys` property.
We need to refactor our definition of `Route` from a class to a typealias without breaking the code that depends on it.
The way we'll do this is to replace the class with a typealias _and_ temporary definitions that emulate the API of the class.

// begin-insert: tags/collections.12:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
fun Route(journeys: List<Journey>) = journeys
val Route.journeys get() = this
----
// end-insert

The `Route` function ensures the calls to the constructor still compile.
The `Route.journeys` extension property ensures that references to the `journeys` property of the Route class still compile when a Route is a List of Journeys.
Then we can inline those temporary definitions, leaving the code that used them working with Lists of Journeys.

However, IntelliJ cannot automatically replace a class definition with a typealias and temporary extensions.
It has to be done by manual editing.
But those edits will prevent code that refers to the `journeys` property from compiling, because the extension of Route  must now be imported.

So, we must refactor the class, and the code that depends on it, into a form that allows us to perform the manual edit without breaking any code.
In this case, this means converting the `journeys` property defined on the class into an extension property that is imported by the files that depend on it.
Then we can replace it with the definition above.
We can do this with a sequence of automated refactoring steps.

First, we apply the "Move to class body" refactoring to the declaration of the `journeys` property in the primary constructor definition.

// begin-insert: tags/collections.8:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    val journeys = journeys
}
----
// end-insert

Then we apply the "Introduce backing property" refactoring to the `journeys` property in the class body.

// begin-insert: tags/collections.9:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    private val _journeys = journeys
    val journeys: List<Journey>
        get() = _journeys
}
----
// end-insert

Now `journeys` is a calculated property, without a backing field, that can be refactored into an extension property on Route that is correctly imported into every file that refers to it.

We'll have to temporarily increase the visibility of the `_journeys` property so that extensions of `Route` can refer to it.

// begin-insert: tags/collections.10:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    internal val _journeys = journeys
    val journeys: List<Journey>
        get() = _journeys
}
----
// end-insert

Then we apply the `Convert to extension` refactoring to the `journeys` property.

// begin-insert: tags/collections.11:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
class Route(journeys: List<Journey>) {
    internal val _journeys = journeys
}

val Route.journeys: List<Journey>
    get() = _journeys
----
// end-insert

Now we can manually replace the Route class with the typealias, `Route` function and `Route.journeys` extension property:

// begin-insert: tags/collections.12:src/main/java/travelator/itinerary/Route.kt#class
[source,kotlin]
----
typealias Route = List<Journey>
fun Route(journeys: List<Journey>) = journeys
val Route.journeys get() = this
----
// end-insert

Finally, we inline the `Route` function and `journeys` extension property.
Now a Route _is_ a List of Journeys, across our entire codebase.

// begin-insert: tags/collections.13:src/main/java/travelator/itinerary/Route.kt
[source,kotlin]
----
typealias Route = List<Journey>

val Route.departsFrom
    get() = first().departsFrom

val Route.arrivesAt
    get() = last().arrivesAt

val Route.duration
    get() = Duration.between(first().departureTime, last().arrivalTime)
----
// end-insert

// begin-insert: tags/collections.13:src/main/java/travelator/rooms/Route_RequiredAccommodation.kt
[source,kotlin]
----
fun Route.requiredAccommodation() =
    this.windowed(2)
        .map { (j1, j2) -> Interchange.between(j1, j2) }
        .filter { it.isAccommodationRequired }
----
// end-insert


=== Conclusion

We started this chapter with a Java class that encapsulated a mutable collection to guarantee value semantics.
As we translated more of our code to Kotlin, we could rely on Kotlin's type system to prevent the collection being modified, and no longer needed to encapsulate it within the class.
That allowed us to convert operations from methods to extensions, and move their definitions close to where they are used.
Because our class encapsulated a single collection, we were able to eliminate the class altogether, and replace it with a typealias.

Immutable collections and extensions allow us to organise our code in different ways.
We can group all the logic required by a particular feature of the application, or group logic that bridges between different domains.
We continue this train of thought in <<organising-code-by-domain>>.

This chapter looked at how we prevent unwanted mutation, and how Kotlin makes this unnecessary.
In <<accumulating-objects-to-transformations>>, we look at a class designed to be mutable and explore how we can refactor code that relies on its mutability to instead work by transforming immutable data.

Something about revisiting the issues of generic vs specific types and naming in <<interfaces-to-functions>>.