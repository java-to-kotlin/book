[[interfaces-to-functions]]
== Interfaces to Functions

****
In Java, we use interfaces to specify a contract between code that defines some functionality, and code that needs it.
Those interfaces couple the two parties together, which can make our software harder to maintain.
How do function types help solve this problem?
****

Imagine, if you can, that you need to send email from some code that you are writing.
Just that for now - not receive mail, or list sent messages - just fire and forget.

The code that describes the email is simple enough:

// begin-insert: src/main/java/encapsulation/Email.kt
[source,kotlin]
----
data class Email(
    val to: EmailAddress,
    val from: EmailAddress,
    val subject: String,
    val body: String
)
----
// end-insert

Given an `Email`, client code would _like_ to call the simplest possible function to send it, which is:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#send
[source,kotlin]
----
fun send(email: Email) {
    ...
}
----
// end-insert

Of course when we come to implement this function, we discover that, to actually send email, we require all sorts of other information.
Not information about the email itself, but rather configuration about how to send it.
Things like the sending server's host name and security credentials -- all the things that your non-technical relative doesn't know, but you need to set up their new computer.
We'll add three extra parameters to `sendEmail` to stand in for all this configuration:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#sendEmail
[source,kotlin]
----
fun sendEmail(
    email: Email,
    serverAddress: InetAddress,
    username: String,
    password: String
) {
    ...
}
----
// end-insert

As a client, things have just become a lot less convenient.
Everywhere we want to send email has to know this configuration -- we'll be passing it around from the top to the bottom of the codebase.
Solving that problem by hiding the details in global variables works fine, until we discover that every run of the unit test suite now sends 50 emails!
There must be a better way of hiding these petty details.

=== Object-Oriented Encapsulation

Object-oriented languages have a ready-made solution to this problem - objects can encapsulate the data:

// begin-insert: src/main/java/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

Now when we want to send email, we need access to an `EmailSender` (rather than the static function).
Once we have an `EmailSender`, instead of calling a function, we invoke a method, and we don't need to tell the method all the petty details because it already knows them -- they are the fields of its class:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: EmailSender = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

In general, the place where we know the configuration, and the place where we want to send an email, will be separated in our code, often by many layers.
Usually in OO, the `sender` will be captured as a property of a class and used by its methods:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#oo_class
[source,kotlin]
----
// Where we know the configuration
val subsystem = Rescuing(
    EmailSender(
        inetAddress("smtp.travelator.com"),
        "username",
        "password"
    )
)

// Where we send the message
class Rescuing(
    private val emailSender: EmailSender
) {
    fun sendThanks() {
        emailSender.send(
            Email(
                to = parse("support@internationalrescue.org"),
                from = parse("support@travelator.com"),
                subject = "Thanks for your help",
                body = "..."
            )
        )
    }
}
----
// end-insert

Often we will extract an interface:

// begin-insert: src/main/java/encapsulation/ISendEmail.kt
[source,kotlin]
----
interface ISendEmail {
    fun send(email: Email)
}
----
// end-insert

// begin-insert: src/main/java/encapsulation/EmailSender.kt#impl
[source,kotlin]
----
class EmailSender(
        ...
) : ISendEmail {
    override fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

If our client code depends on the `ISendEmail` interface rather than the `EmailSender` class, we can configure our tests to use a fake implementation of `ISendEmail` which doesn't actually send emails, but instead allows us to check what would be sent if it did.
Not only can we provide fakes that don't send emails at all, but also different non-fake implementations like `SmtpEmailSender` and `X400EmailSender`, each of which hides both its configuration and implementation from its clients.
We came for the information hiding, but stayed for the implementation hiding.

When we say _hiding_, it sounds a bit pejorative, but the concealment is useful to both client and implementor.
The former doesn't have the problem of having to supply the configuration details at the point of use; the latter is able to evolve separately from its users (provided it doesn't change API, expressed in the interface).

Before we leave the object-oriented realm, note that we don't have to create a named class to implement `ISendEmail`; we can do it anonymously:

// begin-insert: src/main/java/encapsulation/anonymous-class.kt#anon
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): ISendEmail =
    object : ISendEmail {
        override fun send(email: Email) =
            sendEmail(
                email,
                serverAddress,
                username,
                password
            )
    }
----
// end-insert

Why might we want to do this?
Well in situations where we don't control all the clients of our code (we are publishing a library external to our organisation for example), then this gives us flexibility to change our implementation, safe in the knowledge that clients cannot depend on a specific implementation class by downcasting to it and calling other methods.
We call the object that we return here a _closure_, as it closes-over values that it requires from its enclosing context (the function call), capturing them for later reference.

In Kotlin 1.4, we can declare our `ISendEmail` interface as a `fun interface` (one with only one abstract method).
This way we can define the implementation of the single operation with a lambda, rather than an object with a single method:

// begin-insert: src/main/java/encapsulation/anonymous-class.kt#anon2
[source,kotlin]
----
fun interface ISendEmail {
    fun send(email: Email)
}

fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
) = ISendEmail { email ->
    sendEmail(
        email,
        serverAddress,
        username,
        password
    )
}
----
// end-insert

Again, the lambda here is a closure, capturing the values of the parameters of its enclosing function.

=== Functional Encapsulation

Having seen how an OO programmer solves the problem of encapsulating pesky details so clients don't have to supply them at the point of use, how would a functional programmer approach the same problem?

Remember that we're trying to get to a function with this signature:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#send
[source,kotlin]
----
fun send(email: Email) {
    ...
}
----
// end-insert

But we actually need all this information to send the message:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#sendEmail
[source,kotlin]
----
fun sendEmail(
    email: Email,
    serverAddress: InetAddress,
    username: String,
    password: String
) {
    ...
}
----
// end-insert

In functional terms, this is an example of https://en.wikipedia.org/wiki/Partial_application[_partial application_] -- fixing some of the arguments to a function to yield a function with fewer arguments.
While some languages provide built-in support for this, in Kotlin the easiest approach is to write a function to partially apply our configuration.

What we want is a function that takes the configuration and returns a function that knows how to send an email:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender0
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit { // <1>
    ...
}
----
// end-insert

<1> The return type of our function is itself a function, that takes an `Email` and returns `Unit`.

`createEmailSender` is a constructor; not a class constructor, but a function taking the same role.
Both `createEmailSender` and `::EmailSender` are functions that return an object that knows how to send a message.

To see how this works in functions, we can write this in longhand first, by defining an inner function that captures the arguments it requires from the parent:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender1
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit {

    fun result(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
    return ::result
}
----
// end-insert

We can then make the result a lambda expression:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender2
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit {

    val result: (Email) -> Unit =
        { email ->
            sendEmail(
                email,
                serverAddress,
                username,
                password
            )
        }
    return result
}
----
// end-insert

If we inline `result` and convert the whole function to a single expression we are left with this functional definition:

// begin-insert: src/main/java/encapsulation/encapsulation.kt#createEmailSender3
[source,kotlin]
----
fun createEmailSender(
    serverAddress: InetAddress,
    username: String,
    password: String
): (Email) -> Unit =
    { email ->
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
----
// end-insert

So `createEmailSender` is a function that returns a lambda that calls `sendEmail` combining the lambda's single `Email` argument with the configuration from its own parameters.
This is a closure in functional land, and it's not a coincidence that it is very similar to the OO versions with a `fun interface` or `object` definition.

To use this function, we can create it in one place and invoke it in another, very much as we did with the object solution.

// begin-insert: src/main/java/encapsulation/FP-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender( // <1>
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

<1> There is an implicit `invoke` call hidden here.

This is the same shape as the OO case (if we replace the hidden `invoke` with `send`):

// begin-insert: src/main/java/encapsulation/OO-usage.kt#excerpt
[source,kotlin]
----
fun sendThanks() {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

In the unlikely event that you're joining us from JavaScript, or Clojure, the functional form will be familiar, but if you came to Kotlin from Java, this solution probably feels quite alien.

=== Function Types in Java

Both the object and functional forms have allowed us to encapsulate things (in this case configuration, but it could equally well have been collaborators)
to transport them from the place where they are known to the place where they are used.
Any data-structure could have done that, but because the object and the function both have an operation that can be run (`send` and `invoke` respectively), the client can remain oblivious to the details of the configuration and just pass the information that is specific to each invocation (the `Email`).

One way of unifying the functional and OO solutions is to view a function as an object with a single `invoke` method.
This is exactly what Java 8 did when it introduced lambdas.
To refer to a function type, Java uses interfaces with a _Single Abstract Method_ (SAM) that has the desired signature.
Lambdas in Java are a special syntax to implement a SAM interface.
The Java runtime defines SAM interfaces named by role: `Consumer`, `Supplier`, `Function`, `BiFunction`, `Predicate` etc for us.
It also provides primitive specialisations, like `DoublePredicate`, to avoid boxing issues.

Expressed in Java, our functional solution is

// begin-insert: src/main/java/encapsulation/FPUsage.java#foo
[source,java]
----
// Where we know the configuration
Consumer<Email> sender = createEmailSender(
    inetAddress("example.com"),
    "username",
    "password"
);

// Where we send the message
public void sendThanks() {
    sender.accept( // <1>
        new Email(
            parse("support@internationalrescue.org"),
            parse("support@travelator.com"),
            "Thanks for your help",
            "..."
        )
    );
}
----
// end-insert

<1> Accept is the name of the single abstract method on the `Consumer` interface.

`createEmailSender` can be implemented with a lambda:

// begin-insert: src/main/java/encapsulation/FPUsage.java#FPUsageLambda
[source,java]
----
static Consumer<Email> createEmailSender(
    InetAddress serverAddress,
    String username,
    String password
) {
    return email -> sendEmail(
        email,
        serverAddress,
        username,
        password
    );
}
----
// end-insert

This is equivalent to creating an anonymous implementation of the interface, a technique that will be very familiar to those of us who programmed in Java before Java 8:

// begin-insert: src/main/java/encapsulation/FPUsage.java#FPUsageLongHand
[source,java]
----
static Consumer<Email> createEmailSender(
    InetAddress serverAddress,
    String username,
    String password
) {
    return new Consumer<Email>() {
        @Override
        public void accept(Email email) {
            sendEmail(
                email,
                serverAddress,
                username,
                password
            );
        }
    };
}
----
// end-insert

We say "equivalent to creating an anonymous implementation of the interface," but under the hood, the implementation is more complex to avoid unnecessarily defining classes and instantiating objects.

Note that we can't assign the `(Email) -> Unit` result of the Kotlin `createEmailSender` to a variable of type `Consumer<Email>`.
This is because the Kotlin runtime has its own function types that it uses, and the compiler compiles `(Email) -> Unit` into `Function1<Email, Unit>`.
There are a whole series of Kotlin `FunctionN` interfaces for the different numbers of parameters.

As the interfaces are not compatible, in order to mix Java and Kotlin at this functional level we are going to have to thunk sometimes.
Given a Kotlin function type `(Email) -> Unit`:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo1
[source,kotlin]
----
// Kotlin function type
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)
----
// end-insert

We can't just assign `sender` to `Consumer<Email`:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo2
[source,kotlin]
----
val consumer: Consumer<Email> = sender // Doesn't compile <1>
----
// end-insert

<1> `Type mismatch. Required: Consumer<Email> Found:(Email) -> Unit`

We can though convert with a lambda:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo3
[source,kotlin]
----
val consumer: Consumer<Email> = Consumer<Email> { email ->
    sender(email)
}
----
// end-insert

There is a situation where we don't have to convert, which is calling a Java method that takes a SAM parameter, for example, this constructor:

// begin-insert: src/main/java/encapsulation/Rescuing.java#foo
[source,java]
----
class Rescuing {
    private final Consumer<Email> emailSender;

    Rescuing(Consumer<Email> emailSender) {
        this.emailSender = emailSender;
    }
    ...
}
----
// end-insert

Here, the compiler _is_ able to convert `(Email) -> Unit` to `Consumer<Email>`, because Kotlin will convert parameters automatically, so that we can say:

// begin-insert: src/main/java/encapsulation/thunking-consumer.kt#foo4
[source,kotlin]
----
Rescuing(sender)
----
// end-insert

=== Mix and Match

There are two sides to an abstraction, the client code and the implementation code.
So far, both client and implementor have either been object-oriented or functional.
In the OO case, fields carry configuration, and the client invokes a method.
In the functional scheme, a function closes over the configuration, and the client invokes the function.

Can we unify these approaches, passing an OO implementation to a function-expecting client or vice versa?
Or, in Kotlin terms, can we convert `ISendEmail` to `(Email) -> Unit`, and the inverse.
Why yes we can!

Remember that in Java and Kotlin, function types are just interfaces.
Because of this `EmailSender` can implement the type `Consumer<Email>` or  `(Email) -> Unit` respectively, by defining a method with the signature of the function type.

So in Java we can write:

// begin-insert: src/main/java/encapsulation/MixedUsage.java#consumer
[source,java]
----
public class EmailSender
    implements ISendEmail,
        Consumer<Email> // <1>
{
        ...
    @Override
    public void accept(Email email) { // <2>
        send(email);
    }

    @Override
    public void send(Email email) {
        sendEmail(email, serverAddress, username, password);
    }
}
----
// end-insert

<1> Declare
<2> Implement

This is the Kotlin equivalent:

// begin-insert: src/main/java/encapsulation/EmailSender.kt#invoke
[source,kotlin]
----
class EmailSender(
        ...
) : ISendEmail,
    (Email) -> Unit // <1>
{
    override operator fun invoke(email: Email) =
        send(email) // <2>

    override fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

<1> Declare
<2> Implement

If we do this then we can use our class-based sender in place of our functional one.
We'll stick with Kotlin now:

// begin-insert: src/main/java/encapsulation/FP-usage.kt#bar
[source,kotlin]
----
// Where we know the configuration
val sender: (Email) -> Unit = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender( // <1>
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

<1> There is an implicit `invoke` here.

Now our OO implementation has gained an `invoke` method in order to fit in with the FP approach.
This calls into question the usefulness of our `ISendEmail` interface.
We can see that it is equivalent to the function type `(Email) -> Unit`.
All it does is give the name `send` to what happens when you invoke it.
Maybe we could just use the type `(Email) -> Unit` everywhere in place of `ISendEmail`?

If you think that isn't expressive enough, then maybe you aren't a functional programmer.
Luckily there is a middle ground - we can use a type alias to give a name to the functional type, thus communicating our intent.

// begin-insert: src/main/java/encapsulation/typealias.kt#typealias
[source,kotlin]
----
typealias EmailSenderFunction = (Email) -> Unit

class EmailSender(
    ...
) : EmailSenderFunction {
    override fun invoke(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

In reality, we would probably call `EmailSenderFunction`, `EmailSender`.
Here we've given it a different name to avoid confusion with the OO version, but the fact that we want to call them the same thing shows that they serve the same purpose from the client's perspective.

.Expressive Function Types
****
Once we have our head in the functional mindset, the type `(Email) -> Unit` may be expressive enough to tell us the role of the function, especially when bound to a variable named `sender`.
What can you do with an email that doesn't return a result?
Well if it doesn't return a result it must be an action (<<actions>>), but deleting an email might also have a similar signature.
Objects have that advantage over functions -- they get to name their methods (`send(email)` is obviously different to `delete(email)`), at the expense of also having to name the type of the object or interface.

Kotlin has a feature that can help make function types more expressive - we can name the parameters.
So if it helps, we could write `(toSend: Email) -> Unit`.
It doesn't make a great difference here, but can be very useful in situations with parameters of the same type, for example `(username: String, password: String) -> AuthenticatedUser`.
If we use this form, IntelliJ will even helpfully name the parameters when we implement the function with a lambda or a class.
****

There is another way of bridging the OO-FP gap that doesn't involve making our classes implement function types - create a function reference at the point of translation.
Here is our old class-based solution:

// begin-insert: src/main/java/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

We can convert an instance of `EmailSender` to a function type with a lambda:

// begin-insert: src/main/java/encapsulation/mixed-usage.kt#foo
[source,kotlin]
----
val instance = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)
val sender: (Email) -> Unit = { instance.send(it) }
----
// end-insert

or just use a method reference:

// begin-insert: src/main/java/encapsulation/mixed-usage.kt#bar
[source,kotlin]
----
val sender: (Email) -> Unit = instance::send
----
// end-insert

Whilst we've shown these conversions in Kotlin, they also work in Java (with a slightly different syntax).
They work with the `send` method on the `ISendEmail` interface too, although it's not clear that the interface is doing much for us if we are using the function type.

Can we do the opposite - pass our functional sender into something that expects an `ISendEmail`?
This requires more ceremony, as we have to create an anonymous object implementing `ISendEmail` to perform the thunk:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#bar
[source,kotlin]
----
val function: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

val sender: ISendEmail = object : ISendEmail {
    override fun send(email: Email) {
        function(email)
    }
}
----
// end-insert

If we had used a Kotlin 1.4 `fun interface`, we could again remove some boilerplate:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#baz
[source,kotlin]
----
fun interface ISendEmail {
    fun send(email: Email)
}

val sender = ISendEmail { function(it) }
----
// end-insert

=== Comparing the Approaches

Let's remind ourselves of the OO approach.

First we define a type:

// begin-insert: src/main/java/encapsulation/EmailSender.kt#plain
[source,kotlin]
----
class EmailSender(
    private val serverAddress: InetAddress,
    private val username: String,
    private val password: String
) {
    fun send(email: Email) {
        sendEmail(
            email,
            serverAddress,
            username,
            password
        )
    }
}
----
// end-insert

Then we create instances and call methods:

// begin-insert: src/main/java/encapsulation/OO-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: EmailSender = EmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

In functional land we don't have to define a type, because `(Email) -> Unit` just exists (which is to say, is provided by the runtime), so we can just say:

// begin-insert: src/main/java/encapsulation/FP-usage.kt#foo
[source,kotlin]
----
// Where we know the configuration
val sender: (Email) -> Unit = createEmailSender(
    inetAddress("smtp.travelator.com"),
    "username",
    "password"
)

// Where we send the message
fun sendThanks() {
    sender( // <1>
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

<1> With or without the `invoke`.

Clients using the _object_ have to know to call the `send` method to send email; in contrast, clients using the _function_ just have to invoke it, but they only know that the function sends email because it has been assigned the name `sender`.
If that name got lost in the call hierarchy, we are left to guess what happens from the function signature.

The quid-pro-quo of the OO clients having to know to call the `send` method is that we could package up a number of email-related operations into an `EmailSystem`, with methods like `send`, `list`, and `delete`, and pass all this functionality to clients in one go.
Clients can then choose which they need in which context:

// begin-insert: src/main/java/encapsulation/EmailSystem.kt
[source,kotlin]
----
interface EmailSystem {
    fun send(email: Email)
    fun delete(email: Email)
    fun list(folder: Folder): List<Email>
    fun move(email: Email, to: Folder)
}
----
// end-insert

To achieve this functionally would require either passing individual functions around, or some sort of map of name to function, maybe an instance of a class itself:

// begin-insert: src/main/java/encapsulation/fp-email-system.kt#foo
[source,kotlin]
----
class EmailSystem(
    val send: (Email) -> Unit,
    val delete: (Email) -> Unit,
    val list: (folder: Folder) -> List<Email>,
    val move: (email: Email, to: Folder) ->  Unit
)
----
// end-insert

Given such an object, clients could treat it very much like an implementation of the interface:

// begin-insert: src/main/java/encapsulation/fp-email-system.kt#bar
[source,kotlin]
----
fun sendThanks(sender: EmailSystem) {
    sender.send(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

But this is not the same as the OO code.
Instead of invoking a `send` _method_; what is actually happening here is that we are calling `getSender` to access a property of function type, and then calling `invoke` on that function:

// begin-insert: src/main/java/encapsulation/fp-email-system.kt#baz
[source,kotlin]
----
fun sendThanks(sender: EmailSystem) {
    sender.send.invoke(
        Email(
            to = parse("support@internationalrescue.org"),
            from = parse("support@travelator.com"),
            subject = "Thanks for your help",
            body = "..."
        )
    )
}
----
// end-insert

The code may read the same, but it generates very different, and fundamentally incompatible, bytecode.

=== Coupling

An easy to overlook difference between expressing a dependency as an implementation of `ISendEmail`, and an implementation of the function type `(Email) -> Unit`, is the coupling between the client and the implementation, in particular when they are in different code modules.

`ISendEmail` has to be defined somewhere.
The client can't define it, because the implementor will depend on the interface, and the client on the implementation, leading to a circular dependency.
So the interface has to be defined either with the implementation, or in a separate place (package or JAR file) depended on by both implementation and its clients.
The later (an application of the https://en.wikipedia.org/wiki/Dependency_inversion_principle[Dependency Inversion Principle]) is in theory preferable but in practice more work and so often neglected.

With or without Dependency Inversion, the result is the client and implementation being coupled by the interface in ways which can make systems hard to reason with and refactor.
Any change to methods on `EmailSystem` might affect all code that depends on the interface.

In contrast, in the functional world, the runtime defines all the function types, so they don't introduce a compile-time dependency between the client and an implementation.
Unlike `ISendEmail`, which we have to define somewhere, `(Email) -> Unit` (or in Java, `Consumer<Email>`) are part of the language.
Of course there will be a run-time dependency -- the constructor code needs to be visible where the dependency is created, and the client has to be able to invoke the implementation code, but these cause less coupling.
For example, when a dependency is expressed as a function type, we can rename `EmailSystem.send`, and the only change in our client code will be to use a different method reference -- the internals of `sendThanks` are unaffected.

[TIP]
.Only Pass Types That You Own, or That The Runtime Defines
====
An early rule of thumb for OO systems was that, on the inside of our systems, we should program in terms of types that we own, rather than those supplied by libraries.
That way we are insulated from changes that we don't control, and are more likely to write code that can be reused with different implementations.

An exception to this rule is taking a dependency on types provided by the runtime - these are very unlikely to change.
Function types allow us to easily convert from unstable to stable interfaces, allowing parts of our systems to evolve at different rates.
====

=== Object-Oriented or Functional?

Both the object-oriented and functional approaches can achieve the same goals, and with similar levels of expressiveness.
Which should we choose?

Let's consider this from the context of the client code.
If our client only needs to list email, it should have a dependency on a single `(Folder) -> List<Email>` function.
This way it is not coupled to an implementation, and the dependency can be satisfied by anything implementing the function type, including:

* a plain function
* an object implementing the function type
* method reference selecting a method with the desired signature
* a lambda with the desired signature.

Even if we already happen to have an interface, lets say `EmailSystem`, which defines the desired method along with `send`, `move` and `delete`:

// begin-insert: src/main/java/encapsulation/EmailSystem.kt
[source,kotlin]
----
interface EmailSystem {
    fun send(email: Email)
    fun delete(email: Email)
    fun list(folder: Folder): List<Email>
    fun move(email: Email, to: Folder)
}
----
// end-insert

We shouldn't needlessly couple our client to this interface when the function type will do:

// begin-insert: src/main/java/encapsulation/narrowing.kt#one_method
[source,kotlin]
----
class Organiser(
    private val listing: (Folder) -> List<Email>
) {
    fun subjectsIn(folder: Folder): List<String> {
        return listing(folder).map { it.subject }
    }
}

val emailSystem: EmailSystem = ...
val organiser = Organiser(emailSystem::list)
----
// end-insert

Depending on the wider interface misses the opportunity to communicate precisely which operations we require, and forces clients to provide an implementation of the whole interface.
This is particularly irritating in tests, where we will have to introduce fake objects just to get our test code to compile.

The drives of communication and reduced coupling are so strong that even if our client needs to send and delete email, and in practice these are going to be supplied by a single `EmailSystem`, it should probably depend on two functions rather than the interface:

// begin-insert: src/main/java/encapsulation/narrowing.kt#two_methods
[source,kotlin]
----
class Organiser(
    private val listing: (Folder) -> List<Email>,
    private val deleting: (Email) -> Unit
) {
    fun deleteInternal(folder: Folder) {
        listing(rootFolder).forEach {
            if (it.to.isInternal()) {
                deleting.invoke(it)
            }
        }
    }
}

val organiser = Organiser(
    emailSystem::list,
    emailSystem::delete
)
----
// end-insert

Only at the point where the client requires three related operations does it feel like a multi-method interface should be the default:

// begin-insert: src/main/java/encapsulation/narrowing.kt#direct_dependency
[source,kotlin]
----
class Organiser(
    private val emails: EmailSystem
) {
    fun organise() {
        emails.list(rootFolder).forEach {
            if (it.to.isInternal()) {
                emails.delete(it)
            } else {
                emails.move(it, archiveFolder)
            }
        }
    }
}

val organiser = Organiser(emailSystem)
----
// end-insert

Even here, it might be better for the client to accept an object that only supports the desired operations.
We can do that with a new interface (`Dependencies` here), implemented with an `object`:

// begin-insert: src/main/java/encapsulation/narrowing.kt#interface
[source,kotlin]
----
class Organiser(
    private val emails: Dependencies
) {
    interface Dependencies {
        fun delete(email: Email)
        fun list(folder: Folder): List<Email>
        fun move(email: Email, to: Folder)
    }

    fun organise() {
        emails.list(rootFolder).forEach {
            if (it.to.isInternal()) {
                emails.delete(it)
            } else {
                emails.move(it, archiveFolder)
            }
        }
    }
}

val organiser = Organiser(object : Organiser.Dependencies {
    override fun delete(email: Email) {
        emailSystem.delete(email)
    }

    override fun list(folder: Folder): List<Email> {
        return emailSystem.list(folder)
    }

    override fun move(email: Email, to: Folder) {
        emailSystem.move(email, to)
    }
})
----
// end-insert

That's pretty irritating though, maybe this is a place where a class of functions would be better:

// begin-insert: src/main/java/encapsulation/narrowing.kt#object
[source,kotlin]
----
class Organiser(
    private val emails: Dependencies
) {
    class Dependencies(
        val delete: (Email) -> Unit,
        val list: (folder: Folder) -> List<Email>,
        val move: (email: Email, to: Folder) -> Unit
    )

    fun organise() {
        emails.list(rootFolder).forEach {
            if (it.to.isInternal()) {
                emails.delete(it)
            } else {
                emails.move(it, archiveFolder)
            }
        }
    }
}

val organiser = Organiser(
    Organiser.Dependencies(
        delete = emailSystem::delete,
        list = emailSystem::list,
        move = emailSystem::move
    )
)
----
// end-insert

So, until it becomes hard work, we should default to expressing our client's needs as function types.
Our implementation then can be just a function, or something implementing the function type, or a method converted to the function type through method references or lambdas, whichever makes most sense in context.

=== The Legacy of Java

While we said earlier that "our runtime defines all the functions types", that wasn't true of Java until Java 8 introduced `Supplier`, `Consumer`, `Predicate` etc, and the ability to implement them with method references or lambdas.

Because of this, legacy Java code usually expresses dependencies with the same multi-method interfaces that we would use to group them by sub-system (like `EmailSystem` above), even when only one of those methods is required to implement the functionality.
This leads to the coupling problems described earlier.
It also leads to a need for mocking (or more pedantically faking) frameworks to create test implementations of broad interfaces where in practice only one method will be called.
These fakes then sprout the functionality to fail early if you call a method that you didn't mean to call, a problem that would be solved at compile-time if a single function expressed the dependency.

Once we have introduced a mocking framework into our codebase (or, more usually, two or three mocking frameworks to cater for different tastes), they allow us to solve problems, like generating implementations for unused methods and stubbing out interactions with external systems.
Usually though, our code would be improved by restructuring to avoid the need for mocks.
Expressing dependencies as function types is one example, another is moving the interaction with external systems to the outer layers of our code, as we will see in <<performing-io-to-passing-data>>.
<<mocks-to-maps>> looks at how to reduce mock use by refactoring our tests to a more functional form.

=== Traceability

There is a downside to expressing dependencies with function types, and it is a common issue with adding a layer of indirection.
If we use IntelliJ to find the callers of `EmailSystem.send`, the trail goes cold at the point where `EmailSystem::send` is converted to `(Email) -> Unit`.
The IDE doesn't know that invocations of the function are actually calling the method.
It's like our hero enters a river, and the posse tracking her have to scour both banks upstream and downstream to find where she gets out.

This is a price we pay for indirection with method calls too, but our tooling is wise to these, and can at least find all places where a particular method is implemented, and where an implementation is called through an interface.
As with using unencapsulated collections (<<encapsulated-collections-to-typealiases>>) the price that we pay for decoupling and generality is that tooling, and developers, have less context to hang analysis on.
We trust that IDE support will improve its functional analysis, and in the meantime we can help by not passing function types too far from where they are initialized to where they are used.

=== Refactoring from Interfaces to Functions

Travelator is quite well-designed in the Java fashion, with interfaces expressing the relations between components.
For example the `Recommendations` engine depends on `FeaturedDestinations` and a `DistanceCalculator`:

// begin-insert: tags/interfaces-to-functions-2.0:src/main/java/travelator/recommendations/Recommendations.java#setup
[source,java]
----
public class Recommendations {
    private final FeaturedDestinations featuredDestinations;
    private final DistanceCalculator distanceCalculator;

    public Recommendations(
        FeaturedDestinations featuredDestinations,
        DistanceCalculator distanceCalculator
    ) {
        this.featuredDestinations = featuredDestinations;
        this.distanceCalculator = distanceCalculator;
    }
    ...
}
----
// end-insert

The `FeaturedDestinations` interface has a few methods, grouping functionality that accesses a remote service:

// begin-insert: tags/interfaces-to-functions-2.0:src/main/java/travelator/destinations/FeaturedDestinations.java
[source,java]
----
public interface FeaturedDestinations {
    List<FeaturedDestination> findCloseTo(Location location);
    FeaturedDestination findClosest(Location location);

    FeaturedDestination add(FeaturedDestinationData destination);
    void remove(FeaturedDestination destination);
    void update(FeaturedDestination destination);
}
----
// end-insert

It looks like we've already converted the `DistanceCalculator` interface to Kotlin.
It too has more than one method, and hides another external service:

// begin-insert: tags/interfaces-to-functions-2.0:src/main/java/travelator/domain/DistanceCalculator.kt
[source,kotlin]
----
interface DistanceCalculator {
    fun distanceInMetersBetween(
        start: Location,
        end: Location
    ): Int

    fun travelTimeInSecondsBetween(
        start: Location,
        end: Location
    ): Int
}
----
// end-insert

Despite taking a dependency on a total of seven methods, `Recommendations` only actually uses two of them in its implementation:

// begin-insert: tags/interfaces-to-functions-2.0:src/main/java/travelator/recommendations/Recommendations.java#recommendationsFor
[source,java]
----
public List<FeaturedDestinationSuggestion> recommendationsFor(
    Set<Location> journey
) {
    var results = removeDuplicates(
        journey.stream()
            .flatMap(location ->
                recommendationsFor(location).stream()
            )
    );
    results.sort(distanceComparator);
    return results;
}

public List<FeaturedDestinationSuggestion> recommendationsFor(
    Location location
) {
    return featuredDestinations
        .findCloseTo(location) // <1>
        .stream()
        .map(featuredDestination ->
            new FeaturedDestinationSuggestion(
                location,
                featuredDestination,
                distanceCalculator.distanceInMetersBetween( // <2>
                    location,
                    featuredDestination.getLocation()
                )
            )
        ).collect(toList());
}
----
// end-insert

<1> Method on `FeaturedDestinations`
<2> Method on `DistanceCalculator`

`RecommendationsTests` uses mocks to provide implementations of its `DistanceCalculator` and `FeaturedDestinations`, which are passed to the instance of `Recommendations` under test:

// begin-insert: tags/interfaces-to-functions-2.0:src/test/java/travelator/recommendations/RecommendationsTests.java#setup
[source,java]
----
public class RecommendationsTests {

    private final DistanceCalculator distanceCalculator =
        mock(DistanceCalculator.class);
    private final FeaturedDestinations featuredDestinations =
        mock(FeaturedDestinations.class);
    private final Recommendations recommendations = new Recommendations(
        featuredDestinations,
        distanceCalculator
    );
    ...
}
----
// end-insert

The tests specify the expected interactions with the mocks are using two methods: `givenFeaturedDestinationsFor` and `givenADistanceBetween`, which we won't bore you with:

// begin-insert: tags/interfaces-to-functions-2.0:src/test/java/travelator/recommendations/RecommendationsTests.java#test1
[source,java]
----
@Test
public void returns_recommendations_for_multi_location() {
    givenFeaturedDestinationsFor(paris,
        List.of(
            eiffelTower,
            louvre
        ));
    givenADistanceBetween(paris, eiffelTower, 5000);
    givenADistanceBetween(paris, louvre, 1000);

    givenFeaturedDestinationsFor(alton,
        List.of(
            flowerFarm,
            watercressLine
        ));
    givenADistanceBetween(alton, flowerFarm, 5300);
    givenADistanceBetween(alton, watercressLine, 320);

    assertEquals(
        List.of(
            new FeaturedDestinationSuggestion(alton, watercressLine, 320),
            new FeaturedDestinationSuggestion(paris, louvre, 1000),
            new FeaturedDestinationSuggestion(paris, eiffelTower, 5000),
            new FeaturedDestinationSuggestion(alton, flowerFarm, 5300)
        ),
        recommendations.recommendationsFor(Set.of(paris, alton))
    );
}
----
// end-insert

==== Introduce Functions

Before we start moving from interfaces to functions, we'll convert `Recommendations` to Kotlin.
This is the class that currently expresses its dependencies with interfaces, and Kotlin function types are less clunky than Java's.

Converting to Kotlin and applying the refactorings introduced in <<streams-to-sequences>> and <<functions-to-extension-functions>> gives:

// begin-insert: tags/interfaces-to-functions-2.4:src/main/java/travelator/recommendations/Recommendations.kt
[source,kotlin]
----
class Recommendations(
    private val featuredDestinations: FeaturedDestinations,
    private val distanceCalculator: DistanceCalculator
) {
    fun recommendationsFor(
        journey: Set<Location>
    ): List<FeaturedDestinationSuggestion> =
        journey
            .flatMap { location -> recommendationsFor(location) }
            .deduplicated()
            .sortedBy { it.distanceMeters }

    fun recommendationsFor(
        location: Location
    ): List<FeaturedDestinationSuggestion> =
        featuredDestinations.findCloseTo(location)
            .map { featuredDestination ->
                FeaturedDestinationSuggestion(
                    location,
                    featuredDestination,
                    distanceCalculator.distanceInMetersBetween(
                        location,
                        featuredDestination.location
                    )
                )
            }
}

private fun List<FeaturedDestinationSuggestion>.deduplicated() =
    groupBy { it.suggestion }
        .values
        .map { suggestionsWithSameDestination ->
            suggestionsWithSameDestination.closestToJourneyLocation()
        }

private fun List<FeaturedDestinationSuggestion>.closestToJourneyLocation() =
    minByOrNull { it.distanceMeters } ?: error("Unexpected empty group")
----
// end-insert

In order to see how the internals of `Recommendations` would use a function rather than the interface, without having to change its interface yet, we can add a property initialised from an interface method.
Let's add a property for `featuredDestinations::findCloseTo`, calling it `destinationFinder`:

// begin-insert: tags/interfaces-to-functions-2.8:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val featuredDestinations: FeaturedDestinations,
    private val distanceCalculator: DistanceCalculator
) {
    private val destinationFinder: // <1>
        (Location) -> List<FeaturedDestination> =
        featuredDestinations::findCloseTo

    ...

    fun recommendationsFor(
        location: Location
    ): List<FeaturedDestinationSuggestion> =
        destinationFinder(location) // <2>
            .map { featuredDestination ->
                FeaturedDestinationSuggestion(
                    location,
                    featuredDestination,
                    distanceCalculator.distanceInMetersBetween(
                        location,
                        featuredDestination.location
                    )
                )
            }
}
----
// end-insert

<1> Extract a function from the interface.
<2> Use it in place of the method.

This passes the tests, so we are on to something.
It feels like there should be a refactoring to move `destinationFinder` into the constructor, but we haven't found anything better than cutting the definition and pasting where we want it:

// begin-insert: tags/interfaces-to-functions-2.9:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val featuredDestinations: FeaturedDestinations,
    private val distanceCalculator: DistanceCalculator,
    private val destinationFinder:
        (Location) -> List<FeaturedDestination> =
        featuredDestinations::findCloseTo
) {
----
// end-insert

This is, once again, the _expand_ in <<expand-contract>>.
Unfortunately Java doesn't understand the defaulted parameter, so we have to fix up the call sites to add the function argument.
It doesn't really matter, as this is what we want really anyway:

// begin-insert: tags/interfaces-to-functions-2.9:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
private final Recommendations recommendations = new Recommendations(
    featuredDestinations,
    distanceCalculator,
    featuredDestinations::findCloseTo
);
----
// end-insert

Now nothing in `Recommendations` uses the `featuredDestinations` property, so we can remove it (contract):

// begin-insert: tags/interfaces-to-functions-2.10:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val distanceCalculator: DistanceCalculator,
    private val destinationFinder: (Location) -> List<FeaturedDestination>
) {
----
// end-insert

The places in our code that create `Recommendations` now look like this:

// begin-insert: tags/interfaces-to-functions-2.10:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
private final Recommendations recommendations = new Recommendations(
    distanceCalculator,
    featuredDestinations::findCloseTo
);
----
// end-insert

If you're used to refactoring tests with mocks, it may surprise you that the tests have continued to pass through this refactoring.
We can reason that they _should_ pass -- the effect of calling the function bound to `featuredDestinations::findCloseTo` is still to invoke the method on the mocked interface -- but our reasoning is so often proved wrong by running the tests that we don't count our chickens.

We do like a single basket though, so let's do the same thing with the `distanceCalculator`, this time in a fell-swoop, whatever that is:

// begin-insert: tags/interfaces-to-functions-2.11:src/main/java/travelator/recommendations/Recommendations.kt#excerpt
[source,kotlin]
----
class Recommendations(
    private val destinationFinder: (Location) -> List<FeaturedDestination>,
    private val distanceInMetersBetween: (Location, Location) -> Int
) {
    ...
    fun recommendationsFor(
        location: Location
    ): List<FeaturedDestinationSuggestion> =
        destinationFinder(location)
            .map { featuredDestination ->
                FeaturedDestinationSuggestion(
                    location,
                    featuredDestination,
                    distanceInMetersBetween( // <1>
                        location,
                        featuredDestination.location
                    )
                )
            }
}
----
// end-insert

<1> Calling the new function.

The constructor invocations are now:

// begin-insert: tags/interfaces-to-functions-2.11:src/test/java/travelator/recommendations/RecommendationsTests.java#excerpt
[source,java]
----
private final Recommendations recommendations = new Recommendations(
    featuredDestinations::findCloseTo,
    distanceCalculator::distanceInMetersBetween
);
----
// end-insert

Note that a little thought around what to call functional variables can go a long way to making them seem natural in use, although that does sometimes make them a little cryptic where they are defined.

Again the tests still pass, giving us confidence that our production code will see the transformation the same way.
It's particularly nice that we have shown that we can simultaneously cross a method/function boundary, and a Java/Kotlin boundary.
Maybe this interop will work out OK after all!

=== Moving On

We want our code to be simple and flexible.
To this end, libraries need to hide implementation details from client code, and we want to be able to substitute one implementation of some functionality with another.

In OO we hide configuration and implementation inside classes, and express substitutable functionality with interfaces.
In functional programming functions take both roles
We might see the function as more fundamental, but we can view an object as a collection of functions, and a function as an object with a single method.
Both Kotlin and Java allow us to move between realms at the boundaries between implementations and clients, but Kotlin's native function type syntax encourages the use of function types rather than interfaces.
This allows even more decoupling than defining our own interfaces, and should be our default approach.

We continue refactoring this example, and examining this relationship, in <<mocks-to-maps>>.
