[[actions-to-calculations]]
== Actions to Calculations

In his excellent book https://www.manning.com/books/grokking-simplicity[Grokking Simplicity], Eric Normand develops the idea that we can categorise our code into data, calculations, and actions.

In this chapter we'll look at why we might prefer calculations to actions.
<<code-to-data>> examines why data may be a better default than either.

=== Calculations

_Calculations_ are mappings from input values to output values: they are functions.
We specify their working in code (or some other formal notation).
We call them calculations, rather than functions, because many programming languages refer to any named procedure as a function; but to be a calculation, a function must always return the same value given the same input.
You may also see them referred to as _pure_ functions, code with no side-effects.
What is a side-effect? - we'll get on to them in the next section.

This function:

[source,kotlin]
----
fun fullName(customer: Customer) = "${customer.givenName} ${customer.familyName}"
----

is a calculation, as it will always return the same value when supplied the same `Customer`.
This is true only if `Customer` is immutable.footnote:[or at least `givenName` and `secondName` are immutable]
To keep things simple, we'll say that calculations can only have value (as defined in <<beans-to-values>>) parameters.

Methods, and the disguised methods that are member-properties, can also be calculations:

[source,kotlin]
----
data class Customer(
    val givenName: String,
    val familyName: String
) {
    fun upperCaseGivenName() = givenName.toUpperCase()

    val fullName get() = "$givenName $familyName"
}
----

To see when they are, we consider any data accessed via `this` to be an input to the function, so both methods are calculations because `givenName` and `familyName` are both values.

An extension function or property:

[source,kotlin]
----
fun Customer.fullName() = "$givenName $familyName"

val Customer.fullName get() = "$givenName $familyName"
----

can also be a calculation if the data it depends on is a value.

.Computed Property or Function?
****
You may have wondered when to define a computed property and when to have a function that returns a value.
Computed properties are really confusing if they can return different values at different types, at least when defined on values types.
And you'll discover that we consider that most of our types should be value types.
So a good rule of thumb is only to use computed properties when they are calculations, and functions for any results that depend on side effects or mutable data.
****

=== Actions

Code that does not define a value, or specify a pure calculation, is an _action_.
Actions depend on when and/or how many times they are run.
This will happen if they change something in their environment, or their environment affects their result.
In software we call these _side-effects_, which isn't a very good name, because unlike drugs, they are often exactly the thing that we want to happen.
Maybe _outside-effect_ would be a better name, to emphasise that they are external to a procedure's parameters, local variables and return value.

In our `Customers` service:

[source,kotlin]
----
class Customers {
    fun save(data: CustomerData) {
        ...
    }
    fun find(id: String): Customer? {
        ...
    }
}
----

Both `save` and `find` are actions, as find's result depends on whether it is run before or after a customer with that id has been saved.

[source,kotlin]
----
fun email(itinerary: Itinerary) {
    ...
}
----

is an action, because if we run it twice the customer will get two emails, which is different from if we run it once, which is different from if we don't run it at all.
Functions returning `void` or `Unit` are a dead giveaway for actions, because if they do anything they have to do it by side effect.

Functions that have no parameters (so this doesn't include methods or extension functions which can have implicit parameters accessed via `this`) must also either be returning a constant, or be reading from some other source and so be categorised as actions.
So we can deduce that the top-level function:

[source,kotlin]
----
fun requestRate(): Double {
    ...
}
----

is probably an action, reading from some global mutable state, whereas:

[source,kotlin]
----
class Metrics(
   ...
) {

    fun requestRate(): Double {
        ...
    }
}
----

is probably a calculation with an explicit parameter that is a property of `Metrics`.footnote:[provided `Metrics` is immutable.]
We say probably, because in languages that allow IO or mutating data from any code (like Java or Kotlin), there is no way to be sure if a function represents a value, calculation or action short of examining it.
We'll return to that problem soon.

== Why Should We Care?

We should obviously pay special attention to some actions in our software.
Sending the same email to every user twice is a bug, as is not sending it at all.
We care exactly how many times it is sent.
We may even care that it is sent at exactly 8:07am, so that our offer for a free first-class upgrade is at the top of our customer's inbox when they read their email over breakfast.

Other seemingly innocuous actions may be more nocuous than we think.
Changing the order of read and write actions causes concurrency bugs.
Error handling is much more complicated if the second of two sequential actions fails after the first succeeded.
Fundamentally, actions prevent us having free-reign to refactor in ways which change when or whether they are invoked.

Calculations on the other hand can be invoked at any time, with no consequences except a waste of time and energy.
If we are refactoring code and find that we don't need the result of a calculation, we can safely not invoke it.
If it is an expensive calculation, we can safely cache its result; if it is not expensive, we can safely recalculate it on demand if that simplifies things.
It is this feeling of safety that puts the smug smile on the faces of functional programmers.
We'll, that and knowing that a monad is just a monoid in the category of endofunctors.

.Procedural Code
****
Nat and Duncan are both old enough to have learned to program in Sinclair BASIC. This dialect had no local variables, no immutable data, and no concept of defining a function with parameters that could return values.
It requires real discipline to program in such a system, because practically every line of code is an action, and hence potentially affects the functioning of every other statement.

This is in fact very close to the way that our computers actually work, with mutable values held in registers and global memory, manipulated by machine-code actions.
The evolution of programming languages has been a process of restricting the ultimate flexibility of this model, in order that humans can better reason with the code that they create.
****

== Why Prefer Calculations?

Ultimately our software needs to have an effect in the world, so we really need actions.
But at the same time calculations are so much easier to work with.
There is no overlap though, code can't be an action and a calculation.
If we take some code that defines a calculation and have it invoke an action, then it becomes an action,
because it will now depend on when or whether it is called.footnote:[Technically it _could_ read from global state and discard the result and stay a calculation.]
We can think of calculations as the purer code, where code inherits the most tainted level of all of its dependencies.
We see the same thing with susceptibility to errors <<exceptions-to-errors>> and partial functions <<partial-to-total-functions>>.
As with these other taints, if we value purity (which in all these cases brings ease of reasoning and refactoring), we must strive to pull the boundary between impure and pure code to the outer layers of our system - those closest to the entry points.
If we succeed, then a significant proportion of our code can be calculations, and hence easily tested, reasoned-with, and refactored.

If we don't succeed in keeping actions at the top of our call-stack, we can fix things with refactoring.

=== Migrating Actions to Calculations

Let's have a look at recognising and refactoring actions in existing code.

==== Existing Code

There is an HTTP endpoint in Travelator that allows the client app to fetch information about the customers current trip.

// begin-insert: tags/effects.0:src/main/java/travelator/handlers/CurrentTripsHandler.java
[source,java]
----
public class CurrentTripsHandler {

    private final ITrackTrips tracking;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public CurrentTripsHandler(ITrackTrips tracking) {
        this.tracking = tracking;
    }

    public Response handle(Request request) {
        try {
            var customerId = request.getQueryParam("customerId").stream()
                .findFirst();
            if (customerId.isEmpty())
                return new Response(HTTP_BAD_REQUEST);
            var currentTrip = tracking.currentTripFor(customerId.get());
            return currentTrip.isPresent() ?
                new Response(HTTP_OK, objectMapper.writeValueAsString(currentTrip)) :
                new Response(HTTP_NOT_FOUND);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert

Actions are code that is sensitive to time, so words like _current_ are a dead give-away.
Our handler is an action, and that's OK, things on the edge of our systems often are.

The handler delegates to some business logic, implemented in `Tracking`.

// begin-insert: tags/effects.0:src/main/java/travelator/Tracking.java
[source,java]
----
class Tracking implements ITrackTrips {

    private final Trips trips;

    public Tracking(Trips trips) {
        this.trips = trips;
    }

    @Override
    public Optional<Trip> currentTripFor(String customerId) {
        var candidates = trips.currentTripsFor(customerId).stream()
            .filter((trip) -> trip.getBookingStatus() == BOOKED)
            .collect(toList());
        if (candidates.size() == 1)
            return Optional.of(candidates.get(0));
        else if (candidates.size() == 0)
            return Optional.empty();
        else
            throw new IllegalStateException(
                "Unexpectedly more than one current trip for " + customerId
            );
    }
}
----
// end-insert

Using the _current_ rule `Tracking.currentTripFor` is evidently an action too, as is `Trips.currentTripsFor`.
Here is its implementation in `InMemoryTrips`, which is used for testing in place of a version implemented with database queries.

// begin-insert: tags/effects.0:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
public class InMemoryTrips implements Trips {

    ...
    @Override
    public Set<Trip> currentTripsFor(String customerId) {
        return tripsFor(customerId).stream()
            .filter(trip -> trip.isPlannedToBeActiveAt(clock.instant()))
            .collect(toSet());
    }
}
----
// end-insert

The thunking from `Set<Trip>` to `Optional<Trip>` seems to be because there is some business rule around only one booked active trip at any time that is not enforced in the persistence layer.

Until we got here, we have been relying on our knowledge of the meanings of words to establish that Java methods represent actions rather than calculations.
Here finally we find a smoking gun.
Can you spot it?

Yes - `clock.instant()`.
That definitely depends on when we call it.
(If you found another action, well done, but keep it to yourself for now, we'll come back to it.)

Even if we were to not proceed with the rest of this refactoring, there is one change that we should make now.
Once you start to differentiate actions from calculations, it makes sense not to throw a random action into an otherwise pure calculation.
We have discussed values, calculations and actions as applying to named blocks of code, but they also apply at the expression level.
Let's pull the action out so that the remainder of the expression is pure.

// begin-insert: tags/effects.1:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
@Override
public Set<Trip> currentTripsFor(String customerId) {
    var now = clock.instant();
    return tripsFor(customerId).stream()
        .filter(trip -> trip.isPlannedToBeActiveAt(now))
        .collect(toSet());
}
----
// end-insert

That one simple act has allowed us to see that we were previously comparing every trip against a slightly different time!
Was that a problem?
Probably not here, but you've probably worked on systems where it would be.
Duncan for one has recently finished diagnosing an issue where half of a transaction could be accounted for in one day, and the other half in the next.

As well as making it harder to refactor our code, actions make it harder to test too.
Let's see how that is manifested.

// begin-insert: tags/effects.0:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
public class TrackingTests {

    final StoppedClock clock = new StoppedClock();

    final InMemoryTrips trips = new InMemoryTrips(clock);
    final Tracking tracking = new Tracking(trips);

    @Test
    public void returns_empty_when_no_trip_planned_to_happen_now() {
        clock.now = anInstant();
        assertEquals(Optional.empty(), tracking.currentTripFor("aCustomer"));
    }

    @Test
    public void returns_single_active_booked_trip() {
        var diwaliTrip = givenATrip("cust1", "Diwali", "2020-11-13", "2020-11-15", BOOKED);
        givenATrip("cust1", "Christmas", "2020-12-24", "2020-11-26", BOOKED);

        clock.now = diwaliTrip.getPlannedStartTime().toInstant();
        assertEquals(Optional.of(diwaliTrip), tracking.currentTripFor("cust1"));
    }

    ...
}
----
// end-insert

In order to give predictable results we have had to use a fake clock, injected into `InMemoryTrips`.
Having said that `clock.instant()` definitely depends on when we call it, in our tests it doesn't (at least not in the same way).
The alternative would been to have set up trips relative to the time that the tests are being run - you can do this, but things get ugly quickly.

.2015 was the End of Time
****
Duncan and Nat returned to work after Christmas holidays at the beginning of 2015 to find a slew of previously-passing unit tests now failing.
It turns out that 2015-01-01T00:00:00 had been used as a constant for a time that would always be after `now()`.
When that time was in the past, all the tests that relied on this behaviour began failing.

The solution was the refactoring that we are presenting here.
****

Is having to inject a clock https://dhh.dk/2014/test-induced-design-damage.html[Test-Induced Design Damage]?
In some ways it is.
Dependency injection, and in particular mocks, have allowed us to solve testing problems that would otherwise have forced a rethink that might lead to a better design.

==== A Better Desigh

What would a better design look like here?

In order to make this less time-dependant, we can simply supply the time as an argument to the method.
Whilst this forces the caller to know the time, that isn't generally a problem.
In fact this is a special case of the way that we refactor to avoid dependencies on other global variables - instead of calling out to read, pass the value into the function.

Let's start the refactor by adding an (as yet unused) `Instant` parameter to the `Trips.currentTripsFor(customerId)` method.
Before this was

// begin-insert: tags/effects.0:src/main/java/travelator/Trips.java#foo
[source,java]
----
public interface Trips {
    ...
    Set<Trip> currentTripsFor(String customerId);
}
----
// end-insert

We use IntelliJ's _Change Signature_ refactoring to add the parameter, calling it `at`, and defaulting it to `Instant.now()` on the assumption that shouldn't break any code.
Running the tests shows that we are right.

`Trips` now looks like this

// begin-insert: tags/effects.2:src/main/java/travelator/Trips.java#foo
[source,java]
----
public interface Trips {
    ...
    Set<Trip> currentTripsFor(String customerId, Instant at);
}
----
// end-insert

and here is a call

// begin-insert: tags/effects.2:src/main/java/travelator/Tracking.java#foo
[source,java]
----
class Tracking implements ITrackTrips {
    ...

    @Override
    public Optional<Trip> currentTripFor(String customerId) {
        var candidates = trips.currentTripsFor(customerId, Instant.now()) // <1>
            .stream()
            .filter((trip) -> trip.getBookingStatus() == BOOKED)
            .collect(toList());
        if (candidates.size() == 1)
            return Optional.of(candidates.get(0));
        else if (candidates.size() == 0)
            return Optional.empty();
        else
            throw new IllegalStateException(
                "Unexpectedly more than one current trip for " + customerId
            );
    }
}
----
// end-insert
<1> New parameter

Note that we can only pull this trick because `Instant.now()`, while an action, has no side effects that will affect any other part of our program.

That `now()` is not really helping us in `Tracking`, so lets pull it out as a parameter, supplied by the caller again, in this case `CurrentTripsHandler`.

// begin-insert: tags/effects.3:src/main/java/travelator/Tracking.java#foo
[source,java]
----
class Tracking implements ITrackTrips {
    ...

    @Override
    public Optional<Trip> currentTripFor(String customerId, Instant at) { // <1>
        var candidates = trips.currentTripsFor(customerId, at)
            .stream()
            .filter((trip) -> trip.getBookingStatus() == BOOKED)
            .collect(toList());
        if (candidates.size() == 1)
            return Optional.of(candidates.get(0));
        else if (candidates.size() == 0)
            return Optional.empty();
        else
            throw new IllegalStateException(
                "Unexpectedly more than one current trip for " + customerId
            );
    }
}
----
// end-insert
<1> Now a parameter

// begin-insert: tags/effects.3:src/main/java/travelator/handlers/CurrentTripsHandler.java#foo
[source,java]
----
public class CurrentTripsHandler {
    ...
    public Response handle(Request request) {
        try {
            var customerId = request.getQueryParam("customerId").stream()
                .findFirst();
            if (customerId.isEmpty())
                return new Response(HTTP_BAD_REQUEST);
            var currentTrip = tracking.currentTripFor(customerId.get(), Instant.now()); // <1>
            return currentTrip.isPresent() ?
                new Response(HTTP_OK, objectMapper.writeValueAsString(currentTrip)) :
                new Response(HTTP_NOT_FOUND);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert
<1> Supplying the time.

At this point we still haven't changed the behaviour of our code, but neither are we using the time now passed down from our handler.
Let's do that in `InMemoryTrips`, where we started.
We did have

// begin-insert: tags/effects.3:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
public class InMemoryTrips implements Trips {

    ...
    @Override
    public Set<Trip> currentTripsFor(String customerId, Instant at) {
        var now = clock.instant();
        return tripsFor(customerId).stream()
            .filter(trip -> trip.isPlannedToBeActiveAt(now))
            .collect(toSet());
    }
}
----
// end-insert

and now
// begin-insert: tags/effects.4:src/test/java/travelator/InMemoryTrips.java#foo
[source,java]
----
public class InMemoryTrips implements Trips {

    ...
    @Override
    public Set<Trip> currentTripsFor(String customerId, Instant at) {
        return tripsFor(customerId).stream()
            .filter(trip -> trip.isPlannedToBeActiveAt(at))
            .collect(toSet());
    }
}
----
// end-insert

Now that we aren't asking the clock for the time the tests that use `InMemoryTrips` will fail, because the method is now using the value of the parameter, and the tests are not supplying the right value.

// begin-insert: tags/effects.3:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
public class TrackingTests {

    final StoppedClock clock = new StoppedClock();

    final InMemoryTrips trips = new InMemoryTrips(clock);
    final Tracking tracking = new Tracking(trips);

    @Test
    public void returns_empty_when_no_trip_planned_to_happen_now() {
        clock.now = anInstant();
        assertEquals(
            Optional.empty(),
            tracking.currentTripFor("cust1", Instant.now()) // <1>
        );
    }

    @Test
    public void returns_single_active_booked_trip() {
        var diwaliTrip = givenATrip("cust1", "Diwali", "2020-11-13", "2020-11-15", BOOKED);
        givenATrip("cust1", "Christmas", "2020-12-24", "2020-11-26", BOOKED);

        clock.now = diwaliTrip.getPlannedStartTime().toInstant();
        assertEquals(
            Optional.of(diwaliTrip),
            tracking.currentTripFor("cust1", Instant.now()) // <1>
        );
    }

    ...
}
----
// end-insert
<1> These need to be the value we were setting into the `StoppedClock`.

A cunning refactor (kudos to Jordan Stewart) is to replace all the `Instant.now()` calls with `clock.now`

// begin-insert: tags/effects.5:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
@Test
public void returns_empty_when_no_trip_planned_to_happen_now() {
    clock.now = anInstant();
    assertEquals(
        Optional.empty(),
        tracking.currentTripFor("cust1", clock.now)
    );
}

@Test
public void returns_single_active_booked_trip() {
    var diwaliTrip = givenATrip("cust1", "Diwali", "2020-11-13", "2020-11-15", BOOKED);
    givenATrip("cust1", "Christmas", "2020-12-24", "2020-11-26", BOOKED);

    clock.now = diwaliTrip.getPlannedStartTime().toInstant();
    assertEquals(
        Optional.of(diwaliTrip),
        tracking.currentTripFor("cust1", clock.now)
    );
}
----
// end-insert

This gets our tests to pass, because we are now passing the correct time as the argument, albeit via setting and immediately reading a field in the `StoppedClock`.
To fix that, we can replace `clock.now =` with `var clockNow =` and then `clock.now` with `clockNow`.
This cleverness disintermediates the clock.

// begin-insert: tags/effects.6:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
@Test
public void returns_empty_when_no_trip_planned_to_happen_now() {
    var clockNow = anInstant();
    assertEquals(
        Optional.empty(),
        tracking.currentTripFor("cust1", clockNow)
    );
}

@Test
public void returns_single_active_booked_trip() {
    var diwaliTrip = givenATrip("cust1", "Diwali", "2020-11-13", "2020-11-15", BOOKED);
    givenATrip("cust1", "Christmas", "2020-12-24", "2020-11-26", BOOKED);

    var clockNow = diwaliTrip.getPlannedStartTime().toInstant();
    assertEquals(
        Optional.of(diwaliTrip),
        tracking.currentTripFor("cust1", clockNow)
    );
}
----
// end-insert

Now we have simply to inline all the uses of `clockNow` to have a nice functional expression of the tests.
Taking the opportunity to remove the now vestigial `clock` from the tests and `InMemoryTrips` we have

// begin-insert: tags/effects.7:src/test/java/travelator/TrackingTests.java#foo
[source,java]
----
public class TrackingTests {

    final InMemoryTrips trips = new InMemoryTrips();
    final Tracking tracking = new Tracking(trips);

    @Test
    public void returns_empty_when_no_trip_planned_to_happen_now() {
        assertEquals(
            Optional.empty(),
            tracking.currentTripFor("cust1", anInstant())
        );
    }

    @Test
    public void returns_single_active_booked_trip() {
        var diwaliTrip = givenATrip("cust1", "Diwali", "2020-11-13", "2020-11-15", BOOKED);
        givenATrip("cust1", "Christmas", "2020-12-24", "2020-11-26", BOOKED);

        assertEquals(
            Optional.of(diwaliTrip),
            tracking.currentTripFor("cust1", diwaliTrip.getPlannedStartTime().toInstant())
        );
    }

    ...
}
----
// end-insert

==== End Game

We're nearly almost done now (refactoring is never completely done).
Now that neither of our `currentTripFor` methods fetch the time, leaving that to the handler,
tests for the handler may well require us to control _now_.
So we'll probably inject the clock into `CurrentTripHandler` rather than call the raw `Instant.now()`.
Oh, and we haven't converted the code to Kotlin!

This last observation is quite significant.
This way of thinking about values, calculations and actions is not exclusive to Kotlin.
It is certainly possible to make the distinction in any language, and the grain of Java is becoming more functional with time.
We find though that Kotlin's more natural support for immutable data and other functional constructs means that the costs of making the distinction are lower, and so the cost/benefit ratio looks more favourable.
It's also worth observing that a lot of the refactoring steps taken in this chapter (and others) are safe because we are moving around the invocation of calculations and not actions.

Before we finish this chapter, what about the other action we hinted at?
Here is the previous implementation of `Trips`, now converted to Kotlin.

// begin-insert: tags/effects.8:src/test/java/travelator/InMemoryTrips.kt
[source,kotlin]
----
class InMemoryTrips : Trips {
    private val trips: MutableMap<String, MutableSet<Trip>> = mutableMapOf()

    fun addTrip(trip: Trip) {
        val existingTrips = trips.getOrDefault(trip.customerId, mutableSetOf())
        existingTrips.add(trip)
        trips[trip.customerId] = existingTrips
    }

    override fun tripsFor(customerId: String) =
        trips.getOrDefault(customerId, emptySet<Trip>())

    override fun currentTripsFor(customerId: String, at: Instant): Set<Trip> =
        tripsFor(customerId)
            .filter { it.isPlannedToBeActiveAt(at) }
            .toSet()
}
----
// end-insert

That `MutableMap` of ``MutableSet``s is a sign that something can change over time - in this case if we add a trip for a customer the result of `tripsFor` may change - it is an action not a calculation.
If `tripsFor` is an action, then anything that calls it is an action, including our `currentTripsFor`.
The same will obviously be true of the production version of `Trips` that reads and writes to the database.
After all this work, we haven't actually promoted our action to a calculation after all!

Should we be downhearted⸮ - probably not.
Actions are graduated, they can be more or less susceptible to time.
In this case, unless other code _in this interaction_ is also going to fetch the trips for a customer and find an inconsistency, we can treat `Trips` as effectively immutable, and so `tripsFor`, and by extension `currentTripsFor`, are effectively calculations.
In this respect our `InMemoryTrips` is less safe than our database implementation, because if accessed on multiple threads it can mutate the collection returned by `tripsFor`, leading to potential `ConcurrentModificationExceptions` in the `filter` implementation.
Categorising our code into values, calculations and actions has helped us see these issues, and given us a framework for deciding if they are important in context.

Lastly, it is worth noting that one place in which Kotlin makes this categorisation easier is in its default use of immutable data.
When you see `List` in Java you have to find the places in which it is created or referenced in order to establish its mutability, and hence the likelihood that code accessing it can be an action.
In Kotlin when you see `MutableList` you can infer an action, although as we have seen with `InMemoryTrips`, exposing a mutable collection with a read-only alias can lead to actions pretending to be calculations.

=== Conclusions

=== See Also

Categorising code into data, calculations and actions is a formalism introduced by Eric Normand in his book https://www.manning.com/books/grokking-simplicity[Grokking Simplicity].