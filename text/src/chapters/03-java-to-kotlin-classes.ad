[[java-to-kotlin-classes]]
== Java To Kotlin Classes

The class is the basic unit of code organisation in Java.
How do we convert our Java classes to Kotlin, and what differences will we see when we have?

=== Converting Java Classes to Kotlin

Many chapters in this book will start with some history or philosophy (if you're very lucky both), but here we're just going to launch straight into converting a simple class from Java to Kotlin.

Travelator has an `EmailAddress` class.
This is a value type that holds the two parts of an RFC 2822 email address.

// begin-insert: tags/java-to-kotlin-classes.0:src/main/java/travelator/EmailAddress.java
[source,java]
----
public class EmailAddress {
    private final String localPart; // <1>
    private final String domain;

    public EmailAddress(String localPart, String domain) { // <2>
        this.localPart = localPart;
        this.domain = domain;
    }

    public EmailAddress(String value) { // <3>
        this(
            value.substring(0, value.indexOf("@")),
            value.substring(value.indexOf("@") + 1)
        );
    }

    public String getLocalPart() { // <4>
        return localPart;
    }

    public String getDomain() { // <4>
        return domain;
    }

    @Override
    public boolean equals(Object o) { // <5>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EmailAddress that = (EmailAddress) o;
        return localPart.equals(that.localPart) &&
            domain.equals(that.domain);
    }

    @Override
    public int hashCode() { // <5>
        return Objects.hash(localPart, domain);
    }

    @Override
    public String toString() { // <6>
        return localPart + "@" + domain;
    }
}
----
// end-insert

This class is very simple -- it does nothing more than wrap a single string and provides no operations of its own.
Even so, it has a lot of code:

<1> Values are immutable, so the class declares its fields as final.
<2> It must define a constructor to initialise the fields.
<3> There is a secondary constructor that calls the primary constructor.
<4> The accessor methods of its property follows the Java Bean naming conventions.
<5> The class implements the `equals` and `hashCode` methods to ensure that two `EmailAddress` values with equal fields compare as equal.
<6> `toString` returns the canonical form.

Your authors come from the school of Java that assumes that everything we pass, store or return is not null unless explicitly indicated otherwise (<<optional-to-nullable>>).
You can't _see_ that, but it's why there are no `@Nullable` annotations or null checks of parameters.
What you can see is the amount of boilerplate code required.
Happily our IDE generated it for us, but we have to remember to delete and regenerate those methods when we change the fields of the class to avoid confusing bugs.

IntelliJ has an action - "Convert Java file to Kotlin File" (at the time of writing).
When we invoke that, it offers to change other files if necessary to keep things consistent.
It's best to say yes, but as this can potentially modify files throughout the project, only when you have no uncommitted changes, so that it's easy to see what else has been changed.

In this case we find that IntelliJ hasn't changed any other files.
Our `EmailAddress.java` file has been replaced with `EmailAddress.kt` in the same directory:

// begin-insert: tags/java-to-kotlin-classes.2:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
class EmailAddress(
    val localPart: String, val domain: String
) {

    constructor(value: String) : this(
        value.substring(0, value.indexOf("@")),
        value.substring(value.indexOf("@") + 1)
    ) {
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as EmailAddress
        return localPart == that.localPart && domain == that.domain
    }

    override fun hashCode(): Int {
        return Objects.hash(localPart, domain)
    }

    override fun toString(): String {
        return "$localPart@$domain"
    }
}
----
// end-insert

The Kotlin class is noticeably more succinct because it declares its properties in the primary constructor.
Those declarations stand in for all this Java:

// begin-insert: tags/java-to-kotlin-classes.1:src/main/java/travelator/EmailAddress.java#replaced_by_primary_constructor
[source,java]
----
private final String localPart;
private final String domain;

public EmailAddress(String localPart, String domain) {
    this.localPart = localPart;
    this.domain = domain;
}

public String getLocalPart() {
    return localPart;
}

public String getDomain() {
    return domain;
}
----
// end-insert

The primary constructor syntax is convenient, but it does interfere with the "scannability" of the class.
Java classes that follow the standard coding conventions always define their elements in the same order: class name, superclass, interfaces, then within the class body, fields, constructors, and methods.
This makes it easy to skim-read the class and quickly locate the features you're interested in.

It's not quite so easy in Kotlin: a class definition is organised thus: class name, primary constructor (which can contain parameters and/or property definitions), superclass (which may also be the call to the superclass' constructor), interfaces, then within the class body, more properties, more constructors, methods, and companion objects (we'll come to those later).
Coming from Java, Nat and Duncan definitely found it harder to read classes at first, and although we got used to it eventually, we still find it hard at times to neatly format classes that have a primary constructor, a superclass, several interfaces, and properties that are defined outside the primary constructor.

One easy change is to lay out the constructor parameter list line by line.
With the cursor inside the parameter list, we can do that with Alt-Enter and "Put parameters on separate lines".

// begin-insert: tags/java-to-kotlin-classes.3:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
class EmailAddress(
    val localPart: String,
    val domain: String
) {
    constructor(value: String) : this(
        value.substring(0, value.indexOf("@")),
        value.substring(value.indexOf("@") + 1)
    )

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as EmailAddress
        return localPart == that.localPart && domain == that.domain
    }

    override fun hashCode(): Int {
        return Objects.hash(localPart, domain)
    }

    override fun toString(): String {
        return "$localPart@$domain"
    }
}
----
// end-insert

If you're new to Kotlin you may wonder what happened to the `getLocalPart()` and `getDomain()` accessor methods.
Declaring a `domain` property causes the compiler to generate a private `domain` field and a `getDomain()` method, so that Java code can still call it.
Here is a little throw-away code to support a marketing plan:

// begin-insert: tags/java-to-kotlin-classes.3:src/main/java/travelator/Marketing.java
[source,java]
----
public class Marketing {

    public static boolean isHotmailAddress(EmailAddress address) {
        return address.getDomain().equalsIgnoreCase("hotmail.com");
    }
}
----
// end-insert

Inversely, when the class was Java and had an explicit `getDomain()` method, Kotlin code could have called it as `address.domain`.
We'll discuss properties in more detail in <<methods-to-properties>>.

So far converting our class to Kotlin has saved us 10 or so lines of code, but we aren't done yet.
Value types like this are so useful, but so tedious to get right and keep right, that Kotlin supports them at a language level.
Mark the class with the `data` modifier, and the compiler will generate `equals`, `hashCode` and `toString` methods automatically (if they are not defined by the class).
That reduces the `EmailAddress` class to:

// begin-insert: tags/java-to-kotlin-classes.4:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {
    constructor(value: String) : this(
        value.substring(0, value.indexOf("@")),
        value.substring(value.indexOf("@") + 1)
    )

    override fun toString() = "$localPart@$domain" // <1>
}
----
// end-insert

<1>  We don't want the generated `toString()` method, so we define the one that we do want.

=== Conclusions

For simple cases like the `EmailAddress` shown here, it is quick and easy to convert Java to Kotlin.
The result is compatible with existing Java code.
If we also want value semantics, `data` classes allow us to remove even more boilerplate.
Because they are so quick and easy to create, and require no maintenance, we introduce new value classes far more frequently in Kotlin than in Java -
to declare application-specific "micro-types" that wrap primitive values, to hold intermediate results of a calculation pipeline, or to pivot data into temporary structures that make it easier to write application logic.

We look at more advantages of value types in <<beans-to-values>>.
<<static-methods-to-free-standing-functions>> examines how Kotlin represents static methods and data.
