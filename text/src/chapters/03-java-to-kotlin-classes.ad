[[java-to-kotlin-classes]]
== Java To Kotlin Classes

The class is the basic unit of code organisation in Java.
How do we convert our Java classes to Kotlin, and what differences will we see when we have?

=== Converting a Java Class to Kotlin

In this book, we'll work together on the code in Travelator, our fictional trip-planning webapp.
Imagine that we have a feature to implement, but we want to take the opportunity to make our code a little better before we do.
You're pairing with one of Nat or Duncan (choose your favourite, just don't let Nat know).
The pair is the _we_ in our refactoring discussions; not just your author, but also you as part of the team working on Travelator.
Welcome aboard!

.Source Code
****
The source code we show here is available in a GitHub repo at TODO.
A single snapshot of the code isn't helpful though, because this book is about refactoring.
The important details are the changes, both between single commits and over longer intervals.
In order to follow along in Git, you need to check out a repository and then step over commits.

// TODO create placeholder website and put URL here
If you want to do that, we provide instructions on this book's website at TODO.
But we have tried to show everything you need to make sense of the code here in print.
It helps to imagine that the last code sample shown is whatâ€™s active in your editor as we talk about the changes we are about to make.
****

Let's jump into the deep end of the codebase and convert some of our existing Java to Kotlin, starting with `EmailAddress`.
This is a value type that holds the two parts of, you guessed it, an email address:

// begin-insert: tags/java-to-kotlin-classes.0:src/main/java/travelator/EmailAddress.java
[source,java]
----
public class EmailAddress {
    private final String localPart; // <1>
    private final String domain;

    public static EmailAddress parse(String value) { // <2>
        var atIndex = value.lastIndexOf('@');
        if (atIndex < 1 || atIndex == value.length() - 1)
            throw new IllegalArgumentException(
                "EmailAddress must be two parts separated by @"
            );
        return new EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        );
    }

    public EmailAddress(String localPart, String domain) { // <3>
        this.localPart = localPart;
        this.domain = domain;
    }

    public String getLocalPart() { // <4>
        return localPart;
    }

    public String getDomain() { // <4>
        return domain;
    }

    @Override
    public boolean equals(Object o) { // <5>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EmailAddress that = (EmailAddress) o;
        return localPart.equals(that.localPart) &&
            domain.equals(that.domain);
    }

    @Override
    public int hashCode() { // <5>
        return Objects.hash(localPart, domain);
    }

    @Override
    public String toString() { // <6>
        return localPart + "@" + domain;
    }
}
----
// end-insert

This class is very simple -- it does nothing more than wrap two strings and provides no operations of its own.
Even so, it has a lot of code:

<1> Values are immutable, so the class declares its fields as final.
<2> There is a static factory method to `parse` an `EmailAddress` from a string - this calls the primary constructor.
<3> The fields are initialised in a constructor.
<4> The accessor methods of its properties follow the JavaBean naming conventions.
<5> The class implements the `equals` and `hashCode` methods to ensure that two `EmailAddress` values with equal fields compare as equal.
<6> `toString` returns the canonical form.

Your authors come from the school of Java that assumes that everything we pass, store or return is not null unless explicitly indicated otherwise.
You can't see that convention, because it results in an absence of `@Nullable` annotations or null checks of parameters (<<optional-to-nullable>> discusses nullability).
What you _can_ see is the amount of boilerplate code required to express a value composed of two other values.
Happily our IDE generated the `equals` and `hashCode` methods for us, but we have to remember to delete and regenerate those methods if we change the fields of the class to avoid confusing bugs.

So much for the Java; we're here for the Kotlin.
How do we convert?
Helpfully IntelliJ has an action called "Convert Java file to Kotlin File".
When we invoke it, IntelliJ offers to change other files if necessary to keep things consistent.
As the conversion can potentially modify files throughout the project, its best to say yes.

TIP: Make sure you have no uncommitted changes before converting Java source to Kotlin so that you can easily see the impact of the conversion on the rest of your codebase, and revert the conversion if it does something you didn't expect.

In this case IntelliJ, doesn't have to change any other files.
It has though replaced our `EmailAddress.java` file with `EmailAddress.kt` in the same directory:

// begin-insert: tags/java-to-kotlin-classes.2:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
class EmailAddress(val localPart: String, val domain: String) {
    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as EmailAddress
        return localPart == that.localPart && domain == that.domain
    }

    override fun hashCode(): Int {
        return Objects.hash(localPart, domain)
    }

    override fun toString(): String {
        return "$localPart@$domain"
    }

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

The Kotlin class is noticeably more succinct because it declares its properties in the primary constructor - the parameters after the class name.
Parameters marked `val` are considered properties, and so stand in for all this Java:

// begin-insert: tags/java-to-kotlin-classes.1:src/main/java/travelator/EmailAddress.java#replaced_by_primary_constructor
[source,java]
----
private final String localPart;
private final String domain;

public EmailAddress(String localPart, String domain) {
    this.localPart = localPart;
    this.domain = domain;
}

public String getLocalPart() {
    return localPart;
}

public String getDomain() {
    return domain;
}
----
// end-insert

The primary constructor syntax is convenient, but it does interfere with the "scanability" of the class.
Java classes that follow the standard coding conventions always define their elements in the same order: class name, superclass, interfaces, then, within the class body, fields, constructors, and methods.
This makes it easy to skim-read the class and quickly locate the features you're interested in.

It's not quite so easy to find the parts of a Kotlin class.
A Kotlin class definition has a header part with the class name, primary constructor (which can contain parameters and/or property definitions), superclass (which may also be the call to the superclass' constructor) and interfaces
Then within the class body, there are more properties, more constructors, methods, and companion objects.

Coming from Java, Nat and Duncan definitely found it harder to read classes at first, and although we got used to it eventually, we still find it hard at times to format classes for maximum readability, especially if there is a lot going on in the header part.
One easy fix is to lay out the constructor parameter list line by line.
With the cursor inside the parameter list, we can do that with Alt-Enter and "Put parameters on separate lines".
Sometimes a blank line after the header part helps too.

// begin-insert: tags/java-to-kotlin-classes.3:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as EmailAddress
        return localPart == that.localPart && domain == that.domain
    }

    override fun hashCode(): Int {
        return Objects.hash(localPart, domain)
    }

    override fun toString(): String {
        return "$localPart@$domain"
    }

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

One place where Kotlin is noticeably less succinct than Java is that it uses companion objects to host static state and methods - in this case `parse()`.
In Kotlin, we often prefer top-level state and functions to these class-scoped members.
<<static-methods-to-top-level-functions>> discusses the pros and cons.

We currently have Java code that uses the static method, for example the tests:

// begin-insert: tags/java-to-kotlin-classes.0:src/test/java/travelator/EmailAddressTests.java#foo
[source,java]
----
public class EmailAddressTests {

    @Test
    public void parsing() {
        assertEquals(
            new EmailAddress("fred", "example.com"),
            EmailAddress.parse("fred@example.com")
        );
    }

    @Test
    public void parsingFailures() {
        assertThrows(
            IllegalArgumentException.class,
            () -> EmailAddress.parse("@")
        );
        ...
    }

    ...
}
----
// end-insert

The companion object, combined with the `@JVMStatic` annotation, means this didn't have to change when we converted the class to Kotlin, so we'll leave `parse` as it is for now.
We'll discuss how to refactor to top-level functions in <<static-methods-to-top-level-functions>>.

If you're new to Kotlin you may wonder what happened to the `getLocalPart()` and `getDomain()` accessor methods.
Declaring the `domain` property causes the compiler to generate a private `domain` field and a `getDomain()` method, so that Java code can still call it.
Here is a little throw-away code to support a marketing plan:

// begin-insert: tags/java-to-kotlin-classes.3:src/main/java/travelator/Marketing.java
[source,java]
----
public class Marketing {

    public static boolean isHotmailAddress(EmailAddress address) {
        return address.getDomain().equalsIgnoreCase("hotmail.com");
    }
}
----
// end-insert

You can see that Java is accessing the domain property through the `getDomain()` method.
Conversely, when the class was Java and had an explicit `getDomain()` method, Kotlin code could have called it as `address.domain`.
We'll discuss properties in more detail in <<methods-to-properties>>.

So far, converting our class to Kotlin has saved us 14 lines of code, but we aren't done yet.
Value types like this are so useful, but so tedious to get right and keep right, that Kotlin supports them at a language level.
If we mark the class with the `data` modifier the compiler generates any undefined `equals`, `hashCode` and `toString` methods for us.
That reduces the `EmailAddress` class to:

// begin-insert: tags/java-to-kotlin-classes.4:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString(): String { // <1>
        return "$localPart@$domain"
    }

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

<1>  We don't want the generated `toString()` method, so we define the one we do want.

Frankly, that `parse` method still rankles - it's taking up a disproportionate amount of space for the work it is doing.
We'll finally relieve this tension in <<multi-to-single-expression-functions>>.
For now though, we're done with converting our `EmailAddress` Java class to Kotlin.

=== The Limitations of Data Classes

A drawback of data classes is that they offer no encapsulation.
We saw how the compiler generates `equals`, `hashCode` and `toString` methods for data classes, but didn't mention that it also generates a `copy` method that creates a new copy of the value with different values for one or more of its properties.

For example, the following code creates a copy of an `EmailAddress` with a `localPart` of "postmaster" and the same domain:

----
val postmasterEmail = customerEmail.copy(localPart = "postmaster")
----

For many types this is very convenient.
However, when a class abstracts its internal representation or maintains invariants between its properties, that `copy` method allows client code direct access to the internal state of a value, which can break its invariants.

Let's look at an abstract data type in the Travelator application: the `Money` class:

// begin-insert: tags/value_types.4:src/main/java/travelator/money/Money.java#money
[source,java]
----
public class Money {
    private final BigDecimal amount;
    private final Currency currency;

    private Money(BigDecimal amount, Currency currency) { // <1>
        this.amount = amount;
        this.currency = currency;
    }

    public static Money of(BigDecimal amount, Currency currency) { // <1>
        return new Money(
            amount.setScale(currency.getDefaultFractionDigits()),
            currency);
    }

    // ... and convenience overloads

    public BigDecimal getAmount() { // <2>
        return amount;
    }

    public Currency getCurrency() { // <3>
        return currency;
    }

    @Override
    public boolean equals(Object o) { // <3>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amount.equals(money.amount) &&
            currency.equals(money.currency);
    }

    @Override
    public int hashCode() { // <3>
        return Objects.hash(amount, currency);
    }

    @Override
    public String toString() { // <4>
        return amount.toString() + " " + currency.getCurrencyCode();
    }

    public Money add(Money that) { // <5>
        if (!this.currency.equals(that.currency)) {
            throw new IllegalArgumentException(
                "cannot add Money values of different currencies");
        }

        return new Money(this.amount.add(that.amount), this.currency);
    }
}
----
// end-insert

<1> The constructor is private.
Other classes obtain `Money` values by calling the static `Money.of` method, which guarantees that the scale of the amount is consistent with the number of minor units of the currency.
Most currencies have 100 minor units (two digits), but some have fewer, and some more. For example, the Japanese Yen has no minor units, and the Jordanian Dinar is made up of one thousand fils.
+
// TODO - cut for space?
The `of` method follows a coding convention of <<modern-java-style,Modern Java>> that draws a distinction in the source between objects with identity, which are constructed by the new operator, and values, which are obtained from static methods.
This convention is followed by the Java time API (for example `LocalDate.of(2020,8,17)`) and recent additions to the collections API (for example, `List.of(1,2,3)` creates an immutable list)
+
The class provides some convenient overloads of the `of` method for String or int amounts.
<2> A `Money` value exposes its amount and currency properties using JavaBean conventions, even though it is not actually a JavaBean.
<3> The `equals` and `hashCode` methods implement value semantics.
<4> The `toString` method returns a representation of its properties that can be shown to the user, not just for debugging.
<5> `Money` provides operations for calculating with money values.
For example, you can add monetary values together.
The `add` method constructs new `Money` values by calling the constructor directly (rather than using `Money.of`), because the result of `BigDecimal.add` already has the correct scale, so we can avoid the overhead of setting the scale in `Money.of`.

// TODO cut for space?
[NOTE]
====
.BigDecimal.setScale does not set the scale!

The method `BigDecimal.setScale` is confusing.
Although named like a JavaBean setter, it does not actually mutate the BigDecimal object.
Like our `EmailAddress` and `Money` classes, `BigDecimal` is an immutable value type, so `setScale` returns a new `BigDecimal` value with the specified scale.

Sun added the BigDecimal class to the standard library in Java 1.1. This release also included the first version of the JavaBeans API. The hype around the Beans API popularised the JavaBeans coding conventions, and they were widely adopted, even for classes that, like `BigDecimal`, were not JavaBeans (see <<bean-java-style>>).
There were no Java conventions for value types.

Today, we avoid the "set" prefix for methods that do not mutate their receiver and instead use names that emphasise when the method returns a transformation of the receiver.
A common convention is to use the prefix "with" for transformations that affect a single property, which would make the code in our Money class read as:

[source,kotlin]
----
 amount.withScale(currency.getDefaultFractionDigits())
----

In Kotlin we can write extension functions to fix such historical accidents.
If we were writing a lot of code that calculated with BigDecimals, it might be worth doing so to improve the clarity of the code:

[source,kotlin]
----
inline fun BigDecimal.withScale(int scale, RoundingMode mode) =
    setScale(scale, mode)
----
====

Converting Money to Kotlin produces the following code:

// begin-insert: tags/value_types.5:src/main/java/travelator/money/Money.kt#money
[source,kotlin]
----
class Money
private constructor(
    val amount: BigDecimal,
    val currency: Currency
) {
    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val money = o as Money
        return amount == money.amount && currency == money.currency
    }

    override fun hashCode(): Int {
        return Objects.hash(amount, currency)
    }

    override fun toString(): String {
        return amount.toString() + " " + currency.currencyCode
    }

    fun add(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }

        return Money(amount.add(that.amount), currency)
    }

    companion object {
        @JvmStatic
        fun of(amount: BigDecimal, currency: Currency): Money {
            return Money(
                amount.setScale(currency.defaultFractionDigits),
                currency
            )
        }

        // ... and convenience overloads
    }
}
----
// end-insert

The Kotlin class still has a primary constructor, but that constructor is now marked private.
The syntax for this is a little clumsy: we've reformatted the code that the translator produced in an attempt to make it easier to scan.
Like `EmailAddress.parse`, the static `of` functions are now methods on a companion object annotated as `@JvmStatic`.
Overall, the code is not much more concise than the original Java.

Can we shrink it even further by making it a data class?

When we change `class` to `data class`, IntelliJ highlights the `private` keyword of the primary constructor with a warning:

----
Private data class constructor is exposed via the generated 'copy' method."
----

What's that all about?

There is a detail hiding in the implementation of `Money`.
The class maintains an invariant between its properties, guaranteeing that the scale of the amount field is equal to the default number of minor currency digits of the currency field.
The private constructor prevents code outside the `Money` class from creating values that violate the invariant.
The `Money.of(BigDecimal,Currency)` method ensures the invariant is true for new `Money` values.
The `add` method maintains the invariant because adding two `BigDecimal` values with the same scale produces a `BigDecimal` that also has the same scale, and it can therefore call the constructor directly.
The constructor, therefore, need only assign fields, safe in the knowledge that it is never called with parameters that violate the class invariant.

However, the `copy` method of a data class is always public and so _would_ allow client code to create `Money` values that violate the invariant.
Unlike `EmailAddress`, an abstract data type like the `Money` class cannot be implemented by a Kotlin data class.

WARNING: Don't define a value type as a data class if it must maintain invariants between its properties.

We can still make the class more concise and convenient with Kotlin features that we will encounter in later chapters.
So we'll leave the `Money` class for now and come back to it in <<functions-to-operators>> to give it a thorough make-over.

=== Conclusion

For most classes, it is quick and easy to convert Java to Kotlin.
The result is completely compatible with existing Java code.

If we want value semantics, `data` classes allow us to remove even more boilerplate for simple classes like `EmailAddress`.
Because data classes are so quick and easy to create, and require no maintenance, we use them to define new value types far more frequently in Kotlin than in Java:
to declare application-specific "micro-types" that wrap primitive values,
to hold intermediate results of a calculation pipeline,
or to pivot data into temporary structures that make it easier to write application logic.

If our value types must maintain invariants or encapsulate their representation, data classes are not suitable.
In that case we have to implement value semantics ourselves.

We left both `EmailAddress` and `Money` still looking rather "Java-y" ... "Java-ish"? ... "Java-esque"? ... whatever.
In the following chapters we will explore how to apply Kotlin idioms to make code more concise, more type safe, and easier to build code upon.
<<multi-to-single-expression-functions>> looks at how we can make calculation functions and methods, such the `toString` method of both classes or `equals` and `hashCode` of `Money`, more concise by refactoring them to single expression form.
In <<functions-to-operators>> we make the `Money` type more convenient to use in Kotlin by defining operators instead of methods.

Not all our Java classes are value types.
The prevalent Java coding style favours mutable objects.
In <<beans-to-values>>, we look at the advantages of using value types where Java would use mutable objects, and show how to refactor code from mutating objects to transforming values.

Many classes in Java code exist to hold static utility methods.
In Kotlin, functions and data are first class features.
They do not need to be declared as members of classes.
<<static-methods-to-top-level-functions>> explores how to convert Java classes of utility methods into top-level declarations.
