[[java-to-kotlin-classes]]
== Java To Kotlin Classes

The class is the basic unit of code organisation in Java.
How do we convert our Java classes to Kotlin, and what differences will we see when we have?

=== Converting Java Classes to Kotlin

Many chapters in this book will start with some history or philosophy (if you're very lucky both), but here we're just going to launch straight into converting a simple class from Java to Kotlin.

Travelator has an `EmailAddress` class.
This is a value type that holds the two parts of an RFC 2822 email address.

// begin-insert: tags/java-to-kotlin-classes.0:src/main/java/travelator/EmailAddress.java
[source,java]
----
public class EmailAddress {
    private final String localPart; // <1>
    private final String domain;

    public static EmailAddress parse(String value) { // <2>
        var atIndex = value.lastIndexOf('@');
        if (atIndex < 1 || atIndex == value.length() - 1)
            throw new IllegalArgumentException(
                "EmailAddress must be two parts separated by @"
            );
        return new EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        );
    }

    public EmailAddress(String localPart, String domain) { // <3>
        this.localPart = localPart;
        this.domain = domain;
    }

    public String getLocalPart() { // <4>
        return localPart;
    }

    public String getDomain() { // <4>
        return domain;
    }

    @Override
    public boolean equals(Object o) { // <5>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EmailAddress that = (EmailAddress) o;
        return localPart.equals(that.localPart) &&
            domain.equals(that.domain);
    }

    @Override
    public int hashCode() { // <5>
        return Objects.hash(localPart, domain);
    }

    @Override
    public String toString() { // <6>
        return localPart + "@" + domain;
    }
}
----
// end-insert

This class is very simple -- it does nothing more than wrap two strings and provides no operations of its own.
Even so, it has a lot of code:

<1> Values are immutable, so the class declares its fields as final.
<2> There is a static factory method to `parse` and `EmailAddress` from a string - this calls the primary constructor.
<3> The fields are initialised in a primary constructor.
<4> The accessor methods of its properties follow the Java Bean naming conventions.
<5> The class implements the `equals` and `hashCode` methods to ensure that two `EmailAddress` values with equal fields compare as equal.
<6> `toString` returns the canonical form.

Your authors come from the school of Java that assumes that everything we pass, store or return is not null unless explicitly indicated otherwise.
You can't _see_ that, but it's why there are no `@Nullable` annotations or null checks of parameters ((<<optional-to-nullable>> discusses nullability).
What you _can_ see is the amount of boilerplate code required to express a value composed of two other values.
Happily our IDE generated the `equals` and `hashCode` methods for us, but we have to remember to delete and regenerate those methods if we change the fields of the class to avoid confusing bugs.

So much for the Java; we're here for the Kotlin.
How do we convert?
Helpfully IntelliJ has an action - "Convert Java file to Kotlin File" (at the time of writing).
Let's invoke it.
IntelliJ now offers to change other files if necessary to keep things consistent.
As this can potentially modify files throughout the project, its best to say yes, but only when you have no uncommitted changes, so that it's easy to see what else has been changed.

In this case IntelliJ doesn't have to change any other files.
It has though replaced our `EmailAddress.java` file with `EmailAddress.kt` in the same directory:

// begin-insert: tags/java-to-kotlin-classes.2:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
class EmailAddress(val localPart: String, val domain: String) {
    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as EmailAddress
        return localPart == that.localPart && domain == that.domain
    }

    override fun hashCode(): Int {
        return Objects.hash(localPart, domain)
    }

    override fun toString(): String {
        return "$localPart@$domain"
    }

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

The Kotlin class is noticeably more succinct because it declares its properties in the primary constructor - the parameters after the class name.
Those marked `val` are considered properties, and so stand in for all this Java:

// begin-insert: tags/java-to-kotlin-classes.1:src/main/java/travelator/EmailAddress.java#replaced_by_primary_constructor
[source,java]
----
private final String localPart;
private final String domain;

public EmailAddress(String localPart, String domain) {
    this.localPart = localPart;
    this.domain = domain;
}

public String getLocalPart() {
    return localPart;
}

public String getDomain() {
    return domain;
}
----
// end-insert

The primary constructor syntax is convenient, but it does interfere with the "scanability" of the class.
Java classes that follow the standard coding conventions always define their elements in the same order: class name, superclass, interfaces, then within the class body, fields, constructors, and methods.
This makes it easy to skim-read the class and quickly locate the features you're interested in.

It's not quite so easy in Kotlin: a class definition is organised thus: class name, primary constructor (which can contain parameters and/or property definitions), superclass (which may also be the call to the superclass' constructor), interfaces, then within the class body, more properties, more constructors, methods, and companion objects.
Coming from Java, Nat and Duncan definitely found it harder to read classes at first, and although we got used to it eventually, we still find it hard at times to neatly format classes that have a primary constructor, a superclass, several interfaces, and properties that are defined outside the primary constructor.

One easy change is to lay out the constructor parameter list line by line.
With the cursor inside the parameter list, we can do that with Alt-Enter and "Put parameters on separate lines".
Sometimes a blank line after the header part helps too.

// begin-insert: tags/java-to-kotlin-classes.3:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as EmailAddress
        return localPart == that.localPart && domain == that.domain
    }

    override fun hashCode(): Int {
        return Objects.hash(localPart, domain)
    }

    override fun toString(): String {
        return "$localPart@$domain"
    }

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

One place where Kotlin is noticeably less succinct than Java is the use of companion objects to house static state and methods - in this case `parse()`.
Kotlin prefers top-level state and functions to these class-scoped members, although they are still compiled into classes, because all code in the JVM needs to belong to a class.
We currently have Java code that uses the static method, for example the tests:

// begin-insert: tags/java-to-kotlin-classes.0:src/test/java/travelator/EmailAddressTests.java#foo
[source,java]
----
public class EmailAddressTests {

    @Test
    public void parsing() {
        assertEquals(
            new EmailAddress("fred", "example.com"),
            EmailAddress.parse("fred@example.com")
        );
    }

    @Test
    public void parsingFailures() {
        assertThrows(
            IllegalArgumentException.class,
            () -> EmailAddress.parse("@")
        );
        assertThrows(
            IllegalArgumentException.class,
            () -> EmailAddress.parse("fred@")
        );
        ...
    }

    ...
}
----
// end-insert

The companion object combined with the `@JVMStatic` annotation, mean this didn't have to change when we converted to Kotlin, so we'll leave `parse` as it is for now.
We'll discuss how to refactor to top-level functions in <<static-methods-to-free-standing-functions>>.

If you're new to Kotlin you may wonder what happened to the `getLocalPart()` and `getDomain()` accessor methods.
Declaring the `domain` property causes the compiler to generate a private `domain` field and a `getDomain()` method, so that Java code can still call it.
Here is a little throw-away code to support a marketing plan:

// begin-insert: tags/java-to-kotlin-classes.3:src/main/java/travelator/Marketing.java
[source,java]
----
public class Marketing {

    public static boolean isHotmailAddress(EmailAddress address) {
        return address.getDomain().equalsIgnoreCase("hotmail.com");
    }
}
----
// end-insert

You can see that Java is accessing the domain property through the `getDomain()` method.
Inversely, when the class was Java and had an explicit `getDomain()` method, Kotlin code could have called it as `address.domain`.
We'll discuss properties in more detail in <<methods-to-properties>>.

So far converting our class to Kotlin has saved us 10 or so lines of code, but we aren't done yet.
Value types like this are so useful, but so tedious to get right and keep right, that Kotlin supports them at a language level.
Mark the class with the `data` modifier, and the compiler will generate `equals`, `hashCode` and `toString` methods automatically (if they are not defined by the class).
That reduces the `EmailAddress` class to:

// begin-insert: tags/java-to-kotlin-classes.4:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString(): String { // <1>
        return "$localPart@$domain"
    }

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
// end-insert

<1>  We don't want the generated `toString()` method, so we define the one we do want.

Frankly, that `parse` method still rankles - it's taking up a disproportionate amount of space for the work it is doing.
We'll have a crack at making it suitably short and sweet in <<multi-to-single-expression-functions>>.
For now though, we're done with seeing how to convert a Java class to Kotlin.

=== Conclusion

For simple cases like the `EmailAddress` shown here, it is quick and easy to convert Java to Kotlin.
The result is completely compatible with existing Java code.
If we also want value semantics, `data` classes allow us to remove even more boilerplate.

Because they are so quick and easy to create, and require no maintenance, we introduce new value classes far more frequently in Kotlin than in Java -
to declare application-specific "micro-types" that wrap primitive values, to hold intermediate results of a calculation pipeline, or to pivot data into temporary structures that make it easier to write application logic.

We look at more advantages of value types in <<beans-to-values>>.
<<static-methods-to-free-standing-functions>> examines how Kotlin represents static methods and data.
