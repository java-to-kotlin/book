[[bonus-refactoring]]
== Bonus Refactoring

In <<functions-to-extension-functions>>, we started with some Java code that produced a report for marketing.
In this chapter we'll continue to refactor the resulting Kotlin, bringing concepts from <<exceptions-to-errors>>, <<actions-to-calculations>> and <<code-to-data>> to bear on the problem.

=== Starting Point

When we left the code, we had introduced extension functions to the `HighValueCustomersReport`, giving us:

// begin-insert: tags/bonus.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#all
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

Here are the tests:

// begin-insert: tags/bonus.0:src/test/java/travelator/marketing/HighValueCustomersReportTests.java#all
[source,java]
----
class HighValueCustomersReportTests {

    @Test
    public void test() throws IOException {
        List<String> input = List.of(
            "ID\tFirstName\tLastName\tScore\tSpend",
            "1\tFred\tFlintstone\t11\t1000.00",
            "4\tBetty\tRubble\t10\t2000.00",
            "2\tBarney\tRubble\t0\t20.00",
            "3\tWilma\tFlintstone\t9\t0.00"
        );
        List<String> expected = List.of(
            "ID\tName\tSpend",
            "4\tRUBBLE, Betty\t2000.00",
            "1\tFLINTSTONE, Fred\t1000.00",
            "\tTOTAL\t3000.00"
        );
        check(input, expected);
    }

    ...
    private void check(
        List<String> inputLines,
        List<String> expectedLines
    ) throws IOException {
        var output = new StringWriter();
        HighValueCustomersReport.generate(
            new StringReader(String.join("\n", inputLines)),
            output
        );
        assertEquals(String.join("\n", expectedLines), output.toString());
    }
}
----
// end-insert

=== Listening to the Tests

We didn't really look at the tests in <<functions-to-extension-functions>>, but if we do now, what stands out in the light of our chapters about values, calculations and actions?

Look at that `check` function.
It isn't strictly a calculation, but we can see that it is _trying_ to allow us to express the assertions as a comparison of `List<String>` to `List<String>`.
It's having to work hard, because `generate` relies on the side effects of reading and writing from and to its parameters.
In other words, we have a function that works by mutating both of its parameters - it is an action (see <<actions>>.

If we stop for a moment and listen, we may hear the tests talking to us.
They are saying, "Look, that report generation is fundamentally a calculation. It converts a `List<String>` to a `List<String>`. We know it does, because that's what we are checking."

So the tests are telling us that the fundamental signature of `generate` is `generate(lines: List<String>): List<String>`.
In addition, we can see that the tests declare that they throw `IOException`, even though they actually use `StringReader` and `StringWriter` which should never fail.
Our IO is not at the edge of our system, but buried inside `generate`, which, frankly, really doesn't want to be concerned with it.
Making `generate` into a calculation rather than an action would solve this problem too.

Shall we refactor towards this goal?
You're right, that was a rhetorical question.

The refactoring that follows will be easier if the tests are in Kotlin.
IntelliJ is getting every-better at refactoring mixed code, but when we wrote this it wasn't quite good enough.

Here are the tests after conversion to Kotlin, and the application of some of the techniques in this book:

// begin-insert: tags/bonus.1:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#all
[source,kotlin]
----
class HighValueCustomersReportTests {

    @Test
    fun test() {
        check(
            inputLines = listOf(
                "ID\tFirstName\tLastName\tScore\tSpend",
                "1\tFred\tFlintstone\t11\t1000.00",
                "4\tBetty\tRubble\t10\t2000.00",
                "2\tBarney\tRubble\t0\t20.00",
                "3\tWilma\tFlintstone\t9\t0.00"
            ),
            expectedLines = listOf(
                "ID\tName\tSpend",
                "4\tRUBBLE, Betty\t2000.00",
                "1\tFLINTSTONE, Fred\t1000.00",
                "\tTOTAL\t3000.00"
            )
        )
    }

    ...

    private fun check(
        inputLines: List<String>,
        expectedLines: List<String>
    ) {
        val output = StringWriter().apply {
            generate(
                StringReader(inputLines.joinToString("\n")),
                this
            )
        }
        assertEquals(expectedLines.joinToString("\n"), output.toString())
    }
}
----
// end-insert

As the first stage in our refactor, let's try to wean `generate` off of its `reader` parameter.
The code is currently:

// begin-insert: tags/bonus.2:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

We can convert `generate` to read from a `List` by invoking "Introduce parameter" on the `reader.readLines()` expression.
We name the parameter `lines`.
As the expression is the only use of the existing `reader` parameter, IntelliJ removes `reader` for us:

// begin-insert: tags/bonus.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

The parameters to `generate` are now in the wrong order (output then input), but we'll let that go for now, as we want to remove `writer` as well.

The refactoring has also moved the `readLines()` out into the callers - here is the result in test:

// begin-insert: tags/bonus.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter().apply {
        val writer = StringReader(inputLines.joinToString("\n"))
        generate(
            this,
            writer.readLines()
        )
    }
    assertEquals(expectedLines.joinToString("\n"), output.toString())
}
----
// end-insert

This now shouts what the test was whispering all along.
We were having to create a `StringReader` (IntelliJ has very confusingly named it `writer` as part of the refactor) from a list of lines just in order to parse the lines back out in `generate`.
Now the steps are in the same place in the test we can elide them to remove the `Reader`:

// begin-insert: tags/bonus.5:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter().apply {
        generate(this, inputLines)
    }
    assertEquals(expectedLines.joinToString("\n"), output.toString())
}
----
// end-insert

We are now reading from a `List`.
Let's go back and look at how to return a `List` rather than modifying the `Writer`.
Here is the code:

// begin-insert: tags/bonus.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#writer
[source,kotlin]
----
writer.appendLine("ID\tName\tSpend")
for (customerData in valuableCustomers) {
    writer.appendLine(customerData.outputLine)
}
writer.append(valuableCustomers.summarised())
----
// end-insert

Instead of thinking imperatively about the ways that we want to mutate the writer, lets think in terms of the data that we want written and create that:

// begin-insert: tags/bonus.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#resultLines
[source,kotlin]
----
val resultLines = listOf("ID\tName\tSpend") +
    valuableCustomers.map(CustomerData::outputLine) +
    valuableCustomers.summarised()
----
// end-insert

Then we write it in one lump to `writer`:

// begin-insert: tags/bonus.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    val resultLines = listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
    writer.append(resultLines.joinToString("\n"))
}
----
// end-insert

If we now "Extract function" with all but the last line, making it public and calling it `generate` too, we get the following:

// begin-insert: tags/bonus.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    val resultLines = generate(lines)
    writer.append(resultLines.joinToString("\n"))
}

fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    val resultLines = listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
    return resultLines
}
----
// end-insert

Inlining the two vestigial `resultLines` gives:

// begin-insert: tags/bonus.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(writer: Writer, lines: List<String>) {
    writer.append(generate(lines).joinToString("\n"))
}

fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

One more inline then, this time of the old `generate` function.
That replaces its invocation in client code - this is the code in the test:

// begin-insert: tags/bonus.9:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val output = StringWriter().apply {
        this.append(generate(inputLines).joinToString("\n"))
    }
    assertEquals(expectedLines.joinToString("\n"), output.toString())
}
----
// end-insert

This is an application of the techniques in <<code-to-data>> - instead of writing code to perform an action, return the data required to perform it and move the (in this case IO) towards the outer edges of the system.
As this is the test, we don't really want any IO at all, and can simplify everything to:

// begin-insert: tags/bonus.10:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(expectedLines, generate(inputLines))
}
----
// end-insert

This was, after all, what we were aiming for.
Another way of looking at this is that our original `Writer` was an accumultating object, we have replaced it with a transformation as we saw in <<accumulating-objects-to-transformations>>.

Let's take stock of our new `generate`:

// begin-insert: tags/bonus.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)
----
// end-insert

Now that `generate` is doing so much less, it isn't clear that `List<String>.toValuableCustomers()` is worthwhile.
Looking at it afresh we see that it is working at mixed levels, converting and filtering.
Let's inline it:

// begin-insert: tags/bonus.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

That's better, assigning to the local variable does a good job of telling us what the expression means, and the list operations spell out the implementation in place.
This is a case where a single-expression function (<<multi-to-single-expression-functions>>) would probably make things worse, so we'll leave the local alone.
We'll also resist the temptation to make it an extension method, `List<String>.toReport()`, at least for now.

.Refactoring for Readability
****
Refactoring for readability is often this way.
We extract a function to make something more readable in context, but when the context changes the function makes things worse.
Sometimes, something that we felt was quite expressive when we wrote it, turns out to be less so when we read it back later.
Even in the best-gelled teams, individuals also differ in their preferences.
****

=== Efficient Writing

We're quite pleased with this refactor.
It has simplified our tests and the production code, and we have moved from imperative code that mixes IO and logic to a nice pure function with no side-effects.
For a while all is fine in production too, but with the easing of COVID-19 travel restrictions, Travelator becomes the roaring success that we all knew it would be.
Eventually marketing start complaining that the report generation is failing with an `OutOfMemoryError`.
Could we look into it?

We haven't bothered you with the details so far, but there is a `main` method that invokes our report.
It is designed to be invoked with shell redirection, reading from a file piped as the standard input, and writing to a file collected from the standard output.
It started out as Java:

// begin-insert: tags/functions-to-extension-methods.0:src/main/java/travelator/marketing/HighValueCustomersMain.java
[source,java]
----
public class HighValueCustomersMain {

    public static void main(String[] args) throws IOException {
        try (
            var reader = new InputStreamReader(System.in);
            var writer = new OutputStreamWriter(System.out)
        ) {
            HighValueCustomersReport.generate(reader, writer);
        }
    }
}
----
// end-insert

You can see that by reading and writing this way we don't have to worry about reading filenames from the command-line.
We have had two issues with errors, when the input file has been malformed, but marketing sit next door and just call us over to help if these occur.
They give us cake in these cases, so we're hardly incentivized to do a better job of error handling for now.
If we can fix the `OutOfMemoryError` quickly we think we saw some crumpets...

At some point we converted `main` to Kotlin:

// begin-insert: tags/bonus.0:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    InputStreamReader(System.`in`).use { reader ->
        OutputStreamWriter(System.out).use { writer ->
            generate(reader, writer)
        }
    }
}
----
// end-insert

Then it was refactored with the change to the `generate` parameters:

// begin-insert: tags/bonus.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.append(
                generate(
                    reader.readLines()
                ).joinToString("\n")
            )
        }
    }
}
----
// end-insert

Ah, there's our problem.
We're reading the whole of the input into memory (`readLines()`), processing it, and then creating the entire output in memory (`joinToString()`) before writing it back out.

We sometimes run into these problems like these with functional decomposition.
Less often than we might anticipate, but in this case it's ironic that the original `Reader` and `Writer` code did not have this issue, so we have brought it on ourselves in the name of good style.
We could quickly revert our changes and go and see if there are any crumpets left, or we could find a more functional solution.

Let's go back to `generate` and see what leeway we have.

// begin-insert: tags/bonus.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): List<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return listOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

Concentrating on the output for now, we can see that we are building a list of the lines of the output
 - each of those strings won't be sharing any memory with the data that we parsed from the input.
This is then combined into one large string in `main`, that again doesn't share any memory with the lines that created it.
In these situations we want to defer the creation of the intermediates, and `Seqeuences` are designed for just that.
As we'll see, they aren't a panacea, but here they will do nicely.

We can convert `generate` to return a sequence by simply methodically or quickly - for once we'll choose quickly and just replace `listOf` with `sequenceOf`:

// begin-insert: tags/bonus.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

Now we will only be creating the output lines one at a time when the stream is iterated.
So each line can be disposed of quickly rather than hanging around until we have written the whole file.

The tests have to change to realise the `Sequence`:

// begin-insert: tags/bonus.13:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    assertEquals(
        expectedLines,
        generate(inputLines).toList()
    )
}
----
// end-insert

Interestingly though, `main` does not:

// begin-insert: tags/bonus.13:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.append(
                generate(
                    reader.readLines()
                ).joinToString("\n")
            )
        }
    }
}
----
// end-insert

`main` needs to be recompiled now that `generate` returns a `Sequence` rather than a `List`, but its source doesn't need to be changed.
This is because there are extension functions `joinToString(...)` defined on both `Iterable` and `Sequence`.

.Swapping Iterables and Sequences
****
Both the `Iterable` and `Sequence` interfaces have only a single method: `public operator fun iterator(): Iterator<T>`.
They both also have extension functions for `map`, `filter`, `reduce` etc which take the same parameters.
But they are different types because their semantics are very different.
The operations on `Iterable` are eager, whilst those on `Sequence` are lazy - so we cannot swap one for the other with impunity (as we will see later in this chapter).

Nevertheless, the fact that they have such similar APIs means that in situations like this, we can often change very little (source) code when we swap between them.
****

It might not _need_ to change, but unless `main` _does_ change, we are still creating one large string of all the output.
To avoid that we need to get imperative again:

// begin-insert: tags/bonus.14:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            generate(
                reader.readLines()
            ).forEach { line ->
                writer.appendLine(line)
            }
        }
    }
}
----
// end-insert

The pedantic reader (don't worry, you're amongst friends) will have spotted that this behaviour is subtly different to the `joinToString("\n")` version.
We're quietly confident that a trailing newline won't break anything, so we press on.

We can always pretend we aren't looping by hiding the iteration:

// begin-insert: tags/bonus.15:src/main/java/travelator/marketing/HighValueCustomersMain.kt
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(reader.readLines())
            )
        }
    }
}


fun Writer.appendLines(lines: Sequence<CharSequence>): Writer {
    return this.also {
        lines.forEach(this::appendLine)
    }
}
----
// end-insert

Note that while `Writer.appendLines` is defined as single expression, we agreed in <<multi-to-single-expression-functions>> to use long form where functions are actions, and `appendLines` is defiantly that.

Now each `CustomerData::outputLine` inside `generate` will only be called when its line is required to be written to the `Writer`.
This saves memory, but has the interesting effect that the code inside `generate` can throw an `IOException` if the writing fails.
For now, we're going to put that aside, but it will play on our minds until we find a resolution.
The truth is that ++Sequence++s let us pretend that we are programming with values and calculations rather than actions, but they are a leaky abstraction.

On the other hand, they have dug us out of a hole here, and writing to a `Sequence` has fewer leaks than reading from one.
So we'll ship this, having bought ourselves lots of memory headroom with few changes and earned our crumptets. Do they have any butter?

=== Efficient Reading

We'd be remiss if we didn't finish the job and pretend that we also need to save memory on reading too.
Let's try a `Sequence` again.

// begin-insert: tags/bonus.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

We aren't going to be able to stream data straight through `generate` because of that `sortedBy`.
In order to sort, we have to have all the elements in memory at once.
Where we can make savings is in the new instances of `List` that are being created for each of the stages of that pipeline - each one has a non-trivial overhead per item.
In addition, we are keeping each line of the input in memory even after we've split it out into the fields of `CustomerData`.
Reading from a `Sequence` will solve these problems, but bring a few of its own.

We can see this if we change the code in `generate` to convert the `lines` to a `Sequence`, and fix up the methods that did take `List`.

// begin-insert: tags/bonus.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: List<String>): Sequence<String> {
    val valuableCustomers = lines
        .asSequence()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun Sequence<String>.withoutHeader() = drop(1)

private fun Sequence<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

This passes the tests.
Are we done?
Is this another rhetorical question, or what?

Let's cut to the chase and say that the issue is that we end up iterating through the `Sequence` twice.
Once before we return from `generate` in that `sumByDouble`, and again when we fetch the whole report.
We will be doing twice as much work as we need to.
Worse, when we finally get around to passing a `Sequence` reading from a file, we won't be able to iterate over that twice, giving an `IllegalStateException`.
In the same way that there are differences in the runtime behaviour of ++Lists++s that are not expressed in the type system, instances of ++Sequence++s differ, and they also carry hidden state.
Iterating over a `Sequence` looks like iterating over from a `List`, but _may_ change the `Sequence` itself by consuming its contents.

We can check that we aren't abusing this `Sequence` by adding a `.constrainOnce()` call:

// begin-insert: tags/bonus.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
    val valuableCustomers = lines
        .asSequence()
        .constrainOnce()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
----
// end-insert

This will cause our tests to fail with the `IllegalStateException`.
The simplest fix is to resolve the `Sequence` with a `.toList()` call.

// begin-insert: tags/bonus.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
    val valuableCustomers = lines
        .asSequence()
        .constrainOnce()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
----
// end-insert

This will lead to our terminating the whole sequence (and hence ultimately reading the whole file) in that statement, but at least it will only try once, and the memory for each line can be discarded as soon as it is parsed.

Now we can replay the "Introduce parameter" refactoring with the `lines.asSequence()` expression to convert `generate` to take `Sequence<String>`:

// begin-insert: tags/bonus.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun generate(lines: Sequence<String>): Sequence<String> {
    val valuableCustomers = lines
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

As before we can now remove the fake-IO from the tests.
It's worth putting the `constrainOnce()` into `check` to ensure that we don't accidentally try to consume the input twice again.

// begin-insert: tags/bonus.19:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#check
[source,kotlin]
----
private fun check(
    inputLines: List<String>,
    expectedLines: List<String>
) {
    val lines = inputLines.asSequence().constrainOnce()
    assertEquals(
        expectedLines,
        generate(lines).toList()
    )
}
----
// end-insert

We now get to the point, which was to allow `main` to pass a `Sequence` representing the input lines rather than reading them all at once.
Rather than `readLines()`:

// begin-insert: tags/bonus.18:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(reader.readLines())
            )
        }
    }
}
----
// end-insert

we use `buffered().lineSequece()`:

// begin-insert: tags/bonus.19:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            writer.appendLines(
                generate(reader.buffered().lineSequence())
            )
        }
    }
}
----
// end-insert

We're now really quite efficient in our use of memory, and run pleasingly quickly.
Can we resist one last tinker?
How much nicer would `main` read with more extension functions?

// begin-insert: tags/bonus.20:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            reader
                .asLineSequence()
                .toHighValueCustomerReport()
                .writeTo(writer)
        }
    }
}
----
// end-insert

Which finally answers the question we posed back in <<functions-to-extension-functions>> - yes we do end up with report generation as an extension function.

// begin-insert: tags/bonus.20:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
// end-insert

Before we go, we should note once more that while the original version of `generate` had to worry about `IOExceptions`, the new version doesn't.
Or at least, the new version doesn't worry about IO errors because they are hidden from it by the `Sequence` abstractions wrapping the `Reader` and `Writer`.
That doesn't mean that they can't happen, just that `generate` isn't warned that they can.
We'll take a break to see if marketing have any more batter-based rewards before addressing that topic in <<bonus-error-handling>>.
