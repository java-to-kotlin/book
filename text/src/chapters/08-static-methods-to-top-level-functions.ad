[[static-methods-to-top-level-functions]]
== Static Methods to Top-Level Functions

Stand-alone functions are one of the fundamental building blocks of software.
In Java, they have to be declared as methods on a class, but in Kotlin we can declare them as top-level entities.
When should we prefer top-level functions, and how do we refactor our way there from Java?

=== Java Statics

// TODO We don't need to explain classes, objects and statics to our readers.  Rewrite to explain differences between Java and Kotlin and how the compiler targets the JVM.

All values and functions in a Java program have to belong to a class: they are _members_ of that class.
Java calls member-values _fields_, and member-functions _methods_.
By default, fields values are per-instance of the class: different instances have different values.
Methods are also per-instance, in that they have access to the state of the instance that they are invoked on.
If we mark fields as `static` though, they are shared between all instances of the class.
Static methods only have access to this shared state (and visible static fields in other classes), but in return for this restriction we can invoke them without needing an instance of the class.

To simplify the language, the Java designers made the decision to tie all code and data to classes.
We have class-scoped static state, so we need class-scoped static methods.
They could have added free-standing data and functions, but static fields and methods will do.
If the language had options, then developers would have to choose between them, and less choice is often better.
The designers then carried this language design decision forward to the Java Virtual Machine, which in turn has no way to express top-level code or data.

.Static State
****
In the early days of Java, static state was a lot more common than it is today.
We wrote singletons, and argued about how to initialise them in a lazy but safe way.
We used static fields to implement per-class caches of instances.
Then the new millennium fad for testing code all-but killed static state.
That's because it's very difficult to isolate one test from another when they are coupled by state, and very hard to uncouple them when that state is static and so shared between all tests in a JVM.
(Note that _state_ here refers to mutable data. Immutable data -- constants -- are less of a problem.)

So we learned to keep otherwise-static state in object fields and used dependency injection to arrange for there to be only one shared instance of the object in our application.
When we say "dependency injection" here, your authors mean "passing an object to a constructor", rather than the use of a framework.

For the rest of this chapter we restrict our examination to static methods rather than fields, but many of the same discussions and techniques also apply to the latter.
****

Sometimes we have a class with both non-static and static methods acting on the same type - static factories are common as we saw in <<java-to-kotlin-classes>>.
Often though we end up with a class of just static methods.
When there is no static state for them to share, these methods are really just stand-alone functions grouped together and called via their class name.
Like the methods from the `java.util.Collections` class for example:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#scopedMax
[source,java]
----
var max = Collections.max(list);
----
// end-insert

Amazingly the industry didn't really notice how much of a pain that `Collections.` prefix was for a while.
This was because we wrote our programs by adding more and more methods to types that we owned, and so rarely needed static functions.
Static functions are useful when want to add functionality _without_ adding a method to the type that they act on.
This might be because our classes are already sagging under the weight of all the methods that we have already added to them.
It might be because we don't own the class and so can't add the method to it.
Or it might be because the functionality only applies to some instantiations of a generic type, and so cannot be declared as a member of the generic.
For example, `Collections.max` only applies to a collection with comparable elements.

Over time, we began to appreciate the advantages of using standard interfaces, like the Java collections, instead of working with our own abstractions.
Java 5 (with its generics) was the first release that allowed us to use collections directly, rather than wrapping them with our own classes.
It's no accident then that Java 5 also brought the ability to `import static java.util.Collections.max` so that we could then write:

// begin-insert: src/main/java/topLevelFunctions/TopLevel.java#importedMax
[source,java]
----
var m = max(list);
----
// end-insert

Because the JVM only actually supports static methods rather than true top-level functions, this is really only a convenience provided by the compiler.
For the same reason, while Kotlin does have top-level functions, they too are implemented as static methods of classes when running on the JVM.

=== Kotlin Top-Level Functions, Objects and Companion Objects

Kotlin allows functions (and properties and constants) to be declared outside of classes.
In this case, because the JVM has nowhere else for them to go, the compiler generates a class with static members for the top-level declarations.
By default, it derives the name of the class from the name of the file defining the functions.
For example, functions defined in `top-level.kt` end up as static methods on a class called `Top_levelKt`.
If we know the name of the class we can reference it from Java, and either static import or `Top_LevelKt.foo` or directly invoke `Top_levelKt.foo()`.
In the, let's face it, rather likely event that we don't like how the name generated by the Kotlin compiler looks in our Java code, we can explicitly name the generated class by adding a `@file:JvmName` annotation to the top of the file, as we'll see later.

As well as these top-level functions, Kotlin also allows us to define properties and functions scoped to a class like Java.
Instead of just marking these as `static`, Kotlin borrows from Scala and collects them together into `object` declarations.
An `object` declaration define a singleton - there is only one instance of each type.
All the members of an `object` will be compiled to members of a class with the name of the object.
They won't actually be static methods unless specifically marked with an `@JvmStatic` though.
This is because Kotlin allows objects to extend classes and implement interfaces, and that's incompatible with static declarations.

When we need to group static and non-static members in the same class, we can declare the static parts in a `companion object` inside the (otherwise non-static) class declaration.
This groups them in the file, and code in a companion object can access private state in instances of its containing class.
Companion objects can also extend another class and implement interfaces - something that Java statics cannot do.
Compared to Java statics though, they are cumbersome if we just want to define one or two static methods.

In Kotlin then, we can write non-instance-scoped functions as either top-level functions, or methods on a singleton object, and this object may be a companion object or not scoped to a type.

All things being equal, in Kotlin we favour top-level functions.
They are the simplest to declare and reference, and can be moved from file to file within a package without affecting Kotlin client code (but see the caveat in <<moving-top-level-functions>>.
We declare functions as methods on a singleton object instead of top-level functions when we need the ability to implement an interface, or otherwise group functions more tightly.
We use a companion object when we need to mix static and non-static behaviour within a class, or to write factory methods with names like MyType.of(...)`.

As with many aspects of programming, we start with the simplest thing that could work, which is usually a top-level function, and refactor to a more complicated solution only when it brings benefits, such as a more expressive API for our clients, or better maintainablity for us.

=== Refactoring From Static Methods to Top-Level Functions

While we prefer to use top-level declarations, the Java to Kotlin conversion built into IntelliJ doesn't.
It converts our Java statics into object methods.
Let's see how to refactor from Java, through object declarations, to top-level functions.

At Travelator, we allow our customers to build shortlists, such as a shortlist of routes when planning their trip, or a shortlist of hotel rooms on those routes.
The user can rank items in a shortlist by different criteria and discarded items to narrow down the results to a final choice.
Following the guidance in <<dont-mutate-shared-collections>>, a shortlist is stored as an immutable list.
The functions for manipulating a shortlist (returning a modified copy rather than mutating the list) are implemented as static methods of the `Shortlists` class.

// begin-insert: tags/static-to-object-to-functions.0:src/main/java/travelator/Shortlists.java#functions
[source,java]
----
public class Shortlists {
    public static <T> List<T> sorted(
        List<T> shortlist,
        Comparator<? super T> ordering
    ) {
        return shortlist.stream()
            .sorted(ordering)
            .collect(toUnmodifiableList());
    }

    public static <T> List<T> removeItemAt(List<T> shortlist, int index) {
        return Stream.concat(
            shortlist.stream().limit(index),
            shortlist.stream().skip(index + 1)
        ).collect(toUnmodifiableList());
    }

    public static Comparator<HasRating> byRating() {
        return comparingDouble(HasRating::getRating).reversed();
    }

    public static Comparator<HasPrice> byPriceLowToHigh() {
        return comparing(HasPrice::getPrice);
    }

    ... and other comparators
}
----
// end-insert

.Convenience Functions
****
Looking at the implementations of `sorted` and `removeItemAt` reminds us that Nat discovered Kotlin after watching Duncan try to use the Java streams API to analyse some publishing data.
He was so horrified at the difficulty of performing basic operations, compared to Python, that he went looking for a JVM library or language that would ease the pain.
It certainly seems that, whilst the Java APIs are improving recently; for many years the designers seem to have had a policy of never knowingly adding a convenience function.

In contrast, the Kotlin standard library seems to go out of its way to provide functionality just where and when we need it, often in the form of extension functions (<<functions-to-extension-functions>>) on existing types.
****

The functions in `Shortlists` are static methods, and have to be referenced as such.
Spelled out longhand, this looks like:

// begin-insert: tags/static-to-object-to-functions.5:src/test/java/travelator/ShortlistsTest.java#example_usage
[source,java]
----
var reordered = Shortlists.sorted(items, Shortlists.byValue());
----
// end-insert

We usually `static import` the methods though, and they are named to read better that way:

// begin-insert: tags/static-to-object-to-functions.5:src/test/java/travelator/ShortlistsTest.java#example_usage_imported
[source,java]
----
var reordered = sorted(items, byPriceLowToHigh());
----
// end-insert

Converting the Java to Kotlin with IntelliJ we get:

// begin-insert: tags/static-to-object-to-functions.5:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
object Shortlists {
    @JvmStatic
    fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
        return shortlist.stream().sorted(ordering)
            .collect(toUnmodifiableList())
    }

    @JvmStatic
    fun <T> removeItemAt(shortlist: List<T>, index: Int): List<T> {
        return Stream.concat(
            shortlist.stream().limit(index.toLong()),
            shortlist.stream().skip((index + 1).toLong())
        ).collect(toUnmodifiableList())
    }

    @JvmStatic
    fun byRating(): Comparator<HasRating> {
        return comparingDouble(HasRating::rating).reversed()
    }

    @JvmStatic
    fun byPriceLowToHigh(): Comparator<HasPrice> {
        return comparing(HasPrice::price)
    }

    ... and other comparators
}
----
// end-insert

Actually, that isn't quite true.
As is its wont at the time of writing, the converter added some spurious nullability to types, undid static imports, leaving us with `Collectors.toUnmodifiableList()` for example, and managed to create an imports list that didn't compile.
This is the version of the file with those things fixed!

In <<java-to-kotlin-classes>>, we saw that converting a Java class with static _and_ non-static methods produced a Kotlin class with a companion object.
Here the conversion has produced only a top-level object.
Because this Java class had no non-static methods or state, there is no need for the Kotlin translation to include an instantiable class.
Classes with both static and non-static methods are less suitable for conversion to top-level functions.

While the conversion didn't go completely smoothly at the Kotlin level, on the plus side, no Java code was harmed in the conversion.
The client code remains unchanged, because the `@JvmStatic` annotations allow Java code to see the methods as static methods on a `Shortlists` class, as they were before the conversion.

We may want to convert the methods to be top-level functions, but we can't just move them, because Java only understands methods, not functions.
That is true of the whole JVM actually, so even top-level functions have to be hosted somewhere.
If these functions were compiled to methods on a class called `Shortlists` Java would be happy - and that is the job of the `@file:JvmName` annotation we mentioned earlier.
We can manually add the annotation at the top of the file, and remove the `object` scope and `@JvmStatic` annotations to get:

// begin-insert: tags/static-to-object-to-functions.11:src/main/java/travelator/Shortlists.kt#all_functions
[source,kotlin]
----
@file:JvmName("Shortlists")
package travelator

...

fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>) =
    shortlist.stream().sorted(ordering).collect(toUnmodifiableList())


fun <T> removeItemAt(shortlist: List<T>, index: Int) =
    Stream.concat(
        shortlist.stream().limit(index.toLong()),
        shortlist.stream().skip((index + 1).toLong())
    ).collect(toUnmodifiableList())

fun byRating() =
    comparingDouble(HasRating::rating).reversed()

fun byPriceLowToHigh() =
    comparing(HasPrice::price)

fun <T> byValue() where T : HasPrice, T : HasRating =
    comparingDouble { t: T -> t.rating / t.price }.reversed()

... and other comparators
----
// end-insert


This keeps our Java happy, but irritatingly breaks some Kotlin code that was calling the methods.
This was importing the methods from an object, for example `import travelator.Shortlists.sorted`, but Kotlin can't import top-level functions that way.
As far as Kotlin is concerned, the functions are defined at the package scope.
They may be compiled to static methods of a JVM class called `Shortlists`, but that class is an implementation detail of how the compiler maps Kotlin language concepts to the JVM platform.

We can go through all the compilation errors and manually fix the imports to refer to the function at package scope.
For example, we'll have to change `import travelator.Shortlists.sorted` to `import travelator.sorted`.
This is easy enough if the change affects a few files, but if the change has had a wide impact, fixing all the imports is a tedious job, albeit one that _might_ be achieved with a single global search and replace.

Luckily, since we started writing this book, IntelliJ has gained a "Move to top level" refactoring.
Let's revert the last Kotlin change, back to the object declaration, and try again.

=== Move To Top Level

Oddly the new refactoring isn't available on the refactoring menu, but Alt-Enter on an object method name gives the option.
We'll do `sorted` first.
IntelliJ moves the method out of the object scope:

// begin-insert: tags/static-to-object-to-functions.56:src/main/java/travelator/Shortlists.kt#sorted
[source,kotlin]
----
@JvmStatic
fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
    return shortlist.stream().sorted(ordering)
        .collect(toUnmodifiableList())
}
----
// end-insert

Unfortunately it fails to remove the `@JvmStatic` annotation, so we have to delete that ourselves to get the code to compile.
Once we do, we find that it has at least fixed up the callers, which was the problem we had when we just moved the method ourselves.
Where we explicitly referenced the method as `ShortLists.sorted` we now have:

// begin-insert: tags/static-to-object-to-functions.57:src/test/java/travelator/ShortlistsTest.java#example_usage
[source,java]
----
var reordered = ShortlistsKt.sorted(items, Shortlists.byValue());
----
// end-insert

For some reason where we had a static import things have got worse:

// begin-insert: tags/static-to-object-to-functions.57:src/test/java/travelator/ShortlistsTest.java#example_usage_imported
[source,java]
----
var reordered = travelator.ShortlistsKt.sorted(items, byPriceLowToHigh());
----
// end-insert

We can fix that with Alt-Enter and "Add on demand static import...".
We have to do that once in each affected file, so we should have checked in before the refactor - so that we could easily see which files it changed.

// begin-insert: tags/static-to-object-to-functions.58:src/test/java/travelator/ShortlistsTest.java#example_usage_imported
[source,java]
----
var reordered = sorted(items, byPriceLowToHigh());
----
// end-insert

Compared to our previous manual approach of adding an `@file:JvmName("Shortlists")` annotation, our Java clients are now exposed to that icky `ShortlistsKt` name.
As the methods names were designed to be used with static imports though, it is almost always hidden in the imports block where no-one ever looks, so we're prepared to put up with this.
In return for this sacrifice, the conversion has also fixed up the Kotlin callers of `sorted`.
It is now referenced in Kotlin as `travelator.sorted` rather than `travalator.Shortlists.sorted`, which was the point.

We can now move the rest of the methods on `Shortlists` in the same way.
It's a little tedious, but at least when it moves the last method, IntelliJ deletes the empty object, leaving us:

// begin-insert: tags/static-to-object-to-functions.59:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
    return shortlist.stream().sorted(ordering)
        .collect(toUnmodifiableList())
}

fun <T> removeItemAt(shortlist: List<T>, index: Int): List<T> {
    return Stream.concat(
        shortlist.stream().limit(index.toLong()),
        shortlist.stream().skip((index + 1).toLong())
    ).collect(toUnmodifiableList())
}

fun byRating(): Comparator<HasRating> {
    return comparingDouble(HasRating::rating).reversed()
}

fun byPriceLowToHigh(): Comparator<HasPrice> {
    return comparing(HasPrice::price)
}

... and other comparators
----
// end-insert

As we write this, the "Move to top level" refactor is limited to a single method at a time.
If methods depend on each other this can lead to some problems, as we will see in <<functions-to-extension-functions>>.

=== Kotlinify

Of course, we didn't move our methods to top-level functions just for the sake of it.
Not _just_ for the sake of it anyway.
Now our functions are in the idiomatic Kotlin place, let's finish the idiomatic Kotlin job.

<<streams-to-sequences>> gives guidance on converting Java streams to Kotlin - in the case of `sorted` we can just use the Kotlin `sortedWith` extension function:

// begin-insert: tags/static-to-object-to-functions.60:src/main/java/travelator/Shortlists.kt#sorted
[source,kotlin]
----
fun <T> sorted(shortlist: List<T>, ordering: Comparator<in T>): List<T> {
    return shortlist.sortedWith(ordering)
}
----
// end-insert

This makes a very logical extension function (<<functions-to-extension-functions>>):

// begin-insert: tags/static-to-object-to-functions.61:src/main/java/travelator/Shortlists.kt#sorted
[source,kotlin]
----
fun <T> List<T>.sorted(ordering: Comparator<in T>): List<T> {
    return sortedWith(ordering)
}
----
// end-insert

Java still calls this as a static method:

// begin-insert: tags/static-to-object-to-functions.61:src/test/java/travelator/ShortlistsTest.java#example_usage_imported
[source,java]
----
var reordered = sorted(items, byPriceLowToHigh());
----
// end-insert

Where we call it from Kotlin though:

// begin-insert: tags/static-to-object-to-functions.61:src/test/java/travelator/hotels/ShortlistScenarioTest.kt#usage
[source,kotlin]
----
val hotelsByPrice = hotels.sorted(byPriceLowToHigh())
----
// end-insert

These Kotlin usages really aren't gaining us anything over the raw Kotlin API, so we can just inline them:

// begin-insert: tags/static-to-object-to-functions.62:src/test/java/travelator/hotels/ShortlistScenarioTest.kt#usage
[source,kotlin]
----
val hotelsByPrice = hotels.sortedWith(byPriceLowToHigh())
----
// end-insert

This leaves the `sorted` function for Java to call.
Looking at it, it really has nothing to do with shortlists anymore.
Should we move it to a more generic namespace?
Maybe later; for now we'll just follow through on the rest of the file to give:

// begin-insert: tags/static-to-object-to-functions.63:src/main/java/travelator/Shortlists.kt#functions
[source,kotlin]
----
fun <T> Iterable<T>.sorted(ordering: Comparator<in T>): List<T> = 
    sortedWith(ordering)

fun <T> Iterable<T>.withoutItemAt(index: Int): List<T> =
    take(index) + drop(index + 1)

fun byRating(): Comparator<HasRating> =
    comparingDouble(HasRating::rating).reversed()

fun byPriceLowToHigh(): Comparator<HasPrice> =
    comparing(HasPrice::price)

... and other comparators
----
// end-insert

You may have noticed that have renamed `removeItemAt` to `withoutItemAt`.
_With_ (OK, in this case _without_) is a useful device to let the reader know that we are not mutating an object but returning a copy.

[[moving-top-level-functions]]
.Moving Top-Level Functions
[WARNING]
====
`withoutItemAt` looks to be a useful Kotlin function, and we wonder why we can't find a version in the standard library.
Now that it is a top-level function, we can move it out of `Shortlists.kt` to a different file in the same package without changing the Kotlin source that calls it.
However, in the compiled output, that function will now be defined as a static method of a different JVM class.

If we publish Kotlin library code in a JAR file, all is fine provided dependent code is recompiled against the new version.
The Kotlin compiler generates classfiles with metadata sections that let it map Kotlin names to JVM classes and methods.
All may _not_ be fine if dependent code uses our JAR as a binary dependency, and upgrades without recompiling.
The JVM doesn't use the metadata that the Kotlin compiler generated.
If a top-level function has moved from one class to another between versions of a binary dependency, dependent code can get `NoSuchMethodError` thrown at runtime.

We can use the `@JvmMultifileClass` and `@JvmName` annotations to control how our top-level declarations appear in JVM classfiles, so that moving declarations between source files won't break binary compatibility.
However, none of our Kotlin test or example code will have changed, so we can't rely on them to warn us about this kind of breakage.
We just have to take extra care if we move top-level functions published in a library.
====

=== Conclusion

Static functions are the bread and butter of our programs.
In Java these have to be static methods on a class, but in Kotlin we can and should default to defining them as top-level functions.

Automatically converting a Java class of static methods to Kotlin will create an `object` declaration, accessible from both Java and Kotlin.
We can then move the methods on the object to the top-level individually, remaining accessible to both languages, before applying other refactorings to take advantage of more Kotliny goodness.

The most-likely next refactor is to refactor our top-level functions into extension functions.
It is so most-likely that it is the subject of our next chapter, <<functions-to-extension-functions>>.

