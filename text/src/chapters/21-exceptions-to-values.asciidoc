[[exceptions-to-values]]
== Exceptions to Values

++++
<blockquote data-type="epigraph">
<p>In <a data-type="xref" href="#throwing-to-returning">#throwing-to-returning</a> we looked at error-handling strategies for Kotlin, and how to refactor from exceptions in Java to more functional techniques.
The truth is that most code ignores errors in the hope that they won't happen.
Can we do better?</p>
</blockquote>
++++

Someone new in marketing has taken to tweaking the spreadsheet that we last saw in <<performing-io-to-passing-data>>—the one that generates the high-value customer scores.
We don't know what they are doing in detail, but they keep on exporting files that break our parsing and then asking us to explain what a stack trace is.
It's getting a bit embarrassing on both sides of the relationship, so the cake has begun to dry up.
Could there be any more incentive?

Well yes, there could.
We've also been asked to write an unattended job so that marketing can save the file onto a server, and 'we' will automatically write the summarized version.
Without a person in the loop to interpret those stack traces, it looks like we'll have to find a way to report errors properly.

=== Identifying What Can Go Wrong

Here's((("exceptions to values", "identifying what can go wrong", id="EVid21"))) the code as we left it:

// begin-insert: exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }

private fun Sequence<String>.withoutHeader() = drop(1)

internal fun String.toCustomerData(): CustomerData =
    split("\t").let { parts ->
        CustomerData(
            id = parts[0],
            givenName = parts[1],
            familyName = parts[2],
            score = parts[3].toInt(),
            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
        )
    }

private val CustomerData.outputLine: String
    get() = "$id\t$marketingName\t${spend.toMoneyString()}"

private fun Double.toMoneyString() = this.formattedAs("%#.2f")

private fun Any?.formattedAs(format: String) = String.format(format, this)

private val CustomerData.marketingName: String
    get() = "${familyName.toUpperCase()}, $givenName"
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.1&show=file">Example 21.1 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.1&show=diff">(diff)</a> 
</div>
++++
// end-insert

If we're to do a thorough job of error handling, the first thing we have to do is establish what might go wrong.
As we saw in <<throwing-to-returning>>, in Kotlin we don't have checked exceptions to give us clues, but these were so badly used in most Java code that in this respect there isn't much of a difference between the languages.
Unless code has been written to communicate the ways that it can fail, we'll have to rely on examination, intuition, and experience to work it out.
In this case, experience tells us that the failures we actually get are due to missing fields, so we can concentrate there, but we should still do due diligence on all aspects of the code.
Let's work our way up the functions from the bottom of the listing, looking for potential errors.

`CustomerData.marketingName` looks benign:

// begin-insert: exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#marketingName
[source,kotlin]
----
private val CustomerData.marketingName: String
    get() = "${familyName.toUpperCase()}, $givenName"
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.2&show=file">Example 21.2 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.2&show=diff">(diff)</a> 
</div>
++++
// end-insert

If `CustomerData` were implemented in Java, we might find `familyName` resolving to `null` and, hence, throwing when we try `toUpperCase()`, but in Kotlin it can't, so it won't.
As with all code, the function is subject to subclasses of `Error` (such as `OutOfMemoryError`) being thrown, but it should be generally safe.
From here on we'll count throwing `Error` as extraordinary and not consider it in our analysis.

Now `formattedAs`:

// begin-insert: exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#formattedAs
[source,kotlin]
----
private fun Any?.formattedAs(format: String) = String.format(format, this)
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.3&show=file">Example 21.3 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.3&show=diff">(diff)</a> 
</div>
++++
// end-insert

`String.format(format, this)` is((("IllegalFormatException")))((("error handling", "IllegalFormatException"))) implemented as `java.lang.String::format`, which is documented to throw `IllegalFormatException` if the `format` is not compatible with its other input.
This is a https://oreil.ly/ErpGo[partial function]: one that only returns a result for some of the possible values of its parameters.
In this case, it can return a result for all values of `Double`, but only when we use very specific values of `format`.
Luckily, we are only feeding it one particular `format`, the value `%#.2f`, which we know works, so this and its only caller, `Double.toMoneyString()`, should not fail.
If they do fail, it's because our analysis is incorrect (or its assumptions are no longer true), and runtime errors are a reasonable way of signaling this programmer error.

Next we have:

// begin-insert: exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#outputLine
[source,kotlin]
----
private val CustomerData.outputLine: String
    get() = "$id\t$marketingName\t${spend.toMoneyString()}"
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.4&show=file">Example 21.4 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.4&show=diff">(diff)</a> 
</div>
++++
// end-insert

This only calls code that we have just reasoned shouldn't fail, so by the transitive property of failure, it should also be safe.

Note this has been easy so far because these functions are all calculations (<<calculations>>).
They don't depend on any external state, so we can reason about them just by looking at them.

So far so good, now `String.toCustomerData()`:

// begin-insert: exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toCustomerData
[source,kotlin]
----
internal fun String.toCustomerData(): CustomerData =
    split("\t").let { parts ->
        CustomerData(
            id = parts[0],
            givenName = parts[1],
            familyName = parts[2],
            score = parts[3].toInt(),
            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.5&show=file">Example 21.5 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.5&show=diff">(diff)</a> 
</div>
++++
// end-insert

OK, this is another partial function: almost no values of the `String` receiver will lead to this function being able to return a result.
Luckily, almost all the ones that we are getting in practice are OK, which is why error handling is only now becoming a priority.
What could go wrong though?

Starting from the top of the function, `String.split` may behave oddly if we pass it an empty delimiter, but we aren't.
Then we may not have enough parts, so that `parts[n]` throws `IndexOutOfBoundsException`.
Finally, `parts[3]` may not represent an `Int`, or `parts[4]` may not represent a `Double`, both of which will throw `NumberFormatException`.

Having established that `toCustomerData` can fail if passed a `String` that doesn't meet our format specification, what should we do about it?
At the moment, all the ways that it can fail result in an exception being thrown, the program being aborted with an unfriendly error message, and marketing calling us over.
Which leads to two follow-on questions: "Should we abort?" and "How can we improve the((("error messages"))) error message so that marketing can interpret it?"

As we saw in <<throwing-to-returning>>, we shouldn't use exceptions to abort on predictable errors.
The lack of checked exceptions in Kotlin (and their lack of use in Java) means that if we do, we lose the opportunity to communicate that the code is susceptible to failure.
The callers of our code then have to do what we are currently doing: reason with every line of code in an implementation.
Even after then, the implementation might change, silently invalidating the findings.

If((("null, returning in place of exceptions"))) we aren't to throw an exception, then the cheapest change (provided our callers are all Kotlin) is to return `null` when we fail.
Client code will then be forced to consider the `null` case and act accordingly.
For example:

// begin-insert: exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toCustomerData
[source,kotlin]
----
internal fun String.toCustomerData(): CustomerData? =
    split("\t").let { parts ->
        if (parts.size < 4)
            null
        else
            CustomerData(
                id = parts[0],
                givenName = parts[1],
                familyName = parts[2],
                score = parts[3].toInt(),
                spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
            )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.6&show=file">Example 21.6 [exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.6&show=diff">(diff)</a> 
</div>
++++
// end-insert

We could have chosen to simply wrap the whole implementation in a `try` block and return `null` from the `catch`, but here we have been more proactive than reactive.
This means that the code will still throw if the relevant fields cannot be converted to `Int` or `Double`. We'll get to that.

This change breaks `toHighValueCustomerReport`, which is now forced to consider the possibility of failure:

// begin-insert: exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 } // <1>
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.7&show=file">Example 21.7 [exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.7&show=diff">(diff)</a> 
</div>
++++
// end-insert

<1> Doesn't compile because `it` is nullable.

Now if we want to just ignore badly formed input lines, we can get everything running again with `filterNotNull`:

// begin-insert: exceptions-to-values.2:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map(String::toCustomerData)
        .filterNotNull()
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.8&show=file">Example 21.8 [exceptions-to-values.2:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.8&show=diff">(diff)</a> 
</div>
++++
// end-insert

We don't have any tests to support this, and we really should write some, but for now we'll proceed without a safety net because this is an exploratory spike solution.
From here, we can use `null` to represent the other ways that we know `toCustomerData` can fail:

// begin-insert: exceptions-to-values.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toCustomerData
[source,kotlin]
----
internal fun String.toCustomerData(): CustomerData? =
    split("\t").let { parts ->
        if (parts.size < 4)
            return null
        val score = parts[3].toIntOrNull() ?:
            return null
        val spend = if (parts.size == 4) 0.0 else parts[4].toDoubleOrNull() ?:
            return null
        CustomerData(
            id = parts[0],
            givenName = parts[1],
            familyName = parts[2],
            score = score,
            spend = spend
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.9&show=file">Example 21.9 [exceptions-to-values.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.9&show=diff">(diff)</a> 
</div>
++++
// end-insert

[role="pagebreak-before"]
Note((("String::toSomethingOrNull"))) that the Kotlin standard library has helped us out by providing `String::toSomethingOrNull` functions with just this error-handling convention.
Now that this code represents all reasonable errors with `null`, we can go back to `toHighValueCustomerReport` and work out what to do with them instead of pretending that they haven't happened (pronounced `filterNotNull`).

We could abort on the first error, but it seems worth the extra effort to collect all the problem lines and report them somehow.
_Somehow_ is a bit vague, but funnily enough it has a type: `(String) -> Unit` in this case.
Which is to say, we can delegate the what-to-do to a function that accepts the errant line and doesn't affect the result.
We allude to this technique in <<errors-invoking-a-function>>.
To illustrate this, let's add a test:

// begin-insert: exceptions-to-values.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#error
[source,kotlin]
----
@Test
fun `calls back on parsing error`() {
    val lines = listOf(
        "ID\tFirstName\tLastName\tScore\tSpend",
        "INVALID LINE",
        "1\tFred\tFlintstone\t11\t1000.00",
    )

    val errorCollector = mutableListOf<String>()
    val result = lines
        .asSequence()
        .constrainOnce()
        .toHighValueCustomerReport { badLine -> // <1>
            errorCollector += badLine
        }
        .toList()

    assertEquals(
        listOf(
            "ID\tName\tSpend",
            "1\tFLINTSTONE, Fred\t1000.00",
            "\tTOTAL\t1000.00"
        ),
        result
    )
    assertEquals(
        listOf("INVALID LINE"),
        errorCollector
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.10&show=file">Example 21.10 [exceptions-to-values.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.10&show=diff">(diff)</a> 
</div>
++++
// end-insert

<1> This lambda implements `onErrorLine` in the next sample.

Let's implement that with the simplest thing that could possibly work:

// begin-insert: exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(
    onErrorLine: (String) -> Unit = {}
): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map { line ->
            val customerData = line.toCustomerData()
            if (customerData == null)
                onErrorLine(line)
            customerData
        }
        .filterNotNull()
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.11&show=file">Example 21.11 [exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.11&show=diff">(diff)</a> 
</div>
++++
// end-insert

This is still filtering out error lines, but only after passing them off to `onErrorLine`, which can decide what to do.
In `main`, we'll use it to print errors to `System.err` and then abort:

// begin-insert: exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            val errorLines = mutableListOf<String>()
            val reportLines = reader
                .asLineSequence()
                .toHighValueCustomerReport {
                    errorLines += it
                }
            if (errorLines.isNotEmpty()) {
                System.err.writer().use { error ->
                    error.appendLine("Lines with errors")
                    errorLines.asSequence().writeTo(error)
                }
                exitProcess(-1)
            } else {
                reportLines.writeTo(writer)
            }
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.12&show=file">Example 21.12 [exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersMain.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.12&show=diff">(diff)</a> 
</div>
++++
// end-insert

This is one of the few places in this book where we have fallen back on a mutable `List`.
Why here?
For example, we could have changed `toHighValueCustomerReport` to return `Pair<Sequence<String>, List<String>>`, where the second of the pairs is the errors.
The main advantage of this scheme is that it allows the caller to abort early by throwing an exception in `onErrorLine`.
For maximum flexibility, we could even have an error-handling strategy with signature `(String) -> CustomerData?` so that the caller could supply a substitute, allowing recovery from errors in any particular line.

In <<performing-io-to-passing-data>>, we went out of our way to convert `toHighValueCustomerReport` from an action to a calculation.
We then relaxed the purity a little by reading and writing from and to a `Sequence`.
Here we have introduced an error-handling function returning `Unit`, a sure sign that we have introduced an action.
Provided that action's scope is confined to error handling, and any side effects are, as in this `main`, restricted to local variables, this is another reasonable compromise.
This is an expedient error-handling solution that is flexible and communicates well, but pure it isn't.((("", startref="EVid21")))

=== Representing Errors

Now((("exceptions to values", "representing errors", id="EVrep21"))) that we are communicating _that_ our parsing can fail (by returning a nullable type), and _where_ it has failed (with a callback passing the line), can we better communicate _why_ it has failed?

Returning a result type rather than a nullable type allows us to specify what failure modes there are and provide details when they happen.
Let's change `String.toCustomerData()` to return a `Result` rather than nullable:

// begin-insert: exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toCustomerData
[source,kotlin]
----
internal fun String.toCustomerData(): Result<CustomerData, ParseFailure> =
    split("\t").let { parts ->
        if (parts.size < 4)
            return Failure(NotEnoughFieldsFailure(this))
        val score = parts[3].toIntOrNull() ?:
            return Failure(ScoreIsNotAnIntFailure(this))
        val spend = if (parts.size == 4) 0.0 else parts[4].toDoubleOrNull() ?:
            return Failure(SpendIsNotADoubleFailure(this))
        Success(
            CustomerData(
                id = parts[0],
                givenName = parts[1],
                familyName = parts[2],
                score = score,
                spend = spend
            )
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.13&show=file">Example 21.13 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.13&show=diff">(diff)</a> 
</div>
++++
// end-insert

As we did in <<throwing-to-returning>>, we create a sealed class to represent why parsing failed:

// begin-insert: exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#ParseFailure
[source,kotlin]
----
sealed class ParseFailure(open val line: String)
data class NotEnoughFieldsFailure(override val line: String) :
    ParseFailure(line)
data class ScoreIsNotAnIntFailure(override val line: String) :
    ParseFailure(line)
data class SpendIsNotADoubleFailure(override val line: String) :
    ParseFailure(line)
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.14&show=file">Example 21.14 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.14&show=diff">(diff)</a> 
</div>
++++
// end-insert

To be honest, this is overkill in this situation (a single data class carrying the failing line and a string reason would do here), but we are exemplifying excellence in error engineering.
We can fix up the callers of `toCustomerData` by invoking `onErrorLine` with the data held in the `ParseFailure` and then yielding `null` when we have an `Error`. This passes the current tests:

// begin-insert: exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(
    onErrorLine: (String) -> Unit = {}
): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map { line ->
            line.toCustomerData().recover {
                onErrorLine(line)
                null
            }
        }
        .filterNotNull()
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.15&show=file">Example 21.15 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.15&show=diff">(diff)</a> 
</div>
++++
// end-insert

What we really want, though, is to expose the `ParseFailure`.
Let's change the test first to collect the ++ParseFailure++s instead of lines with errors:

// begin-insert: exceptions-to-values.6:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt#excerpt
[source,kotlin]
----
val errorCollector = mutableListOf<ParseFailure>()
val result = lines
    .asSequence()
    .constrainOnce()
    .toHighValueCustomerReport { badLine ->
        errorCollector += badLine
    }
    .toList()
assertEquals(
    listOf(NotEnoughFieldsFailure("INVALID LINE")),
    errorCollector
)
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.16&show=file">Example 21.16 [exceptions-to-values.6:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.16&show=diff">(diff)</a> 
</div>
++++
// end-insert

Now we can change `onErrorLine` to take the failure:

// begin-insert: exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(
    onErrorLine: (ParseFailure) -> Unit = {}
): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map { line ->
            line.toCustomerData().recover {
                onErrorLine(it)
                null
            }
        }
        .filterNotNull()
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.17&show=file">Example 21.17 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.17&show=diff">(diff)</a> 
</div>
++++
// end-insert

This lets `main` report the reason and the line:

// begin-insert: exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt#excerpt
[source,kotlin]
----
if (errorLines.isNotEmpty()) {
    System.err.writer().use { error ->
        error.appendLine("Lines with errors")
        errorLines.asSequence().map { parseFailure ->
            "${parseFailure::class.simpleName} in ${parseFailure.line}"
        }.writeTo(error)
    }
    exitProcess(-1)
} else {
    reportLines.writeTo(writer)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.18&show=file">Example 21.18 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.18&show=diff">(diff)</a> 
</div>
++++
// end-insert

We might not have used the runtime type of the `ParseFailure` to process errors differently, but we have used its name in the error message, so we are at least getting some value from our little sealed class hierarchy.
If the resulting error messages aren't enough to allow marketing to fix their input, then we can use a `when` expression on the sealed class to differentiate between the types of failure, as we saw in <<error-layers>>.

At this point, everything is compiling and our tests pass, so all is good in this little part of the world at least.
Had we had more client code calling this API, or our changes were to ripple through more layers of code, we might have picked a more sophisticated refactoring strategy than changing code in one file and fixing the broken things.
Often, though, it isn't worth the effort when we can get the code compiling and passing the tests in a couple of minutes at most.
If we do find out that we have bitten off more than we can chew, it's easy to revert and take a more considered approach.

Now that the tests are passing, we should go back and make sure everything is as tidy and expressive as it can be.
In particular, we did the quickest thing we could to get everything to work again in `toHighValueCustomerReport`:

// begin-insert: exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
fun Sequence<String>.toHighValueCustomerReport(
    onErrorLine: (ParseFailure) -> Unit = {}
): Sequence<String> {
    val valuableCustomers = this
        .withoutHeader()
        .map { line ->
            line.toCustomerData().recover {
                onErrorLine(it)
                null
            }
        }
        .filterNotNull()
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
        .toList()
    return sequenceOf("ID\tName\tSpend") +
        valuableCustomers.map(CustomerData::outputLine) +
        valuableCustomers.summarised()
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.19&show=file">Example 21.19 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.19&show=diff">(diff)</a> 
</div>
++++
// end-insert

There's something about yielding `null` from the `recover` block and then skipping these with `filterNotNull` that is a little unsatisfactory. It doesn't communicate how it works directly, and gets in the way of the happy path.
We would like to be able to find a nicer formulation of the `valuableCustomers` expression, but the truth is that everything else is a bit worse in your authors' eyes.
If you do find a nice simple way, then please let us know.

Similarly, the early returns in `toCustomerData` look a bit ugly:

// begin-insert: exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toCustomerData
[source,kotlin]
----
internal fun String.toCustomerData(): Result<CustomerData, ParseFailure> =
    split("\t").let { parts ->
        if (parts.size < 4)
            return Failure(NotEnoughFieldsFailure(this))
        val score = parts[3].toIntOrNull() ?:
            return Failure(ScoreIsNotAnIntFailure(this))
        val spend = if (parts.size == 4) 0.0 else parts[4].toDoubleOrNull() ?:
            return Failure(SpendIsNotADoubleFailure(this))
        Success(
            CustomerData(
                id = parts[0],
                givenName = parts[1],
                familyName = parts[2],
                score = score,
                spend = spend
            )
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.20&show=file">Example 21.20 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.20&show=diff">(diff)</a> 
</div>
++++
// end-insert

"Proper" functional error handling would not return early, but use a `flatMap` chain.
Readers of a nervous disposition may wish to look away:

// begin-insert: exceptions-to-values.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toCustomerData
[source,kotlin]
----
internal fun String.toCustomerData(): Result<CustomerData, ParseFailure> =
    split("\t").let { parts ->
        parts
            .takeUnless { it.size < 4 }
            .asResultOr { NotEnoughFieldsFailure(this) }
            .flatMap { parts ->
                parts[3].toIntOrNull()
                    .asResultOr { ScoreIsNotAnIntFailure(this) }
                    .flatMap { score: Int ->
                        (if (parts.size == 4) 0.0
                        else parts[4].toDoubleOrNull())
                            .asResultOr { SpendIsNotADoubleFailure(this) }
                            .flatMap { spend ->
                                Success(
                                    CustomerData(
                                        id = parts[0],
                                        givenName = parts[1],
                                        familyName = parts[2],
                                        score = score,
                                        spend = spend
                                    )
                                )
                            }
                    }
            }
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.21&show=file">Example 21.21 [exceptions-to-values.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.21&show=diff">(diff)</a> 
</div>
++++
// end-insert

Your authors like a single expression even more than most people, but not if this is the `Result` (pun intended).
We could obviously simplify here by introducing more functions (`asResultOr ... flatMap` looks like it is a concept trying to get out, for example).
Some other result libraries would let us abuse coroutines or exceptions to get the same effect as the previous early returns, but without better language support to avoid the indent-per-statement, the grain of Kotlin favors early returns in these cases.
We haven't addressed it specifically in this book, but the fact that lambdas can be compiled inline and so support returns from their enclosing function encourages us to use imperative code in situations like this.
For us then, the early returns will do.

Finally, returning to `main` on our final check before check-in:

// begin-insert: exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    System.`in`.reader().use { reader ->
        System.out.writer().use { writer ->
            val errorLines = mutableListOf<ParseFailure>()
            val reportLines = reader
                .asLineSequence()
                .toHighValueCustomerReport {
                    errorLines += it
                }
            if (errorLines.isNotEmpty()) {
                System.err.writer().use { error ->
                    error.appendLine("Lines with errors")
                    errorLines.asSequence().map { parseFailure ->
                        "${parseFailure::class.simpleName} in ${parseFailure.line}"
                    }.writeTo(error)
                }
                exitProcess(-1)
            } else {
                reportLines.writeTo(writer)
            }
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.22&show=file">Example 21.22 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.22&show=diff">(diff)</a> 
</div>
++++
// end-insert

Those three levels of nested `use` obfuscate the actual structure, and that `exitProcess` from deep in the bowels of the function is also a bit iffy.
We can define our own `using` overload to address the former and pass out an exit code to solve the latter (an example of using data rather than control flow to address errors).
We can extract an extension function to print the errors too:

// begin-insert: exceptions-to-values.8:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    val statusCode = using(
        System.`in`.reader(),
        System.out.writer(),
        System.err.writer()
    ) { reader, writer, error ->
        val errorLines = mutableListOf<ParseFailure>()
        val reportLines = reader
            .asLineSequence()
            .toHighValueCustomerReport {
                errorLines += it
            }
        if (errorLines.isEmpty()) {
            reportLines.writeTo(writer)
            0
        } else {
            errorLines.writeTo(error)
            -1
        }
    }
    exitProcess(statusCode)
}

inline fun <A : Closeable, B : Closeable, C : Closeable, R> using(
    a: A,
    b: B,
    c: C,
    block: (A, B, C) -> R
): R =
    a.use {
        b.use {
            c.use {
                block(a, b, c)
            }
        }
    }

private fun List<ParseFailure>.writeTo(error: OutputStreamWriter) {
    error.appendLine("Lines with errors")
    asSequence().map { parseFailure ->
        "${parseFailure::class.simpleName} in ${parseFailure.line}"
    }.writeTo(error)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.23&show=file">Example 21.23 [exceptions-to-values.8:src/main/java/travelator/marketing/HighValueCustomersMain.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.23&show=diff">(diff)</a> 
</div>
++++
// end-insert

=== What About I/O?

That's((("", startref="EVrep21")))((("exceptions to values", "I/O errors")))((("I/O errors"))) very nearly good enough.
Before we go, though, we should think about I/O errors.
Since we introduced ++List++s and then ++Sequence++s, our report generation code does not have to worry about writing failing, because it is the calling code's responsibility to iterate over the result lines and actually perform the write.
The `main` function in this case makes the reasonable assumption that `System.out` will always be there, but when we implement the unattended job that motivated this refactor, we will have to deal with the possibility that the file or network socket may disappear even if it was open when we started.

There is a similar situation reading.
We are now iterating over each `String` in a `Sequence`.
In the test code, these are in memory, but in production they are being fetched from a file (via `System.in`).
So our `Sequence` operations are subject to failure with `IOExceptions` that the report generation is blissfully unaware of.

There is little that `toHighValueCustomerReport()` can or should do in these cases.
There is no practical way of recovering from I/O errors once we have started reading here—aborting the whole operation is the sensible thing to do.
Helpfully, now the onus is entirely on the caller (in this case `main`).
`toHighValueCustomerReport` signals the errors that it knows about (failure to parse) and how they are represented (subclasses of `ParseFailure`) through its `onErrorLine` parameter.
++IOException++s are not its responsibility.
It is `main` that is passing an I/O-backed `Sequence` into `toHighValueCustomerReport`, so `main` should be aware that `toHighValueCustomerReport` can therefore fail with an `IOException` and deal with it accordingly.
Let's add that code:

// begin-insert: exceptions-to-values.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt#main
[source,kotlin]
----
fun main() {
    val statusCode = try {
        using(
            System.`in`.reader(),
            System.out.writer(),
            System.err.writer()
        ) { reader, writer, error ->
            val errorLines = mutableListOf<ParseFailure>()
            val reportLines = reader
                .asLineSequence()
                .toHighValueCustomerReport {
                    errorLines += it
                }
            if (errorLines.isEmpty()) {
                reportLines.writeTo(writer)
                0
            } else {
                errorLines.writeTo(error)
                -1
            }
        }
    } catch (x: IOException) {
        System.err.println("IO error processing report ${x.message}")
        -1
    }
    exitProcess(statusCode)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=21.24&show=file">Example 21.24 [exceptions-to-values.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=21.24&show=diff">(diff)</a> 
</div>
++++
// end-insert

This is perhaps overkill for this application, but it shows the pattern of catching and dealing with the exceptions that we _expect_ (printing a relatively friendly message for `IOException`) but allowing all others to leak and quit the application.
If we follow the strategy from <<throwing-to-returning>>, _unexpected_ exceptions are either unrecoverable environment errors or programmer errors. In both cases, the default JVM behavior of quitting the process after printing a stack trace gives us a fighting chance of diagnosing the issue.
When we convert this to an unattended server job, we will similarly process expected errors in our top-level handler function.
We might abort on((("IOExceptions"))) `IOException` or retry the whole interaction if we think the problem may be transient.
We know that retrying won't help with parse errors, so we will have to log these and/or send notifications somewhere.
Unexpected errors in handler functions are normally allowed to leak to generic exception-handling code, which will log them and send an internal server error status before returning the thread to its pool.

=== Moving On

Very often in engineering, we have to make compromises.
In particular, attempts to make one thing simpler often complicate another.
I/O complicates our software in two ways.
It is an action, so we can't just ignore whether or when it happens as we refactor; and it is subject to errors, which we have to deal with if we want a robust system.
These errors may be simple environmental failures to read or write, or because the things that we are reading don't meet our expectations—when the marketing file ends badly formatted, for example.

Both actions and errors taint their callers, and the solution in both cases is the same: move the code closer to the entry points so that it taints less of our system.
This, then, is an area where, rather than having to compromise, we can kill two birds with one stone.
By moving I/O to the outside of our systems, we can reduce the ways that both actions and errors complicate our code.








