[[accumulating-objects-to-transformations]]
== Accumulating Objects to Transformations

Java programs usually rely heavily on mutable state, because it is so arduous in Java to define value types and transform values, even with the Streams API.
How can we translate Java code that relies upon mutable objects and side effects to Kotlin code that transforms immutable values?

=== Calculating with Accumulator Parameters

One of the most important things our travellers want to know is how much their travels will cost.
International travel makes this rather complicated.
A trip will incur costs in multiple currencies as it wends its way across borders, but the traveller wants to be able to compare overall costs to make decisions about routes and where to stay.
Therefore, Travelator summarises costs by local currency _and_ the traveller's preferred currency, and shows the overall total in the traveller's preferred currency.
It does this using the `CostSummary` and `CostSummaryCalculator` classes.
Let's take a look at how they are used, and then we'll look at their implementation.

The `Itinerary` class has an operation for summarising its costs with a `CostSummaryCalculator`.
It is used it like this:

[[cost-summary-calculator-usage]]
.Calculating a Cost Summary
// begin-insert: tags/accumulator.0:src/test/java/travelator/itinerary/Itinerary_CostTest.kt#calculation
[source,kotlin]
----
val fx: ExchangeRates = ...

val userCurrency = ...

val calculator = CostSummaryCalculator(userCurrency, fx) // <1>

fun costSummary(i: Itinerary): CostSummary {
    i.addCostsTo(calculator) // <2>
    return calculator.summarise() // <3>
}
----
// end-insert

<1> Here the code creates a `CostSummaryCalculator` with the traveller's preferred currency and a source of currency exchange rates.
<2> This tells the Itinerary to add its costs to the calculator.  In response, the Itinerary adds the cost of its elements: the journeys along the route, accommodation, and other services the traveller plans to pay for.
<3> This calls the calculator's `summarise` method to obtain the `CostSummary`, after all the costs have been collected.


We implemented the `Itinerary.addCostsTo` method as follows:

// begin-insert: tags/accumulator.0:src/main/java/travelator/itinerary/Itinerary.kt#costs
[source,kotlin]
----
data class Itinerary(
    val route: Route,
    val accommodations: List<Accommodation> = emptyList()
) {
    ...

    fun addCostsTo(calculator: CostSummaryCalculator) {
        route.addCostsTo(calculator)
        accommodations.addCostsTo(calculator)
    }

    ...
}

fun Iterable<Accommodation>.addCostsTo(calculator: CostSummaryCalculator) {
    forEach { a ->
        a.addCostsTo(calculator)
    }
}
----
// end-insert

The logic relies upon side effects to accumulate costs in the mutable state of the `CostSummaryCalculator`.

The benefit of this approach is that we can use the calculator to summarise the costs of any object in our domain model without knowing the structure of that object.
The object is responsible for adding costs to the calculator or passing the calculator to its sub-objects.
This decouples the code that asks for the costs from the code that provides the costs, allowing us to evolve them independently.

For example, a Route contains Journeys that each have a cost, but the Itinerary doesn't know or care how the Route is structured or how to collect the costs of those Journeys.  That is encapsulated by the `Route` class.


However, our use of mutable state has two significant disadvantages.

First, it introduces the possibility of aliasing errors.
If we reuse a calculator to summarise the costs of multiple entities, we have to reset its state between each calculation to stop costs collected during one calculation from being included in the next.
The type system cannot help us avoid this mistake.
The example code on <<cost-summary-calculator-usage>> may make this error.
The calculator is not local to the `costSummary` method, but `costSummary` does not reset the calculator before each calculation.
We can't tell if this is a problem or not merely by looking at the `costSummary` method.
We have to understand how that method is used in its wider context, and
as we make changes in that wider context, we have to make sure those changes do not break our assumptions about how the `costSummary` method is used.
Mutable state makes it easy to inadvertently create "spooky action at a distance" (as Einstein famously described quantum entanglement) that is not immediately obvious from the source code.

Second, the stateful computation duplicates _logic_ that is already implemented by the standard library, but makes that duplication hard to spot because the _code_ looks so different.

To see how, let's take a look at the implementation.

Here's the `CostSummary` class:

// begin-insert: tags/accumulator.0:src/main/java/travelator/itinerary/CostSummary.java
[source,java]
----
public class CostSummary {
    private final List<CurrencyConversion> lines = new ArrayList<>();
    private Money total;

    public CostSummary(Currency userCurrency) {
        this.total = Money.of(0, userCurrency);
    }

    public void addLine(CurrencyConversion line) {
        lines.add(line);
        total = total.add(line.getToMoney());
    }

    public List<CurrencyConversion> getLines() {
        return List.copyOf(lines);
    }

    public Money getTotal() {
        return total;
    }
}
----
// end-insert

A `CostSummary` is a mutable POJO (as described in <<beans-to-values>>) that holds a list of `CurrencyConversions` from local currencies to the traveller's preferred currency, and reports the total cost in the traveller's preferred currency.
It stores the total in a field rather than calculating it in the getter, so that the application can efficiently sort items by their `CostSummary`.
This means that a `CostSummary` has to update the total whenever a CurrencyConversion is added.

The CostSummaryCalculator constructs CostSummary objects, using a source of exchange rates to convert costs in local currencies to the traveller's preferred currency.
To avoid rounding errors, it first calculates the total cost in each currency, and then converts those totals to the traveller's preferred currency when asked for a summary.

// begin-insert: tags/accumulator.0:src/main/java/travelator/itinerary/CostSummaryCalculator.java
[source,java]
----
public class CostSummaryCalculator {
    private final Currency userCurrency;
    private final ExchangeRates exchangeRates;
    private final Map<Currency, Money> currencyTotals = new HashMap<>();

    public CostSummaryCalculator(
        Currency userCurrency,
        ExchangeRates exchangeRates
    ) {
        this.userCurrency = userCurrency;
        this.exchangeRates = exchangeRates;
    }
    
    public void addCost(Money cost) {
        currencyTotals.merge(cost.getCurrency(), cost, Money::add);
    }

    public CostSummary summarise() {
        var totals = new ArrayList<>(currencyTotals.values());
        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));

        CostSummary summary = new CostSummary(userCurrency);
        for (var total : totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency));
        }

        return summary;
    }

    public void reset() {
        currencyTotals.clear();
    }
}
----
// end-insert

Thus, the calculation of a `CostSummary` is spread between two classes that intertwine the following responsibilities:

* Hold information from the context of the calculation that is needed to compute the summary
* Calculate per-currency totals, so the calculation doesn't accumulate rounding errors
* Convert costs to the traveller's preferred currency
* Calculate the grand total in the traveller's preferred currency
* Sort the currency conversions in alphabetical order of the original currency code.
* Store the currency conversions and grand total, so they can be displayed to the traveller.

Such comingling of responsibilities across classes is common when one computes by mutating shared state.
We'd like to disentangle the responsibilities and simplify the implementation by not duplicating logic that is already provided by functions in the standard library.
What is the final structure we should refactor towards?

One clue is in the name of the `CostCurrencyCalculator` class.
In linguistic jargon, the class name is an _agent noun_ -- a noun derived from a verb that means no more than a thing that performs the action identified by the verb, such as _driver_ or _baker_ or _calculator_.
`CostCurrencyCalculator` is a "doer class".

Another clue is in the data that the class holds.
The traveller's preferred currency and source of exchange rates are the context for the calculation.
They are managed elsewhere in the application and held by `CostCurrencyCalculator` so that they are close at hand for its calculations.
The map of totals by currency contains transient, intermediate results of the calculation that are irrelevant after the calculation is complete, and in fact should be discarded to avoid aliasing errors.
The class doesn't _own_ any data, only holds it temporarily for operational reasons.

The `CostCurrencyCalculator` class doesn't represent a _concept_ in our application domain model, but a _function_ that we perform upon elements of our domain model.
In Kotlin, we usually implement functions not with objects but with, well, functions.

Let's refactor the calculation from mutable classes to functions that work with immutable data.


=== Refactoring to Functions over Immutable Data

Converting the two classes to idiomatic Kotlin leaves us with "Java in Kotlin syntax", a starting point from which we can start refactoring away the mutability.

// begin-insert: tags/accumulator.1:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money(0, userCurrency)
        private set

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

// begin-insert: tags/accumulator.1:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val totals = ArrayList(currencyTotals.values)
        totals.sortWith(comparing { m: Money -> m.currency.currencyCode })

        val summary = CostSummary(userCurrency)
        for (total in totals) {
            summary.addLine(exchangeRates.convert(total, userCurrency))
        }
        return summary
    }

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

We'll work from the inside, by making CostSummary an immutable value type,
and gradually push immutability outwards through the CostSummaryCalculator.

If CostSummary was immutable, client code would have to pass the list of lines to its constructor instead of calling its `addLine` method.
We can baby-step our way there by adding a secondary constructor to the CostSummary class that takes a list of lines and calls `addLine` for each one:

// begin-insert: tags/accumulator.2:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency) {
    private val _lines: MutableList<CurrencyConversion> = ArrayList()

    private val lines: List<CurrencyConversion>
        get() = _lines.toList()

    var total: Money = Money(0, userCurrency)
        private set

    constructor(
        userCurrency: Currency,
        lines: List<CurrencyConversion>
    ): this(userCurrency) {
        lines.forEach(::addLine)
    }

    fun addLine(line: CurrencyConversion) {
        _lines.add(line)
        total += line.toMoney
    }
}
----
// end-insert

Now we can change the `CostSummaryCalculator.summarise` method to call the new constructor, thereby treating the `CostSummary` class as if it was an immutable value type.
While we are about it, we'll sort the totals by currency code with Kotlin's `List.sortedBy` function, instead of a mutable ArrayList and Java's in-place sort.

// begin-insert: tags/accumulator.2:src/main/java/travelator/itinerary/CostSummaryCalculator.kt#summarise
[source,kotlin]
----
fun summarise() = CostSummary(
    userCurrency,
    currencyTotals.values
        .sortedBy { it.currency.currencyCode }
        .map { exchangeRates.convert(it, userCurrency) })
----
// end-insert

Now we can make the `CostSummary` class actually immutable:

// begin-insert: tags/accumulator.3:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(userCurrency: Currency, val lines: List<CurrencyConversion>) {
    val total = lines
        .map { it.toMoney }
        .fold(Money(0, userCurrency), Money::add)
}
----
// end-insert

We can make `CostSummary` a data class by pushing the calculation of the total out as a constructor parameter.
This will move all the calculation into the `CostSummaryCalculator`, leaving the `CostSummary` merely to hold the results of that calculation.

To do this, we first select the expression to the right of the equals sign in the definition of the `total` property, and use the IDE's "Introduce Parameter" refactoring to push the expression out as a constructor parameter:

// begin-insert: tags/accumulator.4:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(val lines: List<CurrencyConversion>, total: Money) {
    val total = total
}
----
// end-insert

The `total` property will now be highlighted as a style warning.
The IDE is has detected that the property can be declared in the constructor parameter.
It can apply an automatic fix, leaving the class declaration as:

// begin-insert: tags/accumulator.5:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
class CostSummary(val lines: List<CurrencyConversion>, val total: Money)
----
// end-insert

Now we can make `CostSummary` a data class.
Its sole responsibility is to hold the results of the calculation for filtering, sorting and display.

// begin-insert: tags/accumulator.6:src/main/java/travelator/itinerary/CostSummary.kt
[source,kotlin]
----
data class CostSummary(val lines: List<CurrencyConversion>, val total: Money)
----
// end-insert

That leaves our `CostSummaryCalculator` looking like this:

// begin-insert: tags/accumulator.6:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    private val currencyTotals = mutableMapOf<Currency, Money>()

    fun addCost(cost: Money) {
        currencyTotals.merge(cost.currency, cost, Money::plus)
    }

    fun summarise(): CostSummary {
        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        val total = lines
            .map { it.toMoney }
            .fold(Money(0, userCurrency), Money::add)

        return CostSummary(lines, total)
    }

    fun reset() {
        currencyTotals.clear()
    }
}
----
// end-insert

We can apply a similar process to eliminate the remaining shared mutable state in `CostSummaryCalculator`.
In this case we won't add a secondary constructor.
Instead, we will add an overload of the `summarise` method that takes the costs, calls `addCost` for each one, and then returns the result of the original `summarise` method.
This draws a distinction between the _context_ of cost summary calculations, which we pass to the constructor, and the parameters of a _specific_ calculation, which we pass to the `summarise` method.

// begin-insert: tags/accumulator.7:src/main/java/travelator/itinerary/CostSummaryCalculator.kt#summarise_overload
[source,kotlin]
----
fun summarise(costs: Iterable<Money>): CostSummary {
    reset()
    costs.forEach(::addCost)
    return summarise()
}
----
// end-insert

To switch over to using the new `summarise` method, we'll have to stream the costs out of the entities we want to summarise, rather than tell them to add their costs to a mutable calculator that we pass in.
We'll end up using the calculator like this:

// begin-insert: tags/accumulator.8:src/test/java/travelator/itinerary/Itinerary_CostTest.kt#calculation
[source,kotlin]
----
val fx: ExchangeRates = ...
val userCurrency = ...

val calculator = CostSummaryCalculator(userCurrency, fx)

fun costSummary(i: Itinerary) =
    calculator.summarise(i.costs())
----
// end-insert

And we'll report the costs from our domain models like this:

// begin-insert: tags/accumulator.8:src/main/java/travelator/itinerary/Itinerary.kt
[source,kotlin]
----
data class Itinerary(
    val route: Route,
    val accommodations: List<Accommodation> = emptyList()
) {

    fun costs() =
        route.costs() + accommodations.costs()

}

fun Iterable<Accommodation>.costs() =
    flatMap { it.costs() }
----
// end-insert

When all uses of `CostSummaryCalculator` in the application are using our new `summarise` method, we can move the calculation of the `currencyTotals` and `CostSummary` into that method, and delete the `addCost` and no-argument `summarise` methods:

// begin-insert: tags/accumulator.9:src/main/java/travelator/itinerary/CostSummaryCalculator.kt
[source,kotlin]
----
class CostSummaryCalculator(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    fun summarise(costs: Iterable<Money>): CostSummary {
        val currencyTotals = costs
            .groupingBy { it.currency }
            .reduce { _, a, b -> a + b }

        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map { exchangeRates.convert(it, userCurrency) }

        val total = lines
            .map { it.toMoney }
            .fold(Money(0, userCurrency), Money::add)

        return CostSummary(lines, total)
    }
}
----
// end-insert

We can see the shape of the `summarise` calculation more clearly now.
It is a pure function that is applied to a collection of costs, and evaluated in a context comprising the exchange rates and the traveller's preferred currency.
The function transforms the nested entities of our domain model into a flat collection of costs, then transforms the costs into a map of the total for each currency, transforms the totals for each currency into a list of currency conversions, and finally transforms the list of currency conversions into a `CostSummary`.

[TIP]
====
A functional program transforms its inputs into outputs.

If you can't write that easily in one step, transform the inputs into an intermediate representation that is easy to transform into the outputs.

Introduce intermediate forms and transformations until you have a pipeline of simple transformations between intermediate forms that compose to transform the inputs that you _have_ to the outputs that you _want_.
====

=== Enriching the Abstraction We Discovered

Our application does more with exchange rates and the traveller's preferred currency than summarise costs.
For example, while the user is browsing hotel rooms, we show the cost of each room in both local and preferred currencies.
That is, the hotel room browser performs a currency conversion on an individual cost.
The CostSummaryCalculator also has to perform currency conversions on individual costs in order to calculate a summary.
If we extract that functionality as a public method, which we can call `toUserCurrency`, we can initialise the hotel room browser with a CostSummaryCalculator instead of passing it both the exchange rates and preferred currency.
We can also remove the currency conversion calculation -- that we now see is duplicated code -- from the hotel room browser.

At that point, the class is no longer a calculator of cost summaries -- it holds the context for any pricing we do for an individual traveller.
So let's rename it to reflect its new-found responsibility.
At the moment, I can't think of a better name than "PricingContext", which leaves our class looking like this:

// begin-insert: tags/accumulator.11:src/main/java/travelator/itinerary/PricingContext.kt
[source,kotlin]
----
class PricingContext(
    private val userCurrency: Currency,
    private val exchangeRates: ExchangeRates
) {
    fun toUserCurrency(it: Money) =
        exchangeRates.convert(it, userCurrency)

    fun summarise(costs: Iterable<Money>): CostSummary {
        val currencyTotals = costs
            .groupingBy { it.currency }
            .reduce { _, a, b -> a + b }

        val lines = currencyTotals.values
            .sortedBy { it.currency.currencyCode }
            .map(::toUserCurrency)

        val total = lines
            .map { it.toMoney }
            .fold(Money(0, userCurrency), Money::add)

        return CostSummary(lines, total)
    }
}
----
// end-insert

.Naming
****
The name is a bit too generic for my tastes, but will do until we think of something better.
At least it's not misleading.
Renames are cheap, even in a mixed Java/Kotlin codebase, so a small incremental improvement is better than no improvement.
****

This leaves the code that used to use the CostSummaryCalculator looking like this:

// begin-insert: tags/accumulator.11:src/test/java/travelator/itinerary/Itinerary_CostTest.kt#calculation
[source,kotlin]
----
val fx: ExchangeRates = ...
val userCurrency = ...

val pricing = PricingContext(userCurrency, fx)

fun costSummary(i: Itinerary) =
    pricing.summarise(i.costs())
----
// end-insert

Now we have this concept in our codebase, it's easy to find other parts of our application that can use it.
We can move logic from those parts onto the PricingContext, making it a one-stop shop for operations that need to convert monetary amounts into the traveller's preferred currency.
However, the drawback is that the PricingContext ends up full of methods for lots of different use cases.
We want a way to separate that core abstraction we discovered from how we use it in specific use cases in our application.
Extension methods are a way to achieve that.
We explore how we use extension methods and other Kotlin features to organise our code in <<organising-code-by-domain>>.

=== Conclusion

We started this chapter with a calculation that relied on shared, mutable state.
It duplicated logic from the standard library and introduced the risk of aliasing errors.
By the end of the chapter, we had refactored the same calculation to a transformation of immutable data.

To do so, we moved mutation out of our code in two directions: outwards and inwards.
Outwards was obvious: we made the `CostSummaryCalculator` treat the `CostSummary` class as an immutable value type and then made `CostSummary` immutable, then we made users of `CostSummaryCalculator` treat it as an immutable context to a calculation, and then made `CostSummaryCalculator` immutable.
But inwards?
We replaced the imperative code that mutated collections and fields with calls to standard higher-order functions, like `groupingBy`, `fold` and `reduce`.
Under the hood those functions do mutate state, but they hide that mutation from their callers.
From outside, the functions are referentially transparent.

We can use the same approach in our own code when we need to.
Sometimes it is easier to use a mutable collection.
The standard library does not always have a higher-order function that pivots the data the way we need.
If we do need a mutable collection, we can hide that mutation inside a referentially transparent function to limit the blast radius of any potential aliasing errors.
However, every release adds more functions to the standard library, so the need diminishes over time.

Functional programming does not eliminate mutable state but instead _makes it the responsibility of the runtime_.
A functional program declares what the runtime should calculate, and lets the runtime be responsible for computing that calculation.
Kotlin is not a pure functional language, but we get a lot of benefits by following that principle where we can.
