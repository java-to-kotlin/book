[[multi-to-single-expression-functions]]
== Multi- to Single-Expression Functions

++++
<blockquote data-type="epigraph">
<p>Nat and Duncan both love Kotlin's single-expression function definitions.
When should we use this form, why might we prefer it, and what Kotlin features can we use to make more functions single expressions?</p>
</blockquote>
++++

As((("multi- to single-expression functions", "Java and Kotlin syntax")))((("{} (curly braces)")))((("braces ({})")))((("curly braces ({})"))) with Java, the code in a Kotlin function is usually { defined inside braces } and uses
`return` to define the result of the function (unless it is `Unit`, Kotlin's alias for `void`):

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#add
[source,kotlin]
----
fun add(a: Int, b: Int): Int {
    return a + b
}
----
// end-insert

If((("&#x3D; (equals sign)")))((("equals sign (&#x3D;)"))) the top level of the code is a single expression though, we can optionally drop the result type, and define the code with an expression after an equals sign:

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#addToo
[source,kotlin]
----
fun addToo(a: Int, b: Int): Int = a + b
----
// end-insert

We((("subexpressions"))) can read this as: the result of function `add` equals `a + b`.
Which makes sense for a single expression, and can also read nicely when that expression is itself composed of subexpressions:

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#max
[source,kotlin]
----
fun max(a: Int, b: Int): Int =
    when {
        a > b -> a
        else -> b
    }
----
// end-insert

This((("side effects"))) interpretation makes less sense for functions that have side effects, especially those that perform I/O or write to mutable state.
For instance:

// begin-insert: src/main/java/singleExpressionFunctions/functions.kt#printTwice
[source,kotlin]
----
fun printTwice(s: String): Unit = println("$s\n$s")
----
// end-insert

We can't read this as the result of `printTwice` equals `println(..)`, because `println` doesn't have a result, or at least it doesn't return one.
Its function is entirely side effects, as we explored in <<actions-to-calculations>>.

[[single-expresssion-functions-for-calculations]]
[TIP]
.Reserve Single-Expression Functions for Calculations
====
If((("calculations", "reserving single-expression functions for")))((("single-expression functions", seealso="multi- to single-expression functions"))) we adopt a convention of reserving single-expression functions for calculations (<<calculations>>), then we have a way of communicating our intent when we use them.
When we see a single-expression function, we will know that it isn't an action (<<actions>>), and so is much safer to refactor.

In practice this means that single-expression functions shouldn't return `Unit`, or read or write from mutable state, including performing I/O.
====

Your((("multi- to single-expression functions", "benefits of single expressions"))) authors have found that attempting to make as many functions as possible into single expressions improves our software.
For one thing, if we reserve the single-expression form for calculations, then this will decrease the proportion of our code that is <<actions,actions>>, making it easier to understand and modify.
Single expressions will also tend to be shorter than the alternative, limiting the complexity of each function.
When a function does get too large to be easily understood, single-expression style lets us more easily refactor for clarity, because there is less risk of breaking logic that depends on side effects and the order in which actions are performed.

We((("multi- to single-expression functions", "expressions versus statements")))((("expressions, versus statements", seealso="multi- to single-expression functions")))((("statements", "versus expressions"))) also prefer expressions as opposed to statements.
Expressions are _declarative_: we declare _what_ we want the function to calculate and let the Kotlin compiler and runtime decide _how_ to compute that calculation.
We don't have to run the code in a simulated computer in our heads to figure out what the function does.

For example, at the end of <<java-to-kotlin-classes>> we were left with this code for `EmailAddress`:

// begin-insert: single-expressions.0:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString() = "$localPart@$domain"

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress {
            val atIndex = value.lastIndexOf('@')
            require(!(atIndex < 1 || atIndex == value.length - 1)) {
                "EmailAddress must be two parts separated by @"
            }
            return EmailAddress(
                value.substring(0, atIndex),
                value.substring(atIndex + 1)
            )
        }
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.1">Example 9.1 [single-expressions.0:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.1">(diff)</a> 
</div>
++++
// end-insert

The((("toString method"))) `toString` method is already a nice simple single expression.
As we said at the time though, the amount of code required in the `parse` method adds insult to the injury of having to declare static methods in a companion object.
Maybe focusing on making the function into a simple single expression would help?

Before((("refactoring", "in real-life", secondary-sortas="real-life"))) we go on, we should say that lots of the refactoring sequences presented in this book are of the form "Here's one I prepared earlier."
We show you the successful take.
Real-life refactorings, like writing code from scratch, aren't like that.
We try things that don't work at all, or we take a much more circuitous route than we show in the final edit.
Because((("refactoring", "multi- to single-expression functions", id="Rmulti09")))((("multi- to single-expression functions", "step-by-step example", id="MSEstep09"))) this is an otherwise small example, we've taken this opportunity to show what actually happened when we tried to convert `parse` to a single expression.
We think that there are valuable lessons in the journey, but if you just want the destination, you should skip ahead to <<take-4>>.

=== Take 1: Inlining

Let's analyze the code and see what is preventing this function from being a nice single expression:

// begin-insert: single-expressions.1:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@') // <1>
    require(!(atIndex < 1 || atIndex == value.length - 1)) { // <2>
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress( // <3>
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.2">Example 9.2 [single-expressions.1:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.2">(diff)</a> 
</div>
++++
// end-insert

<1> Assigning to `atIndex` is a statement.
<2> The call to `require` is a statement.
<3> Creating the `EmailAddress` is a single expression, depending on `value` and `atIndex`.

The first statement is the assignment to `atIndex`.
In Kotlin, assignment is a statement, not an expression (unlike Java, where we can chain assignments).
Its position in the code also matters—it has to happen here in the code for the value of `atIndex` to be available to compile the rest of the function.
The expression bound to the variable, `value.lastIndexOf(Char)`, is a calculation though, meaning that it will always return the same result for the same arguments (`this` is considered an argument when we call methods).
As a result, we can inline the variable `atIndex` without changing the result of the function, giving:

// begin-insert: single-expressions.2:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    require(!(
        value.lastIndexOf('@') < 1 ||
            value.lastIndexOf('@') == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, value.lastIndexOf('@')),
        value.substring(value.lastIndexOf('@') + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.3">Example 9.3 [single-expressions.2:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.3">(diff)</a> 
</div>
++++
// end-insert

This version won't produce the same bytecode, nor run as fast (probably, it's notoriously difficult to second-guess HotSpot), but it will return the same result.
We still have that `require` call to deal with, though, and we seem to have made everything a bit less understandable already,  so let's revert the change and try another tack.

=== Take 2: Introduce a Function

Another way to remove the assignment statement is to have a scope where `atIndex` is always defined.
We could use a function as such a scope, because a function binds a single evaluation of its arguments to its parameters.
We can see this by selecting all but the code before the assignment and extracting a function `emailAddress`:

// begin-insert: single-expressions.3:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return emailAddress(value, atIndex)
}

private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.4">Example 9.4 [single-expressions.3:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.4">(diff)</a> 
</div>
++++
// end-insert

Now we can inline the `atIndex` variable in `parse`, because the `atIndex` parameter has captured its value for us:

// begin-insert: single-expressions.4:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    return emailAddress(value, value.lastIndexOf('@'))
}

private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.5">Example 9.5 [single-expressions.4:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.5">(diff)</a> 
</div>
++++
// end-insert

Now `parse` is a single expression, but `emailAddress(...)` isn't, so we can't declare victory just yet.
That `require` is always going to cause us some problems, because its job is to prevent evaluation from proceeding.
This is the opposite of an expression, which needs to evaluate to a value.

Often when we reach this sort of impasse when refactoring, inlining the cause of the problem will let us see the way ahead.
So let's inline `require`.
(Suspend disbelief for now; things are going to get worse before they get better.)

// begin-insert: single-expressions.5:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if (!!(atIndex < 1 || atIndex == value.length - 1)) {
        val message = "EmailAddress must be two parts separated by @"
        throw IllegalArgumentException(message.toString())
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.6">Example 9.6 [single-expressions.5:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.6">(diff)</a> 
</div>
++++
// end-insert

There's an awful lot of redundancy that we can remove here.
Alt-Enter on the `if` condition will remove the double-negation `!!`, and then Alt-Enter on the redundant `toString` will remove it.
This allows us to inline `message`, yielding:

// begin-insert: single-expressions.6:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.7">Example 9.7 [single-expressions.6:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.7">(diff)</a> 
</div>
++++
// end-insert

Now we can introduce an `else` to see the structure:

// begin-insert: single-expressions.7:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        return EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.8">Example 9.8 [single-expressions.7:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.8">(diff)</a> 
</div>
++++
// end-insert

At this point we have a function with two statements chosen by an `if`.
This is so tantalizingly close to a single expression that even the IDE can feel it: Alt-Enter on the `if`, and IntelliJ offers to "Lift return out of ‘if’”:

// begin-insert: single-expressions.8:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress {
    return if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.9">Example 9.9 [single-expressions.8:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.9">(diff)</a> 
</div>
++++
// end-insert

There it is—our single expression.
Alt-Enter on the `return` offers "Convert to expression body":

// begin-insert: single-expressions.9:src/main/java/travelator/EmailAddress.kt#emailAddress
[source,kotlin]
----
private fun emailAddress(value: String, atIndex: Int): EmailAddress =
    if ((atIndex < 1 || atIndex == value.length - 1)) {
        throw IllegalArgumentException(
            "EmailAddress must be two parts separated by @"
        )
    } else {
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.10">Example 9.10 [single-expressions.9:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.10">(diff)</a> 
</div>
++++
// end-insert

When we're defining a function as a single expression, `when` is often clearer than `if`.
IntelliJ will do this for us if we Alt-Enter on the `if`.
Here we've also removed unnecessary braces, inlined `message`, and finally converted `parse` to a single expression too:

// begin-insert: single-expressions.10:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String) =
    emailAddress(value, value.lastIndexOf('@'))

private fun emailAddress(value: String, atIndex: Int): EmailAddress =
    when {
        atIndex < 1 || atIndex == value.length - 1 ->
            throw IllegalArgumentException(
                "EmailAddress must be two parts separated by @"
            )
        else -> EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.11">Example 9.11 [single-expressions.10:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.11">(diff)</a> 
</div>
++++
// end-insert

For comparison, here is the original:

// begin-insert: single-expressions.11:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.12">Example 9.12 [single-expressions.11:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.12">(diff)</a> 
</div>
++++
// end-insert

Are we happy with the result?

Not really.
We now have _more_ code, and that `emailAddress` function doesn't feel like it's adding any value except for capturing `atIndex`.

Refactoring is often a process of exploration.
We have a goal in mind, but don't always know how it will turn out.
It's our (your authors') experience that trying to find a single-expression form of a function often improves our code, but we can't look you in the eye and say that has happened here.

We could give up on the idea, or we could push on and try to get there from here.
Instead though, let's revert and try a third approach, informed by the experience we've just gained.

=== Take 3: Let

The reason we extracted the `emailAddress` function was to give us a scope where the `atIndex` value is defined throughout the block; rather than having to be assigned to a local variable.
Where we only have one variable we need to replace, a `let` block gives us this facility without having to define a function.
We can get there in baby steps by first surrounding the code after the assignment with a `let`:

// begin-insert: single-expressions.12:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    atIndex.let {
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        return EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.13">Example 9.13 [single-expressions.12:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.13">(diff)</a> 
</div>
++++
// end-insert

Now we can lift the return out of the `let`; unfortunately IntelliJ doesn't offer to help us this time:

// begin-insert: single-expressions.13:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return atIndex.let {
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.14">Example 9.14 [single-expressions.13:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.14">(diff)</a> 
</div>
++++
// end-insert

Currently, `atIndex` in the `let` block refers to the local that we are trying to remove.
If we add a lambda parameter with the same name, it will bind to that instead:

// begin-insert: single-expressions.14:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    return atIndex.let { atIndex -> // <1>
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.15">Example 9.15 [single-expressions.14:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.15">(diff)</a> 
</div>
++++
// end-insert

<1> `Warning Name shadowed: atIndex`, which is the point

Inline the `atIndex` variable and we have our single expression:

// begin-insert: single-expressions.15:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    return value.lastIndexOf('@').let { atIndex ->
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.16">Example 9.16 [single-expressions.15:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.16">(diff)</a> 
</div>
++++
// end-insert

Now Alt-Enter on the return lets us "Convert to expression body":

// begin-insert: single-expressions.16:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress =
    value.lastIndexOf('@').let { atIndex ->
        require(!(atIndex < 1 || atIndex == value.length - 1)) {
            "EmailAddress must be two parts separated by @"
        }
        EmailAddress(
            value.substring(0, atIndex),
            value.substring(atIndex + 1)
        )
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.17">Example 9.17 [single-expressions.16:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.17">(diff)</a> 
</div>
++++
// end-insert

We've reached the point of no return!
Are we happy with the result?

Duncan is writing this, and he _is_ pretty relieved to have made it here after 15 refactoring steps.
The example has certainly served its purpose of showing some tricks to allow us to get to single-expression functions.
Nevertheless, he isn't convinced that it has demonstrated that seeking single expressions has a significant payoff.
This still seems to be a lot of code, and none of it feels like it is earning its keep.

Can we make this better by raising the level of abstraction?
Let's try a fourth tack.

[[take-4]]
=== Take 4: Stepping Back

If we step out from the mechanical refactorings, we can see that what we are doing is creating an `EmailAddress` from two nonempty strings separated by a particular character, `@` in this case.
Finding two nonempty strings separated by a character sounds like a higher-level concept that we could refactor toward.

One last revert, then, back to:

// begin-insert: single-expressions.17:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    return EmailAddress(
        value.substring(0, atIndex),
        value.substring(atIndex + 1)
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.18">Example 9.18 [single-expressions.17:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.18">(diff)</a> 
</div>
++++
// end-insert

This time we'll concentrate not on `atIndex`, but on those `substring` calls.
We'll pull them out into variables:

// begin-insert: single-expressions.18:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = value.substring(0, atIndex)
    val rightPart = value.substring(atIndex + 1)
    return EmailAddress(
        leftPart,
        rightPart
    )
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.19">Example 9.19 [single-expressions.18:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.19">(diff)</a> 
</div>
++++
// end-insert

Now, one more time with feeling. We can extract a function of all but the return [.keep-together]#statement#:

// begin-insert: single-expressions.19:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val (leftPart, rightPart) = split(value)
    return EmailAddress(
        leftPart,
        rightPart
    )
}

private fun split(value: String): Pair<String, String> {
    val atIndex = value.lastIndexOf('@')
    require(!(atIndex < 1 || atIndex == value.length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = value.substring(0, atIndex)
    val rightPart = value.substring(atIndex + 1)
    return Pair(leftPart, rightPart)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.20">Example 9.20 [single-expressions.19:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.20">(diff)</a> 
</div>
++++
// end-insert

IntelliJ turns out to be really quite clever here, making the result a `Pair` because it has two values to return.

This `split` would be a nice generic function that we might use in other places if it was parameterized with the character.
"Introduce Parameter" on the `'@'` makes that so.
We "Convert parameter to receiver" on `value` while we're there to get a little local extension function:

// begin-insert: single-expressions.20:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress {
    val (leftPart, rightPart) = value.split('@')
    return EmailAddress(
        leftPart,
        rightPart
    )
}

private fun String.split(divider: Char): Pair<String, String> {
    val atIndex = lastIndexOf(divider)
    require(!(atIndex < 1 || atIndex == length - 1)) {
        "EmailAddress must be two parts separated by @"
    }
    val leftPart = substring(0, atIndex)
    val rightPart = substring(atIndex + 1)
    return Pair(leftPart, rightPart)
}
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.21">Example 9.21 [single-expressions.20:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.21">(diff)</a> 
</div>
++++
// end-insert

Now we can introduce a `let`, as we did previously, to get:

// begin-insert: single-expressions.21:src/main/java/travelator/EmailAddress.kt#parse
[source,kotlin]
----
fun parse(value: String): EmailAddress =
    value.split('@').let { (leftPart, rightPart) ->
        EmailAddress(leftPart, rightPart)
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.22">Example 9.22 [single-expressions.21:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.22">(diff)</a> 
</div>
++++
// end-insert

This, finally, is a single-expression function that feels worth the effort!

To finish, we can apply the techniques from this chapter to `split` to make it a single expression, too.
Here then is the final `EmailAddress.kt`:

// begin-insert: single-expressions.22:src/main/java/travelator/EmailAddress.kt
[source,kotlin]
----
data class EmailAddress(
    val localPart: String,
    val domain: String
) {

    override fun toString() = "$localPart@$domain"

    companion object {
        @JvmStatic
        fun parse(value: String): EmailAddress =
            value.splitAroundLast('@').let { (leftPart, rightPart) ->
                EmailAddress(leftPart, rightPart)
            }
    }
}

private fun String.splitAroundLast(divider: Char): Pair<String, String> =
    lastIndexOf(divider).let { index ->
        require(index >= 1 && index != length - 1) {
            "string must be two non-empty parts separated by $divider"
        }
        substring(0, index) to substring(index + 1)
    }
----
++++
<div class="coderef">
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code-links.html?ref=9.23">Example 9.23 [single-expressions.22:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code-links.html?diff=9.23">(diff)</a> 
</div>
++++
// end-insert

[role="pagebreak-before"]
`splitAroundLast` felt like a better name that doesn't clash with the standard `String.split`, and hints that both sides of the split must be nonempty.
Words like _around_, which are unusual in identifiers, should prompt readers of the code to suspend their assumptions about what a function does and actually look it up.

Although `splitAroundLast` does feel like a generally applicable utility function, if we want to promote it to be public, we should probably write some unit tests for it.
We've spent enough time for today though, so we'll make a mental note that we have a `String.splitAroundLast` lying around if we ever need one, and finally commit the change.

.What Should Parse Return?
****
Before we leave this example, note that this refactoring would have been easier had `parse` not thrown an exception on error.
`throw` is an expression that returns `Nothing`—it doesn't complete—and so doesn't sit well when we are trying to decompose into expressions.
<<throwing-to-returning>> talks about this in detail, but had we written `EmailAddress` from scratch in Kotlin, we would probably have returned `EmailAddress?` from `parse`, with `null` on failure.
That doesn't sit well with Java clients, where the type system doesn't warn about nullability.
So we would probably end up with two parsing methods, one for legacy code and one for Kotlin, removing the exception version when there were no Java clients left.
We explore how to support both languages' conventions during a gradual conversion from Kotlin to Java in <<functions-to-operators>>.((("", startref="MSEstep09")))((("", startref="Rmulti09")))
****

=== Moving On

Defining((("multi- to single-expression functions", "benefits of single expressions"))) our calculations as single-expression functions lets us communicate that they are different from side-effecting actions.
Trying to express functions as a simple single expression is a useful discipline that can lead to well-factored, clean code.
To achieve single-expression form, we usually have to factor out subexpressions into their own functions.

Single-expression form is declarative: the expression describes the function's result in terms of its parameters rather than the actions that the computer must perform to compute the result.
Factoring subexpressions into their own functions prompts us to think about what those subexpressions should be denoting, and so guides us to write clearer code.
For example, `String.splitAroundLast('@')` better described what we wanted to calculate than `emailAddress(value: String, atIndex: Int)`.

At((("refactoring", "art of"))) a deeper level, this chapter is about more than single expressions; it's about how we can rearrange our code without changing its behavior.
Many different arrangements of statements and expressions will have the same behavior; refactoring is the art of finding a better one, and getting there safely.
The more arrangements we can visualize, and the more safe routes we can plan, the more options we have to make our code better.

Refactorings don't always succeed the first, second, or even third time we try them.
As developers, we don't always have the luxury of repeated attempts, but the more we practice improving our communication in code, the more often we'll get there before we have to give up and move on.
