[[beans-to-values]]
== Beans to Values

JavaBeans were introduced to allow the development of drag-and-drop GUI builders in the Visual Basic style.
A developer could drop a button onto a form, change its title and icon and then wire in an on-click handler.
Behind the scenes the GUI builder would write code to instantiate a button object and then call setters for the properties that the developer had changed.

To define a bean, a class needs a default (no-argument) constructor, getters for its properties and setters for its mutable properties.footnote:[We'll gloss over the `Serializable` requirement as even Sun never really took this seriously]
This makes a lot of sense for objects that have a lot of properties.
GUI components typically have foreground and background colors, font, label, borders, size, alignments, paddings etc.
Mostly the defaults for these properties are fine, so calling setters for just the special values minimizes the amount of code to be generated.
In fact, if we were to write a GUI toolkit today, I think we'd probably still opt for a similar mutable component model.

When JavaBeans were introduced though, we thought of most objects as mutable, not just UI components.
I mean, why notâ¸® - the point of objects was to encapsulate properties and manage the relationships between them.
They were _designed_ to solve problems like updating the width of a component when its bounds are changed, or the total of a shopping cart as items are added.
Java was quite radical at the time in having an immutable `String` class, although it couldn't help itself and still plumped for a mutable `Date`.

We have a more sophisticated understanding these days, speaking as both your authors and the industry.
We appreciate that we can use objects to represent different types of things - values, entities, services, actions, transactions etc.
And yet the default Java pattern for an object is still the JavaBean - an object with a default constructor and getters and setters for its properties.
Although it may be appropriate for a UI toolkit, this not a good default pattern.
For most things that we want to represent with objects, a value would be better.

=== What is a Value?

Value is a much overloaded term in English.
In computing we say that variables, parameters and fields have values.
In Java those values may be a primitive like `7`, or a reference to an object.
In this book though we don't consider all objects as values.
In later chapters we'll look at finer distinctions , but for now, let's just define a value to be an immutable piece of data.

So `7` is a value, `"banana"` is a value (in Java, where ``String``s are immutable), a `URI` is a value (because ``URI``'s are immutable), but a `java.util.Date` is not a value (because we can call `setYear` on the date).

An instance of an immutable `DBConnectionInfo` is a value, but an instance of `Database` is not a value, even if all its properties are immutable, because it is not a piece of data, it is a means of accessing pieces of data. <<data-to-code>> discusses the difference between data and other immutable objects.

Are JavaBeans values?
Well a bean can certainly be the value of a variable or field, but in this book we use the term value to refer to immutable data.
It is certainly possible to create immutable beans - just don't define any setter methods - but if you combine a default constructor with no mutation you have just a single possible state for every instance of the bean.footnote:[Barring side-effects]
Whilst this is useful in many circumstances it isn't helpful for representing state, so let's just say that the JavaBeans model is a fundamentally mutable one.

What about POJOs - Plain Old Java Objects?
This term refers to classes that don't have to extend from framework types in order to be useful.
Simple JavaBeans (apart from the serialization requirement) are POJOs.
Many POJOs though will not have a default constructor, but instead define constructors to initialize properties that don't have sensible defaults.
Because of this, immutable POJOs are common, unlike immutable beans, and where they just represent data they are values.
Mutable POJOs still seem to be the default though, so much so that many people consider that object-oriented programming is synonymous with mutable objects.
Mutable POJOs are not values.

Beans to Values is a snappy title, but in this chapter we're really looking at migrating from mutable to immutable data, so mutable POJOs are also in scope.

=== Why Should We Prefer Values?

We prefer immutable objects because they are much easier to reason about.
We can put them into sets or use them as map keys.
We never have to worry about a collection changing as we iterate over its contents.
We can explore different scenarios without having to deep-copy initial states, and simply implement undo and redo.
This is before we consider the issues with managing mutable state between different threads or different processes.

The advantages of plain data over more active objects are more nuanced and are discussed in detail in <<todo>>, <<todo>>, <<todo>>.

=== Migrating Beans to Values

Lets look at migrating a use of a mutable bean or POJO to a value.

Preferences in the Travelator mobile app are represented by a `UserPreferences` JavaBean.

// begin-insert: tags/beans-to-values.0:src/main/java/travelator/mobile/UserPreferences.java
[source,java]
----
public class UserPreferences {

    private String greeting;
    private Locale locale;
    private Currency currency;

    public UserPreferences() {
        this("Hello", Locale.UK, Currency.getInstance(Locale.UK));
    }

    public UserPreferences(String greeting, Locale locale, Currency currency) {
        this.greeting = greeting;
        this.locale = locale;
        this.currency = currency;
    }

    public String getGreeting() {
        return greeting;
    }

    public void setGreeting(String greeting) {
        this.greeting = greeting;
    }

    public Locale getLocale() {
        return locale;
    }

    public void setLocale(Locale locale) {
        this.locale = locale;
    }

    public Currency getCurrency() {
        return currency;
    }

    public void setCurrency(Currency currency) {
        this.currency = currency;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserPreferences that = (UserPreferences) o;
        return greeting.equals(that.greeting) &&
            locale.equals(that.locale) &&
            currency.equals(that.currency);
    }

    @Override
    public int hashCode() {
        return Objects.hash(greeting, locale, currency);
    }
}
----
// end-insert


The `Application` has a `preferences` property, which it passes to views that need it.

// begin-insert: tags/beans-to-values.0:src/main/java/travelator/mobile/Application.java#foo
[source,java]
----
public class Application {

    private final UserPreferences preferences;

    public Application(UserPreferences preferences) {
        this.preferences = preferences;
    }

    public void showWelcome() {
        new WelcomeView(preferences).show();
    }

    public void editPreferences() {
        new PreferencesView(preferences).show();
    }
    ...
}
----
// end-insert

Finally `PreferencesView` updates its `preferences` when the user makes changes.

// begin-insert: tags/beans-to-values.0:src/main/java/travelator/mobile/PreferencesView.java#foo
[source,java]
----
public class PreferencesView extends View {

    private final UserPreferences preferences;
    private final GreetingPicker greetingPicker = new GreetingPicker();
    private final LocalePicker localePicker = new LocalePicker();
    private final CurrencyPicker currencyPicker = new CurrencyPicker();

    public PreferencesView(UserPreferences preferences) {
        this.preferences = preferences;
    }

    public void show() {
        greetingPicker.setGreeting(preferences.getGreeting());
        localePicker.setLocale(preferences.getLocale());
        currencyPicker.setCurrency(preferences.getCurrency());
        super.show();
    }

    protected void onGreetingChange() {
        preferences.setGreeting(greetingPicker.getGreeting());
    }

    protected void onLocaleChange() {
        preferences.setLocale(localePicker.getLocale());
    }

    protected void onCurrencyChange() {
        preferences.setCurrency(currencyPicker.getCurrency());
    }
    ...
}
----
// end-insert

This design, whilst simple, is fraught with complications typical of mutable data.

* If the `PreferencesView` and `WelcomeView` are both active, the `WelcomeView` can get out of sync with the current values.
* `UserPreferences` equality and hashCode depend on the values of its properties, which may be changed.
So we can't reliably use it in sets or as keys in maps.
* There is nothing to indicate that the `WelcomeView` only reads from the preferences.
If it accidentally changed a value that would probably be a defect.
* Errors in the `PreferencesView` could lead to data corruption, especially if there is coupling between preference properties, or between preferences and other application data.
* If reading and writing occur on different threads we have to manage synchronisation at the preference property level.

Before we refactor to using an immutable value, let's convert `Application` and `UserPreferences` to Kotlin, which will help us see the nature of our model. `Application` is simple

// begin-insert: tags/beans-to-values.1:src/main/java/travelator/mobile/Application.kt#foo
[source,kotlin]
----
class Application(
    private val preferences: UserPreferences
) {
    fun showWelcome() {
        WelcomeView(preferences).show()
    }

    fun editPreferences() {
        PreferencesView(preferences).show()
    }
    ...
}
----
// end-insert

`UserPreferences` is more complicated.
At the time of writing, IntelliJ yields this

// begin-insert: tags/beans-to-values.1:src/main/java/travelator/mobile/UserPreferences.kt
[source,kotlin]
----
class UserPreferences @JvmOverloads constructor(
    var greeting: String = "Hello",
    var locale: Locale = Locale.UK,
    var currency: Currency = Currency.getInstance(Locale.UK)
) {
    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val that = o as UserPreferences
        return greeting == that.greeting && locale == that.locale && currency == that.currency
    }

    override fun hashCode(): Int {
        return Objects.hash(greeting, locale, currency)
    }
}
----
// end-insert

That `@JVMOverloads` annotation tells the compiler to generate constructors allowing combinations of `greeting`, `locale` or `currency` to be defaulted - which wasn't what our original Java did - it had just two constructors.
Arguably the conversion is more flexible, but it is unnecessary complication, so let's simplify.
At the same time we can implement `equals` and `hashCode` automatically by making it a data class.

// begin-insert: tags/beans-to-values.2:src/main/java/travelator/mobile/UserPreferences.kt
[source,kotlin]
----
data class UserPreferences(
    var greeting: String,
    var locale: Locale,
    var currency: Currency
) {
    constructor() : this(
        greeting = "Hello",
        locale = Locale.UK,
        currency = Currency.getInstance(Locale.UK)
    )
}
----
// end-insert

Why not make `Application` a data class too?
Well it didn't have equality and hashCode defined in Java version - it's unlikely that we are going to be treating ``Application``s as things to be put into collections.
It's best to save the `data` annotation for when it helps communicate our intent or reduces the amount of code we have to maintain.

At this stage we haven't changed the functioning of our application, just simplified its expression.
Those `var` (as opposed to `val`) properties are the sign that we have mutable data.
It's worth reminding ourselves at this point to that the Kotlin compiler is going to generate a private field, a getter method, and a setter method for each property, so that our Java continues to see the data class as a bean.

How now do we make `UserPreferences` immutable?
After all, we do want the preferences seen in the app to reflect any changes the user makes.
The answer is to move the mutation.

.Directions in Code
****
Your authors disagree about the orientation of our software systems.

Duncan (who is writing this) thinks mainly in terms of call stacks, which confusingly grow downwards.
So entry points (`main` and event handlers) are at the top of the system, code called from there is at a lower level, which calls still-lower level code and so on until we reach CPU instructions and finally microcode.
Confusingly Java stack traces show the entry point at the bottom, but we seem to be able to cope.

Nat apparently thinks more outside-in.
For him both entry points and exit points (say database calls or other IO) are at a high level.
Raw CPU is the inner level.
No, I don't get it either.

In this section at least, we're going with my interpretation.
With luck, by the time we finish the book, we'll have settled on some wording that we can both agree on.
****

In common with many of the refactorings in this book, we're going to move the problematic thing (in this case mutation) up.
Which is to say, towards the entry point, or into the higher-level, more application-specific code.
Instead of mutating the preferences, we are going to update the reference in the `Application`.
The reference we're going to use will be an updated copy returned by `PreferencesView`.

Instead of making all the changes at once, let's start by converting `PreferencesView` to Kotlin and return the existing mutable preferences from a `showModal` method

// begin-insert: tags/beans-to-values.3:src/main/java/travelator/mobile/PreferencesView.kt#foo
[source,kotlin]
----
class PreferencesView(
    private val preferences: UserPreferences
) : View() {
    private val greetingPicker = GreetingPicker()
    private val localePicker = LocalePicker()
    private val currencyPicker = CurrencyPicker()

    fun showModal(): UserPreferences {
        greetingPicker.greeting = preferences.greeting
        localePicker.locale = preferences.locale
        currencyPicker.currency = preferences.currency
        show()
        return preferences
    }

    protected fun onGreetingChange() {
        preferences.greeting = greetingPicker.greeting
    }

    protected fun onLocaleChange() {
        preferences.locale = localePicker.locale
    }

    protected fun onCurrencyChange() {
        preferences.currency = currencyPicker.currency
    }
    ...
}
----
// end-insert

Now make `Application.preferences` a mutable property, set from the result of `showModal()`

// begin-insert: tags/beans-to-values.3:src/main/java/travelator/mobile/Application.kt#foo
[source,kotlin]
----
class Application(
    private var preferences: UserPreferences
) {
    ...

    fun editPreferences() {
        preferences = PreferencesView(preferences).showModal()
    }
    ...
}
----
// end-insert

This gives us the worst of both worlds, a mutable reference to mutable data, but we haven't finished.
`PreferencesView` can now copy rather than mutate its preferences.

// begin-insert: tags/beans-to-values.4:src/main/java/travelator/mobile/PreferencesView.kt#foo
[source,kotlin]
----
class PreferencesView(
    private var preferences: UserPreferences
) : View() {
    private val greetingPicker = GreetingPicker()
    private val localePicker = LocalePicker()
    private val currencyPicker = CurrencyPicker()

    fun showModal(): UserPreferences {
        greetingPicker.greeting = preferences.greeting
        localePicker.locale = preferences.locale
        currencyPicker.currency = preferences.currency
        show()
        return preferences
    }

    protected fun onGreetingChange() {
        preferences = preferences.copy(greeting = greetingPicker.greeting)
    }

    protected fun onLocaleChange() {
        preferences = preferences.copy(locale = localePicker.locale)
    }

    protected fun onCurrencyChange() {
        preferences = preferences.copy(currency = currencyPicker.currency)
    }
    ...
}
----
// end-insert

Now there are no setters called on preferences - we can make it a proper value.
While we're there we'll get rid of that irritating default constructor by inlining it into the one place in the code that it was used.

// begin-insert: tags/beans-to-values.5:src/main/java/travelator/mobile/UserPreferences.kt
[source,kotlin]
----
data class UserPreferences(
    val greeting: String,
    val locale: Locale,
    val currency: Currency
)
----
// end-insert

What have we achieved?
We've replaced two immutable references to a mutable value, with two mutable references to immutable values.
Now we can see at a glance which views can update the preferences, and if we had to manage updates across threads we could do that at the application level.
Having a mutable reference in `PreferencesView` is a bit irritating, we can fix that by not holding a reference at all, but instead passing the preferences into `showModal`.
In this scheme there is no point in updating the individual preference properties when their respective pickers update.

// begin-insert: tags/beans-to-values.6:src/main/java/travelator/mobile/PreferencesView.kt#foo
[source,kotlin]
----
class PreferencesView : View() {
    private val greetingPicker = GreetingPicker()
    private val localePicker = LocalePicker()
    private val currencyPicker = CurrencyPicker()

    fun showModal(preferences: UserPreferences): UserPreferences {
        greetingPicker.greeting = preferences.greeting
        localePicker.locale = preferences.locale
        currencyPicker.currency = preferences.currency
        show()
        return UserPreferences(
            greeting = greetingPicker.greeting,
            locale = localePicker.locale,
            currency = currencyPicker.currency
        )
    }
    ...
}
----
// end-insert

// begin-insert: tags/beans-to-values.6:src/main/java/travelator/mobile/Application.kt#foo
[source,kotlin]
----
class Application(
    private var preferences: UserPreferences
) {
    ...

    fun editPreferences() {
        preferences = PreferencesView().showModal(preferences)
    }
    ...
}
----
// end-insert

It may seem a bit of waste to create a new `UserPreferences` to return from `showModal` even if nothing has changed.
If you're used to sharing mutable objects it may even seem dangerous.
In the world of values though, two `UserPreferences` with the same values are to most intents and purposes the same object, and you would have to be in a very constrained environment to detect the extra allocation.

=== Conclusions

In this chapter we've examined some of the advantages of immutable values over mutable data.
We've seen how to migrate mutation upwards (towards our applications entry points) by replacing immutable references to mutable objects with mutable references to immutable objects.
The end result is that less of our code has to deal with the consequences and complications of mutability.

That said, JavaBeans were designed for use in user-interface frameworks, and UIs are in many ways the last bastion of mutable objects.
If we had more exacting liveness requirements, shared objects with change events might be a better pattern than immutable values.

=== See Also

TODO Relationship to other chapters.


