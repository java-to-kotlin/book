[[functions-to-extension-functions]]
== Functions to Extension Functions

Kotlin has a special form of function called an _extension function_ that is called like a method but is in fact (usually) a top-level function.
It's easy to convert from a normal function to an extension function, and back.
When should we prefer one to the other?

=== Functions and Methods

Object-oriented programming is the art of solving problems by sending messages to objects.
Want to know the length of `myString`?
Send it a message `myString.length()` asking it.
Want to print that string to the console?
Put the string in a message and ask an object representing the console to print it for you - `System.out.println(myString)`.
In a classic OO languages, we define how an object reacts to a message by defining methods on classes.
Methods are bound to their class, and have access to the members (fields and other methods) associated with a particular instance.
When we invoke a method, the runtime arranges for the correct version of a method to be called (depending on the runtime type of the object), and for it to have access to instance state.

In contrast, in functional programming we solve problems by calling functions with values.
We find the length of `myString` by passing it to a `length(myString)` function.
We print to the console with `println(myString)`, and if we wanted to print somewhere else we would pass that to the function: `println(myString, System.err)`.
Functions are not defined _on_ a type - function parameters and results _have_ a type.

The paradigms have pros and cons, but for now let's just consider discoverability and extensibility.

Here is a `Customer` type:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#customer
[source,kotlin]
----
data class Customer(
    val id: String,
    val givenName: String,
    val familyName: String
) {
    ...
}
----
// end-insert

This is a class, so straight away we know that we can send messages to ask for the `id`, `givenName` and `familyName`.
What about other operations?
In a class-based system we only have to scroll down to see another message that we can send:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#customerFull
[source,kotlin]
----
data class Customer(
    val id: String,
    val givenName: String,
    val familyName: String
) {
    val fullName get() = "$givenName $familyName"
}
----
// end-insert

Often we don't even get as far as looking at the definition.
If we have a variable `val customer: Customer`, we can type `customer.` and our IDE will eagerly tell us that we can call `id`, `givenName`, `familyName` or `fullName`.
In fact, this auto-complete is in many ways better than looking at the class definition, because it also shows us supertype and other operations (`equals`, `copy` etc) that are defined in other files or implicit in the language.

In a functional decomposition, `fullName` would be a function, and, if we suspect it exists, we would have to search our codebase for it.
In this case it will be a function where the only argument is of type `Customer`.
It's surprisingly hard to get IntelliJ to help us - "Find Usages" grouped by parameter type will do the job, but it's hardly convenient.
IDEs for functional languages apparently do a better job, but will have to resort to conventions to decide when to present a function according to the type of multiple parameters.
In practice, we expect to find the definition of `Customer` and its fundamental operations close together in the source, perhaps in the same file or at least namespace, so we might navigate there and find the functions where we expect them, but our tools haven't been very helpful.

Score one to OO for discoverability then.
What about extensibility?
What happens when we want to add an operation to `Customer`?
Marketing would like to render the name reversed with the `familyName` in upper case in some report they would like.
(You may notice that whenever we need a simple but arbitrary example we blame marketing.)

If we own the code then we can just add a method:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#postalName
[source,kotlin]
----
data class Customer(
    val id: String,
    val givenName: String,
    val familyName: String
) {
    val fullName get() = "$givenName $familyName"
    fun nameForMarketing() = "${familyName.toUpperCase()}, $givenName}"
}
----
// end-insert

If we don't own the code, then we can't add a method, and so we have to fall back on a function.
In Java we might have a collection of these static functions in a class called `Marketing`, or `CustomerUtils`.
In Kotlin we can make them top-level functions (see <<static-methods-to-top-level-functions>>), but the principle is the same:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketing
[source,kotlin]
----
fun nameForMarketing(customer: Customer) =
    "${customer.familyName.toUpperCase()}, $customer.givenName}"
----
// end-insert

What of the functional solution?
Well this is the functional solution too.
So the functional solution is arguably better for extensibility, because extension operations are indistinguishable from those (like `fullName`) provided by the original authors, whereas the OO solution makes us look for two different types of implementation, methods and functions.

Even if we _do_ own the code for the `Customer` class, we should be wary of adding methods like `nameForMarketing`.
If the class `Customer` is a fundamental domain class in our application: lots of other code will depend on it.
Adding a report for marketing shouldn't force us to recompile and retest everything, but it will if we add a method.
So it's better that we keep `Customer` as small as possible and add keep non-core operations as external functions, even if this means they are not as discoverable as methods.

In Kotlin, those functions don't have to be as hard to find as we've made out though - they can be extension functions.

=== Extension Functions

Kotlin's extension functions look like methods, but are in fact just functions.
(As we saw in <<static-methods-to-top-level-functions>>, technically they are _also_ methods, because on the JVM all code has to be a defined in a method.
In <<extension-functions-as-methods>> we'll see that extension functions can in fact also be non-static methods of another class.)

As their name implies, extension functions give us the ability to _extend_ the operations available on a type.
They do this while supporting the intuitive, dot-means-send-a-message calling convention of methods, which allows them to be discoverable in the same Ctrl-Space way.

So, if we define an extension function:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketingExt
[source,kotlin]
----
fun Customer.nameForMarketing() = "${familyName.toUpperCase()}, $givenName}"
----
// end-insert

then we can call it as if it is a method

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#callingExt
[source,kotlin]
----
val s = customer.nameForMarketing()
----
// end-insert

and IntelliJ will auto-suggest it along with the actual methods.

Java isn't quite so helpful - it just sees the extension function as a static function:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#callingExt
[source,java]
----
var s = Extension_functionsKt.nameForMarketing(customer); // <1>
----
// end-insert

<1> `Extension_functionsKt` is the name of the class containing our top-level declarations as static methods - see <<static-methods-to-top-level-functions>>.

Interestingly, we can't call the function in the same way from Kotlin:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#error
[source,kotlin]
----
nameForMarketing(customer) // doesn't compile <1>
----
// end-insert

<1> `Unresolved reference. None of the following candidates is applicable because of receiver type mismatch:
public fun Customer.nameForMarketing(): String ...`.

_Receiver_, by the way, is the name that Kotlin gives to `this` in an extension function.

[TIP]
.Function Types for Methods and Extension Functions
====
While we can't call extension functions as normal functions in Kotlin, we can assign them to normal function references. So the following compiles:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#references
[source,kotlin]
----
val methodReference: (Customer.() -> String) =
    Customer::fullName
val extensionFunctionReference: (Customer.() -> String) =
    Customer::nameForMarketing

val methodAsFunctionReference: (Customer) -> String =
    methodReference
val extensionAsFunctionReference: (Customer) -> String =
    extensionFunctionReference
----
// end-insert

We can invoke these as expected:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke1
[source,kotlin]
----
customer.methodReference()
customer.extensionFunctionReference()

methodAsFunctionReference(customer)
extensionAsFunctionReference(customer)
----
// end-insert

We can also use the _with-receiver_ references as if they took the receiver as the first argument:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke2
[source,kotlin]
----
methodReference(customer)
extensionFunctionReference(customer)
----
// end-insert

We cannot, however, call the plain references as if they had a receiver.
Both of these lines fail to compile, with an `Unresolved reference` error:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#invoke3
[source,kotlin]
----
customer.methodAsFunctionReference()
customer.extensionAsFunctionReference()
----
// end-insert

====

Note that extension functions don't have any special access to the private members of the class that they are extending, they can only have the same privileges as normal functions in their scope.

=== Extension Properties

Kotlin also supports extension properties.
As we discuss in <<methods-to-properties>>, Kotlin property accessors are actually method calls.
In the same way that extension functions are static functions that are called like methods, extension properties are static functions that are called like properties, which are in turn methods.
Extension properties can't store any data because they don't really add fields to their class - they can only be computed.

`nameForMarketing` could have been defined as an extension property:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nameForMarketingProp
[source,kotlin]
----
val Customer.nameForMarketing get() = "${familyName.toUpperCase()}, $givenName}"
----
// end-insert

In fact, it probably _should_ be a property, as it is a simple calculation ( <<calculations>>) and so always returns the same result.

Most of what we have to say about extension functions applies to extension properties unless we specifically distinguish between them.

[WARNING]
.Extensions are Not Polymorphic
====
Although invoking an extension function looks like a method call, it is not, in fact, sending a message to an object.
For polymorphic method calls, Kotlin uses the dynamic type of the receiver at runtime to select the method to execute.
For extensions, Kotlin uses the static type of the receiver at compile time to select the function to call.

If we need to use extensions in a polymorphic way, we can often achieve this by calling polymorphic methods from our extension functions.
====

=== Conversions

So far we have seen extension functions adding operations to a type.
Conversions from one type to another are a common case.
Travelator needs to convert customer details to and from JSON and XML.
How should we convert from `JsonNode` to `Customer`?

We could add a constructor: `Customer(JsonNode)` that knows how to extract the relevant data, but it really doesn't feel right to pollute our `Customer` class with dependencies on a specific JSON library, and then maybe an XML parser, and then what?
The same argument applies to adding conversions to the `JsonNode` class.
Even if we _could_ change its code, pretty soon it would be unmanageable with all the `JsonNode.toMyDomainType()` methods.

In Java, we would write a class of utility functions of the form:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#toCustomer
[source,java]
----
static Customer toCustomer(JsonNode node) {
        ...
}
----
// end-insert

Or with Nat and Duncan's preferred naming convention:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#customerFrom
[source,java]
----
static Customer customerFrom(JsonNode node) {
        ...
}
----
// end-insert

.Naming Conversions
****
A function converting a `JsonNode` to a `Customer` might be called `nodeToCustomer`, `createCustomer`, `toCustomer`, `customerFrom` or `customerFor`.
Why should we pick `customerFrom`?

Let's examine the alternatives where they are invoked:

[source,java]
----
var customer = nodeToCustomer(node)
----

This is OK, but the repetition of `node` is irritating.

[source,java]
----
var customer = createCustomer(node)
----

This is better, but doesn't hint at the relationship between `node` and `customer`.

[source,java]
----
var customer = toCustomer(node)
----

This lets us know that `node` contains everything we need to create a `Customer`, but doesn't flow in English.

[source,java]
----
var customer = customerFrom(node)
----

This flows, and hints that we are extracting the data for `customer` from `node`.

[source,java]
----
var customer = customerFor(node)
----

This also flows, but suggests a different relationship than parsing.
_For_ implies a lookup operation: `phoneNumberFor(customer)`, or composition: `wheelFor(bicycle)`.

Do these distinctions actually matter?
Mostly no, and we should be wary of leaning on the subtleties of English when our teammates and clients may not be native speakers.
But there is no point in not using the bestest words that we can.
Compared to `createCustomer(node)`, the use of `customerFrom(node)` may help a reader to understand what is happening in one pass rather than two, or prevent an incorrect assumption that leads to an error.
We can make small but significant improvements by looking at how our code reads in context.
****

Calling the conversions individually isn't too horrible:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#calling
[source,java]
----
var customer = customerFrom(node);
var customer2 = toCustomer(node);
----
// end-insert

If we need to combine functions though, things start to go awry:

// begin-insert: src/main/java/extensionFunctions/SomeJava.java#chaining
[source,java]
----
var marketingLength = nameForMarketing(customerFrom(node)).length();
----
// end-insert

We're all developers here (except our poor editor Sarah), and used to reading function invocations.
So it's easy to underestimate the cognitive load of searching for the innermost call and working your way out through function and method calls to compute how an expression evaluates.
Not what it evaluates to, just the order in which it evaluates.
In Kotlin, we can write the conversion as an extension on `JsonNode` and enjoy a soothing flow from left to right:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#chaining
[source,kotlin]
----
fun JsonNode.toCustomer(): Customer = SOME_CODE()

val marketingLength = jsonNode.toCustomer().nameForMarketing().length
----
// end-insert

Ahh ... that's much more readable.

=== Nullability

One major difference between invoking a method and calling a function is in the treatment of `null` references.
If we have a reference that is `null`, we can't send a message to it, because there is nothing to send a message to.
Some runtimes will allow you to pretend by silently ignoring such calls, but not the JVM, which signals its disgust with a `NullPointerException`.
In contrast, we are able to have `null` _parameters_.
We may not know what to do with them, but they don't prevent the runtime from finding code to invoke.

So whilst `thing.method()` and `thing.extensionFunction()` look like equivalent calls, `method` can never be called if `thing` is `null`, whereas `extensionFunction` can.
In order to allow this we have to declare the receiver as nullable.
Here's an example from the code to convert an XML `Element` to a `Customer`.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#xml
[source,kotlin]
----
fun Element?.toCustomer(): Customer? = this?.let { element ->
    Customer(
        element.attribute("id"),
        element.attribute("first-name"),
        element.attribute("last-name")
    )
}
----
// end-insert

Inside a method, `this` can never be `null`.
Inside an extension function declared on a nullable type, it can be, so we use `this?.let` to create the customer only if the receiver isn't `null`.

Extension functions on nullable types can significantly reduce the noise of properly handling `null` values in Kotlin, again reducing the cognitive load of understanding what our code is doing.

=== Generics

So far we have looked at extension functions defined on concrete types.
Just as with normal functions, they can have generic parameters though, and things become really interesting when the receiver is generic.

Here's a useful extension function that for some reason isn't part of the standard library.
It is defined as an extension on any type, including `null` references.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed
[source,kotlin]
----
fun <T> T.printed(): T = this.also(::println)
----
// end-insert

(This definition, by the way, breaks a rule of thumb we explain in <<single-expresssion-functions-for-calculations>>.
We like to live on the edge.)

We can use this when we want to debug the value of an expression in place.
For example, remember this:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed2
[source,kotlin]
----
val marketingLength = jsonNode.toCustomer().nameForMarketing().length
----
// end-insert

If we need to see the value of the customer for debugging we would normally need to pull out a variable:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed3
[source,kotlin]
----
val customer = jsonNode.toCustomer()
println(customer)
val marketingLength = customer.nameForMarketing().length
----
// end-insert

With `printed` we have a function that prints the value of the receiver and returns it unchanged, so that we can write:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#printed4
[source,kotlin]
----
val marketingLength = jsonNode.toCustomer().printed().nameForMarketing().length
----
// end-insert

which is much less disruption, and easy to search for before we check in.

Note that even if we had been able to add a method to `Any?`, there is no way for a method to say that it returns the same type as its receiver.
Had we written:

[source,kotlin]
----
class Any {
    fun printed() = this.also(::println)
}

----

the return type would have been `Any`, and so we could not then invoke `nameForMarketing()` etc on the result.

We can also define extension functions for specialised generic types, for example `Iterable<Customer>`:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#familyNames
[source,kotlin]
----
fun Iterable<Customer>.familyNames(): Set<String> =
    this.map(Customer::familyName).toSet()
----
// end-insert

This extension function is applicable to any `Collection<Customer>`, but not to collections of other types.
This allows us to use collections to represent domain concepts rather than defining our own types - see <<encapsulated-collections-to-typealiases>>.
We can also extract parts of collections pipelines into named operations - see <<extracting-part-of-a-pipeline>>.

=== Use in the Standard Library

The Kotlin library authors faced the same issue extending types that they don't own as we do - in their case the types provided by the Java standard library.
While they sometimes resorted to compiler trickery, a lot of the Kotlin standard library is extension functions.
This includes fundamental functions like `map`, `filter` and `reduce` (defined as extensions on `Iterable`), and the scope functions `let`, `run`, `with`, `apply` and `also`. There is also an extension function `Any?.toString`.
This returns the `String` representation of any reference, including `null`.

[WARNING]
.toString on Nullable Types
====
Where a method and extension function are both in scope and visible, the compiler will generate a call to the method, not the function.
As we've discussed, a method can never be safely called on a nullable type, but an extension function can.
So to aid debugging, Kotlin defines a `toString` extension function, the code for which is effectively:

[source,kotlin]
----
fun Any?.toString(): String =
    this?.let { it.toString() }
    ?: "null"
----

This is called if you invoke `toString` on a nullable type:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#nullableToString
[source,kotlin]
----
val customer: Customer = SOME_CODE()
val customerString: String = customer.toString()
// Calls Customer.toString()

val nullableCustomer: Customer? = SOME_CODE()
val nullableCustomerString: String = nullableCustomer.toString()
// Calls Any?.toString()
----
// end-insert

Here `nullableCustomerString` will be either the result of calling the `Customer.toString` method if customer is not `null`, or otherwise the `String` with value `"null"`.
That's a reference pointing to not to `null`, but to the characters "null".

Being able to call `toString()` on `null` is a neat trick.
But, beware that if you have initialised a `String` by calling `toString()` on a reference, when you print it and see "null", it may be a `String` with those characters, not a `null` reference.
This can lead to hours of debugging - ask us how we know!
====

[[extension-functions-as-methods]]
=== Extension Functions as Methods

We normally define extension functions as top-level functions.
They can, though, be defined _inside_ a class definition.
In this case they can access the members of their own class, and 'extend' another type.

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#jsonWriter
[source,kotlin]
----
class JsonWriter(
    private val objectMapper: ObjectMapper,
) {
    fun Customer.toJson(): JsonNode = objectMapper.valueToTree(this)
}
----
// end-insert

Here `Customer.toJson` has access to two values of `this`.
It can refer to the `Customer` receiver of the extension function, or the `JsonWriter` instance of the method.
In longhand, the function is:

// begin-insert: src/main/java/extensionFunctions/extension-functions.kt#this
[source,kotlin]
----
fun Customer.toJson(): JsonNode =
    this@JsonWriter.objectMapper.valueToTree(this@toJson)
----
// end-insert

This isn't a technique that we should use too often (it can be hard to interpret which receiver applies without IDE assistance), but it can simplify code by allowing the simple left-to-right reading of extension functions while hiding details that would complicate things.
In particular, it allows DSLs to hide details (like the `ObjectMapper`) that clients shouldn't be bothered by.

[[refactoring-to-extension-functions]]
=== Refactoring to Extension Functions

The actual mechanics of converting a static method to an extension function are simple, but we have to hone a sense for where an extension function will make things better.
Let's work our way through a part of Travelator and see how we do.

Those clever people in marketing have come up with a spreadsheet that gives customers a score according to how valuable they are to the company - their expected future spending.
They're constantly tweaking the algorithm, so they don't want to us to automate that.
Instead, they export a tab-separated file of customer data, score and spend, and we produce a summary report from that file.
Here are our tests:

// begin-insert: tags/functions-to-extension-methods.0:src/test/java/travelator/marketing/HighValueCustomersReportTests.java
[source,java]
----
class HighValueCustomersReportTests {

    @Test
    public void test() throws IOException {
        List<String> input = List.of(
            "ID\tFirstName\tLastName\tScore\tSpend",
            "1\tFred\tFlintstone\t11\t1000.00",
            "4\tBetty\tRubble\t10\t2000.00",
            "2\tBarney\tRubble\t0\t20.00",
            "3\tWilma\tFlintstone\t9\t0.00"
        );
        List<String> expected = List.of(
            "ID\tName\tSpend",
            "4\tRUBBLE, Betty\t2000.00",
            "1\tFLINTSTONE, Fred\t1000.00",
            "\tTOTAL\t3000.00"
        );
        check(input, expected);
    }

    @Test
    public void emptyTest() throws IOException {
        List<String> input = List.of(
            "ID\tFirstName\tLastName\tScore\tSpend"
        );
        List<String> expected = List.of(
            "ID\tName\tSpend",
            "\tTOTAL\t0.00"
        );
        check(input, expected);
    }

    @Test
    public void emptySpendIs0() {
        assertEquals(
            new CustomerData("1", "Fred", "Flintstone", 0, 0D),
            HighValueCustomersReport.customerDataFrom("1\tFred\tFlintstone\t0")
        );
    }

    private void check(
        List<String> inputLines,
        List<String> expectedLines
    ) throws IOException {
        var output = new StringWriter();
        HighValueCustomersReport.generate(
            new StringReader(String.join("\n", inputLines)),
            output
        );
        assertEquals(String.join("\n", expectedLines), output.toString());
    }
}
----
// end-insert

You can see that we haven't gone to town on these, as marketing do have habit of changing their minds, but in essence the report needs to list the customers who have a score of ten or more, sorted by spend, with a final total line.

Here is the code:

// begin-insert: tags/functions-to-extension-methods.0:src/main/java/travelator/marketing/HighValueCustomersReport.java
[source,java]
----
public class HighValueCustomersReport {

    public static void generate(Reader reader, Writer writer) throws IOException {
        List<CustomerData> valuableCustomers = new BufferedReader(reader).lines()
            .skip(1) // header
            .map(line -> customerDataFrom(line))
            .filter(customerData -> customerData.score >= 10)
            .sorted(comparing(customerData -> customerData.score))
            .collect(toList());

        writer.append("ID\tName\tSpend\n");
        for (var customerData: valuableCustomers) {
            writer.append(lineFor(customerData)).append("\n");
        }
        writer.append(summaryFor(valuableCustomers));
    }

    private static String summaryFor(List<CustomerData> valuableCustomers) {
        var total = valuableCustomers.stream()
            .mapToDouble(customerData -> customerData.spend)
            .sum();
        return "\tTOTAL\t" + formatMoney(total);
    }

    static CustomerData customerDataFrom(String line) {
        var parts = line.split("\t");
        double spend = parts.length == 4 ? 0 :
            Double.parseDouble(parts[4]);
        return new CustomerData(
            parts[0],
            parts[1],
            parts[2],
            Integer.parseInt(parts[3]),
            spend
        );
    }

    private static String lineFor(CustomerData customer) {
        return customer.id + "\t" + marketingNameFor(customer) + "\t" +
            formatMoney(customer.spend);
    }

    private static String formatMoney(double money) {
        return String.format("%#.2f", money);
    }

    private static String marketingNameFor(CustomerData customer) {
        return customer.familyName.toUpperCase() + ", " + customer.givenName;
    }
}
----
// end-insert

You can see that this is already a very functional (as opposed to object-oriented) expression of the solution.
This will make it easy to convert to top-level functions, and top-level functions are easy to convert to extension functions.

But first, here is `CustomerData`:

// begin-insert: tags/functions-to-extension-methods.0:src/main/java/travelator/marketing/CustomerData.java#foo
[source,java]
----
public class CustomerData {
    public final String id;
    public final String givenName;
    public final String familyName;
    public final int score;
    public final double spend;

    public CustomerData(
        String id,
        String givenName,
        String familyName,
        int score,
        double spend
    ) {
        this.id = id;
        this.givenName = givenName;
        this.familyName = familyName;
        this.score = score;
        this.spend = spend;
    }

    @Override
    public boolean equals(Object o) {
        ...
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, givenName, familyName, score, spend);
    }
}
----
// end-insert

This isn't trying to represent everything about a customer, just the data we care about for this report, which is why whoever wrote it just used fields.
(<<methods-to-properties>> discusses this trade-off.)
I doubt we (erm, whoever wrote it) would even have bothered with `equals` and `hashCode` had it not been for the `emptySpendIs0` test.
That `double` for spend looks suspicious too, but it hasn't caused us any problems yet, so we'll suspend our disbelief and just convert the whole thing to a Kotlin data class (see <<beans-to-values>> before we go on.

Normally that would be a really simple job because of the excellent interop, but it turns out that (at the time of writing) the converter cannot believe that anyone would stoop to raw field access. So it doesn't update Java that accesses, for example `customerData.score`, to call `customerData.getScore()` (the Kotlin property), resulting in a slew of compile failures.
Rather than fixing those, we revert, and use the "Encapsulate Fields" refactor to convert all the fields and field accesses in `Customer` to getters.

// begin-insert: tags/functions-to-extension-methods.1:src/main/java/travelator/marketing/CustomerData.java#foo
[source,java]
----
public class CustomerData {
    private final String id;
    private final String givenName;
    private final String familyName;
    private final int score;
    private final double spend;

    ...
    @Override
    public boolean equals(Object o) {
        ...
    }

    @Override
    public int hashCode() {
        return Objects.hash(getId(), getGivenName(),
            getFamilyName(), getScore(), getSpend());
    }

    public String getId() {
        return id;
    }

    public String getGivenName() {
        return givenName;
    }
    ...
}
----
// end-insert

Now client code will also be calling the getters:

// begin-insert: tags/functions-to-extension-methods.1:src/main/java/travelator/marketing/HighValueCustomersReport.java#foo
[source,java]
----
private static String lineFor(CustomerData customer) {
    return customer.getId() + "\t" + marketingNameFor(customer) + "\t" +
        formatMoney(customer.getSpend());
}
----
// end-insert

This allows us to convert `CustomerData` to a Kotlin data class without breaking the Java.
"Convert Java file to Kotlin File", followed by adding the `data` modifier and deleting the `equals` and `hashCode` overrides gives us:

// begin-insert: tags/functions-to-extension-methods.2:src/main/java/travelator/marketing/CustomerData.kt
[source,kotlin]
----
data class CustomerData(
    val id: String,
    val givenName: String,
    val familyName: String,
    val score: Int,
    val spend: Double
)
----
// end-insert

Now we can go ahead and convert `HighValueCustomerReport` to Kotlin too - it's entirely self-contained.
That doesn't go brilliantly - `customerDataFrom` doesn't compile after the conversion:

// begin-insert: tags/functions-to-extension-methods.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt#customerDataFrom
[source,kotlin]
----
object HighValueCustomersReport {
    ...
    @JvmStatic
    fun customerDataFrom(line: String): CustomerData {
        val parts = line.split("\t".toRegex()).toTypedArray()
        val spend: Double = if (parts.size == 4) 0 else parts[4].toDouble() // <1>
        return CustomerData(
            parts[0],
            parts[1],
            parts[2], parts[3].toInt(), // <2>
            spend
        )
    }
    ...
}
----
// end-insert

<1> `The integer literal does not conform to the expected type Double`.
<2> Two parameters to a line for some strange reason.

The converter hasn't been smart enough to know that Kotlin doesn't coerce the integer 0 to double, leading to a compile error.
On the bright side, if this is the best computers can do, maybe our jobs are safe for a few years yet!
Let's help IntelliJ out by clicking on the error and Alt-Entering to fix it.
After a reformat, this gives us:

// begin-insert: tags/functions-to-extension-methods.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt#customerDataFrom
[source,kotlin]
----
object HighValueCustomersReport {
    ...
    @JvmStatic
    fun customerDataFrom(line: String): CustomerData {
        val parts = line.split("\t".toRegex()).toTypedArray()
        val spend: Double = if (parts.size == 4) 0.0 else parts[4].toDouble()
        return CustomerData(
            parts[0],
            parts[1],
            parts[2],
            parts[3].toInt(),
            spend
        )
    }
    ...
}
----
// end-insert

As we discussed in <<static-methods-to-top-level-functions>>, the conversion has placed the functions into an `object HighValueCustomersReport`, so that Java code can still find them.
If we try to convert them to top level functions using the techniques in that chapter, we find that dependencies between the methods means that the code doesn't compile at times.
We can solve the problem either by moving the private methods first, or by just ignoring the compiler until the `HighValueCustomersReport` is emptied and removed.

// begin-insert: tags/functions-to-extension-methods.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#all
[source,kotlin]
----
package travelator.marketing

...

@Throws(IOException::class)
fun generate(reader: Reader?, writer: Writer) {
    val valuableCustomers = BufferedReader(reader).lines()
        .skip(1) // header
        .map { line: String -> customerDataFrom(line) }
        .filter { (_, _, _, score) -> score >= 10 }
        .sorted(Comparator.comparing { (_, _, _, score) -> score })
        .collect(Collectors.toList())
    writer.append("ID\tName\tSpend\n")
    for (customerData in valuableCustomers) {
        writer.append(lineFor(customerData)).append("\n")
    }
    writer.append(summaryFor(valuableCustomers))
}

private fun summaryFor(valuableCustomers: List<CustomerData>): String {
    val total = valuableCustomers.stream()
        .mapToDouble { (_, _, _, _, spend) -> spend }
        .sum()
    return "\tTOTAL\t" + formatMoney(total)
}

fun customerDataFrom(line: String): CustomerData {
    val parts = line.split("\t".toRegex()).toTypedArray()
    val spend: Double = if (parts.size == 4) 0.0 else parts[4].toDouble()
    return CustomerData(
        parts[0],
        parts[1],
        parts[2],
        parts[3].toInt(),
        spend
    )
}

private fun lineFor(customer: CustomerData): String {
    return customer.id + "\t" + marketingNameFor(customer) + "\t" +
        formatMoney(customer.spend)
}

private fun formatMoney(money: Double): String {
    return String.format("%#.2f", money)
}

private fun marketingNameFor(customer: CustomerData): String {
    return customer.familyName.toUpperCase() + ", " + customer.givenName
}
----
// end-insert

OK, it's time to look for places where extension functions can improve the code.
Starting at the end is the `marketingNameFor` that we saw (a slightly different version of) earlier.
If we Alt-Enter on the `customer` parameter IntelliJ will offer to "Convert parameter to receiver".
This gives:

// begin-insert: tags/functions-to-extension-methods.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt#marketingNameFor
[source,kotlin]
----
private fun lineFor(customer: CustomerData): String {
    return customer.id + "\t" + customer.marketingNameFor() + "\t" +
        formatMoney(customer.spend)
}

...
private fun CustomerData.marketingNameFor(): String {
    return familyName.toUpperCase() + ", " + givenName
}
----
// end-insert

That `For` in `marketingNameFor` is confusing now we've moved the parameter to be the receiver, because the `For` doesn't have a subject.
Let's "Convert function to property" named `marketingName` (<<methods-to-properties>> explains how and why), then "Convert to expression body".
Oh, and "Convert concatenation to template on both strings!
Phew, that flurry of Alt-Entering gives:

// begin-insert: tags/functions-to-extension-methods.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt#marketingNameFor
[source,kotlin]
----
private fun lineFor(customer: CustomerData): String =
    "${customer.id}\t${customer.marketingName}\t${formatMoney(customer.spend)}"

private fun formatMoney(money: Double): String {
    return String.format("%#.2f", money)
}

private val CustomerData.marketingName: String
    get() = "${familyName.toUpperCase()}, $givenName"
----
// end-insert

Now `formatMoney` is letting us down, so again we can "Convert parameter to receiver", rename to `toMoneyString`, and "Convert to expression body":

// begin-insert: tags/functions-to-extension-methods.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt#toMoneyString
[source,kotlin]
----
private fun lineFor(customer: CustomerData): String =
    "${customer.id}\t${customer.marketingName}\t${customer.spend.toMoneyString()}"

private fun Double.toMoneyString() = String.format("%#.2f", this)
----
// end-insert

The `String.format` rankles a bit.
Kotlin would allow us to write `"%#.2f".format(this)`, but we prefer swapping the parameter and receiver to give:

// begin-insert: tags/functions-to-extension-methods.9:src/main/java/travelator/marketing/HighValueCustomersReport.kt#formattedAs
[source,kotlin]
----
private fun Double.toMoneyString() = this.formattedAs("%#.2f")

private fun Double.formattedAs(format: String) = String.format(format, this)
----
// end-insert

`Double.formattedAs` is the first extension function we've written that had a parameter as well as its receiver.
That's because the others have been very specific conversions, this one is more general.
While we're thinking general, `formattedAs` can equally well apply to any type, including `null`, so we can upgrade it to:

// begin-insert: tags/functions-to-extension-methods.9.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#formattedAs
[source,kotlin]
----
private fun Any?.formattedAs(format: String) = String.format(format, this)
----
// end-insert

It now feels like a good candidate for moving into our library of generally useful Kotlin functions.

Next `customerDataFrom` is in our sights.
It is currently:

// begin-insert: tags/functions-to-extension-methods.10:src/main/java/travelator/marketing/HighValueCustomersReport.kt#customerDataFor
[source,kotlin]
----
fun customerDataFrom(line: String): CustomerData {
    val parts = line.split("\t".toRegex()).toTypedArray()
    val spend: Double = if (parts.size == 4) 0.0 else parts[4].toDouble()
    return CustomerData(
        parts[0],
        parts[1],
        parts[2],
        parts[3].toInt(),
        spend
    )
}
----
// end-insert

Before we go on, let's observe that `CharSequence.split()`, `String.toRegex()`, `Collection<T>.toTypedArray()`, `String.toDouble()` and `String.toInt()` are all extension functions provided by the Kotlin standard library.

There's a lot we can tidy up before we address ++customerDataFrom++s interface.
Kotlin has a `CharSequence.split(delimters)` that we can use in place of the regex.
Then we can inline `spend`, followed by Alt-Enter and "Add names to call arguments" to help make sense of constructor call:

// begin-insert: tags/functions-to-extension-methods.10.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt#customerDataFor
[source,kotlin]
----
fun customerDataFrom(line: String): CustomerData {
    val parts = line.split("\t")
    return CustomerData(
        id = parts[0],
        givenName = parts[1],
        familyName = parts[2],
        score = parts[3].toInt(),
        spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
    )
}
----
// end-insert

<<multi-to-single-expression-functions>> argues in favour of single-expression functions.
This certainly doesn't _need_ to be a single-expression, but let's practice anyway:

// begin-insert: tags/functions-to-extension-methods.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt#customerDataFor
[source,kotlin]
----
fun customerDataFrom(line: String): CustomerData =
    line.split("\t").let { parts ->
        CustomerData(
            id = parts[0],
            givenName = parts[1],
            familyName = parts[2],
            score = parts[3].toInt(),
            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
        )
    }
----
// end-insert

At last, we can get around to converting to an extension function .
Again we change the name (to `toCustomerData`) to make sense at the call-site:

// begin-insert: tags/functions-to-extension-methods.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt#customerDataFor
[source,kotlin]
----
fun String.toCustomerData(): CustomerData =
    split("\t").let { parts ->
        CustomerData(
            id = parts[0],
            givenName = parts[1],
            familyName = parts[2],
            score = parts[3].toInt(),
            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
        )
    }
----
// end-insert

Note that the Java in our tests is still calling this as a static method:

// begin-insert: tags/functions-to-extension-methods.12:src/test/java/travelator/marketing/HighValueCustomersReportTests.java#customerDataFor
[source,java]
----
@Test
public void emptySpendIs0() {
    assertEquals(
        new CustomerData("1", "Fred", "Flintstone", 0, 0D),
        HighValueCustomersReportKt.toCustomerData("1\tFred\tFlintstone\t0")
    );
}
----
// end-insert

Now let's address `summaryFor`:

// begin-insert: tags/functions-to-extension-methods.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt#summaryFor
[source,kotlin]
----
private fun summaryFor(valuableCustomers: List<CustomerData>): String {
    val total = valuableCustomers.stream()
        .mapToDouble { (_, _, _, _, spend) -> spend }
        .sum()
    return "\tTOTAL\t" + total.toMoneyString()
}
----
// end-insert

That destructuring is odd, but we can get rid of it by hand-converting the stream to Kotlin - this isn't a thing that IntelliJ can do when we wrote this, but we give guidance in <<streams-to-sequences>>.
We'll remove the string concatenation while we're there:

// begin-insert: tags/functions-to-extension-methods.14:src/main/java/travelator/marketing/HighValueCustomersReport.kt#summaryFor
[source,kotlin]
----
private fun summaryFor(valuableCustomers: List<CustomerData>): String {
    val total = valuableCustomers.sumByDouble { it.spend }
    return "\tTOTAL\t${total.toMoneyString()}"
}
----
// end-insert

Now the familiar combo of converting to an appropriately named single-expression extension function:

// begin-insert: tags/functions-to-extension-methods.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt#summaryFor
[source,kotlin]
----
private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }
----
// end-insert

At this stage only `generate` is left unimproved:

// begin-insert: tags/functions-to-extension-methods.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader?, writer: Writer) {
    val valuableCustomers = BufferedReader(reader).lines()
        .skip(1) // header
        .map { line: String -> line.toCustomerData() }
        .filter { (_, _, _, score) -> score >= 10 }
        .sorted(Comparator.comparing { (_, _, _, score) -> score })
        .collect(Collectors.toList())
    writer.append("ID\tName\tSpend\n")
    for (customerData in valuableCustomers) {
        writer.append(lineFor(customerData)).append("\n")
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

Again, we currently have to convert Java streams to Kotlin list operations by hand:

// begin-insert: tags/functions-to-extension-methods.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader.readLines()
        .drop(1) // header
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    writer.append("ID\tName\tSpend\n")
    for (customerData in valuableCustomers) {
        writer.append(lineFor(customerData)).append("\n")
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

Note here that every link in that transformation chain is an extension function not a method!

`Appendable.appendLine()` is another extension function that allows us to simplify the output stage:

// begin-insert: tags/functions-to-extension-methods.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader.readLines()
        .drop(1) // header
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(lineFor(customerData))
    }
    writer.append(valuableCustomers.summarised())
}
----
// end-insert

It feels like we should be able to remove that `// header` comment by extracting a function.
<<extracting-part-of-a-pipeline>> details how to extract a function from a chain, but look at what happens when we try that technique but don't convert `withoutHeader` to an extension function:

// begin-insert: tags/functions-to-extension-methods.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = withoutHeader(reader.readLines())
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(lineFor(customerData))
    }
    writer.append(valuableCustomers.summarised())
}

private fun withoutHeader(list: List<String>) = list.drop(1)
----
// end-insert

We've lost the nice pipeline flow from left to right, top to bottom - `withoutHeader` comes before the `readLines` in the text but after it in execution order.
Alt-Enter on the `list` parameter in `withoutHeader` and "Convert Parameter to Receiver" restores the flow:

// begin-insert: tags/functions-to-extension-methods.20:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader.readLines()
        .withoutHeader()
        .map(String::toCustomerData)
        .filter { it.score >= 10 }
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(lineFor(customerData))
    }
    writer.append(valuableCustomers.summarised())
}

private fun List<String>.withoutHeader() = drop(1)
----
// end-insert

We can make this even more expressive with two more extensions, `List<String>.toValuableCustomers()` and `CustomerData.outputLine`.

// begin-insert: tags/functions-to-extension-methods.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt#generate
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }
...

private val CustomerData.outputLine: String
    get() = "$id\t$marketingName\t${spend.toMoneyString()}"
----
// end-insert

This still isn't quite as sweet as we might like, but we've proved the point of extension functions.
<<performing-io-to-passing-data>> and <<ignoring-to-handling-errors>> will finish off this refactoring, looking at the use of the reader and writer.
In the meantime, here's the whole file:

// begin-insert: tags/functions-to-extension-methods.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt#all
[source,kotlin]
----
@Throws(IOException::class)
fun generate(reader: Reader, writer: Writer) {
    val valuableCustomers = reader
        .readLines()
        .toValuableCustomers()
        .sortedBy(CustomerData::score)
    writer.appendLine("ID\tName\tSpend")
    for (customerData in valuableCustomers) {
        writer.appendLine(customerData.outputLine)
    }
    writer.append(valuableCustomers.summarised())
}

private fun List<String>.toValuableCustomers() = withoutHeader()
    .map(String::toCustomerData)
    .filter { it.score >= 10 }

private fun List<String>.withoutHeader() = drop(1)

private fun List<CustomerData>.summarised(): String =
    sumByDouble { it.spend }.let { total ->
        "\tTOTAL\t${total.toMoneyString()}"
    }

internal fun String.toCustomerData(): CustomerData =
    split("\t").let { parts ->
        CustomerData(
            id = parts[0],
            givenName = parts[1],
            familyName = parts[2],
            score = parts[3].toInt(),
            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()
        )
    }


private val CustomerData.outputLine: String
    get() = "$id\t$marketingName\t${spend.toMoneyString()}"

private fun Double.toMoneyString() = this.formattedAs("%#.2f")

private fun Any?.formattedAs(format: String) = String.format(format, this)

private val CustomerData.marketingName: String
    get() = "${familyName.toUpperCase()}, $givenName"
----
// end-insert

Note that every function except the entry point is a single-expression extension function.
We haven't made `generate` an extension function because there isn't a natural parameter to make the receiver - it doesn't feel like a natural operation on `Reader` or `Writer`.
Duncan thinks that may change when we finish this refactoring - let's see shall we?

=== Conclusion

Extension functions and properties are the unsung heroes of the Kotlin language.
The canonical use of extension functions is to add methods to types we don't own and cannot modify ourselves.

However, Kotlin language features and tooling combine to encourage us -- quite insistently -- to write extension functions for our _own_ types as well.
Kotlin's null-safe dereference operator makes it more convenient to call an extension function through a potentially null reference than to pass the reference to a function as a parameter when it is non-null.
The type of a free-standing generic extension can express relationships between the receiver and its result that cannot be expressed by open methods.
Autocompletion in IntelliJ includes extension functions along with the methods that can call on a value, but it does not show you functions that you can pass the value to as a parameter.

As a result, extension functions allow us to write code that is more easily discovered, understood and maintained.
Many of the other techniques presented in this book build on extension functions, as we will see in
<<encapsulated-collections-to-typealiases>>,
<<open-to-sealed-classes>> and
<<multi-to-single-expression-functions>>.
