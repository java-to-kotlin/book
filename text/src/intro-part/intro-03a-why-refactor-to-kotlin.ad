[[why-refactor-to-kotlin]]
=== Why _Refactor_ to Kotlin?

Being responsible for business-critical systems means that we were never able to focus _only_ on converting our Java codebase to Kotlin.
We always had to migrate code to Kotlin at the same time as changing the system to meet new business needs,
maintaining a mixed Java/Kotlin codebase as we did so.
We managed the risk by working in small changes, making each easy to understand, and cheap to discard if we found out it broke something.
Our process was to first convert Java code to Kotlin, giving us a Java-esque design in Kotlin syntax.
We then incrementally applied Kotlin language features to make the code increasingly easier to understand, more type safe, more concise, and with a more compositional structure that is easier to change without unpleasant surprises.

Small, safe, reversible changes that improved the design: we _refactored_ from idiomatic Java to idomatic Kotlin.

These days most projects are multilingual.
A "Java" web app, for example, will involve code written in Java, HTML, CSS, JavaScript, at least one templating language, maybe more if you have templating on the server and in the browser, JSX if you're using React, and one or more query languages (SQL, etc).
Itâ€™s common to refactor logic between these languages: persistence logic from Java into a query language or vice versa, browser-side presentation between Javascript code and CSS rules or HTML elements as browsers evolve, or between JavaScript code manipulating the DOM and browser-side templating; server-side presentation between the template language and functions or objects in the host language; and so on.

Refactoring _between_ languages is usually harder than refactoring _within_ a single language because refactoring tools do not work well across the boundaries between the languages, if they work at all.
Porting logic from one language to another must be done manually, which takes longer and introduces more risk.
Once multiple languages are in use, the language boundary impedes refactoring because when you refactor code in one language, the IDE does not update dependent code written in other languages to be compatible.

What makes the combination of Java and Kotlin unique is how seamless is the boundary between the two languages.
Thanks to the design of the Kotlin language, the way it is mapped to the JVM platform, and JetBrains' investment in developer tooling, refactoring Java to Kotlin and refactoring a combined Java/Kotlin codebase is almost as easy as refactoring in a single codebase.

Our experience has been that we can refactor Java to Kotlin without impacting productivity, and that as more of the codebase is converted to Kotlin, productivity accelerates.


=== We Minimise Text Edits

When the IDE does not have distinct user-interface actions for a large-scale transformation we wish to do, we have to perform it as a sequence of more granular refactorings.
We use the IDE's automatic refactoring whenever we can, and fall back on text editing when the IDE does not automate a transformation we need.

It's tedious and error prone to refactor by editing text.
To reduce the risk, and our boredom, we minimise the amount of text editing we have to do.
If we _must_ edit text, we prefer that edit to affect a single expression.
So, we use automatic refactorings to transform the code so that is possible, edit one expression, and then use automatic refactorings to tidy back up to the final state we're aiming for.

The first time we describe a large-scale refactoring we'll go through it step by step, and show how the code changes at each step.
This takes quite a lot of space on the page, and will take a bit of reading time to follow.
In practice, however, these large refactorings are quick to apply.
They typically take a few seconds, a few minutes at most.


=== We Assume Good Test Coverage

[quote, Martin Fowler, Refactoring (1999)]
If you want to refactor, the essential precondition is having solid tests.

Good test coverage ensures that the code transformations we want to merely improve design have not inadvertently changed our system's behaviour.
In  this book, we assume that you have good test coverage.
We do not cover how to write automated tests.
Other authors have addressed these topics in more detail than we could in the book.  For example: [Freeman and Pryce], [Beck].
However, we do show how to apply Kotlin features to simplify JUnit tests.

As we walk through multi-step code transformations, we do not always state when we run the tests.
Assume we run our tests after every change, no matter how small.

If your system does not already have good test coverage it can be difficult (and expensive) to retrofit tests to the code because the logic you want to test is entangled with other aspects of the system.
You're in a chicken and egg situation: you have refactor so that you can improve test coverage so that you can refactor.
We do not cover how to retrofit tests to existing code.
Again, other authors have addressed these topics in more detail than we could.  For example: [Feathers].


=== We Commit With Git Bisect In Mind

Just as we don't explicitly state when we run our tests, nor do we explicitly state when we commit our changes.
Assume we commit our changes whenever they have added value to the code, no matter how small.

We know our test suite isn't perfect.
If we do, by accident, break something that is not caught by our tests, we want to find the commit that introduced the fault and fix it as quick as we can.

The `git bisect` command automates that search.
We write a test that demonstrates the error and `git bisect` does a binary search of the history to find the first commit that makes that test fail.

If the commits in our history contain a mish-mash of unrelated changes, `git bisect` is not much help: it cannot tell which of the changes within a commit introduced the error.
If commits mix refactoring _and_ changes to behaviour, reverting a bad refactoring step is likely to break _other_ behaviour in the system.

Therefore we commit small, focused changes that separate refactorings from each other, and from changes to behaviour, to make it easy to understand what changed and fix any erroneous change.
