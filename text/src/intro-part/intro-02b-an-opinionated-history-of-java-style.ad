[[java-programming-style]]
=== An opinionated history of Java programming style

Like ancient poets, we divide the development of Java programming style into four distinct ages: the Primeval Age, the Beans Age, the Enterprise Age, and the Modern Age.
We'll use these names as a convenient shorthand when discussing Kotlin's interop features.

[[primeval-java-style]]
==== Primeval Style

Originally intended for use in domestic appliances and interactive TV, Java only took off when Netscape adopted Java applets in their hugely popular Navigator browser.
Sun released the Java development kit 1.0, Microsoft included Java in Internet Explorer, and suddenly everyone with a web browser had a Java runtime environment.
Interest in Java as a programming language exploded.

The of the fundamentals of Java were defined at that time:
the Java virtual machine and its bytecode and classfile format; primitive and reference types; null references; garbage collection; classes and interfaces; methods and control flow statements; checked exceptions for error handling; the abstract windowing toolkit; classes for networking with Internet and web protocols; and the loading and linking of code at runtime, sandboxed by a security manager.
However, Java wasnâ€™t yet ready for general purpose programming: the JVM was slow, and the standard library sparse.

Java looked like a cross between C++ and Smalltalk, and Java programming style at the time was influenced by those two languages.
The "getFoo/setFoo" and "AbstractSingletonProxyFactoryBean" conventions that programmers of other languages poke fun at were not yet widespread.

One of Java's unsung innovations was an official coding convention that spelled out how programmers should name packages, classes, methods, and variables.
C and C++ programmers followed a seemingly infinite variety of coding conventions, and code that combined multiple libraries ended up looking [.line-through]#like a right dog's dinner# somewhat inconsistent.
Java's one true coding convention meant that Java programmers could seamlessly integrate strangers' libraries into their programs, and encouraged widespread use of open source libraries in the Java community.

[[bean-java-style]]
==== Bean Style

After its initial success, Sun set out to make Java a practical tool for building applications.
Java 1.1 (1996) added to the language (most notably inner classes), improved the runtime (most notably just-in-time compilation and reflection), and extended the standard library.
Java 1.2 (1998) added a standard collections API and the Swing cross-platform GUI framework, which ensured Java applications looked and felt equally awkward on every desktop operating system.

At this time, Sun was eyeing Microsoft and Borland's domination of corporate software development.
Java had the potential to be a strong competitor to Visual Basic and Delphi.
Sun added a slew of APIs that were heavily inspired by Microsoft APIs:
JDBC for data base access (equivalent to Microsoft's ODBC); Swing for desktop GUI programming (equivalent to Microsoft's MFC); and the API that had the greatest influence on Java programming style: Java Beans.

Java Beans was Sun's attempt to compete with Microsoft's ActiveX component model for low-code, graphical, drag-and-drop programming.
Programmers could use ActiveX components in their Visual Basic programs, or embed them in office documents, or in web pages on their corporate intranet.
It was notoriously difficult to write an ActiveX component.
Java Beans were much easier: you merely had to follow some additional coding conventions for your class to be considered a "bean" that could be instantiated and configured in a graphical designer.

For a class to be a Java Bean, it had to have a constructor that took no arguments, and expose an interface made up of public properties that could be read and optionally written, methods that could be invoked, and events that objects of the class would emit.
In an application designer, programmers could instantiate beans, set their properties, and connect a bean's events to the methods of other beans.
By default, properties were defined by methods with names that started with "get" and "set".
This default could be overridden, but doing so required additional classes of boilerplate code.
Programmers usually went to the effort when retrofitting existing classes to act as Java Beans.
In new code, it was much easier to go with the grain.

The drawback of Beans style is that it relies heavily on mutable state, and requires more of that state to be public than plain ol' Java objects because you cannot pass parameters to an object's constructor.
Object state must be mutable so that it can be set after construction and objects must often be instantiated in an invalid state -- with required properties initialised to null, for example -- and then put into a valid state by setting their public properties.
User interface components work well as beans, because they can safely be initialised with default content and styling and adjusted after construction.
Treating other components of a system, that have no reasonable defaults, in the same way is error prone, and the type checker can't ensure they have been fully initialised.
The Beans conventions make writing correct code harder and changes in dependencies can silently break client code.

In the end, graphical composition of Java beans never became mainstream, but the coding conventions stuck.
Java programmers followed the Java Bean conventions even when they had no intention of their class being used as a Java Bean.
Beans had an enormous, lasting, and not entirely positive, influence on Java programming style.

[[enterprise-java-style]]
==== Enterprise Style

Java did eventually spread through the enterprise.
It didn't replace Visual Basic on the corporate desktop as expected, but unseated C++ as the server-side language of choice.
In 1998, Sun released Java 2 Enterprise Edition (J2EE, later rebranded as JavaEE), a suite of standard APIs for programming server-side, transaction processing systems.


The J2EE APIs suffer from _abstraction inversion_.
The Java Beans and applets APIs also suffer from abstraction inversion -- they both disallow passing parameters to constructors, for example -- but it is far more severe in J2EE.
J2EE applications don't have a single entry point.
They are comprised of many small components whose lifetime is managed by an "application container", and are exposed to one another through a JNDI name service.
Applications need a lot of boilerplate code and mutable state to look up and store the resources they depend on.
Programmers responded by inventing [role="pattern"]_Dependency Injection_ (DI) frameworks that did all the resource look up and binding and managed lifetimes.
The most successful of these is Spring.
It builds upon the Java Beans coding conventions, and uses reflection to compose applications from "beans".

****
.Abstraction Inversion
_Abstraction Inversion_ is an architectural flaw in which a software platform prevents client code from using lower level mechanisms that it requires.
This forces programmers to reimplement those lower level mechanisms using the higher-level facilities exposed by the platform's API, which in turn use the very features being reimplemented.
The end result is unnecessary code, poor performance, and additional maintenance and testing costs.
****

In terms of programming style, DI encourages programmers to avoid direct use of the `new` keyword, and rely on the DI framework to instantiate objects.
(We count Android APIs in these as well: they also exhibit abstraction inversion, and Android programmers also turn to DI frameworks to help them write to the APIs).
DI frameworks focus on mechanism over domain modelling lead to "enterprisey" class names, such as Spring's infamous `AbstractSingletonProxyFactoryBean`.

On the plus side, though, 1999 saw the release of Java 5, which added generics to the language: the most significant change to date. This era also saw a massive uptake of Open Source libraries in the Java community, powered by the Maven Central package repository.
The availability of top-notch open source libraries fueled the adoption of Java for business critical application development, and led to more open source libraries, in a virtuous circle.
This was followed by best in class development tools, including IntelliJ which we use in this book.

[[modern-java-style]]
==== Modern Style

Java 8 brought the next big change to the language -- lambdas -- and significant additions to the standard library to take advange of them.
The Streams API encouraged a functional programming style, in which processing is performed by transforming streams of immutable values rather than changing the state of mutable objects.
A new date/time API ignored Java Beans coding conventions for property accessors, and followed coding conventions common to the Primeval Style.

The growth of the cloud platforms meant that programmers didn't need to deploy their servers into JavaEE application containers.
Lightweight web application frameworks let programmers write a `main` function to compose their applications.
Many server-side programmers stopped using DI frameworks -- function and object composition were good enough -- and DI frameworks released greatly simplified APIs to stay relevant.
With no DI framework or mutable state, there's less need to follow Java Bean coding conventions.
Within a single codebase, exposing fields of immutable values works fine, because the IDE can encapsulate a field behind accessors in an instant if they're needed.

Java 11 introduced modules, but so far they have not seen widespread adoption outside the JDK itself.
The most exciting thing about recent Java releases has been the modularisation of the JDK and removal of seldom-used modules, such as CORBA, from the JDK into optional extensions.

[[future-java-style]]
==== The future

The future of Java promises more features to make Modern Style easier to apply: records, pattern matching, user defined value types, and eventually the unification of primitive and reference types into a uniform type system.

However this is a challenging effort that will take many years to complete.
Java started off with some deep-seated inconsistencies and edge cases that are hard to unify into clean abstractions while staying backwards-compatible.
Kotlin has the benefit of 25 years of hindsight, and a clean slate from which to start afresh.
