= The "Grain" of the Kotlin Language

All programming languages make some things easier to write, and other things more difficult.
This affects the way we design programs in that language.
For example, it has always been possible write functional code in Java, but it was so cumbersome to define functions and use higher-order functions before Java 8 that few programmers did.
Instead, most Java code mutated shared state.
Writing functional code _went against the grain_ of Java.
It required too much effort compared to the benefit to be worth doing.

Each programming language has its "grain": it's easier to work with the grain, and going against the grain requires constant effort with uncertain pay-off.

Kotlin also has a "grain".

Explicit design goals: "Concise", "Safe", "Interoperable", "Tool-friendly".

Unspoken preferences...

Transformation over Mutation: data classes make it easy to define new types with value semantics.
The stdlib makes it easier & more concise to transform collections immutable data than iterate and mutate data in place.

Concision over ???:
expression oriented, when statement, primary constructors, data classes, single-expression functions.

Static type safety over dynamic reflection:
type inference, flow-sensitive typing, Nothing, (and the big selling point) null safety.
Kotlin encourages a type-safe, compositional coding style.
Designed from the get-go to be used with a language aware editor that statically analyses the code for navigation and program transformation.
If you want to use reflection, you have to add a platform-specific library dependency.

Explicit over Implicit:
no implicit type coercion, even from smaller range to larger range.
No implicit parameters, like Scala.
Cannot have user-defined short-cut operators that could be implemented to have different control flow.

Regularity over special cases:
compared to Java, there are fewer special cases that interact in unpredictable ways.
No primitive/reference type distinction, no special case for void.
Extension functions allow you to add new operations to existing types, that look the same at the call point.
You can write user-defined control structures using inline functions and return, break, continue etc. will act as expected.

Easy interop with existing Java code over purity:
supports different <<java-programming-style,Java programming styles>>, to allow idiomatic Java and Kotlin code to coexist in the same codebase.
Some of that support removes guarantees provided by other language features, and should _only_ be used to interop with legacy Java.
For example, lateinit opens a hole in the type system for Java DI frameworks that use reflection to violate encapsulation boundaries.
As soon as you declare a variable `lateinit var`, it's up to you to ensure the variable is initialised correctly.
The type checker will not catch your mistakes.

== _Faux Amis_ for Java Programmers

A _faux ami_ is a word in a foreign language that looks similar to a word in your native tongue, but has a significantly different meaning.
Likewise, Kotlin has syntax that look similar to Java -- sometimes even using the same keywords -- but that have quite different semantics.
We will call attention to these as we come to them, and take some time to explore how the difference influences idiomatic Kotlin design.
Feel free to skip any digression if you are comfortable with that aspect of the language.


