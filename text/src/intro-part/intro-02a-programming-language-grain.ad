[[what-is-grain]]
=== The "Grain" of a Programming Language

In all programming languages, some things are easier to write, and other things more difficult.
This affects the way we design programs in that language.

For example, it has always been possible write Java code in a functional style, but few programmers did.
Look what was required in Java 1.0.2 (the first public Java release) to do something as simple as calculating the sum of a list of numbers by reducing them with the addition operator.
Java had no function types in its standard library, so you would have had to define interfaces for them:

// begin-insert: src/main/java/grain/java1/Function2.java
[source,java]
----
public interface Function2 {
    Object apply(Object arg1, Object arg2);
}
----
// end-insert

Then you would have had to write the `reduce` higher-order function, hiding the iteration and mutation required by the Vector class. (The Java standard library didn't include the collections framework yet).

// begin-insert: src/main/java/grain/java1/Vectors.java#reduce
[source,java]
----
public class Vectors {
    public static Object reduce(Vector l, Object initial, Function2 f) {
        Object result = initial;
        for (int i = 0; i < l.size(); i++) {
            result = f.apply(result, l.get(i));
        }
        return result;
    }

    ...
}
----
// end-insert

You would have had to define a separate class for every function you wanted to pass to your `reduce` function -- no lambdas or closures back then, not even inner classes.

// begin-insert: src/main/java/grain/java1/AddIntegers.java
[source,java]
----
public class AddIntegers implements Function2 {
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}
----
// end-insert

And _finally_ you could use all that to calculate the sum:

// begin-insert: src/test/java/grain/java1/TheGrainOfJavaTest.java#reduce
[source,java]
----
int sum = ((Integer) Vectors.reduce(counts, new Integer(0), new AddIntegers()))
    .intValue();
----
// end-insert

That's a lot of effort for what can be achieved, in modern languages, with a single expression.
But that's not the end of it.
Because Java had no standard function types, you couldn't easily combine different libraries written in a functional style.
You had to write adapter classes to map between the function types defined in different libraries.
And because the virtual machine had no JIT and a simple garbage collector, functional code would perform much worse than the imperative alternative.

There was just not enough pay-off.
Java programmers found it easier to write imperative code that iterated over collections and mutated state.
Writing functional code _went against the grain_ of Java.

Every programming language has a grain.
It's easier to work with the grain of a language.
Going against the grain involves constant effort with an uncertain pay-off.
A language's grain forms over time as its designers and users build a common understanding of how language features interact and encode their understanding and preferences in libraries that others build upon.
The grain influences the way code is written in the language, which influences the evolution of the language and libraries, which influences the evolution of the grain.

For example, Java 1.1 added anonymous inner classes to the language, and Java 2 added the collections framework to the standard library.  Anonymous inner classes meant that you didn't need to write a named class for each function you wanted to pass to your `reduce` function, but the resulting code was arguably harder to read.

// begin-insert: src/test/java/grain/java2/TheGrainOfJavaTest.java#reduce
[source,java]
----
int sum = ((Integer) Lists.reduce(counts, new Integer(0), new Function2() {
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
})).intValue();
----
// end-insert

Functional idioms still went against the grain of Java 2.

Java 5 added generics, which improved type safety, and autoboxing, which removed some boilerplate:

// begin-insert: src/main/java/grain/java5/Function2.java
[source,java]
----
public interface Function2<A,B,R> {
    R apply(A arg1, B arg2);
}
----
// end-insert

// begin-insert: src/test/java/grain/java5/TheGrainOfJavaTest.java#reduce
[source,java]
----
int sum = Lists.reduce(counts, 0, new Function2<Integer, Integer, Integer>() {
    @Override
    public Integer apply(Integer arg1, Integer arg2) {
        return arg1 + arg2;
    }
});
----
// end-insert

This was enough for https://github.com/google/guava[Google's Guava library] to include some common higher-order functions over collections, although `reduce` was not among them. However, the authors of Guava recommended writing imperative code where possible because it had better performance and was usually easier to read.

Functional programming still went largely against the grain of Java 5, but you could see the start of a trend.

Java 8 added anonymous functions (aka "lambda expressions") and method references to the language and the Streams API to the standard library.  The compiler and virtual machine optimised lambdas to avoid the performance overhead of anonymous inner classes.  The Streams API fully embraced functional idioms.

// begin-insert: src/test/java/grain/java8/TheGrainOfJavaTest.java#reduce
[source,java]
----
int sum = counts.stream().reduce(0, Integer::sum);
----
// end-insert

It still wasn't entirely plain sailing. Java's type system creates awkward edge cases because of the distinction between reference and primitive types. The Streams API was missing some common higher-order functions that you'd reach for if coming from a functional language (or even Ruby).  Checked exceptions don't play well with the Streams API and functional programming in general.  And making immutable classes with value semantics still involves a lot of boilerplate code.  But with Java 8, Java fundamentally changed to make a functional style work with, not against, its grain.

A language's grain influences the way that programmers write code in the language, which influences the evolution of the language and its libraries, changing the grain, altering the way that programmers write code in the language, on amnd on in a continual cycle of mutual feedback and evolution.

In the case of Java, the grain of the language, and the way programmers adapted to it, evolved through several distinct programming styles.
Kotlin has features designed specifically to simplify the interop with code written in these styles.
We'll refer to these styles as a shorthand when explaining why these features exist, and when to use or avoid them.
