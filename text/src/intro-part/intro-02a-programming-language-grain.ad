[[what-is-grain]]
=== The "Grain" of a Programming Language

In all programming languages, some things are easier to write, and other things more difficult.
This affects the way we design programs in that language.
For example, it has always been possible write Java code in a functional style, but few programmers did.
Look what was required in Java 1.0.2 (the first public Java release) to do something as simple as calculating the sum of a list of numbers by reducing them with the addition operator.
Java had no function types in its standard library, so you would have had to define interfaces for them:

// begin-insert: src/main/java/grain/java1/Function2.java
[source,java]
----
public interface Function2 {
    Object apply(Object arg1, Object arg2);
}
----
// end-insert

Then you would have had to write the `reduce` higher-order function, hiding the iteration and mutation required by the Vector class. (The Java standard library didn't include the collections framework yet).

// begin-insert: src/main/java/grain/java1/Vectors.java#reduce
[source,java]
----
public class Vectors {
    public static Object reduce(Vector l, Object initial, Function2 f) {
        Object result = initial;
        for (int i = 0; i < l.size(); i++) {
            result = f.apply(result, l.get(i));
        }
        return result;
    }

    ...
}
----
// end-insert

You would have had to define a separate class for every function you wanted to pass to your `reduce` function -- no lambdas or closures back then, not even inner classes.

// begin-insert: src/main/java/grain/java1/AddIntegers.java
[source,java]
----
public class AddIntegers implements Function2 {
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}
----
// end-insert

And _finally_ you could use all that to calculate the sum:

// begin-insert: src/test/java/grain/java1/TheGrainOfJavaTest.java#reduce
[source,java]
----
int sum = ((Integer) Vectors.reduce(counts, new Integer(0), new AddIntegers())).intValue();
----
// end-insert

That's a lot of effort for what can be achieved, in modern languages, with a single expression.
But that's not the end of it: because Java had no standard function types, you couldn't easily combine different libraries written in a functional style.
You had to write adapter classes to map between the function types defined in different libraries.

There was just not enough pay-off.
Java programmers found it easier to write procedural code that iterated over collections and mutated state than the boilerplate needed for a functional style.
Writing functional code _went against the grain_ of Java.

Every programming language has a grain.
It's easier to work with the grain of a language.
Going against the grain involves constant effort with an uncertain pay-off.
A language's grain forms over time as its designers and users build a common understanding of how language features interact and encode their understanding and preferences in libraries that others build upon.

