[[grain-of-kotlin]]
=== The Grain of Kotlin

Kotlin is a young language, but it clearly has a different grain to Java.

The https://kotlinlang.org/#why-kotlin["Why Kotlin"] section of https://kotlinlang.org[kotlinlang.org] lists four design goals: "Concise", "Safe", "Interoperable", and "Tool-friendly".
The designers of the language and its standard library also encoded implicit preferences that contribute to these design goals.

Kotlin prefers the transformation of immutable data to mutation of state.::
Data classes make it easy to define new types with value semantics.
The standard library makes it easier and more concise to transform collections of immutable data than iterate and mutate data in place.

Kotlin prefers behaviour to be explicit.::
For example, there is no implicit coercion between types, even from smaller to larger range.
Java implicitly converts int values to long values, because there is no loss of precision.
In Kotlin you have to explicitly call `Int.toLong()`.
The preference for explicitness is especially strong when it comes to control flow.
Although you can overload arithmetic and comparison operators for your own types, you cannot overload the shortcut logical operators (`&&` and `||`), because that would allow you to define different control flow.
Polymorphism is opt-in, not opt-out.

Kotlin prefers static over dynamic binding.::
Kotlin encourages a type-safe, compositional coding style.
Extension functions are bound statically.
By default, classes are not extensible and methods are not polymorphic.
You must explicitly opt in to polymorphism and inheritance.
If you want to use reflection, you have to add a platform-specific library dependency.
Kotlin is designed from the get-go to be used with a language aware editor that statically analyses the code to guide the programmer automate navigation and automate program transformation.

Kotlin doesn't like special cases.::
Compared to Java, Kotlin has fewer special cases that interact in unpredictable ways.
There is no distinction between primitive and reference types.  There is no void type for functions that return but do not return a value -- functions in Kotlin either return a value, or never return at all.
Extension functions allow you to add new operations to existing types, that look the same at the call point.
You can write new control structures as inline functions and the break, continue and return statements act the same as they do in built-in control structures.

Kotlin breaks its own rules to make migration easier.::
The Kotlin language has features to allow idiomatic Java and Kotlin code to coexist in the same codebase.
Some of those features remove guarantees provided by type checker, and should _only_ be used to interop with legacy Java.
For example, lateinit opens a hole in the type system so that Java dependency injection frameworks that initialise objects by reflection can inject values through the encapsulation boundaries that are normally enforced by the compiler.
If you declare a property as `lateinit var`, it's up to you to ensure the code initialises the property before reading it -- the compiler will not catch your mistakes.


