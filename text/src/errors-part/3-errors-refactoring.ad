= We Refactor Error Handling Code

Now that we know the error handling options available to us,
let's refactor some Java code to give us some practice.

== Existing Code

There is an HTTP endpoint in Travelator that allows the client app to register a `Customer`.

// begin-insert: tags/errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java
[source,java]
----
public class CustomerRegistrationHandler {

    private final IRegisterCustomers registration;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public CustomerRegistrationHandler(IRegisterCustomers registration) {
        this.registration = registration;
    }

    public Response handle(Request request) {
        try {
            RegistrationData data = objectMapper.readValue(
                request.getBody(),
                RegistrationData.class
            );
            Customer customer = registration.register(data);
            return new Response(HTTP_CREATED, objectMapper.writeValueAsString(customer));
        } catch (JsonProcessingException x) {
            return new Response(HTTP_BAD_REQUEST);
        } catch (ExcludedException x) {
            return new Response(HTTP_FORBIDDEN);
        } catch (DuplicateException x) {
            return new Response(HTTP_CONFLICT);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert


`CustomerRegistrationHandler`'s job is to extract data from the request body,
pass it to `registration` for processing,
and return a response with either a JSON representation of a `Customer`
or a suitable error status.

.HTTP
****
We'd rather not tie our example code to a particular Java HTTP framework,
so we have abstracted incoming calls behind a simple function that takes a `Request` and returns a `Response`.

ifdef::todos[]
Something about sending the correct status' being import in order to maintain correct HTTP systems
endif::[]
****

`CustomerRegistration` implements the business rules,
which is that potential customers should be vetted
against an `ExclusionList` of undesireables.

// begin-insert: tags/errors.0:src/main/java/travelator/CustomerRegistration.java
[source,java]
----
public class CustomerRegistration implements IRegisterCustomers {

    private final ExclusionList exclusionList;
    private final Customers customers;

    public CustomerRegistration(
        Customers customers,
        ExclusionList exclusionList
    ) {
        this.exclusionList = exclusionList;
        this.customers = customers;
    }

    public Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException {
        if (exclusionList.exclude(data)) {
            throw new ExcludedException();
        } else {
            return customers.add(data.name, data.email);
        }
    }
}
----
// end-insert

Note that as well as failing because of exclusion,
`register` can fail because `customers.add` can fail with a `DuplicateException`.
Here is the `Customers` interface.

// begin-insert: tags/errors.0:src/main/java/travelator/Customers.java
[source,java]
----
public interface Customers {

    Customer add(String name, String email) throws DuplicateException;

    Optional<Customer> find(String id);
}
----
// end-insert

Finally, `Customer` is another value type.
Here it is after conversion to Kotlin.

// begin-insert: tags/errors.1:src/main/java/travelator/Customer.kt
[source,kotlin]
----
data class Customer(
    val id: String,
    val name: String,
    val email: String
)
----
// end-insert

This is typical of the Java code that your authors would write.
It expresses the things that might reasonably go wrong as the checked
`ExcludedException` and `DuplicateException`,
and these are all caught at in the top-level `handle` where they are reported to the caller,
in this case as HTTP status codes.
Your style might be to use unchecked exceptions,
in which case this code would be similar
but without the exceptions
as part of the method signatures.

In addition to the checked exceptions,
every method can raise or pass on runtime exceptions.
In this case we might expect that failures to persist a `Customer`,
perhaps because of database communications issues,
would be raised as a runtime exception.

== Our Conversion Strategy

If we were to just convert this code to Kotlin,
we would lose the advantages of checked exceptions to tell us
what could go wrong and show where we are handling those problems.
So as we convert we will replace exception-based
error handling with a functional alternative using Result4k.

In this example we'll start at the lowest level
and work our way up,
keeping higher levels working,
until the predictable error cases,
those that would have been expressed as checked exceptions,
no longer use exceptions.
At the same time we have to be mindful that pretty much any instruction in the JVM can fail,
so we need to defend against these cases.

== Starting at the Bottom

If we convert `Customers` to Kotlin we get

// begin-insert: tags/errors.2:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {
    @Throws(DuplicateException::class) // <1>
    fun add(name: String?, email: String?): Customer?
    fun find(id: String?): Optional<Customer?>?
}
----
// end-insert

<1> Although Kotlin doesn't have checked exceptions, the `@Throws` annotation allows interoperation with Java code.
Without it, a Java implementation of `Customers` cannot override the method
(assuming that it does actually throw `DuplicateException`).
Worse, Java client code can't catch the exception
or declare that it is passed on,
as it is a compile error for Java code to handle a checked exception
that the compiler cannot see is possible.

Before we go further, conversion to Kotlin has failed to infer the nullability of the parameters and results in Customers,
lets fix that.

// begin-insert: tags/errors.3:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {
    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Customer /// |
    fun find(id: String): Optional<Customer>       /// |
}
----
// end-insert

What we're going to do for now is to add to our interface a version of `Customers.add` that instead of throwing an exception,
returns `Result<Customer, DuplicateException>`.

If we were starting from scratch we would probably not use an exception
the type of our error,
but here it lets us interoperate with Java easily.
We are going to keep the old throwy version around for now so that we don't break existing callers,
convert those callers to use the `Result` version,
then remove the old version when we can.

First we add Result4k to our build.

// begin-insert: tags/errors.4:build.gradle#Result4k
[source,groovy]
----
dependencies {
     ... 
    implementation "com.natpryce:Result4k:2.0.0"
     ... 
}
----
// end-insert

and then we can add a default method to thunk from the exception case to the result.
We can't call it `add` too, as both have the same parameters, so we call it `addToo` for now.

// begin-insert: tags/errors.5:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {
    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Customer

    @JvmDefault // <1>
    fun addToo(name:String, email:String)
        : Result<Customer, DuplicateException> =
        try {
            Success(add(name, email))
        } catch (x: DuplicateException) {
            Failure(x)
        }

    fun find(id: String): Optional<Customer>
}
----
// end-insert

<1> This annotation tells the compiler to generate Java-compatible default methods.
We wouldn't have had to do this had we left `Customers` in Java -
we live and learn.
You have to tell the compiler how to implement `@JVMDefault` with a compiler switch.

// begin-insert: tags/errors.5:build.gradle#foo
[source,groovy]
----
compileKotlin {
    kotlinOptions.jvmTarget = "1.8"
    kotlinOptions.freeCompilerArgs = ['-Xjvm-default=compatibility']
}
----
// end-insert

.Naming
****
It's a bit irritating that we can't name the new method `add` as well,
but the JVM won't allow methods that differ only on return type to have the same name.

If we can't think of a good name in these or other situations,
we err on the side of using a bad one.
In all likelihood we'll come up with a better name later,
and the bad name will reduce the risk that we settle for not-good-enough.

In this case it really shouldn't matter,
because we know that by the end of this refactor we will have deleted the original method,
and can steal its name once it is gone.
****

Now we have both exception and result versions of the method,
we can migrate the callers of the exception version.
While we can use Result4k from Java,
it's a lot more convenient from Kotlin.
So let's take `CustomerRegistration` (the caller of `add`)

// begin-insert: tags/errors.5:src/main/java/travelator/CustomerRegistration.java
[source,java]
----
public class CustomerRegistration implements IRegisterCustomers {

    private final ExclusionList exclusionList;
    private final Customers customers;

    public CustomerRegistration(
        Customers customers,
        ExclusionList exclusionList
    ) {
        this.exclusionList = exclusionList;
        this.customers = customers;
    }

    public Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException {
        if (exclusionList.exclude(data)) {
            throw new ExcludedException();
        } else {
            return customers.add(data.name, data.email);
        }
    }
}
----
// end-insert

and convert it to Kotlin

// begin-insert: tags/errors.6:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        return if (exclusionList.exclude(data)) {
            throw ExcludedException()
        } else {
            customers.add(data.name, data.email)
        }
    }

}
----
// end-insert

That `customers.add` expression is the one that can throw `DuplicateException`.
We're going to replace it with a call to `addTo`
but keeping the behaviour the same.
So we pull out `result` as a local

// begin-insert: tags/errors.7:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result = customers.add(data.name, data.email)
        result
    }
}
----
// end-insert

Now if we call `addToo` instead it will no longer throw,
but the exception will be returned in the Result.
This won't compile yet

// begin-insert: tags/errors.8:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> = customers.addToo(data.name, data.email)
        result // <1>
    }
}
----
// end-insert

<1> Type mismatch. Required: Customer Found: Result<Customer, DuplicateException>

Now in the case of failure,
we want to throw the `DuplicateException` in the `Result`
(in order to keep the current behaviour of `register`).
We can use `result.recover`,
which will give us the content of the `Failure` to throw

// begin-insert: tags/errors.9:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        val result: Result<Customer, DuplicateException> = customers.addToo(data.name, data.email)
        result.recover { throw it }
    }
}
----
// end-insert

and now we can inline to get back to a shorter form

// begin-insert: tags/errors.10:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    return if (exclusionList.exclude(data)) {
        throw ExcludedException()
    } else {
        customers.addToo(data.name, data.email).recover {
            throw it
        }
    }
}
----
// end-insert

Finally, that nesting looks a bit too confusing for comfort,
so lets simplify it with a guard clause,
even though it prevents our using the single-expression form.

// begin-insert: tags/errors.11:src/main/java/travelator/CustomerRegistration.kt#foo
[source,kotlin]
----
@Throws(ExcludedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Customer {
    if (exclusionList.exclude(data))
        throw ExcludedException()
    return customers.addToo(data.name, data.email)
        .recover { throw it }
}
----
// end-insert

That is a good place for a rest,
having replaced one use of exceptions with a result type.

== Broadening

OK, ready to go again? Good.

We now have to choose whether to proceed depth or breadth first.
Depth-first would address the caller of `CustomerRegistration.register`,
breadth-first would first fix up the other callers of `Customers.add`,
so that we can remove it.
As it happens our example code has no other callers of `add`,
so let's go that way.

While there is no other caller of `Customers.add`,
there are of course implementations.
Let's look at the (not thread-safe) test version.

// begin-insert: tags/errors.11:src/test/java/travelator/InMemoryCustomers.java
[source,java]
----
public class InMemoryCustomers implements Customers {

    private final List<Customer> list = new ArrayList<>();
    private int id = 0;

    @Override
    public Customer add(String name, String email) throws DuplicateException {
        if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
            throw new DuplicateException("customer with email " + email + " already exists");
        int newId = id++;
        Customer result = new Customer(Integer.toString(newId), name, email);
        list.add(result);
        return result;
    }

    @Override
    public Optional<Customer> find(String id) {
        return list.stream().filter(customer -> customer.getId().equals(id)).findFirst();
    }

    // for test
    public void add(Customer customer) {
        list.add(customer);
    }

    public int size() {
        return list.size();
    }
}
----
// end-insert

The easiest way to implement `addToo` here is probably just to duplicate `add`
and fix it up

// begin-insert: tags/errors.12:src/test/java/travelator/InMemoryCustomers.java#foo
[source,java]
----
@SuppressWarnings("unchecked")
@Override
public Result<Customer, DuplicateException> addToo(
    String name, String email
) {
    if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
        return new Failure<>(
            new DuplicateException("customer with email " + email + " already exists")
        );
    int newId = id++;
    Customer result = new Customer(Integer.toString(newId), name, email);
    list.add(result);
    return new Success<Customer>(result);
}
----
// end-insert

We can also use this strategy to add `addToo` to our production implementations of Customers.

If we still had any remaining callers of `add`
we could implement `add` by delegating to our new `addTo`,
but we don't.
So we can just remove it from here and the interface,
and then rename `addToo` to `add`,
leaving us with

// begin-insert: tags/errors.13:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
----
// end-insert

and

// begin-insert: tags/errors.13:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        if (exclusionList.exclude(data))
            throw ExcludedException()
        return customers.add(data.name, data.email)
            .recover { throw it }
    }
}
----
// end-insert

We left `InMemoryCustomers` as Java really just to demonstrate that we could return Result4k types from our old code,
but we can't resist the conversion,
as the code now has a number of warnings
of the type `Not annotated [X] overrides @NotNull [X]`.

After converstion we have

// begin-insert: tags/errors.14:src/test/java/travelator/InMemoryCustomers.kt
[source,kotlin]
----
class InMemoryCustomers : Customers {

    private val list: MutableList<Customer> = ArrayList()
    private var id = 0

    override fun add(name: String, email: String): Result<Customer, DuplicateException> =
        when {
            list.any { it.email == email } -> Failure(
                DuplicateException("customer with email $email already exists")
            )
            else -> {
                val result = Customer(id++.toString(), name, email)
                list.add(result)
                Success(result)
            }
        }

    override fun find(id: String): Optional<Customer> =
        list.firstOrNull { it.id == id }.toOptional()

    // for test
    fun add(customer: Customer) {
        list.add(customer)
    }

    fun size(): Int = list.size
}
----
// end-insert

Lets recap where we are now.
`Customers` is now Kotlin,
and `add` returns a `Result` instead of throwing `DuplicateException`.

// begin-insert: tags/errors.14:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
----
// end-insert

`IRegisterCustomers` is still Java, and still throws 2 types of exception.
// begin-insert: tags/errors.14:src/main/java/travelator/IRegisterCustomers.java
[source,java]
----
public interface IRegisterCustomers {
    Customer register(RegistrationData data)
        throws ExcludedException, DuplicateException;
}
----
// end-insert

`CustomerRegistration` is now Kotlin, and is the place where we now thunk between
`Result.Error` and `DuplicateException`.

// begin-insert: tags/errors.14:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        if (exclusionList.exclude(data))
            throw ExcludedException()
        return customers.add(data.name, data.email)
            .recover { throw it }
    }
}
----
// end-insert

== Stepping Out

Now we have converted a whole layer of our interaction to use a result type,
we move to the next.

If we are to follow the same pattern with `IRegisterCustomers` as we did with `Customers` -
provide a default implementation of an adapter between exception-throwing and error-returning -
we are going to have to address the issue of how to express
the result of a function that can fail because of one of two causes.
In code -
`Result<Customer, Either<ExcludedException, DuplicateException>>`.


We could reach for a generic `Either` type,
but that only gets us so far as a strategy.
For a start,
`Either<ExcludedException, DuplicateException>`
is not the same thing as `Either<DuplicateException, ExcludedException>`,
which is at best really confusing,
and will get even worse if we ever have to expand to `OneOf<ExcludedException, DuplicateException, SomeOtherProblem>`.
Instead,
our best bet here is not to try to express the error in terms of existing types,
but to map to a new type.

As _exception_ and _error_ are all overloaded terms,
we've chosen `RegistrationProblem`,
with subtypes of `Excluded`,
(which carries no additional information and so can be an object),
and `Duplicate`
(which carries any data from the original `DuplicateException`).
We use these when we add a default implementation of `registerToo` to the interface.

// begin-insert: tags/errors.15:src/main/java/travelator/IRegisterCustomers.kt
[source,kotlin]
----
interface IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    fun register(data: RegistrationData): Customer

    fun registerToo(data: RegistrationData): Result<Customer, RegistrationProblem> =
        try {
            Success(register(data))
        } catch (x: ExcludedException) {
            Failure(Excluded)
        } catch (x: DuplicateException) {
            Failure(Duplicate(x.message))
        }
}

sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
----
// end-insert

Now we can migrate callers of `register` to `registerToo`.
Starting with `CustomerRegistrationHandler`,
which we convert to Kotlin first.

// begin-insert: tags/errors.16:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt
[source,kotlin]
----
class CustomerRegistrationHandler(
    private val registration: IRegisterCustomers
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val customer = registration.register(data)
            Response(
                HTTP_CREATED,
                objectMapper.writeValueAsString(customer)
            )
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: ExcludedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}
----
// end-insert

Now call `registerToo` instead of `register` in the handler,
and interpret the return type with `when`

// begin-insert: tags/errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt
[source,kotlin]
----
class CustomerRegistrationHandler(
    private val registration: IRegisterCustomers
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val customerResult = registration.registerToo(data)
            when (customerResult) {
                is Success -> Response(
                    HTTP_CREATED,
                    objectMapper.writeValueAsString(customerResult)
                )
                is Failure -> customerResult.reason.toResponse()

            }
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: ExcludedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}

private fun RegistrationProblem.toResponse() = when (this) {
    is Duplicate -> Response(HTTP_CONFLICT)
    is Excluded -> Response(HTTP_FORBIDDEN)
}
----
// end-insert

before removing the unnecessary exception cases
and simplifying the error case
with `map` and `recover`.

// begin-insert: tags/errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt#foo
[source,kotlin]
----
fun handle(request: Request): Response =
    try {
        val data = objectMapper.readValue(
            request.body,
            RegistrationData::class.java
        )
        registration.registerToo(data)
            .map {
                Response(
                    HTTP_CREATED,
                    objectMapper.writeValueAsString(it)
                )
            }
            .recover { it.toResponse() }
    } catch (x: JsonProcessingException) {
        Response(HTTP_BAD_REQUEST)
    } catch (x: Exception) {
        Response(HTTP_INTERNAL_ERROR)
    }
----
// end-insert

Note that this code is not exception-free.
Firstly the `ObjectMapper` can still throw `JSONProcessingException`.
That is the reality of Java (and frankly most Kotlin) APIs,
but the code is safe and communicates well,
as the throwing and catching are in the same method.
Secondly we still have to consider other `RuntimeExceptions` that could be thrown from anywhere
(`NullPointerException` etc).
These could have crossed function boundaries and leaked up to here,
where the buck stops at the top-level catch-all.
The reality is that we can still have unexpected exceptions,
but the expected failure cases are now expressed by `Results`
and communicated in our code.

Now we can confess that the `RegistrationHandlerTests` got broken a few steps ago.
Ordinarily we would have fixed them straight away,
but that would have interrupted our explanation.

The problem is that the tests are mock tests which expect calls to `IRegister.register`,
but we are now calling `registerToo`. For example

// begin-insert: tags/errors.19:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java#foo
[source,java]
----
public class CustomerRegistrationHandlerTests {

    @RegisterExtension
    final Mockery mockery = new JUnit5ClassMockery();

    final IRegisterCustomers registration = mockery.mock(IRegisterCustomers.class);
    final CustomerRegistrationHandler handler = new CustomerRegistrationHandler(registration);

    final String fredBody = toJson("{ 'name' : 'fred', 'email' : 'fred@bedrock.com' }");
    final RegistrationData fredData = new RegistrationData("fred", "fred@bedrock.com");

    @Test
    public void returns_Created_with_body_on_success()
        throws DuplicateException, ExcludedException {

        mockery.checking(new Expectations() {{
            oneOf(registration).register(fredData);
            will(returnValue(new Customer("0", fredData.name, fredData.email)));
        }});

        String expectedBody = toJson(
            "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
        );
        assertEquals(
            new Response(HTTP_CREATED, expectedBody),
            handler.handle(new Request(fredBody))
        );
    }

    @Test
    public void returns_Conflict_for_duplicate()
        throws DuplicateException, ExcludedException {

        mockery.checking(new Expectations() {{
            oneOf(registration).register(fredData);
            will(throwException(new DuplicateException("deliberate")));
        }});

        assertEquals(
            new Response(HTTP_CONFLICT),
            handler.handle(new Request(fredBody))
        );
    }
    ...
    private String toJson(String jsonIsh) {
        return jsonIsh.replace('\'', '"');
    }
}
----
// end-insert

We can fix the wrong expectation,
and the return type,
in one edit.
Note that returning a error type has simplified our mock tests -
we can dispense with a special `throwException` action in favour of returning
`Success` or `Failure`.

// begin-insert: tags/errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java#foo
[source,java]
----
@Test
public void returns_Created_with_body_on_success() {
    mockery.checking(new Expectations() {{
        oneOf(registration).registerToo(fredData);
        will(returnValue(
            new Success<>(
                new Customer("0", fredData.name, fredData.email)))
        );
    }});

    String expectedBody = toJson(
        "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
    );
    assertEquals(
        new Response(HTTP_CREATED, expectedBody),
        handler.handle(new Request(fredBody))
    );
}

@Test
public void returns_Conflict_for_duplicate() {
    mockery.checking(new Expectations() {{
        oneOf(registration).registerToo(fredData);
        will(returnValue(
            new Failure<>(new Duplicate("deliberate")))
        );
    }});

    assertEquals(
        new Response(HTTP_CONFLICT),
        handler.handle(new Request(fredBody))
    );
}
----
// end-insert

At this point we can return to `CustomerRegistration`
and implement `registerToo` directly.
In lieu of any cleverer idea we do this by duplicating the `register` method
and fettling the error handling,
using `Result.mapFailure` to convert DuplicateException to Duplicate.

// begin-insert: tags/errors.21:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer {
        if (exclusionList.exclude(data))
            throw ExcludedException()
        return customers.add(data.name, data.email)
            .recover { throw it }
    }

    override fun registerToo(data: RegistrationData): Result<Customer, RegistrationProblem> {
        if (exclusionList.exclude(data))
            return Failure(Excluded)
        return customers.add(data.name, data.email)
            .mapFailure { exception: DuplicateException -> // <1>
                Duplicate(exception.message)
            }
    }
}
----
// end-insert

<1> Note that we explicitly type the lambda parameter in `mapFailure`.
This way if we change the return type of `add` to have a different failure type
the compiler will force us to change how we handle it.

There are two problems with this.
Firstly, `registerToo` has no test code,
and secondly, we have the duplicate logic caused by our just copying the code.
We can fix both by implementing `register` in terms of `registerToo` -
the opposite of what we did in IRegister.

// begin-insert: tags/errors.22:src/main/java/travelator/CustomerRegistration.kt
[source,kotlin]
----
class CustomerRegistration(
    private val customers: Customers,
    private val exclusionList: ExclusionList
) : IRegisterCustomers {

    @Throws(ExcludedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Customer =
        registerToo(data).recover { error ->
            when (error) {
                is Excluded -> throw ExcludedException()
                is Duplicate -> throw DuplicateException(error.message)
        }
    }

    override fun registerToo(data: RegistrationData): Result<Customer, RegistrationProblem> {
        if (exclusionList.exclude(data))
            return Failure(Excluded)
        return customers.add(data.name, data.email)
            .mapFailure { exception: DuplicateException -> // <1>
                Duplicate(exception.message)
            }
    }
}
----
// end-insert

Now our RegistrationTests, which work in terms of `register`, will be testing `registerToo` for us.

// begin-insert: tags/errors.22:src/test/java/travelator/CustomerRegistrationTests.java
[source,java]
----
public class CustomerRegistrationTests {

    InMemoryCustomers customers = new InMemoryCustomers();
    Set<String> excluded = Set.of(
        "cruella@hellhall.co.uk"
    );
    CustomerRegistration registration = new CustomerRegistration(customers,
        (registrationData) -> excluded.contains(registrationData.email)
    );

    @Test
    public void adds_a_customer_when_not_excluded()
        throws DuplicateException, ExcludedException {
        assertEquals(Optional.empty(), customers.find("0"));

        Customer added = registration.register(
            new RegistrationData("fred flintstone", "fred@bedrock.com")
        );
        assertEquals(
            new Customer("0", "fred flintstone", "fred@bedrock.com"),
            added
        );
        assertEquals(added, customers.find("0").orElseThrow());
    }

    @Test
    public void throws_DuplicateException_when_email_address_exists() {
        customers.add(new Customer("0", "fred flintstone", "fred@bedrock.com"));
        assertEquals(1, customers.size());

        assertThrows(DuplicateException.class,
            () -> registration.register(
                new RegistrationData("another name", "fred@bedrock.com")
            )
        );
        assertEquals(1, customers.size());
    }

    @Test
    public void throws_ExcludedException_when_excluded() {
        assertThrows(ExcludedException.class,
            () -> registration.register(
                new RegistrationData("cruella de vil", "cruella@hellhall.co.uk")
            )
        );
        assertEquals(0, customers.size());
    }
}
----
// end-insert

This would be a good way to keep both `register`
and `registerToo`
while we migrate away from Java and exceptions
to Kotlin and an error type.
In this case though the tests are actually the last callers of `register`,
so let's convert them to call `registerToo`.
We could take the time to show how to use Result4k in Java,
but I for one am pretty tired of this refactoring now,
so we'll convert the tests to Kotlin and
then to call `register` with the immortal words,
"Here's one I made earlier".

// begin-insert: tags/errors.23:src/test/java/travelator/CustomerRegistrationTests.kt
[source,kotlin]
----
class CustomerRegistrationTests {

    private val customers = InMemoryCustomers()
    private val excluded = setOf("cruella@hellhall.co.uk")
    private val registration = CustomerRegistration(
        customers,
        ExclusionList { excluded.contains(it.email) }
    )

    @Test
    fun `adds a customer when not excluded`() {
        assertEquals(Optional.empty<Any>(), customers.find("0"))
        val added = registration.registerToo(
            RegistrationData("fred flintstone", "fred@bedrock.com")
        ).valueOrNull()
        assertEquals(
            Customer("0", "fred flintstone", "fred@bedrock.com"),
            added
        )
        assertEquals(added, customers.find("0").orElseThrow())
    }

    @Test
    fun `returns Duplicate when email address exists`() {
        customers.add(Customer("0", "fred flintstone", "fred@bedrock.com"))
        assertEquals(1, customers.size())
        val failure = registration.registerToo(
            RegistrationData("another name", "fred@bedrock.com")
        ).failureOrNull()
        assertEquals(
            Duplicate("customer with email fred@bedrock.com already exists"),
            failure
        )
        assertEquals(1, customers.size())
    }

    @Test
    fun `returns Excluded when excluded`() {
        val failure = registration.registerToo(
                RegistrationData("cruella de vil", "cruella@hellhall.co.uk")
        ).failureOrNull()
        assertEquals(
            Excluded,
            failure
        )
        assertEquals(0, customers.size())
    }
}
----
// end-insert

Now we have no callers of `register`,
we can finally remove it and rename `registerToo` to `register`,
ending up with exception-free Kotlin.

// begin-insert: tags/errors.24:src/main/java/travelator/IRegisterCustomers.kt
[source,kotlin]
----
interface IRegisterCustomers {
    fun register(data: RegistrationData): Result<Customer, RegistrationProblem>
}

sealed class RegistrationProblem

object Excluded : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
----
// end-insert

// begin-insert: tags/errors.24:src/main/java/travelator/Customers.kt
[source,kotlin]
----
interface Customers {

    fun add(name:String, email:String): Result<Customer, DuplicateException>

    fun find(id: String): Optional<Customer>
}
----
// end-insert

Hmm, not quite exception-free because of that `DuplicateException`,
which is not thrown from anywhere anymore,
just created and
put into a `Failure`.
It's an easy fix to rename the class to `DuplicateCustomer`
and stop extending `Exception`,
or to reuse the existing `Duplicate` subclass of `RegistrationProblem`.
Which is better?
Well it is a little strange for `Customers.add`,
which is in our domain layer,
to use an error type from the business rules layer,
so we should probably keep them separate.
You can trust us to fix it without bothering you,
and we will have more to say about errors crossing contexts
in future chapters.











