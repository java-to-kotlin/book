= We Refactor Error Handling Code

Now that we know the error handling options available to us,
let's refactor some Java code to give us some practice.

== Existing Code

There is an HTTP endpoint in Colloquiumatic that allows the client to register an attendee.

// begin-insert: tags/errors.0:src/main/java/colloquiumatic/handlers/RegistrationHandler.java
[source,java]
----
public class RegistrationHandler {

    private final IRegister registration;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public RegistrationHandler(IRegister registration) {
        this.registration = registration;
    }

    public Response handle(Request request) {
        try {
            RegistrationData data = objectMapper.readValue(
                request.getBody(),
                RegistrationData.class
            );
            Attendee attendee = registration.register(data);
            return new Response(HTTP_CREATED, objectMapper.writeValueAsString(attendee));
        } catch (JsonProcessingException x) {
            return new Response(HTTP_BAD_REQUEST);
        } catch (BlacklistedException x) {
            return new Response(HTTP_FORBIDDEN);
        } catch (DuplicateException x) {
            return new Response(HTTP_CONFLICT);
        } catch (Exception x) {
            return new Response(HTTP_INTERNAL_ERROR);
        }
    }
}
----
// end-insert


RegistrationHandler's job is to extract data from the request body,
pass it to a `registration` for processing,
and return a response with either a JSON representation of an Attendee
or a suitable error status.

.HTTP
****
We'd rather not tie our example code to a particular Java HTTP framework,
so we have abstracted all that behind a simple function that takes a Request and returns a Response.

ifdef::todos[]
Something about sending the correct status' being import in order to maintain correct HTTP systems
endif::[]
****

Registration implements the business rules,
which is that potential attendees should be vetted against a blacklist.

// begin-insert: tags/errors.0:src/main/java/colloquiumatic/Registration.java
[source,java]
----
public class Registration implements IRegister {

    private final Blacklist blacklist;
    private final Attendees attendees;

    public Registration(
        Attendees attendees,
        Blacklist blacklist
    ) {
        this.blacklist = blacklist;
        this.attendees = attendees;
    }

    public Attendee register(RegistrationData data)
        throws BlacklistedException, DuplicateException {
        if (blacklist.isAcceptable(data))
            return attendees.add(data.name, data.email);
        else throw new BlacklistedException();
    }
}
----
// end-insert

Note that as well as failing because of blacklisting,
`register` can fail because `attendees.add` can fail with a DuplicateException.
Here is the Attendees interface.

// begin-insert: tags/errors.0:src/main/java/colloquiumatic/Attendees.java
[source,java]
----
public interface Attendees {

    Attendee add(String name, String email) throws DuplicateException;

    Optional<Attendee> find(String id);
}
----
// end-insert

Finally, Attendee is another value type.
Here it is after conversion to Kotlin.

// begin-insert: tags/errors.1:src/main/java/colloquiumatic/Attendee.kt
[source,kotlin]
----
data class Attendee(
    val id: String,
    val name: String,
    val email: String
)
----
// end-insert

This is typical of the Java code that your authors would write.
It expresses the things that might reasonably go wrong as the checked
BlacklistedException and DuplicateException,
and these are all caught at in the top-level `handle` where they are reported to the caller,
in this case as HTTP status codes.
Your style might be to use unchecked exceptions,
in which case this code would be similar
but without the exceptions
as part of the method signatures.


In addition to the checked exceptions,
every method can raise or pass on runtime exceptions.
In this case we might expect that failures to persist an Attendee,
perhaps because of database communications issues,
would be raised as a runtime exception.

== Our Conversion Strategy

If we were to just convert this code to Kotlin,
we would lose the advantages of checked exceptions to tell us
what could go wrong and show where we are handling those problems.
So as we convert we will replace exception-based
error handling with a functional alternative using result4k.

In this example we'll start at the lowest level
and work our way up,
keeping higher levels working,
until the predictable error cases,
those that would have been expressed as checked exceptions,
no longer use exceptions.
At the same time we have to be mindful that pretty much any instruction in the JVM can fail,
so we need to defend against these cases.

== Starting at the Bottom

If we convert Attendees to Kotlin we get

// begin-insert: tags/errors.2:src/main/java/colloquiumatic/Attendees.kt
[source,kotlin]
----
interface Attendees {
    @Throws(DuplicateException::class) // <1>
    fun add(name: String?, email: String?): Attendee?
    fun find(id: String?): Optional<Attendee?>?
}
----
// end-insert

1. Although Kotlin doesn't have checked exceptions, the `@Throws` annotation allows interoperation with Java code.
Without it, a Java implementation of Attendees cannot override the method
(assuming that it does actually throw DuplicateException).
Worse, it can't catch the exception
or declare that it is passed on,
as it is a compile error for Java code to handle a checked exception
that the compiler cannot see is possible.

Before we go further, conversion to Kotlin has failed to infer the nullability of the parameters and results in Attendees,
lets fix that.

// begin-insert: tags/errors.3:src/main/java/colloquiumatic/Attendees.kt
[source,kotlin]
----
interface Attendees {
    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Attendee /// |
    fun find(id: String): Optional<Attendee> /// |
}
----
// end-insert

What we're going to do for now is to add to our interface a version of `Attendees.add` that instead of throwing an exception,
returns `Result<Attendee, DuplicateException>`.

If we were starting from scratch we would probably not use an exception as our error type,
but here it lets us interoperate with Java easily.
We'll keep the old throwy version around for now so that we don't break existing callers,
convert those callers to use the result version,
then remove the old version when we can.

First we add result4k to our build.

// begin-insert: tags/errors.4:build.gradle#result4k
[source,groovy]
----
dependencies {
     ... 
    implementation "com.natpryce:result4k:2.0.0"
     ... 
}
----
// end-insert

and then we can add a default method to thunk from the exception case to the result.
We can't call it `add` too, as both have the same parameters, so we call it `addToo` for now.

// begin-insert: tags/errors.5:src/main/java/colloquiumatic/Attendees.kt
[source,kotlin]
----
interface Attendees {
    @Throws(DuplicateException::class)
    fun add(name: String, email: String): Attendee

    @JvmDefault // <1>
    fun addToo(name:String, email:String)
        : Result<Attendee, DuplicateException> =
        try {
            Success(add(name, email))
        } catch (x: DuplicateException) {
            Failure(x)
        }

    fun find(id: String): Optional<Attendee>
}
----
// end-insert

<1> This annotation tells the compiler to generate Java-compatible default methods.
We wouldn't have had to do this had we left Attendees in Java -
we live and learn.
You have to tell the compiler how to implement `@JVMDefault` with a compiler switch.

// begin-insert: tags/errors.5:build.gradle#foo
[source,groovy]
----
compileKotlin {
    kotlinOptions.jvmTarget = "1.8"
    kotlinOptions.freeCompilerArgs = ['-Xjvm-default=compatibility']
}
----
// end-insert

.Naming
****
It's a bit irritating that we can't name the new method `add` as well,
but the JVM won't allow methods that differ only on return type to have the same name.

If we can't think of a good name in these or other situations,
we err on the side of using a bad one.
In all likelihood we'll come up with a better name later,
and the bad name will reduce the risk that we settle for not-good-enough.

In this case it really shouldn't matter,
because we know that by the end of this refactor we will have replaced the original method,
and can steal its name.
****

Now we have both exception and result version of the method,
we can migrate the callers of the exception version.
While we can use result4k from Java,
it's a lot more convenient from Kotlin.
So let's take Registration (the caller of `add`)

// begin-insert: tags/errors.5:src/main/java/colloquiumatic/Registration.java
[source,java]
----
public class Registration implements IRegister {

    private final Blacklist blacklist;
    private final Attendees attendees;

    public Registration(
        Attendees attendees,
        Blacklist blacklist
    ) {
        this.blacklist = blacklist;
        this.attendees = attendees;
    }

    public Attendee register(RegistrationData data)
        throws BlacklistedException, DuplicateException {
        if (blacklist.isAcceptable(data))
            return attendees.add(data.name, data.email);
        else throw new BlacklistedException();
    }
}
----
// end-insert

and convert it to Kotlin

// begin-insert: tags/errors.6:src/main/java/colloquiumatic/Registration.kt
[source,kotlin]
----
class Registration(
    private val attendees: Attendees,
    private val blacklist: Blacklist
) : IRegister {

    @Throws(BlacklistedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Attendee {
        return if (blacklist.isAcceptable(data))
            attendees.add(data.name, data.email)
        else throw BlacklistedException()
    }
}
----
// end-insert

That `attendees.add` expression is the one that can throw DuplicateException.
We're going to want to look at its result,
so we invert the if

// begin-insert: tags/errors.7:src/main/java/colloquiumatic/Registration.kt#invert
[source,kotlin]
----
@Throws(BlacklistedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Attendee {
    return if (!blacklist.isAcceptable(data)) throw BlacklistedException()
    else
        attendees.add(data.name, data.email)
}
----
// end-insert

move the return

// begin-insert: tags/errors.8:src/main/java/colloquiumatic/Registration.kt#invert
[source,kotlin]
----
@Throws(BlacklistedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Attendee {
    if (!blacklist.isAcceptable(data))
        throw BlacklistedException()
    return attendees.add(data.name, data.email)
}
----
// end-insert

and then extract the result as a local

// begin-insert: tags/errors.9:src/main/java/colloquiumatic/Registration.kt#invert
[source,kotlin]
----
@Throws(BlacklistedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Attendee {
    if (!blacklist.isAcceptable(data))
        throw BlacklistedException()
    val result: Attendee = attendees.add(data.name, data.email)
    return result
}
----
// end-insert

Now if we call `addToo` instead it will no longer throw,
but the exception will be returned in the Result.
This won't compile yet

// begin-insert: tags/errors.10:src/main/java/colloquiumatic/Registration.kt#invert
[source,kotlin]
----
@Throws(BlacklistedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Attendee {
    if (!blacklist.isAcceptable(data))
        throw BlacklistedException()
    val result: Result<Attendee, DuplicateException> =
        attendees.addToo(data.name, data.email)
    return result // <1>
}
----
// end-insert

<1> Type mismatch. Required: Attendee Found: Result<Attendee, DuplicateException>

Now to throw the exception in the result
(in order to keep the current behaviour of `register`)
we can use `result.recover` which will give us the exception back to throw

// begin-insert: tags/errors.11:src/main/java/colloquiumatic/Registration.kt#invert
[source,kotlin]
----
@Throws(BlacklistedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Attendee {
    if (!blacklist.isAcceptable(data))
        throw BlacklistedException()
    val result: Result<Attendee, DuplicateException> =
        attendees.addToo(data.name, data.email)
    return result.recover { x -> throw x }
}
----
// end-insert

and now we can inline to get back to a shorter form

// begin-insert: tags/errors.12:src/main/java/colloquiumatic/Registration.kt#invert
[source,kotlin]
----
@Throws(BlacklistedException::class, DuplicateException::class)
override fun register(data: RegistrationData): Attendee {
    if (!blacklist.isAcceptable(data))
        throw BlacklistedException()
    return attendees.addToo(data.name, data.email)
        .recover { throw it }
}
----
// end-insert

That is a good place for a rest,
having learned to replace one use of exceptions with a result type.

== Moving Up a Level

OK, ready to go again? Good.

We now have to choose whether to proceed depth or breadth first.
Depth first would address the caller of `Registration.register`,
breadth first would first fix up other callers of `Attendees.add`.
As it happens our example code has no other callers of `add`,
and breadth first will allow us to remove our irritating `addToo`,
so lets go that way.

While there is no other caller of `Attendees.add`, there is of course at least one implementation.
Let's look at the (not thread-safe) test version.

// begin-insert: tags/errors.12:src/test/java/colloquiumatic/InMemoryAttendees.java
[source,java]
----
public class InMemoryAttendees implements Attendees {

    private final List<Attendee> list = new ArrayList<>();
    private int id = 0;

    @Override
    public Attendee add(String name, String email) throws DuplicateException {
        if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
            throw new DuplicateException("attendee with email " + email + " already exists");
        int newId = id++;
        Attendee result = new Attendee(Integer.toString(newId), name, email);
        list.add(result);
        return result;
    }

    @Override
    public Optional<Attendee> find(String id) {
        return list.stream().filter(attendee -> attendee.getId().equals(id)).findFirst();
    }

    // for test
    public void add(Attendee attendee) {
        list.add(attendee);
    }

    public int size() {
        return list.size();
    }
}
----
// end-insert

The easiest way to implement `addToo` here is probably just to duplicate `add` and fix it up

// begin-insert: tags/errors.13:src/test/java/colloquiumatic/InMemoryAttendees.java#foo
[source,java]
----
@Override
public Attendee add(String name, String email) throws DuplicateException {
    if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
        throw new DuplicateException("attendee with email " + email + " already exists");
    int newId = id++;
    Attendee result = new Attendee(Integer.toString(newId), name, email);
    list.add(result);
    return result;
}

@SuppressWarnings("unchecked")
@Override
public Result<Attendee, DuplicateException> addToo(String name, String email) {
    if (list.stream().anyMatch( item -> item.getEmail().equals(email)))
        return new Failure<DuplicateException>(new DuplicateException("attendee with email " + email + " already exists"));
    int newId = id++;
    Attendee result = new Attendee(Integer.toString(newId), name, email);
    list.add(result);
    return new Success<Attendee>(result);
}
----
// end-insert

Were we still to have any uses of `add` we could implement it in terms of our new method,
but we don't, so we can just remove it from here and the interface, and then rename `addToo` to `add`, leaving us with

// begin-insert: tags/errors.14:src/main/java/colloquiumatic/Attendees.kt
[source,kotlin]
----
interface Attendees {

    fun add(name:String, email:String): Result<Attendee, DuplicateException>

    fun find(id: String): Optional<Attendee>
}
----
// end-insert

and

// begin-insert: tags/errors.14:src/main/java/colloquiumatic/Registration.kt
[source,kotlin]
----
class Registration(
    private val attendees: Attendees,
    private val blacklist: Blacklist
) : IRegister {

    @Throws(BlacklistedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Attendee {
        if (!blacklist.isAcceptable(data))
            throw BlacklistedException()
        return attendees.add(data.name, data.email)
            .recover { throw it }
    }
}
----
// end-insert

We left InMemoryAttendees as Java really just to demonstrate that we could return result4k types from our old code,
but I can't resist the conversion, as it has a number of warnings of the type `Not annotated [X] overrides @NotNull [X]`.

// begin-insert: tags/errors.15:src/test/java/colloquiumatic/InMemoryAttendees.kt
[source,kotlin]
----
class InMemoryAttendees : Attendees {

    private val list = mutableListOf<Attendee>()
    private var id = 0

    override fun add(name: String, email: String): Result<Attendee, DuplicateException> =
        when {
            list.any { it.email == email } ->
                Failure(DuplicateException("attendee with email $email already exists"))
            else -> {
                val result = Attendee(id++.toString(), name, email)
                list.add(result)
                Success(result)
            }
        }

    override fun find(id: String): Optional<Attendee> =
        list.firstOrNull { it.id == id }.toOptional()

    // for test
    fun add(attendee: Attendee) {
        list.add(attendee)
    }

    fun size() = list.size
}
----
// end-insert

Lets recap where we are now. Attendees is now Kotlin, and `add` returns a result instead of throwing DuplicateException

// begin-insert: tags/errors.15:src/main/java/colloquiumatic/Attendees.kt
[source,kotlin]
----
interface Attendees {

    fun add(name:String, email:String): Result<Attendee, DuplicateException>

    fun find(id: String): Optional<Attendee>
}
----
// end-insert

IRegister is still Java, and still throws 2 types of exception.
// begin-insert: tags/errors.15:src/main/java/colloquiumatic/IRegister.java
[source,java]
----
public interface IRegister {
    Attendee register(RegistrationData data)
        throws BlacklistedException, DuplicateException;
}
----
// end-insert

Registration is now Kotlin, and is the place where we now thunk between error and exception

// begin-insert: tags/errors.15:src/main/java/colloquiumatic/Registration.kt
[source,kotlin]
----
class Registration(
    private val attendees: Attendees,
    private val blacklist: Blacklist
) : IRegister {

    @Throws(BlacklistedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Attendee {
        if (!blacklist.isAcceptable(data))
            throw BlacklistedException()
        return attendees.add(data.name, data.email)
            .recover { throw it }
    }
}
----
// end-insert

If we are to follow the same pattern with IRegister as we did with Attendees -
provide a default implementation of an adapter between exception-throwing and error-returning -
we are going to have to address the issue of how to express
`Result<Attendee, Either<BlacklistedException, DuplicateException>>`.

We could reach for a generic Either type, but that only gets us so far as a strategy.
For a start, it will mean that `Either<BlacklistedException, DuplicateException>` is not the same thing as `Either<DuplicateException, BlacklistedException>`,
which is at best confusing,
and gets worse when we expand to `OneOf<BlacklistedException, DuplicateException, SomeOtherProblem>`.
Instead our best bet here is not to try to express the error in terms of existing types
but to map to a new type.

// begin-insert: tags/errors.16:src/main/java/colloquiumatic/IRegister.kt
[source,kotlin]
----
interface IRegister {

    @Throws(BlacklistedException::class, DuplicateException::class)
    fun register(data: RegistrationData): Attendee

    fun registerToo(data: RegistrationData): Result<Attendee, RegistrationProblem> =
        try {
            Success(register(data))
        } catch (x: BlacklistedException) {
            Failure(BlackListed)
        } catch (x: DuplicateException) {
            Failure(Duplicate(x.message))
        }
}

sealed class RegistrationProblem

object BlackListed : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
----
// end-insert

As exception and error are all overloaded terms,
we've chosen RegistrationProblem,
with subtypes of Blacklisted,
which carries no additional information and so can be an object,
and Duplicate,
which carries any data from the original exception.

Now we can go and migrate callers of `register` to `registerToo`. Starting with RegistrationHandler, which we convert to Kotlin first.

// begin-insert: tags/errors.17:src/main/java/colloquiumatic/handlers/RegistrationHandler.kt
[source,kotlin]
----
class RegistrationHandler(
    private val registration: IRegister
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val attendee = registration.register(data)
            Response(
                HTTP_CREATED,
                objectMapper.writeValueAsString(attendee)
            )
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: BlacklistedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}
----
// end-insert

Now call the adapter method and act on the return type

// begin-insert: tags/errors.18:src/main/java/colloquiumatic/handlers/RegistrationHandler.kt
[source,kotlin]
----
class RegistrationHandler(
    private val registration: IRegister
) {
    private val objectMapper = ObjectMapper()

    fun handle(request: Request): Response {
        return try {
            val data = objectMapper.readValue(
                request.body,
                RegistrationData::class.java
            )
            val attendee: Result<Attendee, RegistrationProblem> =
                registration.registerToo(data)
            when (attendee) {
                is Success -> Response(HTTP_CREATED, objectMapper.writeValueAsString(attendee.value))
                is Failure -> attendee.reason.toResponse()
            }
        } catch (x: JsonProcessingException) {
            Response(HTTP_BAD_REQUEST)
        } catch (x: BlacklistedException) {
            Response(HTTP_FORBIDDEN)
        } catch (x: DuplicateException) {
            Response(HTTP_CONFLICT)
        } catch (x: Exception) {
            Response(HTTP_INTERNAL_ERROR)
        }
    }
}

private fun RegistrationProblem.toResponse() = when (this) {
    is Duplicate -> Response(HTTP_CONFLICT)
    is BlackListed -> Response(HTTP_FORBIDDEN)
}
----
// end-insert

before removing the unnecessary exception cases and simplifying the error case

// begin-insert: tags/errors.19:src/main/java/colloquiumatic/handlers/RegistrationHandler.kt#foo
[source,kotlin]
----
fun handle(request: Request): Response = try {
    val data = objectMapper.readValue(
        request.body,
        RegistrationData::class.java
    )
    registration.registerToo(data)
        .map {
            Response(HTTP_CREATED, objectMapper.writeValueAsString(it))
        }
        .recover { error ->
            error.toResponse()
        }
} catch (x: JsonProcessingException) {
    Response(HTTP_BAD_REQUEST)
} catch (x: Exception) {
    Response(HTTP_INTERNAL_ERROR)
}
----
// end-insert

Note that this code is not exception-free.
Firstly the ObjectMapper can still throw.
That is the reality of Java (and frankly most Kotlin) APIs,
but the code is safe and communicates well as the throwing and catching are in the same method.
Secondly we still have to consider other runtime exceptions that could be thrown from anywhere (NullPointerException etc).
These can could have crossed function boundaries and leaked up to here, where the buck stops -
at the top-level catch-all.
The reality is that we still have unexpected exceptions,
but the expected failure cases are now expressed by Results and communicated in our code.


Now we can confess that the RegistrationHandlerTests got broken a few steps ago.
Ordinarily we would have fixed them straight away,
but that would have interrupted our explanation.

The problem is that the tests are mock tests which expect calls to `IRegister.register`,
but we are now calling `registerToo`. For example

// begin-insert: tags/errors.20:src/test/java/colloquiumatic/handlers/RegistrationHandlerTests.java#foo
[source,java]
----
public class RegistrationHandlerTests {

    @RegisterExtension
    final Mockery mockery = new JUnit5ClassMockery();

    final IRegister registration = mockery.mock(IRegister.class);
    final RegistrationHandler handler = new RegistrationHandler(registration);

    final String fredBody = toJson("{ 'name' : 'fred', 'email' : 'fred@bedrock.com' }");
    final RegistrationData fredData = new RegistrationData("fred", "fred@bedrock.com");

    @Test
    public void returns_Created_with_body_on_success()
        throws DuplicateException, BlacklistedException {

        mockery.checking(new Expectations() {{
            oneOf(registration).register(fredData);
            will(returnValue(new Attendee("0", fredData.name, fredData.email)));
        }});

        String expectedBody = toJson(
            "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
        );
        assertEquals(
            new Response(HTTP_CREATED, expectedBody),
            handler.handle(new Request(fredBody))
        );
    }

    @Test
    public void returns_Conflict_for_duplicate()
        throws DuplicateException, BlacklistedException {

        mockery.checking(new Expectations() {{
            oneOf(registration).register(fredData);
            will(throwException(new DuplicateException("deliberate")));
        }});

        assertEquals(
            new Response(HTTP_CONFLICT),
            handler.handle(new Request(fredBody))
        );
    }
    ...
    private String toJson(String jsonIsh) {
        return jsonIsh.replace('\'', '"');
    }
}
----
// end-insert

We can fix the wrong expectation and the return type in one edit.
Note that returning a error type has simplified our mock tests -
we can dispense with a special `throwException` action in favour of returning
`Success` or `Failure`.

// begin-insert: tags/errors.21:src/test/java/colloquiumatic/handlers/RegistrationHandlerTests.java#foo
[source,java]
----
@Test
public void returns_Created_with_body_on_success() {
    mockery.checking(new Expectations() {{
        oneOf(registration).registerToo(fredData);  /// |
        will(returnValue(                           /// |
            new Success<>(                          /// |
                new Attendee("0", fredData.name, fredData.email) /// |
            )));                                    /// |
    }});

    String expectedBody = toJson(
        "{'id':'0','name':'fred','email':'fred@bedrock.com'}"
    );
    assertEquals(
        new Response(HTTP_CREATED, expectedBody),
        handler.handle(new Request(fredBody))
    );
}

@Test
public void returns_Conflict_for_duplicate() {
    mockery.checking(new Expectations() {{
        oneOf(registration).registerToo(fredData);  /// |
        will(returnValue(                           /// |
            new Failure<>(                          /// |
                new Duplicate("deliberate")         /// |
            )));                                    /// |
    }});

    assertEquals(
        new Response(HTTP_CONFLICT),
        handler.handle(new Request(fredBody))
    );
}
----
// end-insert

At this point we can now return to Registration
and implement `registerToo` directly.
In lieu of any cleverer idea we do this by duplicating the `register` method
and fettling the error handling,
using `Result.mapFailure` to convert DuplicateException to Duplicate.

// begin-insert: tags/errors.22:src/main/java/colloquiumatic/Registration.kt
[source,kotlin]
----
class Registration(
    private val attendees: Attendees,
    private val blacklist: Blacklist
) : IRegister {

    @Throws(BlacklistedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Attendee {
        if (!blacklist.isAcceptable(data))
            throw BlacklistedException()
        return attendees.add(data.name, data.email)
            .recover { throw it }
    }

    override fun registerToo(data: RegistrationData): Result<Attendee, RegistrationProblem> {
        if (!blacklist.isAcceptable(data))
            return Failure(BlackListed)
        return attendees.add(data.name, data.email)
            .mapFailure { exception: DuplicateException ->
                Duplicate(exception.message)
            }
    }
}
----
// end-insert

There are two problems with this.
Firstly, `register` now has no test code,
and secondly, we have the duplicate logic caused by our just duplicating the code.
We can fix both by implementing `registerToo` in terms of `register` -
the opposite of what we did in IRegister.

// begin-insert: tags/errors.23:src/main/java/colloquiumatic/Registration.kt
[source,kotlin]
----
class Registration(
    private val attendees: Attendees,
    private val blacklist: Blacklist
) : IRegister {

    @Throws(BlacklistedException::class, DuplicateException::class)
    override fun register(data: RegistrationData): Attendee =
        registerToo(data).recover { error ->
            when (error) {
                is BlackListed -> throw BlacklistedException()
                is Duplicate -> throw DuplicateException(error.message)
            }
        }

    override fun registerToo(data: RegistrationData): Result<Attendee, RegistrationProblem> =
        if (blacklist.isAcceptable(data)) {
            attendees.add(data.name, data.email)
                .mapFailure { exception: DuplicateException ->
                    Duplicate(exception.message)
                }
        } else Failure(BlackListed)
}
----
// end-insert

Now our RegistrationTests, which work in terms of `register`, will be testing `registerToo` for us.

// begin-insert: tags/errors.23:src/test/java/colloquiumatic/RegistrationTests.java
[source,java]
----
public class RegistrationTests {

    InMemoryAttendees attendees = new InMemoryAttendees();
    Map<String, Boolean> blacklist = Map.of(
        "fred@bedrock.com", true,
        "cruella@hellhall.co.uk", false
    );
    Registration registration = new Registration(attendees,
        (registrationData) -> blacklist.get(registrationData.email)
    );

    @Test
    public void adds_an_attendee_when_not_blacklisted()
        throws DuplicateException, BlacklistedException {
        assertEquals(Optional.empty(), attendees.find("0"));

        Attendee added = registration.register(
            new RegistrationData("fred flintstone", "fred@bedrock.com")
        );
        assertEquals(
            new Attendee("0", "fred flintstone", "fred@bedrock.com"),
            added
        );
        assertEquals(added, attendees.find("0").orElseThrow());
    }

    @Test
    public void throws_duplicate_when_email_address_exists() {
        attendees.add(new Attendee("0", "fred flintstone", "fred@bedrock.com"));
        assertEquals(1, attendees.size());

        assertThrows(DuplicateException.class,
            () -> registration.register(
                new RegistrationData("fred flintstone", "fred@bedrock.com")
            )
        );
        assertEquals(1, attendees.size());
    }

    @Test
    public void throws_blacklisted_when_blacklisted() {
        assertThrows(BlacklistedException.class,
            () -> registration.register(
                new RegistrationData("cruella de vil", "cruella@hellhall.co.uk")
            )
        );
        assertEquals(0, attendees.size());
    }
}
----
// end-insert

Of course, we are currently trying to get rid of `register`,
and these tests are it's last bastion.
We could take the time to show how to use result4k in Java,
but I for one am pretty tired of this refactoring now,
so we'll convert the tests to Kotlin and
then to register with the immortal words,
"here's one I made earlier".

// begin-insert: tags/errors.24:src/test/java/colloquiumatic/RegistrationTests.kt
[source,kotlin]
----
class RegistrationTests {

    var attendees = InMemoryAttendees()
    var blacklist = mapOf(
        "fred@bedrock.com" to true,
        "cruella@hellhall.co.uk" to false
    )
    var registration = Registration(
        attendees,
        Blacklist { registrationData ->
            blacklist.getOrDefault(registrationData.email, false)
        }
    )

    @Test
    fun `adds an attendee when not blacklisted`() {
        assertEquals(Optional.empty<Any>(), attendees.find("0"))

        val added = registration.registerToo(
            RegistrationData("fred flintstone", "fred@bedrock.com")
        ).valueOrNull()
        assertEquals(
            Attendee("0", "fred flintstone", "fred@bedrock.com"),
            added
        )
        assertEquals(added, attendees.find("0").orElseThrow())
    }

    @Test
    fun `returns duplicate when email address exists`() {
        attendees.add(Attendee("0", "fred flintstone", "fred@bedrock.com"))
        assertEquals(1, attendees.size())

        val failure = registration.registerToo(
            RegistrationData("fred flintstone", "fred@bedrock.com")
        ).failureOrNull()
        assertEquals(
            Duplicate("attendee with email fred@bedrock.com already exists"),
            failure
        )
        assertEquals(1, attendees.size())
    }

    @Test
    fun throws_blacklisted_when_blacklisted() {
        val failure = registration.registerToo(
            RegistrationData("cruella de vil", "cruella@hellhall.co.uk")
        ).failureOrNull()
        assertEquals(
            BlackListed,
            failure
        )
        assertEquals(0, attendees.size())
    }
}
----
// end-insert

Now we have no callers of `register`,
we can finally remove it and rename `registerToo` to `register`,
ending up with (almost) exception-free Kotlin.

// begin-insert: tags/errors.25:src/main/java/colloquiumatic/IRegister.kt
[source,kotlin]
----
interface IRegister {
    fun register(data: RegistrationData): Result<Attendee, RegistrationProblem>
}

sealed class RegistrationProblem

object BlackListed : RegistrationProblem()

data class Duplicate(
    val message: String?
) : RegistrationProblem()
----
// end-insert

// begin-insert: tags/errors.25:src/main/java/colloquiumatic/Attendees.kt
[source,kotlin]
----
interface Attendees {

    fun add(name:String, email:String): Result<Attendee, DuplicateException>

    fun find(id: String): Optional<Attendee>
}
----
// end-insert

Hmm, not quite exception-free because of that DuplicateException,
which is not thrown from anywhere anymore, just created and
put into a Failure.
It's an easy fix to rename the class to DuplicateProblem
and stop extending Exception -
you can trust us to do it without bothering you.











