== An opinionated history of Java programming style

Kotlin has features that support different _styles_ of Java programming.  Over the decades, Java programming style has developed through several distinct eras, that we'll name Classical Style, Beans Style, Enterprise Style, and Modern Style.  We'll refer to these styles as a shorthand when explaining why certain Kotlin features exist, and how to use them.

=== Classical Style

Originally intended for domestic appliances and interactive TV, Java only took off when Netscape supported Java applets in their hugely popular Navigator browser.  Suddenly everyone with a web browser had a Java runtime environment.  Sun released the Java development kit 1.0, Microsoft included Java in Internet Explorer, and interest in Java as a programming language exploded.

A lot of the fundamentals of Java existed at that time: the Java virtual machine and its bytecode and classfile format; primitive and reference types; null references; garbage collection; classes and interfaces; methods and control flow statements; checked exceptions for error handling; the abstract windowing toolkit; classes for networking with Internet and web protocols; and loading and linking of code at runtime, sandboxed by a security manager. However, Java wasnâ€™t yet ready for general purpose programming: the JVM was slow and the standard library sparse.

Java looked like a cross between C++ and Smalltalk, and Java programming style at the time was influenced by those two languages. It had not yet developed the "getFoo/setFoo" and "AbstractSingletonProxyFactoryBean" conventions that programmers of other languages poke fun at.

One of Java's unsung innovations was an official coding convention that spelled out how programmers should name packages, classes, methods, and variables.  C and C++ programmers followed a seemingly infinite variety of coding conventions, and code that combined multiple libraries ended up looking [.line-through]#like a right dog's dinner# somewhat inconsistent.  Java's one true coding convention meant that Java programmers could seamlessly integrate strangers' libraries into their programs, and encouraged widespread use of open source libraries in the Java community.

=== Bean Style

1996: Java started to become a practical tool with version 1.1. This release introduced language changes (most notably inner classes), runtime changes (most notably just-in-time compilation and reflection), and many additions to the standard library.  1998: Java 1.2 introduced a standard collections API and the Swing cross-platform GUI framework, which ensured Java applications stood out on every desktop operating system.

Sun was eyeing Microsoft's domination of corporate software development. Java had potential as a competitor to Visual Basic.  They added a slew of APIs that were, to be charitable, heavily inspired by Microsoft APIs.  JDBC for data base access (Microsoft had ODBC), Swing for desktop GUI programming (Microsoft had MFC), and the API that had the biggest influence on Java programming style: Java Beans.

Java Beans was Sun's attempt to compete with Microsoft's ActiveX component model for low-code, graphical, drag-and-drop programming.  Programmers could use ActiveX components in their Visual Basic programs, or embed them in office documents, or in web pages on their corporate intranet.  ActiveX components were notoriously difficult to write, and Java Beans were much easier.  You merely had to follow some additional coding conventions for your class to be considered a "bean" that could be instantiated and configured in a graphical UI designer.

To be a Java Bean, a class had to have a constructor that took no arguments, and expose an interface made up of public properties that could be read and optionally written, methods that could be invoked, and events that objects of the class would announce.  In an application designer, programmers could instantiate beans, set their properties, and write event listeners that invoked methods of other beans.  By default, properties were defined by methods with names that started with get and set.  This default could be overridden, but doing so required so much boilerplate that programmers usually only did so for existing classes. It was much easier to follow the conventions in new classes.

The drawback of Beans style is that it relies heavily on mutable state, and requires more of that state to be public than plain ol' Java objects because you cannot pass parameters to an object's constructor.  Object state must be mutable so that it can be set after construction and objects must often be instantiated in an invalid state -- with required properties initialised to null, for example -- and then put into a valid state by setting their public properties.  The type checker can't ensure this has been done correctly. So writing a correct code is harder and changes in dependencies can silently break client code.

In the end, graphical composition of Java beans never became mainstream, but the coding conventions stuck.  Java programmers followed the Java Bean conventions even when they had no intention of their class being used as a Java Bean.  Beans had an enormous, lasting, and not entirely positive, influence on Java programming style.

=== Enterprise Style

Java did eventually spread through the enterprise. It didn't replace Visual Basic on the corporate desktop as expected, but unseated C++ as the server-side language of choice.  In 1998, Sun released Java 2 Enterprise Edition (J2EE, later rebranded as JavaEE), a suite of standard APIs for programming server-side, transaction processing systems.

1999 saw Java 5, the most significant change to the language to date. Java 5 (aka 1.5), introduced generic types and API changes to the standard library to use generics.

The J2EE APIs suffer from _abstraction inversion_.  The Java Beans and applets APIs also suffer from abstraction inversion -- they both disallow passing parameters to constructors, for example -- but it is far more severe in J2EE.  J2EE applications don't have a single entry point. They are defined as many small components whose lifetime is managed by an "application container", and are exposed to one another through the JNDI name service.  Applications need a lot of boilerplate code and mutable state to look up and store the resources they depend on.  Programmers responded by inventing "dependency injection" frameworks that did all the resource look up and binding and managed lifetimes. The most successful of these is Spring.  It builds upon the Java Beans coding conventions, and uses reflection to compose applications from "beans".

****
.Abstraction Inversion

_Abstraction Inversion_ is an architectural flaw in which a software platform prevents client code from using lower level mechanisms, and forces programmers to reimplement those lower level mechanisms using the facilities exposed by the platform's API, which in turn uses the very features being reimplemented.  The result is unnecessary code, poor performance, incompatible implementations,  that performs  a construct need functions implemented within it but not exposed by its interface. The result is that the users re-implement the required functions in terms of the interface, which in its turn uses the internal implementation of the same functions. This may result in implementing lower-level features in terms of higher-level ones, thus the term 'abstraction inversion'.
****

In terms of programming style, DI encourages programmers to eschew direct use of the `new` keyword, and rely on the DI framework to instantiate objects.  (I'd count Android APIs in these as well: they also exhibit abstraction inversion, and Android programmers also turn to DI frameworks to help them write to the APIs.). DI frameworks focus on mechanism over domain modelling, leading to "enterprisey" class names, such as Spring's infamous `AbstractSingletonProxyFactoryBean`.

But on the plus side, this era saw a massive uptake of Open Source libraries in the Java community, powered by the Maven Central package repository.  The availability of top notch open source libraries fueled the adoption of Java for business critical application development, and led to more open source libraries, in a virtuous circle.  This was followed by best in class development tools, including IntelliJ which we use in this book.


=== Modern Style

Java 8 included the significant changes to the language since Java 5 --lambdas -- and significant additions to the standard library to take advange of them.  The Streams API encouraged a functional programming style, in which processing is performed by transforming streams of immutable values rather than changing the state of mutable objects.  The date/time API ignored Java Beans coding conventions for property accessors, and followed coding conventions common to the Classical Style.

The growth of the cloud platforms meant that programmers didn't need to deploy their servers into JavaEE application containers. Lightweight web application frameworks let programmers write a `main` function to compose their applications.  Many server side programmers stopped using DI frameworks -- function and object composition were good enough -- and DI frameworks released greatly simplified APIs to stay relevant.  With no DI framework or mutable state, there's less need to follow Java Bean coding conventions.  For internal code that is not published to Maven Central, exposing fields of immutable values works fine, because the IDE can encapsulate a field behind accessors in an instant if they're needed.

Java 11 introduced modules, but so far they have not seen widespread adoption outside the JDK itself.  The most exciting thing about recent Java releases has been the modularisation of the JDK and removal of obsolete modules -- CORBA, JavaFX, etc.

=== The future

The future of Java seems to be more features to make Modern Style easier to apply: records, pattern matching, user defined value types, and eventually the unification of primitive and reference types into a uniform type system.

However this is a challenging effort that will take many years to complete.  Java started off with some deep seated inconsistencies and edge cases that are hard to unify into clean abstractions while keeping backward compatibility.  Kotlin has the benefit of 25 years of hindsight and a clean slate.
