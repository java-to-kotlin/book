
Let's look more closely at generics and subtyping. But first, let's again take another short detour to define some terminology...

A generic is not a type, but is best thought of as a "function on types".  Applying a function to a value (or values) produces a value. Applying a generic to an type (or types) produces a type.  We call the type that it produces an _instantiation_ of the generic.

For example, here is a definition of a generic type, `Box`.  The basic syntax for generic types is the same as Java.

[source,kotlin]
----
interface Box<ITEM> {
    fun put(item: ITEM)
    fun take(): ITEM
}
----

To use a Box, we have to apply `Box<ITEM>` to the type of ITEM that we want to store in a box.  Or, in jargon, we want to _instantiate_ the generic for the type of item we want to store.  For example, we can have a `Box<Orange>` or `Box<Fish>`:

[source,kotlin]
----
class Orange { ... }
class Fish { ... }

val boxOfOranges : Box<Orange> = ...
val boxOfFish : Box<Fish> = ...
----

`Box<Orange>` and `Box<Fish>` are different types, which means that Kotlin will not let us pass a box of fish to code that expects a box of oranges and vice versa.

****
Generics highlight the difference between types and classes.  A generic is not a type, but does have a class.  Applying the generic to type parameters creates a type, but the class of the type is the class of the generic.  Kotlin doesn't create new class objects to represent instantiated generics.  Luckily you don't have to worry about that distinction unless you use reflection, and I find that I need to use reflection far less in Kotlin than I did in Java.
****


== Generics and subtyping

By default, generic types do not introduce subtyping relationships between instantiations of the generic.

For example, if `Orange` and `Apple` are subtypes of `Fruit`, the types `Box<Orange>` and `Box<Apple>` are _not_ subtypes of `Box<Fruit>`.

Let's walk through what would happen if they _were_... TODO

But it is useful to have subtyping relationships between instantiations of a generic type, and Kotlin helps us create these relationships more conveniently than in Java, by specifying _variance declarations_ on generic parameters.


=== Out variance

"Out" variance identifies data that is passed out from the generic.

[source,kotlin]
----
interface Supplier<out T> {
    fun receive(): T
}
----

Out variance creates subtype relationships between instantiations of the generic type that are the same as the subtype relationships between the actual parameter types.

For example: if I need a supplier of fruit,  then I can use a supplier that only supplies oranges.  But if I can only receive oranges, then a supplier that can supply all kinds of fruit will cause problems when they return a fruit that is not an orange.


=== In variance

"In" variance identifies data that is passed into the generic.

[source,kotlin]
----
interface Juicer<in T> {
    fun juice(solid: T): Liquid
}
----


In variance creates subtype relationships between instantations of the generic type that are the _opposite_ of subtype relationships between the actual parameter types.  It creates new supertypes!

A bit mind-bending, but makes sense when you think about it.

If I have need to put oranges into a juicer, I can use an orange squeezer, or a generic juicer.  Both will be able to juice oranges.

The other way would make no sense: if I need to juice different kinds of fruit, I cannot use a juicer that only squeezes oranges, and would get jammed if fed apples.


=== Variance and function types

Variance is inferred for function types: parameter types automatically get in variance, and the result type out variance.

However, variance is _not_ inferred for other generic types. As a result, it's easy to make your generic types too restrictive.

[source,kotlin]
----
interface Source<T> {
   fun take(): T
}

class AutomaticJuicer(val source: Source<Fruit>) ...

val apples: Source<Apple> = ...
val juicer = AutomaticJuicer(apples) // type error
----

That's not a problem within a single codebase: when the type checker complains, you can add the variance modifiers to the generic.  Be careful if you publish a library:  your users will not have that option.

When writing a generic type, keep an eye on IntelliJ's code analysis highlighting: it identifies where you should add variance declarations.


== Separate types for read, write, and read/write

Use interfaces to define distinct types that can have in or out variance.

[source,kotlin]
----
interface Store<in T> {
   fun put(item: T)
}

interface Source<out T> {
   fun take(): T
}

interface Box<T>: Store<T>, Source<T>
----

Lots of examples in the standard library. E.g. List<T> / MutableList<T>
