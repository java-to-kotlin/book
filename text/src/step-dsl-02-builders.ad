[[builders]]
= We look at alternatives to the [.pattern]_Builder_ pattern

Java programmers use the [.pattern]_Builder_ pattern for several purposes:
to make it easier to instantiate classes that have many constructor parameters;
to construct immutable objects in imperative code;
to allow tests to specify only the properties relevant to a test scenario and use safe defaults for all others;
to act as the grammar of an embedded domain-specific language expressed with chained method calls, known as a [.pattern]_Fluent API_.
Despite all the repetitive boiler plate code they involve, Java programmers do find builders are worth the effort and address real challenges that they face using the language.

In this chapter, we'll look at how Kotlin makes many of these uses of builders unnecessary. Later we'll look at how to leverage Kotlin language features to simplify writing builders and embedded domain-specific languages.


== Builders for constructors with many parameters

The following code shows class representing session proposals.  Our system has a web application for people to propose conference sessions during the CFP period.

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/Proposal.java#built_object
[source,java]
[%autofit]
----
public class Proposal {
    private final SessionType type;
    private final String title;
    private final List<PresenterDetails> presenters;
    private final int durationInSlots;
    private final String blurb;
    private final String detailsForReviewers;
    private final String extraRequirements;

    public Proposal( // <1>
        SessionType type,
        String title,
        List<PresenterDetails> presenters,
        int durationInSlots,
        String blurb,
        String detailsForReviewers,
        String extraRequirements
    ) {
        this.type = type;
        this.title = title;
        this.presenters = List.copyOf(presenters);
        this.durationInSlots = durationInSlots;
        this.blurb = blurb;
        this.detailsForReviewers = detailsForReviewers;
        this.extraRequirements = extraRequirements;
    }

    public static ProposalBuilder builder() { // <2>
        return new ProposalBuilder();
    }

    public SessionType getType() {
        return type;
    }

    public String getTitle() {
        return title;
    }

    // ... the rest of the accessors, equals, hashCode, and toString
}
----
// end-insert

The Proposal constructor has a lot of parameters, because Proposals have a lot of fields and sub-objects.  This makes calling the constructor directly error-prone. It's easy to pass the parameters in the wrong order, and end up with an presenter's email address where their name should be, or details for reviewers where the blurb for the audience should be, and it's difficult to spot those errors when reading the code.

To address these problems, we use the [.pattern]_Builder_ pattern.  Here's the method that parses a Proposal from a form posted by a web browser:

// begin-insert: tags/builders.0:src/main/java/colloquiumatic/proposal/ProposalFormParser.java#use_builder
[source,java]
[%autofit]
----
public Proposal parseProposalForm(Form form) throws FormParseException {
    ProposalBuilder proposal = Proposal.builder()
        .setType(form.field("type", SessionType.class))
        .setTitle(form.field("title"))
        .setBlurb(form.field("blurb"))
        .setDetailsForReviewers(form.field("details"))
        .setExtraRequirements(form.field("extra_requirements"))
        .setDurationInSlots(form.field("slots", Integer.class, Integer::parseInt));

    int i = 1;
    while (form.hasField("presenter_" + i + "_name")) {
        proposal.addPresenter(
            PresenterDetails.builder()
                .setName(form.field("presenter_" + i + "_name"))
                .setCountryISO2(form.field("presenter_" + i + "_country_iso2"))
                .setEmailAddress(form.field("presenter_" + i + "_email"))
                .build());
        i = i + 1;
    }

    return proposal.build();
}
----
// end-insert

The builder makes clear which properties the code is setting, which helps us avoid setting the wrong properties when we are writing the code, and makes it much easier to understand the code when we read it later.

TODO: in Kotlin, use named parameters.  The loop can be replaced by a collection pipeline.

In new Kotlin code, write it like this....


To refactor your way there, do this ....


== Builders of test data

Our tests that create Proposal objects also use builders, but for a slightly different reason.

Here's a test...

...

And here's the code that creates the builder.

...

In Kotlin, we can use constants instead of builders, as long as the objects we want to create are data objects.

