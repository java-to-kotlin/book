= Chapter 2 - More Stuff

Casting around the code for some more easy wins we find another value class -  Session.

// [start-insert] <main/java/chapter1/java/Session.java>
[source,java]
----
public class Session {

    public final String title;
    public final List<Presenter> presenters; // <1>

    public Session(String title, List<Presenter> presenters) {
        this.title = title;
        this.presenters = List.copyOf(presenters); // <2>
    }

    public String getTitle() {
        return title;
    }

    public List<Presenter> getPresenters() {
        return presenters;
    }

    // <3>
    public Session withPresenters(List<Presenter> newLineUp) {
        return new Session(title, newLineUp);
    }

    public Session withTitle(String newTitle) {
        return new Session(newTitle, presenters);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Session session = (Session) o;
        return Objects.equals(title, session.title) &&
            Objects.equals(presenters, session.presenters);
    }

    @Override
    public int hashCode() {
        return Objects.hash(title, presenters);
    }

    @Override
    public String toString() {
        return "chapter1.java.Session{" +
            "title='" + title + '\'' +
            ", presenters=" + presenters +
            '}';
    }
}
----
// [end-insert]

Like Presenter, Session is immutable and has tedious code to manage object identity. But it has some other features, namely

<1> One of the fields is a collection.

<2> Because `presenters` is a collection, and Java collections are mutable, we take a defensive copy in the constructor.

<3> There are some convenience methods that return a copy of the session with modified properties.

If we use IntelliJ to convert this to Kotlin, we get the following

// [start-insert] <main/kotlin/chapter1/kotlin/Session.kt>
[source,kotlin]
----
class Session(val title: String, presenters: List<Presenter>?) { // <1>
    val presenters: List<Presenter> // <2>

    fun withPresenters(newLineUp: List<Presenter>?): Session { // <4>
        return Session(title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(newTitle, presenters)
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val session = o as Session
        return title == session.title &&
            presenters == session.presenters
    }

    override fun hashCode(): Int {
        return Objects.hash(title, presenters)
    }

    override fun toString(): String {
        return "chapter1.java.Session{" +
            "title='" + title + '\'' +
            ", presenters=" + presenters +
            '}'
    }

    init {
        this.presenters = java.util.List.copyOf(presenters) // <3>
    }
}
----
// [end-insert]

The conversion has left us with some dubious Kotlin

<1> The `presenters` constructor parameter is marked with a `?` - Kotlin's way of indicating that it may be null. Why this is we don't know. (Don't worry, we'll talk a lot more about nullability throughout this book.)
<2> We have a `presenters` property outside the constructor.
<3> Which is initialised in this dangling `init` block.
<4> The `newPresenters` parameter has also been made nullable.

Alt-Enter at <3> will join the initialisation

[source,kotlin]
----
    val presenters : List<Presenter> = java.util.List.copyOf(presenters)
----

and we can just delete the question marks to show that `presenters` is not nullable.

// [start-insert] <main/kotlin/chapter1/kotlin/Session.2.kt>
[source,kotlin]
----
class Session(val title: String, presenters: List<Presenter>) {

    val presenters : List<Presenter> = java.util.List.copyOf(presenters)

    fun withPresenters(newLineUp: List<Presenter>): Session {
        return Session(title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(newTitle, presenters)
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val session = o as Session
        return title == session.title &&
            presenters == session.presenters
    }

    override fun hashCode(): Int {
        return Objects.hash(title, presenters)
    }

    override fun toString(): String {
        return "chapter1.java.Session{" +
            "title='" + title + '\'' +
            ", presenters=" + presenters +
            '}'
    }
}
----
// [end-insert]

`java.util.List` may have caught your attention. The other Lists here are Kotlin's own types, which are essentially immutable views of the Java type. You'll find they are often interchangeable, and we'll cover them in detail in later chapters. Here you can see that we can assign a `java.util.List` to a Kotlin list.

We would like to be able to remove all that value object boilerplate by making Session a data class, but in order to do that we have to have all the properties initialised in the constructor, and that defensive `java.util.List.copyOf` is presenting that at the moment. Checking all the callers of the constructor we find that none of them mutate the presenters having passed them in, so we can move the property into the constructor and we have another data class.

// [start-insert] <main/kotlin/chapter1/kotlin/Session.3.kt>
[source,kotlin]
----
data class Session(
    val title: String,
    val presenters: List<Presenter>
) {

    fun withPresenters(newLineUp: List<Presenter>): Session {
        return Session(title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(newTitle, presenters)
    }
}
----
// [end-insert]

None of the Java users of Session have had to change so far - let's look at the tests for example.

// [start-insert] <test/java/chapter1/java/SessionTests.java>
[source,java]
----
public class SessionTests {

    private static Presenter alice = new Presenter("id1", "Alice");
    private static Presenter bob = new Presenter("id2", "Bob");
    private static final List<Presenter> noPresenters = Collections.emptyList();

    private Session aSession = new Session("The Title", List.of(bob, alice));

    @Test
    public void can_change_title() {
        assertEquals(
            new Session("Another Title", List.of(bob, alice)),
            aSession.withTitle("Another Title")
        );
    }

    @Test
    public void can_change_presenters() {
        assertEquals(
            new Session("The Title", noPresenters),
            aSession.withPresenters(noPresenters)
        );
    }
}
----
// [end-insert]

<1> We can see that the `java.util.List<String>` argument is compatible with the `kotlin.collections.List<String>` parameter.

Converting the tests to Kotlin with IntelliJ we get

// [start-insert] <test/kotlin/chapter1/kotlin/SessionTests.kt>
[source,kotlin]
----
class SessionTests {
    private val aSession = Session(
        "The Title",
        java.util.List.of(bob, alice)
    )

    @Test
    fun can_change_title() {
        assertEquals( // <1>
            Session(
                "Another Title",
                java.util.List.of(bob, alice)
            ),
            aSession.withTitle("Another Title")
        )
    }

    @Test
    fun can_change_presenters() {
        assertEquals(
            Session("The Title", noPresenters),
            aSession.withPresenters(noPresenters)
        )
    }

    companion object {
        private val alice = Presenter("id1", "Alice")
        private val bob = Presenter("id2", "Bob")
        private val noPresenters: List<Presenter> = emptyList()
    }
}
----
// [end-insert]

<1> Actually we had that irritating lack of static imports again - we've fixed that already.

Look at the differences between the Java and Kotlin versions. They are very similar except that the static members have been moved onto a companion object. This provides a namespace for class-scoped code with advantages over Java that we will examine in later chapters. For now though it's just a bit of an irritation, so we'll make the properties plain old fields.

The `java.util.List.of` also stands out, and in fact IntelliJ offers to convert it to the Kotlin equivalent - `kotlin.collections.listOf`. Another Alt-Enter Easter egg can be found on the function names - IntelliJ will offer to convert them to eg `can change title` using the backtick feature to allow spaces and other characters in identifiers.

Once we're done the tests now look like this

// [start-insert] <test/kotlin/chapter1/kotlin/SessionTests.2.kt>
[source,kotlin]
----
class SessionTests {

    private val alice = Presenter("id1", "Alice")
    private val bob = Presenter("id2", "Bob")
    private val noPresenters: List<Presenter> = emptyList()

    private val aSession = Session(
        "The Title",
        listOf(bob, alice)
    )

    @Test
    fun `can change title`() {
        assertEquals(
            Session(
                "Another Title",
                listOf(bob, alice)
            ),
            aSession.withTitle("Another Title")
        )
    }

    @Test
    fun `can change presenters`() {
        assertEquals(
            Session("The Title", noPresenters),
            aSession.withPresenters(noPresenters)
        )
    }
}
----
// [end-insert]

We have one more data class trick up our sleeve. Returning to Session

// [start-insert] <main/kotlin/chapter1/kotlin/Session.3.kt>
[source,kotlin]
----
data class Session(
    val title: String,
    val presenters: List<Presenter>
) {

    fun withPresenters(newLineUp: List<Presenter>): Session {
        return Session(title, newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(newTitle, presenters)
    }
}
----
// [end-insert]

we can make use of Kotlin's named parameters (Alt-Enter inside the brackets)

// [start-insert] <main/kotlin/chapter1/kotlin/Session.4.kt#foo>
[source,kotlin]
----
    fun withPresenters(newLineUp: List<Presenter>): Session {
        return Session(title = title, presenters = newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return Session(title = newTitle, presenters = presenters)
    }
----
// [end-insert]

and then replace the constructor invocations with the special copy method

// [start-insert] <main/kotlin/chapter1/kotlin/Session.5.kt#foo>
[source,kotlin]
----
    fun withPresenters(newLineUp: List<Presenter>): Session {
        return copy(title = title, presenters = newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return copy(title = newTitle, presenters = presenters)
    }
----
// [end-insert]

Now remove the redundant arguments

// [start-insert] <main/kotlin/chapter1/kotlin/Session.6.kt#foo>
[source,kotlin]
----
    fun withPresenters(newLineUp: List<Presenter>): Session {
        return copy(presenters = newLineUp)
    }

    fun withTitle(newTitle: String): Session {
        return copy(title = newTitle)
    }
----
// [end-insert]

Where a Kotlin function body consists of a single expression you can Alt-Enter on the brace to convert it to a shorter form.

// [start-insert] <main/kotlin/chapter1/kotlin/Session.7.kt#foo>
[source,kotlin]
----
    fun withPresenters(newLineUp: List<Presenter>) = copy(presenters = newLineUp)

    fun withTitle(newTitle: String) = copy(title = newTitle)
----
// [end-insert]

All the time that there are Java uses of `withPresenters` and `withTitle` that is as far as we can go, but once the all callers have been converted to Kotlin, we can inline the methods

// [start-insert] <test/kotlin/chapter1/kotlin/SessionTests.3.kt#foo>
[source,kotlin]
----
    @Test
    fun `can change title`() {
        assertEquals(
            Session(
                "Another Title",
                listOf(bob, alice)
            ),
            aSession.copy(title = "Another Title")
        )
    }

    @Test
    fun `can change presenters`() {
        assertEquals(
            Session("The Title", noPresenters),
            aSession.copy(presenters = noPresenters)
        )
    }
----
// [end-insert]

at which point the test is now just checking the compiler, so we can delete it, leaving just the Session class.

// [start-insert] <main/kotlin/chapter1/kotlin/Session.8.kt>
[source,kotlin]
----
data class Session(
    val title: String,
    val presenters: List<Presenter>
)
----
// [end-insert]

== Conclusions

*