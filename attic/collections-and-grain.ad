The grain of Java and Kotlin are very different when it comes to collections.
Java's collection interfaces, in keeping with its object-oriented roots, are fundamentally mutable and so force you to encapsulate collections within classes to avoid accidental aliasing.
Kotlin's collections default to being unmodifiable, with APIs that return transformed copies rather than mutating in place, reducing the need such encapsulation.
Kotlin's standard library contains many more useful higher-order functions than Java's collection and stream APIs.
This reduces the need for imperative programming when processing collections.
These two forces encourage designs in which many free-standing functions transform a few generic collection types.

The different grains of the two languages bump up against one another at the interop boundary.
The interop between Java and Kotlin collections is virtually seamless, thanks to some compiler magic.
However, you need to be aware of that magic and its limitations to avoid confusing bugs.

