[role="digression"]
= The Kotlin Type Hierarchy

What are _types_?
And how do they relate to _classes_?

Both types and classes define a set of values and the operations that can be performed upon those values.
The key difference is that types relate to the _syntax of expressions_.
Classes relate to the runtime values referred to by the expressions.
A (over-)simplification: types exist in the compiler, classes in the VM.

.Types in the compiler and classes in the VM
image::diagrams/types-vs-classes.png[Types in the compiler and classes in the VM]

When you define a class in Kotlin, you also declare a type for that class.
One thing to beware of, however: the subtype/supertype relationships between types and subclass/superclass relationships between classes are sometimes different.
That won’t affect your code, unless you use reflection.
Happily (and this is a theme that will come up from time to time throughout the book) you need to use reflection far less in Kotlin than in Java.

The compiler's type checker ensures that code is self-consistent by analysing the syntax alone, without running the code.
By writing our code to work with the type checker, we need write fewer tests.
And it's not only by catching errors at compile time that types help us write correct code.
They let the IDE point out mistakes as we type, so we can correct errors before we compile, autosuggest and autocomplete code to save us time, and ensure refactorings transform the code correctly.

One of the reasons Java programmers prefer to rely on reflection is to avoid the boilerplate that Java syntax and type checker imposes on typed code.
In Kotlin you don't need to choose between type safety and clarity.
Type inference means you don’t need to declare types or even generic type parameters much of the time.

Compared to Java, Kotlin's type system is based on a simpler, more consistent conceptual framework.
It has very few rules to learn, and those rules combine consistently and predictably.

Kotlin organises all types of object into a hierarchy of supertype/subtype relationships.
The classes and interfaces you define will be part of that hierarchy, even if you don't explicitly use inheritance.
Subtype relationships are introduced by subclassing or implementing interfaces, but also, less obviously, by nullability and generics, as we will see later.

Unlike Java, Kotlin does not draw a distinction between "primitive" types, that are intrinsic to the language, and user-defined types -- they are all part of the same type hierarchy.
Nor does Kotlin draw a distinction between functions that return a value and those do not -- there is no "void" type in Kotlin.

The type checker ensures that code uses values correctly with respect to subtype/supertype relationships.
For example, you can store a value of a subtype into a variable of a supertype.

[source,kotlin]
----
var f: Fruit = Banana()
f = Peach()
----

You cannot store a value of a supertype into a variable of a subtype without an explicit cast or runtime type test.

[source,kotlin]
----
val b = Banana(bendiness=0.5)
val f: Fruit = b
val b2: Banana = f
// Error: Type mismatch: inferred type is Fruit but Banana was expected
----

Kotlin builds useful language features, such as null safety and unreachable code analysis, on this type hierarchy.
They do not rely on special cases that you must memorise, or ad-hoc checks in the compiler and IDE that stop working when your code gets too complicated, and we can write code that works with them to improve the developer experience of working withinin our codebases.

== Starting from the Top

The "top" of the class hierarchy is the class `kotlin.Any`.

For example, the types String and Int are both subtypes of `Any`.

plantuml::diagrams/any-intrinsics.plantuml[]

If you define a class that is not explicitly derived from another class, the class will be an immediate subtype of Any.

// begin-insert: src/main/java/digression/types/user_defined_type.kt#user_defined_type
[source,kotlin]
----
class Fruit(val ripeness: Double)
----
// end-insert

plantuml::diagrams/any-user-defined-type.plantuml[User defined types are subtypes of Any]

If you do specify a base class for a user-defined class, the base class will be the immediate supertype of the new class, but the ultimate ancestor of the class will be the type Any.

// begin-insert: src/main/java/digression/types/inheritance/example.kt#inheritance
[source,kotlin]
----
abstract class Fruit {
    abstract val ripeness: Double
}

class Banana(override val ripeness: Double, val bendiness: Double): Fruit()
class Peach(override val ripeness: Double, val fuzziness: Double): Fruit()
----
// end-insert

plantuml::diagrams/any-user-defined-type-hierarchy.plantuml[]

If your class implements one or more interfaces, it will have multiple immediate supertypes, with Any as the ultimate ancestor.

[source,kotlin]
----
interface ICanGoInASalad
interface ICanBeSunDried

class Tomato(ripeness: Double): 
    Fruit(ripeness), 
    ICanGoInASalad, 
    ICanBeSunDried 
----

plantuml::diagrams/interfaces.plantuml[]

This is one of those situations where the subtype/supertype relationships are different from the subclass/superclass relationships exposed by reflection.
If you reflect on an interface that is not derived from another interface,, it's superclass is reported as `null`, not `Any`.

`kotlin.Any` is the equivalent of `java.lang.Object` in Java.
The Kotlin compiler maps references to Any to `java.lang.Object` to simplify interop with Java code (TODO: more detail about this).

== Unit

Kotlin is an expression oriented language.
Kotlin does not have void functions, like Java and C. Functions always return a value.
Functions that don’t actually calculate anything – being called for their side effect, for example – return `Unit`, a type that has a single value, also called `Unit`.

Most of the time you don’t need to explicitly specify Unit as a return type or return Unit from functions.
If you write a function with a block body and do not specify the result type, the compiler will treat it as a Unit function.
If you write a single-expression function, the compiler can infer the Unit return type, just like any other type.

[source,kotlin]
----
fun example1() {
    println("block body and no explicit return type, so returns Unit")
}

val u1: Unit = example1()

fun example2() =
    println("single-expression function for which the compiler infers the return type as Unit")

val u2: Unit = example2()
----

There’s nothing special about `Unit`.
Like any other type, it’s a subtype of `Any`.
It can be made nullable, so is a subtype of `Unit?`, which is a subtype of `Any?`.

plantuml::diagrams/nullable-unit.plantuml[]

The type `Unit?` is a strange little edge case, a result of the consistency of Kotlin’s type system.
It has only two members: the `Unit`
value and `null`.
I’ve never found a need to use it explicitly, but the fact that there is no special case for ``void'' in the type system makes it much easier to treat all kinds of functions generically.

== Nothing

At the very bottom of the Kotlin type hierarchy is the type `Nothing`.

plantuml::diagrams/nothing.plantuml[]

As its name suggests, Nothing is a type that has no instances.
An expression of type Nothing does not result in a value.

Note the distinction between Unit and Nothing.
Evaluation of an expression type Unit results in the singleton value `Unit`.
Evaluation of an expression of type Nothing never returns at all.

This means that any code following an expression of type Nothing is unreachable.
The compiler and IDE will warn you about such unreachable code.

What kinds of expression evaluate to Nothing?
Those that perform control flow.

For example, the `throw` keyword interrupts the calculation of an expression and throws an exception out of the enclosing function.
A throw is therefore an expression of type Nothing.

Because Nothing is a subtype of every other type, the type system allows any expression in the program to fail to calculate a value.
There's no way to specify that an expression will never fail.
This models real world eventualities, such as the JVM running out of memory while calculating an expression, or someone pulling out the computer’s power plug.
It also means that we can throw exceptions from within any expression.

[source,kotlin]
----
fun formatCell(value: Double): String =
    if (value.isNaN()) 
        throw IllegalArgumentException("$value is not a number") 
    else 
        value.toString()
----

It may come as a surprise to learn that the `return` statement has the type Nothing.
Return is a control flow statement that immediately returns a value from the enclosing function, interrupting the evaluation of any expression of which it is a part.

[source,kotlin]
----

 fun formatCellRounded(value: Double): String {
    val rounded: Long = if (value.isNaN()) return "#ERROR" else value.roundToLong()
    return rounded.toString()
}
----

A function that enters an infinite loop or kills the current process has a result type of Nothing.
For example, the Kotlin standard library declares the `exitProcess` function as:

[source,kotlin]
----
fun exitProcess(status: Int): Nothing
----

If you write your own function that returns Nothing, the compiler will check for unreachable code after a call to your function just as it does with built-in control flow statements.

[source,kotlin]
----
inline fun forever(action: ()->Unit): Nothing {
    while(true) action()
}

fun example() {
    forever {
        println("doing...")
    }
    println("done") // Warning: Unreachable code
}
----

Like null safety, Kotlin does not implement unreachable code analysis with ad-hoc, special-case checks in the IDE and compiler, as it has to be in Java.
It’s a function of the type system.

== Nullable Nothing?

`Nothing`, like any other type, can be made nullable, giving the type
`Nothing?`. `Nothing?` can _only_ contain one value: `null`.
In fact,
`Nothing?` _is_ the type of `null`.

`Nothing?` is the ultimate subtype of all nullable types, which lets the value `null` be used as a value of any nullable type.

plantuml::diagrams/nullable-nothing.plantuml[]

== Nullable Unit?

The consistency of Kotlin's type system creates an odd wrinkle: the type `Unit?`.
It has only two members: the Unit value and null.

I’ve never found a need to use it explicitly. The fact that there is no special case for “void” in the type system makes it possible to pass any type of functions to higher order functions like `map`, `filter` and `fold`.  However, there are usually better alternatives for functions that return `Unit`.  For example, passing a function that returns `Unit` to `map` will create an unnecessary collection containing multiple references to the `Unit` value.  The `forEach` function is more efficient.

== In summary

When you consider it all at once, Kotlin’s entire type hierarchy can feel quite complicated.

plantuml::diagrams/entire-hierarchy.plantuml[]

But compared to Java, Kotlin has a simpler and more consistent type system, fewer rules to learn, and no special cases:
there's a hierarchy of supertype/subtype relationships with `Any?`
at the top and `Nothing` at the bottom, and subtype relationships between non-null and nullable types.

Useful language features like null safety, object-oriented polymorphism, and unreachable code analysis all result from these simple, predictable rules.
Thanks to this consistency, Kotlin’s type checker is a powerful tool that helps you write concise, correct programs.
